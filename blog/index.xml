<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>博客 on Linner&#39;s Blog</title>
    <link>/blog/</link>
    <description>Recent content in 博客 on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>Copyright © 2020-2023 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Thu, 10 Aug 2023 08:40:27 +0000</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>VS Code 中英字符对齐</title>
      <link>/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Thu, 10 Aug 2023 08:40:27 +0000</pubDate>
      
      <guid>/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/</guid>
      <description><![CDATA[在VS Code中，编写代码或者Markdown时，中文字符与英文字符通常是无法对齐的。可以通过使用Ubuntu Mono字体，让VS Code的]]></description>
      <content:encoded><![CDATA[<p>在VS Code中，编写代码或者Markdown时，中文字符与英文字符通常是无法对齐的。可以通过使用Ubuntu Mono字体，让VS Code的中英字符能够对齐。</p>
<p>Ubuntu Mono字体可以从<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener noreferrer">https://github.com/powerline/fonts<i class="fas fa-external-link-square-alt ms-1"></i></a>下载。可以直接通过网页下载其<code>zip</code>压缩包，或者将其<code>clone</code>到本地：</p>
<pre tabindex="0"><code>git clone https://github.com/powerline/fonts
</code></pre><p>如果是在Windows上安装该字体，可以找到项目下的<code>UbuntuMono</code>文件夹，直接双击打开<code>.ttf</code>文件，根据显示的内容提示，就能完成安装。</p>
<p>找到<code>UbuntuMono</code>文件夹并打开，双击打开下方红框中所有<code>.tff</code>文件进行安装：</p>
<p><picture><img class="img-fluid " alt="uTools_1691657594650.png" src="/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/uTools_1691657594650.png" loading="lazy" width="391" height="222" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="uTools_1691657696387.png" src="/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/uTools_1691657696387.png" loading="lazy" width="1424" height="746" />
</picture>

</p>
<p>然后根据界面中显示的字体名称，修改VS Code的字体：</p>
<p><picture><img class="img-fluid " alt="uTools_1691657808584.png" src="/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/uTools_1691657808584.png" loading="lazy" width="392" height="164" />
</picture>

</p>
<p>打开VS Code的设置，搜索<code>@id:editor.fontFamily</code>，然后将<code>Ubuntu Mono</code>字体加入后即修改成功：</p>
<p><picture><img class="img-fluid " alt="uTools_1691657918498.png" src="/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/uTools_1691657918498.png" loading="lazy" width="704" height="127" />
</picture>

</p>
<p>如果要根据某种语言设置字体，可以在VS Code中按下 Ctrl+Shift+P，然后在打开的输入框中搜索<code>settings.json</code>：</p>
<p><picture><img class="img-fluid " alt="uTools_1691658592418.png" src="/blog/2023/08/vs-code-%E4%B8%AD%E8%8B%B1%E5%AD%97%E7%AC%A6%E5%AF%B9%E9%BD%90/uTools_1691658592418.png" loading="lazy" width="745" height="165" />
</picture>

</p>
<p>Default Settings是VS Code默认的配置；Workspace Settings是当前工作区的配置（也就是当前工作目录）；User Settings是当前登录用户的配置；Markdown PDF这个配置是因为我已经进行过配置，所以才会显示。根据你的需要进行选择即可，这里我选择修改User Settings。</p>
<p>然后在打开的<code>settings.json</code>文件夹中按Ctrl+F查找<code>&quot;[markdown]&quot;</code>这个设置项（如果没有的话就自己创建）。在<code>&quot;[markdown]&quot;</code>项下，新增或修改如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;[markdown]&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;editor.fontFamily&#34;</span><span class="p">:</span> <span class="s2">&#34;Ubuntu Mono derivative Powerline&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">,</span>
</span></span></code></pre></div><p>如果觉得字体太小，可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;[markdown]&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;editor.fontFamily&#34;</span><span class="p">:</span> <span class="s2">&#34;Ubuntu Mono derivative Powerline&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;editor.fontSize&#34;</span><span class="p">:</span> <span class="mi">17</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">,</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>NVM 安装</title>
      <link>/blog/2023/08/nvm-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 06 Aug 2023 05:31:54 +0000</pubDate>
      
      <guid>/blog/2023/08/nvm-%E5%AE%89%E8%A3%85/</guid>
      <description><![CDATA[Debian 安装 NVM NVM（Node Version Manager）是一个用于管理 Node.js 版本的工具。它允许你在同一台机器上同时安装和切换不同的 Node.js 版本，以便于在不同项目中使]]></description>
      <content:encoded><![CDATA[<h1 id="debian-安装-nvm" data-numberify>Debian 安装 NVM<a class="anchor ms-1" href="#debian-安装-nvm"></a></h1>
<p>NVM（Node Version Manager）是一个用于管理 Node.js 版本的工具。它允许你在同一台机器上同时安装和切换不同的 Node.js 版本，以便于在不同项目中使用特定的 Node.js 版本。</p>
<p>NVM 支持在 Linux、macOS、和 Windows 系统上使用，并且与不同的 Shell（如 Bash、Zsh）兼容。</p>
<p>在Debian上安装NVM的步骤如下（Ubuntu同理）：</p>
<ol>
<li>
<p>安装NVM之前，需要先安装依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt update
</span></span><span class="line"><span class="cl">sudo apt upgrade
</span></span><span class="line"><span class="cl">sudo apt install curl build-essential gnupg2 -y
</span></span></code></pre></div></li>
<li>
<p>下载并执行NVM的安装脚本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh <span class="p">|</span> bash
</span></span></code></pre></div><p>如果你要指定安装NVM的版本，可以修改以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">curl https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh <span class="p">|</span> bash
</span></span></code></pre></div><p>将<code>v0.38.0</code>换成你所需的版本即可。</p>
</li>
<li>
<p>等待下载，并且脚本执行成功后，重新加载终端的配置信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">source</span> .bashrc
</span></span></code></pre></div><p>如果你使用的是ZSH，可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">source</span> .zshrc
</span></span></code></pre></div><p>不同的终端，重新加载对应的配置文件即可。</p>
</li>
</ol>
<hr>
<h1 id="安装脚本无法下载的问题" data-numberify>安装脚本无法下载的问题<a class="anchor ms-1" href="#安装脚本无法下载的问题"></a></h1>
<p>如果遇到NVM的<code>install.sh</code>无法下载的问题，例如<code>curl</code>报以下错误：</p>
<pre tabindex="0"><code>curl: (6) Could not resolve host: raw.githubusercontent.com
</code></pre><p>多半是域名污染导致的。就算你使用科学的方法，也不一定能下载成功，还是会报一样的错误。</p>
<p>解决这种问题可以先从域名IP查询网站上查询IP：<a href="https://www.ipaddress.com/" target="_blank" rel="noopener noreferrer">https://www.ipaddress.com/<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>然后将查询到的IP通过本地的<code>hosts</code>文件来解析。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim /etc/hosts
</span></span></code></pre></div><p>然后加入以下内容：</p>
<pre tabindex="0"><code>185.199.108.133 raw.githubusercontent.com
</code></pre><p>上方的<code>185.199.108.133</code>这个IP，替换成你查询到的结果即可。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>软考概念总结篇</title>
      <link>/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/</link>
      <pubDate>Thu, 25 May 2023 11:34:54 +0800</pubDate>
      
      <guid>/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/</guid>
      <description><![CDATA[计算机系统 跳转连接：软件设计师——计算机系统篇 基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节]]></description>
      <content:encoded><![CDATA[<h1 id="计算机系统" data-numberify>计算机系统<a class="anchor ms-1" href="#计算机系统"></a></h1>
<p>跳转连接：<a href="/p/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%af%87/">软件设计师——计算机系统篇</a></p>
<h2 id="基本单位" data-numberify>基本单位<a class="anchor ms-1" href="#基本单位"></a></h2>
<table>
<tr>
    <td>位（比特）<br>最小数据单位</td>
    <td><b>bit、b</b></td>
    <td></td>
</tr>
<tr>
    <td>字节<br>最小存储单位</td>
    <td>byte、B</td>
    <td>1B = 8b</td>
</tr>
<tr>
    <td>千字节</td>
    <td>KB</td>
    <td>1KB = 1024B</td>
</tr>
<tr>
    <td>兆字节</td>
    <td>MB</td>
    <td>1MB = 1024KB</td>
</tr>
<tr>
    <td>吉字节</td>
    <td>GB</td>
    <td>1GB = 1024MB</td>
</tr>
<tr>
    <td>太字节</td>
    <td>TB</td>
    <td>1TB = 1024GB</td>
</tr>
</table>
<h2 id="中央处理单元" data-numberify>中央处理单元<a class="anchor ms-1" href="#中央处理单元"></a></h2>
<p>CPU的功能：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">程序控制</td>
<td style="text-align:left">通过执行指令来控制程序的执行顺序。</td>
</tr>
<tr>
<td style="text-align:center">操作控制</td>
<td style="text-align:left">CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</td>
</tr>
<tr>
<td style="text-align:center">时间控制</td>
<td style="text-align:left">对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</td>
</tr>
<tr>
<td style="text-align:center">数据处理</td>
<td style="text-align:left">通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。</td>
</tr>
</tbody>
</table>
<p>CPU的组成：</p>
<ul>
<li>运算器：
<ul>
<li>算术逻辑单元（ALU）：处理数据，对数据进行算术运算和逻辑运算。</li>
<li>累加寄存器（AC，累加器）：通用寄存器，存放操作数或者结果。。</li>
<li>数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字。</li>
<li>状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态。</li>
</ul>
</li>
<li>控制器：
<ul>
<li>指令寄存器（IR）：暂存要执行的指令。</li>
<li>程序计数器（PC，指令计数器）：寄存信息和指令计数。</li>
<li>地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。</li>
<li>指令译码器（ID）。</li>
</ul>
</li>
<li>寄存器组</li>
<li>内部总线</li>
</ul>
<h2 id="数据编码" data-numberify>数据编码<a class="anchor ms-1" href="#数据编码"></a></h2>
<p><picture><img class="img-fluid " alt="带符号数的范围" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png" loading="lazy" width="1174" height="273" />
</picture>

</p>
<h2 id="寻址方式" data-numberify>寻址方式<a class="anchor ms-1" href="#寻址方式"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:left">操作数就包含在指令中。</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:left">操作数在内存，指令给出操作数的地址。</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:left">操作数在寄存器，指令给出操作数的寄存器名（地址）。</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:left">操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。</td>
</tr>
<tr>
<td style="text-align:center">间接寻址</td>
<td style="text-align:left">指令中给出操作数地址（操作数地址在内存中）的地址。</td>
</tr>
<tr>
<td style="text-align:center">相对寻址</td>
<td style="text-align:left">指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。</td>
</tr>
<tr>
<td style="text-align:center">变址寻址</td>
<td style="text-align:left">操作数地址等于变址寄存器的内容加偏移量。</td>
</tr>
</tbody>
</table>
<h2 id="校验码" data-numberify>校验码<a class="anchor ms-1" href="#校验码"></a></h2>
<p>编码系统的码距：</p>
<ul>
<li>$\ge 2$：该编码系统具有<u>检错能力</u>；</li>
<li>$\ge 3$：该编码系统才<u>可能有纠错能力</u>。</li>
</ul>
<p>奇偶校验码：</p>
<ul>
<li>码距为2。</li>
<li>仅能检测奇数位数出错。</li>
</ul>
<p>海明码：</p>
<p>设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：</p>
<p>$$
2^k-1 \ge n+k
$$</p>
<p>循环冗余（n,k）码：</p>
<ul>
<li>信息码（数据），占k位；</li>
<li>校验码，占n-k位；</li>
<li>码距为2，可以检错不能纠错。</li>
</ul>
<h2 id="计算机指令集" data-numberify>计算机指令集<a class="anchor ms-1" href="#计算机指令集"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">RISC<br>精简指令集（计算机）</th>
<th style="text-align:center">CISC<br>复杂指令集（计算机）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指令种类</td>
<td style="text-align:center">少、精简</td>
<td style="text-align:center">多、复杂</td>
</tr>
<tr>
<td style="text-align:center">指令复杂度</td>
<td style="text-align:center">低（简单）</td>
<td style="text-align:center">高（复杂）</td>
</tr>
<tr>
<td style="text-align:center">指令长度</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">变化</td>
</tr>
<tr>
<td style="text-align:center">寻址方式</td>
<td style="text-align:center">少</td>
<td style="text-align:center">复杂多样</td>
</tr>
<tr>
<td style="text-align:center">实现（译码方式）</td>
<td style="text-align:center">硬布线控制逻辑（组合逻辑控制器）</td>
<td style="text-align:center">微程序控制技术</td>
</tr>
<tr>
<td style="text-align:center">通用寄存器数量</td>
<td style="text-align:center">多、大量</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">流水线技术</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<h2 id="流水线技术" data-numberify>流水线技术<a class="anchor ms-1" href="#流水线技术"></a></h2>
<p>执行$n$条指令：</p>
<ul>
<li>
<p>顺序执行总时间：</p>
<p>$$
顺序执行总时间=单条指令执行的时间\times n
$$</p>
</li>
<li>
<p>流水线执行总时间：</p>
<p>$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$</p>
<p>流水线（操作）周期为执行时间最长的一段操作的时间。</p>
</li>
<li>
<p>连续输入$n$条指令的吞吐率：</p>
<p>$$
吞吐率=\cfrac {n}{总执行时间}
$$</p>
<p>如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：</p>
<p>$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$</p>
</li>
<li>
<p>加速比：</p>
<p>$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$</p>
</li>
</ul>
<h2 id="存储器" data-numberify>存储器<a class="anchor ms-1" href="#存储器"></a></h2>
<p>按存储器所处位置可分为：</p>
<ul>
<li>内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。</li>
<li>外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。</li>
</ul>
<p>按存储器工作方式：</p>
<ul>
<li>读/写存储器（RAM）。</li>
<li>只读存储器：ROM、PROM、EPROM、EEPROM等。
<ul>
<li>固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。</li>
<li>可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。</li>
</ul>
</li>
</ul>
<h2 id="缓存" data-numberify>缓存<a class="anchor ms-1" href="#缓存"></a></h2>
<p>高速缓存中的地址映像方法：</p>
<ul>
<li>
<p>直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884025087.png" loading="lazy" width="825" height="526" />
</picture>

</p>
</li>
<li>
<p>全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884252415.png" loading="lazy" width="730" height="538" />
</picture>

</p>
</li>
<li>
<p>组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。</p>
</li>
</ul>
<blockquote>
<p>发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。</p>
<p>地址映像都是由硬件自动完成。</p>
</blockquote>
<h2 id="中断" data-numberify>中断<a class="anchor ms-1" href="#中断"></a></h2>
<p>程序查询方式（程序直接控制方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888001780.png" loading="lazy" width="754" height="1174" />
</picture>

</p>
<ul>
<li>CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数放入内存。</li>
</ul>
<p>中断驱动方式：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888578058.png" loading="lazy" width="787" height="1134" />
</picture>

</p>
<ul>
<li>I/O设备通过中断信号主动向CPU报告I/O操作已完成。</li>
<li>CPU和I/O可并行工作。</li>
<li>CPU利用率得到提升。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数据放入内存。</li>
</ul>
<p>DMA方式（直接存储器存储方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888972074.png" loading="lazy" width="816" height="723" />
</picture>

</p>
<ul>
<li>CPU和I/O可并行工作。</li>
<li>仅在传送数据块多开始和结束时才需要CPU的干预。</li>
<li>由外设直接将数据放入内存。</li>
<li>一次读写的单位为&quot;块&quot;而不是字。</li>
</ul>
<p>DMA传输数据比中断驱动方式传输数据要快一点。</p>
<h2 id="总线" data-numberify>总线<a class="anchor ms-1" href="#总线"></a></h2>
<p>微机中的总线分为：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<p>常见总线：</p>
<ul>
<li>ISA总线。</li>
<li>EISA总线。</li>
<li>PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。</li>
<li>PCI Express 总线。</li>
<li>前端总线。</li>
<li>RS-232C。</li>
<li>SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。</li>
<li>SATA。</li>
<li>USB。</li>
<li>IEEE-1394。</li>
<li>IEEE-488总线。</li>
</ul>
<h2 id="加密与认证技术" data-numberify>加密与认证技术<a class="anchor ms-1" href="#加密与认证技术"></a></h2>
<p>加密技术用于防止第三方窃听：</p>
<ul>
<li>
<p>对称加密：只有一把密钥。加密和解密用同一把密钥。</p>
<ul>
<li>密钥分发有缺陷。</li>
<li>加密解密速度很快。</li>
<li>适合加量大量明文数据。</li>
</ul>
</li>
<li>
<p>非对称加密：</p>
<ul>
<li>加密和解密不是同一把密钥。</li>
<li>一共有两把密钥，分别是公钥和私钥。</li>
<li>用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。</li>
<li>不能通过一把密钥推出另一把密钥。</li>
<li>用接收方的公钥加密明文可以实现防止窃听的效果。</li>
<li>密钥分发没有缺陷。</li>
<li>加密解密速度很慢。</li>
</ul>
</li>
</ul>
<p>认证技术用于防止篡改、假冒和否认：</p>
<ul>
<li>摘要（防止篡改）：Hash算法加密，放在密文后。</li>
<li>数字签名（防止假冒和否认）：<u>发送方用私钥对摘要进行签名</u>（加密）。接收方用<u>发送方的公钥对数字签名进行验证</u>（解密）。</li>
</ul>
<p>数字证书：CA机构用私钥对用户的公钥签名（加密）。接收方用CA的公钥验证（解密），从而得到用户的公钥。</p>
<p>加密算法：</p>
<ul>
<li>对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：
<ul>
<li>DES</li>
<li>3DES</li>
<li>RC-5</li>
<li>IDEA</li>
<li>AES</li>
<li>RC4</li>
</ul>
</li>
<li>非对称密钥（公钥、公开密钥加密）算法：
<ul>
<li>RSA</li>
<li>ECC</li>
<li>DSA</li>
</ul>
</li>
<li>其他加密算法：
<ul>
<li>Hash函数</li>
<li>SHA-1安全散列算法</li>
<li>MD5摘要算法</li>
</ul>
</li>
</ul>
<h2 id="系统可靠度" data-numberify>系统可靠度<a class="anchor ms-1" href="#系统可靠度"></a></h2>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1157" height="400" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1133" height="376" />
</picture>

</p>
<hr>
<h1 id="程序设计语言" data-numberify>程序设计语言<a class="anchor ms-1" href="#程序设计语言"></a></h1>
<p>跳转连接：<a href="/p/%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e7%af%87/">软件设计师——程序设计语言篇</a></p>
<h2 id="编译过程" data-numberify>编译过程<a class="anchor ms-1" href="#编译过程"></a></h2>
<p><picture><img class="img-fluid " alt="编译过程" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680232196718.png" loading="lazy" width="549" height="466" />
</picture>

</p>
<p>必须的编译过程阶段：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>目标代码生成</li>
</ol>
<p>可省略的编译过程阶段：</p>
<ul>
<li>中间代码生成</li>
<li>（中间或目标）代码优化</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">词法分析</td>
<td style="text-align:left">对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号</td>
</tr>
<tr>
<td style="text-align:center">语法分析</td>
<td style="text-align:left">根据语言的语法规则将单词符号序列分解成各类语法单位</td>
</tr>
<tr>
<td style="text-align:center">语义分析</td>
<td style="text-align:left">检查源程序是否包含静态语义错误</td>
</tr>
<tr>
<td style="text-align:center">中间代码生成</td>
<td style="text-align:left">分水岭，上面是前端，下面是后端</td>
</tr>
<tr>
<td style="text-align:center">代码优化</td>
<td style="text-align:left">所做的优化一般与具体的机器无关</td>
</tr>
<tr>
<td style="text-align:center">目标代码生成</td>
<td style="text-align:left">把中间代码变换成机器指令</td>
</tr>
</tbody>
</table>
<h2 id="正规式" data-numberify>正规式<a class="anchor ms-1" href="#正规式"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">闭包</td>
<td style="text-align:left">表示其前面链接的符号或集合可以出现$[0, +\infty]$次。</td>
</tr>
<tr>
<td style="text-align:center"><code>·</code></td>
<td style="text-align:center">连接</td>
<td style="text-align:left">可省略，将多个符号或集合连接起来。表示逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center">或</td>
<td style="text-align:left">表示逻辑或。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1680248469003.png" loading="lazy" width="990" height="277" />
</picture>

</p>
<p>设$U$、$V$和$W$均为正规式：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680249034196.png" loading="lazy" width="974" height="185" />
</picture>

</p>
<h2 id="有限自动机" data-numberify>有限自动机<a class="anchor ms-1" href="#有限自动机"></a></h2>
<ul>
<li>
<p><strong>确定的有限自动机</strong>（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的<strong>状态是唯一的</strong>。</p>
<p>一个DFA是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$：</p>
<ul>
<li>
<p>$S$：包含<u>状态的有限集</u>（每个元素称为一个状态）。</p>
</li>
<li>
<p>$\Sigma$：有穷<u>字母表</u>，其每个元素称为一个<u>输入字符</u>。</p>
</li>
<li>
<p>$f$：$S \times \Sigma \to S$ 上的<u>单值部分映像</u>。</p>
<p>$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$</p>
<p>表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。</p>
</li>
<li>
<p>$s_0$：唯一的<u>开始状态</u>，$s_0 \in S$。</p>
</li>
<li>
<p>$Z$：非空的<u>终止状态集合</u>，$Z \subseteq S$。</p>
</li>
</ul>
<p>DFA可以用两种直观的方式表示：</p>
<ul>
<li>
<p><strong>状态转换图</strong>：简称为转换图，是一个有向图。</p>
<ul>
<li>
<p>DFA中的每个<strong>状态</strong>对应转换图中的一个<strong>结点</strong>。</p>
</li>
<li>
<p>DFA中的每个<strong>转换函数</strong>对应图中的一条<strong>有向弧</strong>。</p>
</li>
<li>
<p><strong>双圈表示的结点是终态结点。</strong></p>
<blockquote>
<p>终态也可以是初态。</p>
</blockquote>
</li>
</ul>
<p>若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。</p>
</li>
<li>
<p><strong>状态转换矩阵</strong>：用一个二位数组$M$表示。</p>
<p>矩阵元素$M[A,a]$：</p>
<ul>
<li><strong>行下标</strong>：表示状态。当前状态为$A$。</li>
<li><strong>列下标</strong>：表示输入的字符。当前输入为$a$。</li>
<li>$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251834262.png" loading="lazy" width="983" height="160" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251962756.png" loading="lazy" width="982" height="585" />
</picture>

</p>
</li>
<li>
<p><strong>不确定的有限自动机</strong>（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的<strong>状态是不唯一的</strong>。</p>
<p>NFA也是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：</p>
<ul>
<li>
<p>$f$是$S \times \Sigma \to 2^S$ 上的映像。</p>
<p>对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。</p>
</li>
<li>
<p>有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。</p>
</li>
</ul>
<blockquote>
<p>DFA是NFA的特例。</p>
</blockquote>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680252743732.png" loading="lazy" width="918" height="407" />
</picture>

</p>
</li>
</ul>
<p><u>有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。</u></p>
<h2 id="设计语言成分" data-numberify>设计语言成分<a class="anchor ms-1" href="#设计语言成分"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">成分</th>
<th style="text-align:left">包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据成分</td>
<td style="text-align:left"><ul><li>标识符</li><li>关键字</li><li>常量</li><li>变量</li><li>全局量</li><li>局部量</li><li>数据类型</li></ul></td>
</tr>
<tr>
<td style="text-align:center">运算成分</td>
<td style="text-align:left"><ul><li>算数</li><li>关系</li><li>逻辑</li><li>位</li></ul></td>
</tr>
<tr>
<td style="text-align:center">控制结构</td>
<td style="text-align:left"><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul></td>
</tr>
<tr>
<td style="text-align:center">传输成分</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">函数</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h1 id="数据结构" data-numberify>数据结构<a class="anchor ms-1" href="#数据结构"></a></h1>
<p>跳转连接：<a href="/p/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%af%87/">软件设计师——数据结构篇</a></p>
<h2 id="线性表" data-numberify>线性表<a class="anchor ms-1" href="#线性表"></a></h2>
<p><strong>顺序表：</strong></p>
<p>在表长为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：</p>
<ul>
<li>
<p>在第$i$个插入位置插入，需要移动$n+1-i$个元素。</p>
<ul>
<li>在第1个位置插入（$a_1$）需要移动$n$个元素；</li>
<li>在第$n+1$个位置插入（$a_n$后面）不需要移动元素。</li>
</ul>
</li>
<li>
<p>设在第$i$个插入位置插入的概率为$p_i$，<u>等概率下插入</u>一个新元素需要移动的元素个数的<u>期望值$E_{insert}$</u>为：</p>
<p>$$
E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}
$$</p>
</li>
</ul>
<p>在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：</p>
<ul>
<li>
<p>删除第$i$个元素$a_i$需要移动$n-i$个元素。</p>
<ul>
<li>删除元素$a_1$需要移动$n-1$个元素；</li>
<li>删除元素$a_n$不需要移动元素。</li>
</ul>
</li>
<li>
<p>设$a_i$被删除的概率为$q_i$，<u>等概率下删除元素</u>时需要移动的元素个数的<u>期望值$E_{delete}$</u>为：</p>
<p>$$
E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}
$$</p>
</li>
</ul>
<p><strong>插入操作时间复杂度：</strong></p>
<ul>
<li>最好情况（在第$n+1$个位置插入）：$O(1)$；</li>
<li>最坏情况（在第1个位置插入）：$O(n)$；</li>
<li>平均复杂度：$O(n)$。</li>
</ul>
<p><strong>链表插入和删除操作时间复杂度</strong>（带不带头节点的复杂度都一样）：</p>
<ul>
<li>最好情况（在$i=1$位置）：$O(1)$；</li>
<li>最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$</li>
<li>平均复杂度：$O(n)$</li>
</ul>
<h2 id="串的模式匹配" data-numberify>串的模式匹配<a class="anchor ms-1" href="#串的模式匹配"></a></h2>
<p>朴素的模式匹配（布鲁特一福斯）算法：</p>
<p>设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：</p>
<ul>
<li>
<p>最好情况：$O(m)$，次数为$m$；</p>
</li>
<li>
<p>最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$</p>
</li>
<li>
<p>平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$</p>
</li>
</ul>
<h2 id="数组" data-numberify>数组<a class="anchor ms-1" href="#数组"></a></h2>
<p>设：</p>
<ul>
<li>二维数组为$A[n,m]$，$n$为行数，$m$为列数；</li>
<li>数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；</li>
<li>$LOC(a_{i,j})$为元素$a_{i,j}$的地址；</li>
<li>$L$为单个元素的存储空间大小。</li>
</ul>
<p>则有：</p>
<ul>
<li>
<p>以行为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$</p>
</li>
<li>
<p>以列为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$</p>
</li>
</ul>
<p><strong>对称矩阵：</strong></p>
<p>假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p>如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p><strong>三对角矩阵：</strong></p>
<p>设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：</p>
<p>$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$</p>
<p>如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$</p>
<h2 id="树" data-numberify>树<a class="anchor ms-1" href="#树"></a></h2>
<ul>
<li>
<p>设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：</p>
<p>$$
n = (\sum_{i=1}^{n}{d_i})+1
$$</p>
<p><strong>度</strong>：结点拥有的子树数。</p>
</li>
<li>
<p>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。</p>
</li>
<li>
<p>高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。</p>
</li>
</ul>
<p><strong>二叉树：</strong></p>
<ul>
<li>
<p>第$i$层（$i \ge 1$）上<u>最多</u>有$2^{i-1}$个结点。</p>
</li>
<li>
<p>高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。</p>
</li>
<li>
<p>若二叉树终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。</p>
</li>
<li>
<p>具有$n$个结点的完全二叉树的深度（高度）为：</p>
<p>$$
\lfloor \log_2{n} \rfloor + 1;
$$</p>
<p>或：</p>
<p>$$
\lceil \log_2{(n+1)} \rceil
$$</p>
</li>
<li>
<p>二叉树形态总数（卡特兰数）：</p>
<p>$$
\cfrac{C^{n}_{2n}}{n+1}
$$</p>
</li>
</ul>
<p><strong>链式存储二叉树：</strong></p>
<p>设有$n$个结点的二叉树，则其<strong>空指针域数量</strong>：</p>
<ul>
<li>
<p>对于二叉链表：</p>
<ul>
<li>总指针域个数：$2n$；</li>
<li>分支数（子孙结点数，非空指针域个数）：$n-1$。</li>
</ul>
<p>可得：</p>
<p>$$
空指针域数=2n-(n-1)=n+1
$$</p>
</li>
<li>
<p>对于三叉链表：</p>
<ul>
<li>总指针域个数：$3n$；</li>
<li>分支数（子孙结点数）：$n-1$；</li>
<li>指向父结点且非空的指针域个数：$n-1$。</li>
</ul>
<p>即，非空指针域个数为：$2(n-1)$。</p>
<p>可得：</p>
<p>$$
空指针域数=3n-2(n-1)=n+2
$$</p>
</li>
</ul>
<p><strong>平衡二叉树：</strong></p>
<p>设一个二叉树的左右子树高度之差的绝对值为$d$，那么</p>
<ul>
<li>不平衡的二叉树：$d &gt; 1$；</li>
<li>平衡的二叉树：$d \le 1$。</li>
</ul>
<p><strong>哈夫曼树</strong>（最优二叉树）：带权路径长度最短。</p>
<p>设：</p>
<ul>
<li>带权叶子结点数：$n$；</li>
<li>叶子结点的权值：$w_k$；</li>
<li>叶子结点到根的路径长度：$l_k$。</li>
</ul>
<p>则树的带权路径长度为：</p>
<p>$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$</p>
<p>给定$n$个权值后，哈夫曼树的结点数$m$就确定了：</p>
<p>$$
m = 2 \times n - 1
$$</p>
<p><strong>哈夫曼压缩比：</strong></p>
<p><picture><img class="img-fluid " alt="压缩比例题" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680959771881.png" loading="lazy" width="784" height="489" />
</picture>

</p>
<ol>
<li>
<p>按照<u>出现频率</u>计算<u>加权平均长度</u>：</p>
<p>$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$</p>
<p>即：</p>
<p>$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$</p>
<p>压缩后平均长度为2.2。</p>
</li>
<li>
<p>计算压缩比：</p>
<p>$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$</p>
<p>即，</p>
<ul>
<li>
<p>编码5个字符至少需要3位：$2^2 &lt; 5 &lt; 2^3$，所以压缩前编码长度为3；</p>
</li>
<li>
<p>压缩比：</p>
<p>$$
\cfrac{3-2.2}{3} \approx 0.27
$$</p>
</li>
</ul>
</li>
</ol>
<h2 id="图" data-numberify>图<a class="anchor ms-1" href="#图"></a></h2>
<p><strong>完全图</strong>：</p>
<ul>
<li>$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边。</li>
<li>$n$个顶点的有向完全图共有$n(n-1)$条边。</li>
</ul>
<p>对于所有的图，其所有顶点的度数之和 $= 2e$（$e$为边数）。</p>
<p>$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。</p>
<p>图的邻接矩阵：横$i$竖$j$，横出竖入。</p>
<p><strong>深度优先搜索：</strong></p>
<ol>
<li>设置搜索指针$p$，使$p$指向顶点$v$；</li>
<li>访问$p$所指顶点，并使$p$指向与其<u>相邻接的且尚未被访问过</u>的顶点。</li>
<li>若$p$所指顶点存在，则重复步骤2，否则执行步骤4。</li>
<li>沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。</li>
</ol>
<p><strong>广度优先搜索：</strong></p>
<ol>
<li>从图中的某个顶点$v$出发；</li>
<li>访问$v$后，依次访问$v$的各个未被访问过的邻接点；</li>
<li>分别从$v$的邻接点出发，依次访问它们的邻接点；</li>
<li>按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；</li>
<li>若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。</li>
</ol>
<p>广度和深度优先搜索<strong>时间复杂度</strong>（一样）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<p><strong>AOV 网拓扑排序</strong>：如果所有顶点已输出，说明网中不存在回路，否则说明存在。</p>
<ol>
<li>在AOV网中选择一个入度为0的顶点且输出它。</li>
<li>从网中删除该顶点及与该顶点有关的所有弧。</li>
<li>重复上述两步，直到网中不存在入度为0的顶点为止。</li>
</ol>
<hr>
<h1 id="操作系统" data-numberify>操作系统<a class="anchor ms-1" href="#操作系统"></a></h1>
<p>跳转连接：<a href="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/">软件设计师——操作系统篇</a></p>
<h2 id="进程的三态" data-numberify>进程的三态<a class="anchor ms-1" href="#进程的三态"></a></h2>
<ul>
<li><strong>运行</strong>：当一个进程在处理机上运行时。</li>
<li><strong>就绪</strong>：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。</li>
<li><strong>阻塞</strong>（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。</li>
</ul>
<h2 id="同步互斥" data-numberify>同步互斥<a class="anchor ms-1" href="#同步互斥"></a></h2>
<ul>
<li>
<p><strong>同步</strong>：指在系统中一些需要相互合作，协同工作的进程。</p>
</li>
<li>
<p><strong>互斥</strong>：指系统中多个进程因争用临界资源而互斥执行。</p>
</li>
<li>
<p>临界资源（CR）：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。</p>
</li>
<li>
<p>临界区（CS）：是进程中对临界资源实施操作的那段程序。</p>
<p>互斥临界区管理的4条原则：有空即进、无空则等、有限等待和让权等待。</p>
</li>
</ul>
<h2 id="信号量" data-numberify>信号量<a class="anchor ms-1" href="#信号量"></a></h2>
<ul>
<li>公用信号量：实现进程间的互斥，初值为<code>1</code>或资源的数目。</li>
<li>私用信号量：实现进程间的同步，初值为<code>0</code>或某个正整数。</li>
</ul>
<p>信号量$S$的物理意义：</p>
<ul>
<li>$S \ge 0$：表示某资源的可用数，此时<strong>有可用资源</strong>；</li>
<li>$S &lt; 0$：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。</li>
</ul>
<p>PV操作：P申请V释放，P减V加，P进V出。</p>
<ul>
<li>P操作$S &lt; 0$：无可用资源，置该进程为<strong>阻塞</strong>状态。</li>
<li>V操作$S \le 0$：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列。</li>
</ul>
<p>假定信号量S表示某条消息，进程可以：</p>
<ul>
<li>调用P操作：测试消息是否到达；</li>
<li>调用V操作：通知消息已经准备好。</li>
</ul>
<h2 id="死锁" data-numberify>死锁<a class="anchor ms-1" href="#死锁"></a></h2>
<p>产生死锁的原因：</p>
<ul>
<li>进程间互相<u>竞争资源</u>。</li>
<li><u>进程推进顺序非法</u>。</li>
</ul>
<p>产生死锁的4个必要条件：</p>
<ul>
<li>互斥条件</li>
<li>请求保持条件</li>
<li>不可剥夺条件</li>
<li>环路条件</li>
</ul>
<p>发生死锁时，在进程资源有向图中必构成环路。</p>
<p>造成死锁的情况：</p>
<ul>
<li>进程推进顺序不当</li>
<li>同类资源分配不当</li>
<li>PV操作使用不当</li>
</ul>
<p>死锁的处理策略：</p>
<ul>
<li>鸵鸟策略（不理睬策略）</li>
<li>预防策略</li>
<li>避免策略</li>
<li>检测与解除死锁</li>
</ul>
<p>死锁预防：</p>
<ul>
<li>
<p>预先静态分配法：破坏了“不可剥夺条件”，<u>预先分配所需资源，保证不等待资源</u>。</p>
<p>该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源。</p>
</li>
<li>
<p>资源有序分配法：破坏了“环路条件”，<u>把资源分类按顺序排列，保证不形成环路</u>。</p>
<p>该方法存在的问题是限制进程对资源的请求：由于资源的排序占用系统开销。</p>
</li>
</ul>
<p><a href="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/#%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95">银行家算法</a></p>
<h2 id="线程轻型进程" data-numberify>线程（轻型进程）<a class="anchor ms-1" href="#线程轻型进程"></a></h2>
<ul>
<li>基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈）。</li>
<li>与其它同一进程的线程共享进程所拥有的全部资源。</li>
</ul>
<p>线程分为：</p>
<ul>
<li>用户级线程</li>
<li>内核支持线程</li>
</ul>
<h2 id="存储管理" data-numberify>存储管理<a class="anchor ms-1" href="#存储管理"></a></h2>
<p><strong>程序的局限性：</strong></p>
<ul>
<li>
<p><strong>时间局限性</strong>：</p>
<ul>
<li>如果程序中的某条<u>指令一旦执行</u>，则不久的将来该指令<u>可能再次被执行</u>；</li>
<li>如果某个<u>存储单元被访问</u>，则不久以后该存储单元<u>可能再次被访问</u>。</li>
</ul>
<p>产生时间局限性的典型原因是<u>在程序中存在着大量的循环操作</u>。</p>
</li>
<li>
<p><strong>空间局限性</strong>：指一旦<u>程序访问了某个存储单元</u>，则在不久的将来，<u>其附近的存储单元也最有可能被访问</u>。</p>
<p>即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为<u>程序是顺序执行的</u>。</p>
</li>
</ul>
<p><strong>段页式存储管理：</strong></p>
<ol>
<li>将整个主存划分成大小相等的存储块（页框）。</li>
<li>将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。</li>
<li>将每个段划分成若干页，以页框为单位离散分配。</li>
</ol>
<h2 id="缓冲" data-numberify>缓冲<a class="anchor ms-1" href="#缓冲"></a></h2>
<p><picture><img class="img-fluid " alt="单缓冲并行工作示意图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189558038.png" loading="lazy" width="1251" height="272" />
</picture>

</p>
<p>$n$个作业的单缓冲所花费的时间为：</p>
<p>$$
(Max(C, T) + M) \times n + Min(C, T)
$$</p>
<p><picture><img class="img-fluid " alt="双缓冲并行工作示意图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189296831.png" loading="lazy" width="1147" height="257" />
</picture>

</p>
<p>$n$个作业的双缓冲所花费的时间为：</p>
<p>$$
Max(T, M, C) \times n + T + M + C - Max(T, M, C)
$$</p>
<p>即，</p>
<p>$$
Max(T, M, C) \times (n - 1) + T + M + C
$$</p>
<h2 id="磁盘调度" data-numberify>磁盘调度<a class="anchor ms-1" href="#磁盘调度"></a></h2>
<ul>
<li>
<p><strong>先来先服务</strong>（First-Come First-Served，FCFS）：根据进程请求访问磁盘的先后次序进行调度。</p>
<ul>
<li>优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。</li>
<li>缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</li>
</ul>
</li>
<li>
<p><strong>最短寻道时间优先</strong>（Shortest Seek Time First，SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。</p>
<ul>
<li>优点：可能会出现饥饿现象。</li>
<li>缺点：不能保证平均寻道时间最短。</li>
</ul>
</li>
<li>
<p><strong>扫描算法</strong>（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。</p>
<p>在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<ul>
<li>优点：避免了饥饿现象的出现。</li>
<li>缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。</li>
</ul>
</li>
<li>
<p><strong>单向扫描算法</strong>（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定磁头只做单向移动。</p>
<p>例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p>
</li>
</ul>
<h2 id="旋转调度算法" data-numberify>旋转调度算法<a class="anchor ms-1" href="#旋转调度算法"></a></h2>
<p><picture><img class="img-fluid " alt="初始逻辑记录分布情况" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683268410250.png" loading="lazy" width="322" height="311" />
</picture>

</p>
<p>设$n$个扇区的磁盘，经过一个扇区的时间为$t$，读取一个记录后处理的时间为$c$，那么：</p>
<ul>
<li>
<p>顺序处理完所有记录的总时间为：</p>
<p>$$
(t + nt) (n-1) + t + c
$$</p>
<p>即：</p>
<p>$$
t \times n^2 + c
$$</p>
</li>
<li>
<p>记录优化后的总时间：</p>
<p>$$
n(t + c)
$$</p>
</li>
</ul>
<h2 id="多级磁盘索引结构" data-numberify>多级磁盘索引结构<a class="anchor ms-1" href="#多级磁盘索引结构"></a></h2>
<ul>
<li>
<p><strong>直接索引</strong>：索引表中的地址项直接指向磁盘数据块。</p>
<p><picture><img class="img-fluid " alt="直接索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683271855209.png" loading="lazy" width="670" height="659" />
</picture>

</p>
</li>
<li>
<p><strong>一级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的记录是地址项，这些地址项直接指向磁盘数据块。</p>
<p>称这个磁盘索引块为<strong>一级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="一级间接地址索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683274982800.png" loading="lazy" width="904" height="737" />
</picture>

</p>
</li>
<li>
<p><strong>二级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的一个记录指向一个一级索引块。</p>
<p>称这个记录指向一级索引块的磁盘索引块为<strong>二级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="二级间接地址索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683275164015.png" loading="lazy" width="1121" height="784" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="面向对象" data-numberify>面向对象<a class="anchor ms-1" href="#面向对象"></a></h1>
<p>跳转连接：<a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/">软件设计师——面向对象篇</a></p>
<h2 id="设计原则" data-numberify>设计原则<a class="anchor ms-1" href="#设计原则"></a></h2>
<ul>
<li>
<p><strong>责任原则</strong>（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>（Open &amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即<strong>开放的</strong>；但是不可修改的，即<strong>封闭的</strong>。</p>
</li>
<li>
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。</p>
<p>即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，<u>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</u>。</p>
</li>
<li>
<p><strong>接口分离原则</strong>（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>即：<u>依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。</u></p>
<p>这样做的好处就在于可以最大限度地应对可能的变化。</p>
</li>
</ul>
<p>Robert C. Martin提出的面向对象设计原则（重点的）：</p>
<ul>
<li><strong>共同封闭原则</strong>（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</li>
<li><strong>共同重用原则</strong>（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。</li>
</ul>
<h2 id="uml" data-numberify>UML<a class="anchor ms-1" href="#uml"></a></h2>
<p><a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#uml">面向对象——UML</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
</li>
</ul>
<h2 id="设计模式" data-numberify>设计模式<a class="anchor ms-1" href="#设计模式"></a></h2>
<p><a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">面向对象——设计模式</a></p>
<p>设计模式代码仓库：<a href="https://gitee.com/linner_cheng/design-patterns" target="_blank" rel="noopener noreferrer">https://gitee.com/linner_cheng/design-patterns<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<p>设计模式分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:left">创建型</th>
<th style="text-align:left">结构型</th>
<th style="text-align:left">行为型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:left">与对象的创建有关</td>
<td style="text-align:left">处理类或对象的组合</td>
<td style="text-align:left">描述类或对象的交互和职责分配</td>
</tr>
<tr>
<td style="text-align:center">类模式</td>
<td style="text-align:left">Factory Method（工厂方法模式）</td>
<td style="text-align:left">Adapter（适配器模式）</td>
<td style="text-align:left">Interpreter（解释器模式）<br>Template Method（模板方法模式）</td>
</tr>
<tr>
<td style="text-align:center">对象模式</td>
<td style="text-align:left">Abstract Factory（抽象工厂模式）<br>Builder（生成器模式）<br>Prototype（原型模式）<br>Singleton（单例模式）</td>
<td style="text-align:left">Adapter（适配器模式）<br>Bridge（桥接模式）<br>Composite（组合模式）<br>Decorator（装饰器模式）<br>Facade（外观模式）<br>Flyweight（享元模式）<br>Proxy（代理模式）</td>
<td style="text-align:left">Chain of Responsibility（责任链模式）<br>Command（命令模式）<br>Iterator（迭代器模式）<br>Mediator（中介者模式）<br>Memento（备忘录模式）<br>Observer（观察者模式）<br>State（状态模式）<br>Strategy（策略模式）<br>Visitor（访问者模式）</td>
</tr>
</tbody>
</table>
<p>创建型设计模式（抽象了对象的实例化过程）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:center">动态生产对象</td>
<td style="text-align:left">定义创建对象的接口，由子类实例化对象。让类的实例化延迟到其子类。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:center">生成系列对象</td>
<td style="text-align:left">提供创建一系列对象的接口，无需指定具体的类。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:center">构造复杂对象</td>
<td style="text-align:left">将复杂对象的构建与表示分离。使得同样的构建可以创建不同的表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:center">克隆对象</td>
<td style="text-align:left">用原型实例指定创建对象的类型，通过复制原型来创建对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:center">一个实例</td>
<td style="text-align:left">保证一个类仅有一个实例，并提供一个全局访问点。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left"><ul><li>一个类不知道它所必须创建对象的类</li><li>由子类来指定创建的对象</li><li>将创建对象的职责委托给多个帮助子类中的某一个</li></ul></td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left"><ul><li>系统独立于它产品的创建、<u>组合</u>和表示</li><li>系统由多个产品系列中的一个来配置</li><li>强调一系列相关产品对象的设计，以便进行联合使用</li><li>提供一个产品类库，只显示它们的接口而不是实现</li></ul></td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left"><ul><li>创建复杂对象的算法，独立于该对象的组成部分以及它们的装配方式</li><li>构造过程必须允许被构造的对象有不同的表示</li></ul></td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left"><ul><li>系统独立于它产品创建、<u>构成</u>和表示</li><li>要实例化的类是在运行时刻指定，如动态装载</li><li>避免创建一个与产品类层次平行的工厂类层次</li></ul></td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left"><ul><li>类只能有一个实例，用户可从一个全局点访问</li><li>这个唯一实例是通过子类化可扩展的，客户无须更改代码就能使用扩展实例</li></ul></td>
</tr>
</tbody>
</table>
<p>结构型模式（组合类或对象获得新的结构）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器（类/对象）</td>
<td style="text-align:center">接口转换</td>
<td style="text-align:left">将类的接口转换成兼容其他类的接口。<br>使原本接口不兼容的类可以一起工作。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:center">抽象与实现分离</td>
<td style="text-align:left">将类的抽象与实现分离，使它们可以独立变化。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">组合对象</td>
<td style="text-align:left">将对象组合成树型结构以表示“部分——整体”的层次结构。<br>使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td style="text-align:center">装饰</td>
<td style="text-align:center">动态附加职责</td>
<td style="text-align:left">动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:center">对外统一接口</td>
<td style="text-align:left">为子系统定义和提供一个统一的对外高层接口（外观）。<br>简化了该子系统的使用。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:center">共享大量细粒度对象</td>
<td style="text-align:left">提供支持大量细粒度对象共享的有效方法。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:center">中介代理</td>
<td style="text-align:left">为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left"><ul><li>使用接口不符合要求的类</li><li>创建可复用、可与其它不相关类或不可预见类协同工作</li><li>（仅适用于对象适配器）想使用子类，但又不想对它们子类化来匹配接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left"><ul><li>在抽象和实现之间没有固定的绑定关系</li><li>抽象以及实现都可以通过生成子类的方法扩充</li><li>对抽象的实现部分的修改不会对用户产生影响</li><li>隐藏抽象的实现</li><li>在多个对象间共享实现，用户并不知道</li></ul></td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left"><ul><li>表示对象的部分——整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，并统一地使用它们</li></ul></td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left"><ul><li>不影响其他对象，而动态透明地添加职责</li><li>处理那些可以撤销的职责</li><li>不能采用子类进行扩充</li></ul></td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left"><ul><li>为一个复杂子系统提供一个简单接口</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性</li><li>需要构建一个层次结构的子系统时</li></ul></td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left"><ul><li>使用了大量的对象，造成很大开销</li><li>对象的大多数状态都可变为外部状态</li><li>删除对象的外部状态后，可以用相对较少的共享对象取代很多组对象</li></ul></td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left"><ul><li>在需要比较通用和复杂对象指针代替简单指针时</li></ul></td>
</tr>
</tbody>
</table>
<p>行为型模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:center">职责传递</td>
<td style="text-align:left">将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。<br>给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:center">请求封装为对象</td>
<td style="text-align:left">将一个请求封装为一个对象，可用不同请求对客户进行参数化。<br>将请求排队或记录日志，支持撤销操作。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:center">语句解释</td>
<td style="text-align:left">给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:center">顺序访问数据集</td>
<td style="text-align:left">提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:center">不直接引用</td>
<td style="text-align:left">用对象封装一系列的对象交互。<br>使各对象不需显式地相互调用，达到低耦合。<br>可以独立改变对象间的交互。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:center">保存状态</td>
<td style="text-align:left">不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。<br>可以在以后恢复保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:center">联动</td>
<td style="text-align:left">定义对象间的一种一对多依赖关系。<br>一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">状态封装成类</td>
<td style="text-align:left">把对象的行为封装在不同的状态对象中。<br>允许一个对象在其内部状态改变时改变它的行为。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:center">多方案切换</td>
<td style="text-align:left">定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:center">框架</td>
<td style="text-align:left">定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。<br>可以不改变算法结构而重新定义其某些特定步骤。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:center">数据与操作分离</td>
<td style="text-align:left">封装作用与某对象结构中元素的操作。<br>可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left"><ul><li>有多个对象处理请求，运行时刻自动确定由谁处理</li><li>不明指定接收者的情况下向多个对象中的一个提交请求</li><li>可处理请求的对象集合被动态指定</li></ul></td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left"><ul><li>抽象出待执行的动作以参数化某对象</li><li>不同的时刻指定、排列和执行请求</li><li>支持取消操作，支持修改日志</li></ul></td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left"><ul><li>文法简单</li><li>效率不是关键问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left"><ul><li>访问聚合对象的内容而不暴露其内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left"><ul><li>一组对象以复杂的方式进行通信</li><li>一个对象引用其他很多对象并且直接与这些对象通信</li><li>定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul></td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left"><ul><li>必须保存一个对象在某一个时刻的（部分）状态</li><li>如果用接口让其他对象直接得到这些状态，会暴露对象的实现细节并破坏对象的封装性</li></ul></td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left"><ul><li>当抽象模型有两个方面，其中一个方面依赖于另一个方面</li><li>当改变一个对象的同时需要改变其他对象，又不知道有多少对象待改变</li><li>当一个对象必须通知其他对象，又不能假定其他对象是谁（不能紧耦合）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left"><ul><li>对象的行为决定于它的状态，且在运行时刻根据状态改变行为</li><li>操作中含有庞大的多分支的条件语句</li></ul></td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left"><ul><li>许多相关的类仅仅是行为有异</li><li>需要使用一个算法的不同变体</li></ul></td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left"><ul><li>一次性实现算法中不变的部分，将可变的行为留给子类实现</li><li>各子类中公共行为被提取到公共父类中，避免代码重复</li></ul></td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left"><ul><li>对象结构包含很多类对象，用户想对这些对象实施操作</li><li>对对象结构中的对象进行很多不同且不相关的操作</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新操作</li></ul></td>
</tr>
</tbody>
</table>
<p>个人理解的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left">具体工厂（工厂接口的实现）创建具体对象。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left">一个具体工厂（抽象工厂的子类）创建多个产品，不同工厂用不同方式创建这一系列产品。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left">复杂对象通过切换构建<code>construct(Builder)</code>来创建不同表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left">多个原型之间通过克隆<code>Prototype.clone()</code>来复制对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left">通过私有化无参构造方法、静态<code>Singleton instance</code>属性和静态<code>getInstance()</code>方法使对象保持单例。</td>
</tr>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left">适配器继承目标类，重写目标类的方法，方法将不兼容的接口包装成与目标类一致的接口。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left">将产品（抽象）与其某属性（实现）分开，通过桥接（组合）产品与其属性独立出来的类来制造不同产品。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left">用树形结构和一致的抽象类让部分和整体的操作一致。如文件树。</td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left">装饰器继承被装饰类，通过构造器传入被装饰对象，然后在与被装饰类一致的方法中添加新操作。多个装饰器嵌套可组成一条装饰链。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left">复杂子系统有很多操作，外观将其简化。跟适配器很像。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left">让一个对象假装成许多个对象。就是很多个对象之间可能有一部分属性的值是一样的，定义一个对象然后共享这部分属性。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left">代理就是给被代理对象加一些操作，跟适配器和外观不同的是代理的接口是与被代理对象一致的。</td>
</tr>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left">有多个接口一致的对象，将请求在这些对象间层层转发，请求可以被其中一个对象处理（JavaWeb里的过滤器）。和嵌套的装饰器很像。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left">就是一个命令一个对象，调用这些对象的方式一致（对象接口一致）。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left">解释语言的上下文。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left">在集合对象的外部，通过迭代器访问集合中的元素，对应的迭代器可由集合对象给出<code>iterator()</code>。跟Java里的迭代器一个样。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left">有多个类似对象，这些对象通过中介互相发送消息（就好像微信聊天一样，微信就是中介）。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left">捕获并保存对象的内部状态，并且可以恢复到原型保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left">在目标对象状态更新时，观察者们可以收到通知<code>update()</code>，然后更新自身状态，与目标对象的状态保持一致。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left">一个状态一个类，在状态中通过判断变换到其它状态。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left">就是动态切换算法。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left">模板实现算法操作中不变的部分，其余的交给子类去实现。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left">就是在<code>Visitor.visit(访问对象)</code>中定义对象的操作，然后在结构类中提供<code>accept(Visitor)</code>来访问这些对象。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="数据库" data-numberify>数据库<a class="anchor ms-1" href="#数据库"></a></h1>
<p>跳转连接：<a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/">软件设计师——数据库篇</a></p>
<h2 id="三级模式两级映像" data-numberify>三级模式两级映像<a class="anchor ms-1" href="#三级模式两级映像"></a></h2>
<p><picture><img class="img-fluid " alt="三级模式两级映像" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681373319410.png" loading="lazy" width="486" height="377" />
</picture>

</p>
<p>三级结构有3类数据模型：</p>
<ul>
<li><strong>外模型</strong>：用户使用的<strong>数据视图</strong>，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。</li>
<li><strong>概念模型</strong>：全局的<strong>逻辑数据视图</strong>，是数据库管理员所看到的实体、实体属性和实体之间的联系。</li>
<li><strong>内模型</strong>：数据的物理<strong>存储模型</strong>。</li>
</ul>
<p>三个物理模型分别对应数据库系统的3层结构：</p>
<ul>
<li>
<p><strong>外模式（子模式、用户模式）</strong>：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。</p>
</li>
<li>
<p><strong>概念模式（模式）</strong>：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。</p>
</li>
<li>
<p><strong>内模式（物理模式、存储模式）</strong>：是数据在数据库内部的表示方式。</p>
<p>定义<u>所有的<strong>内部记录类型</strong>、<strong>索引</strong>和<strong>文件</strong>的组织方式</u>。</p>
</li>
</ul>
<p>数据库系统在三级模式之间提供了两级映像：</p>
<ul>
<li>模式——内模式映像存在于<u>概念级和内部级</u>之间，实现<u>概念模式和内模式</u>间的相互转换。</li>
<li>外模式——模式映像：存在于<u>外部级和概念级</u>之间，实现了<u>外模式和概念模式</u>之间的相互转换。</li>
</ul>
<p>二级映像功能保证数据的独立性：</p>
<ul>
<li><strong>物理独立性</strong>：指当数据库的<u>内模式发生改变时，数据的逻辑结构不变</u>。</li>
<li><strong>逻辑独立性</strong>：指用户的<u>应用程序与数据库的逻辑结构是相互独立的</u>。</li>
</ul>
<h2 id="完整性约束" data-numberify>完整性约束<a class="anchor ms-1" href="#完整性约束"></a></h2>
<ul>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ul>
<h2 id="关系代数运算符" data-numberify>关系代数运算符<a class="anchor ms-1" href="#关系代数运算符"></a></h2>
<p><picture><img class="img-fluid " alt="关系代数运算符" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681431891302.png" loading="lazy" width="735" height="301" />
</picture>

</p>
<ul>
<li>
<p><strong>广义笛卡儿积</strong>（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。</p>
<p>元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \times S$，其形式定义如下：</p>
<p>$$
R \times S = \{ t| (t \ = \ &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \}
$$</p>
<p>如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \times K2$个元组。</p>
<blockquote>
<p>$&lt;t^n, t^m&gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。</p>
</blockquote>
</li>
<li>
<p><strong>投影</strong>（Projection）：投影运算是从关系的<u>垂直方向</u>进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\pi_A (R)$，其形式定义如下：</p>
<p>$$
\pi_A (R) = \{ t[A]|t \in R \}
$$</p>
</li>
<li>
<p><strong>选择</strong>（Selection）：选择运算是从关系的<u>水平方向</u>进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\sigma_F (R)$其形式定义如下：</p>
<p>$$
\sigma_A (R) = \{ t| (t \in R) \wedge F(t) = True \}
$$</p>
<p>其中，$F(t)$中的运算对象可以是：</p>
<ul>
<li>属性名（或列的序号）；</li>
<li>常数；</li>
<li>运算符；</li>
<li>算术比较符（$&lt;, \le, &gt;, \ge, \neq$）；</li>
<li>逻辑运算符（$\wedge, \vee, \neg$）。</li>
</ul>
</li>
<li>
<p><strong>连接</strong>（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。</p>
<blockquote>
<p>可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。</p>
</blockquote>
<ul>
<li>
<p><strong>$\theta$连接</strong>：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[X] \ \theta \ t^m[Y]) \}
$$</p>
<p>其中：</p>
<ul>
<li>$X \theta Y$：连接的条件；</li>
<li>$\theta$：比较运算符；</li>
<li>$X$和$Y$分别为$R$和$S$上度数相等且可比的属性组；</li>
<li>$t^n\left[ X \right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量；</li>
<li>$t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。</li>
</ul>
<p>$\theta$连接也可以表示为：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] \ \theta \ t^m[j]) \}
$$</p>
<p>其中，</p>
<ul>
<li>
<p>$i=1,2,3,\cdots,n$；</p>
</li>
<li>
<p>$j=1,2,3,\cdots,m$；</p>
</li>
<li>
<p>$i \theta j$：</p>
<p>从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\theta$运算的元组进行连接。</p>
</li>
</ul>
<p>$\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\theta$连接可表示为：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \sigma_{X \theta Y}(R \times S)
$$</p>
<p>或：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \sigma_{i \theta j}(R \times S)
$$</p>
</li>
<li>
<p><strong>等值连接</strong>：当$\theta$为“=”时，称之为等值连接，记为$R \mathop{\Join}\limits_{i = j} S$，其形式定义如下：</p>
<p>$$
R \mathop{\Join}\limits_{i = j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] = t^m[j]) \}
$$</p>
</li>
<li>
<p>$F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\mathop{\Join}\limits_{F}$。</p>
<p>$F$是形为$F_1 \wedge F_2 \wedge \cdots \wedge F_n$的公式，每个$F_p$是形为$i \theta j$的式子。</p>
</li>
<li>
<p><strong>自然连接</strong>：自然连接是一种特殊的等值连接，它要求两个关系中<u>进行比较的分量必须是相同的属性组</u>，并且在结果集中<u>将重复属性列去掉</u>。</p>
<p>若：</p>
<ul>
<li>
<p>$t^n \in R$，$t^m \in S$；</p>
</li>
<li>
<p>$R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；</p>
</li>
<li>
<p>假定$R$关系的属性：</p>
<p>$$
A_1,A_2,\cdots,A_{n-k},B_1,B_2,\cdots,B_k
$$</p>
</li>
<li>
<p>$S$关系的属性：</p>
<p>$$
B_1,B2,\cdots,B_k,B_{k+1},B_{k+2},\cdots,B_m
$$</p>
</li>
</ul>
<p>自然连接可以记为$R \Join S$,其形式定义如下：</p>
<p>$$
R \Join S = \{ t| (t = &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (R.B_1 = S.B_1) \wedge (R.B_2 = S.B_2) \wedge \cdots \wedge (R.B_k = S.B_k) \}
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>外连接</strong>（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。</p>
<p>外连接运算有3种：</p>
<ul>
<li>
<p><strong>左外连接</strong>（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>右外连接</strong>（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>全外连接</strong>（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681454087063.png" loading="lazy" width="762" height="575" />
</picture>

</p>
</li>
</ul>
<h2 id="sql" data-numberify>SQL<a class="anchor ms-1" href="#sql"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#sql">数据库篇——SQL</a></p>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。</p>
<p>关键字：<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。</p>
<p>关键字：<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。</p>
<p>关键字：<code>SELECT</code>等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。</p>
</li>
</ol>
<p>授权语句格式（<code>GRANT</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">GRANT</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">TO</span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">WITH</span><span class="w"> </span><span class="k">GRANT</span><span class="w"> </span><span class="k">OPTION</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><p>常见的操作权限如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">对象类型</th>
<th style="text-align:left">操作权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">属性列</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">视图</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">基本表</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALTER</code>、<br><code>INDEX</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:center"><code>DATABASE</code></td>
<td style="text-align:left"><code>CREATETAB</code></td>
</tr>
</tbody>
</table>
<ul>
<li>建立表的权限，可由DBA授予普通用户；</li>
<li><code>WITH GRANT OPTION</code>：表示获得了这些权限的用户还可以将权限赋给其他用户。</li>
</ul>
<p>收回权限语句格式（<code>REVOKE</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">REVOKE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><h2 id="函数依赖" data-numberify>函数依赖<a class="anchor ms-1" href="#函数依赖"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">结论</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">函数依赖</td>
<td style="text-align:left">元组在$X$上的属性值相等，那么在$Y$上的属性值也相等</td>
<td style="text-align:left">$X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">非平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是非平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">完全函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$X&rsquo; \subset X$，$X&rsquo; \not\rightarrow Y$</td>
<td style="text-align:left">$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">部分函数依赖（局部函数依赖）</td>
<td style="text-align:left">$X \rightarrow Y$，$X \stackrel{f}{\not\longrightarrow} Y$</td>
<td style="text-align:left">$Y$对$X$部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">传递依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$，$Y \rightarrow Z$</td>
<td style="text-align:left">$Z$对$X$传递依赖</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">码（候选码，候选关键字）</td>
<td style="text-align:left">若$K \stackrel{f}{\rightarrow} U$，则$K$为$R$的候选码</td>
</tr>
<tr>
<td style="text-align:center">主属性</td>
<td style="text-align:left">包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">非主属性</td>
<td style="text-align:left">不包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">外码</td>
<td style="text-align:left">$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码</td>
</tr>
</tbody>
</table>
<p>Armstrong公理系统：</p>
<table>
<thead>
<tr>
<th style="text-align:center">定律</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自反律</td>
<td style="text-align:left">$Y \subseteq X \subseteq U$</td>
<td style="text-align:left">$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">增广律</td>
<td style="text-align:left">$X \rightarrow Y$，$Z \subseteq U$</td>
<td style="text-align:left">$XZ \rightarrow XZ$</td>
</tr>
<tr>
<td style="text-align:center">传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ Y \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">合并规则</td>
<td style="text-align:left">$X \rightarrow Y,\ X \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow YZ$</td>
</tr>
<tr>
<td style="text-align:center">伪传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ WY \rightarrow Z$</td>
<td style="text-align:left">$XW \rightarrow Z$</td>
</tr>
<tr>
<td style="text-align:center">分解规则</td>
<td style="text-align:left">$X \rightarrow Y,\ Z \subseteq Y$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<h2 id="关系模式的分解" data-numberify>关系模式的分解<a class="anchor ms-1" href="#关系模式的分解"></a></h2>
<ul>
<li><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%97%a0%e6%8d%9f%e8%bf%9e%e6%8e%a5">无损连接</a></li>
<li><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e4%bf%9d%e6%8c%81%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96">保持函数依赖</a></li>
</ul>
<h2 id="范式" data-numberify>范式<a class="anchor ms-1" href="#范式"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e8%8c%83%e5%bc%8f">数据库篇——范式</a></p>
<ol>
<li>
<p>第一范式（1NF）：若关系模式R的<u>每一个分量是不可再分的数据项</u>，则关系模式R属于第一范式。</p>
<p>如，关系模式$R&lt;U,F&gt;$：</p>
<p>$$
U = \{ 学号,姓名,学院,院长,课程号,课程名,成绩 \} \\
F = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长,课程号 \rightarrow 课程名,(学号,课程号) \rightarrow 成绩 \}
$$</p>
</li>
<li>
<p>第二范式（2NF）：若关系模式$R \in 1NF$，且<u>每一个非主属性完全依赖于码</u>，则关系模式$R \in 2NF$。</p>
<p>即当<u>1NF消除了对主键的部分函数依赖后就能满足2NF</u>。</p>
<p>例如，$学号 \rightarrow 学院$，即$(学号,课程号) \stackrel{P}{\rightarrow} 学院$（部分依赖于码），所以$R \not\in 2NF$。</p>
<p><u>模式的分解需要保持函数依赖。</u>根据$F$，将$R$分解为：</p>
<ul>
<li>
<p>$R_1&lt;U_1,F_1&gt;$：</p>
<p>$$
U_1 = \{ 学号,姓名,学院,院长 \} \\
F_1 = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长 \}
$$</p>
</li>
<li>
<p>$R_2&lt;U_2,F_2&gt;$：</p>
<p>$$
U_2 = \{ 课程号,课程名 \} \\
F_2 = \{ 课程号 \rightarrow 课程名 \}
$$</p>
</li>
<li>
<p>$R_3&lt;U_3,F_3&gt;$：</p>
<p>$$
U_3 = \{ 学号,课程号,成绩 \} \\
F_3 = \{ (学号,课程号) \rightarrow 成绩 \}</p>
</li>
</ul>
<p>则，$R1 \in 2NF$，$R2 \in 2NF$，$R3 \in 2NF$。</p>
</li>
<li>
<p>第三范式（3NF）：若关系模式$R(R \in 2NF)$中<u>任何一个非主属性都不传递函数依赖于码</u>。</p>
<p>若关系模式$R&lt;U,F&gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：</p>
<ul>
<li>$X \rightarrow Y(Y \not\rightarrow X)$，</li>
<li>$Y \rightarrow Z$，</li>
</ul>
<p>则关系模式$R \in 3NF$，其中：</p>
<ul>
<li>$Y$为属性组，</li>
<li>$Z(Z \not\subseteq Y)$为非主属性。</li>
</ul>
<p>即当<u>2NF消除了非主属性对主键的传递函数依赖</u>，则称为3NF。</p>
<p>如，$R_1$中有$学号 \rightarrow 学院$，$学院 \rightarrow 院长$（非主属性&quot;院长&quot;传递依赖于主键&quot;学号&quot;）。可将$R_1$分解为：</p>
<ul>
<li>
<p>$R_{11}&lt;U_{11},F_{11}&gt;$：</p>
<p>$$
U_{11} = \{ 学号,姓名,学院 \} \\
F_{11} = \{ 学号 \rightarrow 姓名, 学号 \rightarrow 学院 \}
$$</p>
</li>
<li>
<p>$R_{12}&lt;U_{12},F_{12}&gt;$：</p>
<p>$$
U_{12} = \{ 学院,院长 \} \\
F_{12} = \{ 学院 \rightarrow 院长 \}
$$</p>
</li>
</ul>
</li>
</ol>
<p>范式之间的关系：</p>
<p>$$
5NF \sub 4NF \sub BCNF \sub 3NF \sub 2NF \sub 1NF
$$</p>
<p><picture><img class="img-fluid " alt="规范化范式的包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681894653450.png" loading="lazy" width="564" height="309" />
</picture>

</p>
<p>3NF和BCNE它们是进行规范化的主要目标。</p>
<p>1NF到4NF之间的转换关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">范式</th>
<th style="text-align:left">转换关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1NF</td>
<td style="text-align:left">每一个分量是不可再分的数据项</td>
</tr>
<tr>
<td style="text-align:center">2NF</td>
<td style="text-align:left">1NF消除了部分函数依赖后满足2NF</td>
</tr>
<tr>
<td style="text-align:center">3NF</td>
<td style="text-align:left">2NF消除了非主属性对码的传递函数依赖后满足3NF</td>
</tr>
<tr>
<td style="text-align:center">BCNF</td>
<td style="text-align:left">3NF消除了主属性对码的部分和传递函数依赖后满足BCNF</td>
</tr>
<tr>
<td style="text-align:center">4NF</td>
<td style="text-align:left">BCNF消除非平凡且非函数依赖的多值依赖后满足4NF</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="规范化步骤" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681988070233.png" loading="lazy" width="288" height="303" />
</picture>

</p>
<p>几种范式及其分解的性质：</p>
<table>
<thead>
<tr>
<th style="text-align:left">性质</th>
<th style="text-align:center">3NF</th>
<th style="text-align:center">BCNF</th>
<th style="text-align:center">4NF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">消除函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">消除多值函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">保持函数依赖</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">保持多值函数依赖</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<h2 id="数据库设计" data-numberify>数据库设计<a class="anchor ms-1" href="#数据库设计"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1">数据库篇——数据库设计</a></p>
<h2 id="分布式数据库" data-numberify>分布式数据库<a class="anchor ms-1" href="#分布式数据库"></a></h2>
<p>基本概念：</p>
<ul>
<li><strong>分片透明</strong></li>
<li><strong>复制透明</strong></li>
<li><strong>位置透明</strong></li>
<li><strong>逻辑透明</strong></li>
</ul>
<p>性质：</p>
<ul>
<li><strong>共享性</strong>：数据存储在不同的结点数据共享。</li>
<li><strong>自治性</strong>：指每结点对本地数据都能独立管理。</li>
<li><strong>可用性</strong>：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。</li>
<li><strong>分布性</strong></li>
</ul>
<hr>
<h1 id="结构化设计" data-numberify>结构化设计<a class="anchor ms-1" href="#结构化设计"></a></h1>
<p>跳转连接：<a href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/">软件设计师——结构化设计篇</a></p>
<h2 id="模块化" data-numberify>模块化<a class="anchor ms-1" href="#模块化"></a></h2>
<ul>
<li>
<p><strong>模块</strong>：是在程序中是数据说明、可执行语句等<u>程序对象的集合</u>，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。</p>
<p>在软件的体系结构中，模块是可组合、分解和更换的单元。</p>
</li>
<li>
<p><strong>模块化</strong>：是指<u>将一个待开发的软件分解成若干个小的简单部分一模块</u>，<u>每个模块可独立地开发、测试，最后组装成完整的程序</u>。</p>
<p>这是一种<u>复杂问题“分而治之”的原则</u>。</p>
<p>模块化的<u>目的是使程序的结构清晰，容易阅读、理解、测试和修改。</u></p>
</li>
<li>
<p><strong>模块独立</strong>：是指<u>每个模块完成一个相对独立的特定子功能</u>，并且<u>与其他模块之间的联系简单</u>。</p>
<p>衡量模块独立程度的标准有（模块独立性的两个定性标准）：</p>
<ul>
<li><strong>耦合性</strong>；</li>
<li><strong>内聚性</strong>。</li>
</ul>
<p>在将软件系统划分模块时，应尽量做到<strong>高内聚</strong>、<strong>低耦合</strong>，提高模块的独立性。</p>
</li>
</ul>
<p>通常，可以按照在软件系统中的功能将模块分为四种类型：</p>
<ul>
<li>传入模块：取得数据或输入数据，经过某些处理，再将其传送给其他模块。</li>
<li>传出模块：输出数据，在输出前可能进行某些处理。数据可能被输出到系统的外部，或者会输出到其他模块进行进一步处理。</li>
<li>变换模块：从上级调用模块得到数据，进行特定的处理，转换成其他形式，再将加工结果返回给调用模块。</li>
<li>协调模块：一般不对数据进行加工，主要是通过调用、协调和管理其他模块来完成特定的功能。</li>
</ul>
<h2 id="耦合和内聚" data-numberify>耦合和内聚<a class="anchor ms-1" href="#耦合和内聚"></a></h2>
<p><picture><img class="img-fluid " alt="耦合的种类" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683443957893.png" loading="lazy" width="874" height="133" />
</picture>

</p>
<table>
<thead>
<tr>
<th style="text-align:center">耦合类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无直接耦合</td>
<td style="text-align:left">没有直接关系，不传递任何信息</td>
</tr>
<tr>
<td style="text-align:center">数据耦合</td>
<td style="text-align:left">调用关系，传递简单数据值</td>
</tr>
<tr>
<td style="text-align:center">标记耦合</td>
<td style="text-align:left">传递数据结构</td>
</tr>
<tr>
<td style="text-align:center">控制耦合</td>
<td style="text-align:left">调用关系，被调模块传递给主调模块控制变量</td>
</tr>
<tr>
<td style="text-align:center">外部耦合</td>
<td style="text-align:left">通过软件之外的环境联结</td>
</tr>
<tr>
<td style="text-align:center">公共耦合</td>
<td style="text-align:left">通过公共数据环境相互作用</td>
</tr>
<tr>
<td style="text-align:center">内容耦合</td>
<td style="text-align:left">直接使用另一个模块的内部数据<br>或通过非正常入口转入另一个模块内部</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="内聚的种类" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683460613634.png" loading="lazy" width="852" height="150" />
</picture>

</p>
<table>
<thead>
<tr>
<th style="text-align:center">内聚类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偶然内聚<br>（巧合内聚）</td>
<td style="text-align:left">各处理之间没有任何联系</td>
</tr>
<tr>
<td style="text-align:center">逻辑内聚</td>
<td style="text-align:left">执行若干个逻辑上相似的功能，<br>通过参数确定该模块完成哪一个功能</td>
</tr>
<tr>
<td style="text-align:center">时间内聚</td>
<td style="text-align:left">把需要同时执行的动作组合在一起</td>
</tr>
<tr>
<td style="text-align:center">过程内聚</td>
<td style="text-align:left">完成多个任务，这些任务必须按指定的过程执行</td>
</tr>
<tr>
<td style="text-align:center">通信内聚</td>
<td style="text-align:left">所有处理都在同一个数据结构上操作，<br>或者各处理使用相同的输入数据或者产生相同的输出数据</td>
</tr>
<tr>
<td style="text-align:center">顺序内聚</td>
<td style="text-align:left">各处理都与同一功能密切相关且必须顺序执行，<br>前一功能元素的输出就是下一功能元素的输入</td>
</tr>
<tr>
<td style="text-align:center">功能内聚</td>
<td style="text-align:left">所有元素共同作用完成一个功能，缺一不可</td>
</tr>
</tbody>
</table>
<h2 id="系统结构设计原则" data-numberify>系统结构设计原则<a class="anchor ms-1" href="#系统结构设计原则"></a></h2>
<p>为保证总体结构设计顺利完成，应遵循以下几条原则：</p>
<ul>
<li>
<p><strong>分解——协调原则</strong>：</p>
<p>系统整体，具有其整体的目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</p>
</li>
<li>
<p><strong>自顶向下的原则</strong>：从上往下，逐层分解；先确定上层模块的功能，再确定下层模块的功能。</p>
</li>
<li>
<p><strong>信息隐蔽、抽象的原则</strong>：<u>上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做</u>。</p>
</li>
<li>
<p><strong>一致性原则</strong>：统一的规范、标准、文件模式……</p>
</li>
<li>
<p><strong>明确性原则</strong>：每个模块必须：</p>
<ul>
<li>功能明确、接口明确；</li>
<li>消除多重功能和无用接口。</li>
</ul>
</li>
<li>
<p><strong>高内聚、低耦合</strong></p>
</li>
<li>
<p><strong>模块的扇入系数和扇出系数要合理</strong>：</p>
<ul>
<li><strong>扇出系数</strong>：模块直接调用其他模块的个数。</li>
<li><strong>扇入系数</strong>：模块被其他模块调用时，直接调用它的模块个数。</li>
</ul>
<p><u>一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7</u>。</p>
</li>
<li>
<p><strong>模块的规模适当</strong>：</p>
<ul>
<li><u>过大的模块常常使系统分解得不充分；</u></li>
<li><u>过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</u></li>
</ul>
</li>
<li>
<p><u>模块的作用范围应该在其控制范围之内。</u></p>
</li>
<li>
<p>避免或减少使用病态连接：病态连接是指从中部进入或访问一个模块。</p>
</li>
</ul>
<h2 id="系统文档" data-numberify>系统文档<a class="anchor ms-1" href="#系统文档"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">人员</th>
<th style="text-align:center">阶段</th>
<th style="text-align:left">文档</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用户<br>系统分析人员</td>
<td style="text-align:center">系统规划<br>系统分析</td>
<td style="text-align:left">沟通文档，主要是<strong>规划报告</strong>、<strong>合同</strong>、<strong>方案</strong>：<br><ul><li>可行性研究报告</li><li>总体规划报告</li><li>系统开发合同</li><li>系统方案说明书</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>项目管理人员</td>
<td style="text-align:center">项目期内</td>
<td style="text-align:left">沟通文档（项目管理文件），主要是<strong>计划</strong>、<strong>报告</strong>类文档：<br><ul><li>系统开发计划<ul><li>工作任务分解表</li><li>PERT图</li><li>甘特图</li><li>预算分配表</li></ul></li><li>系统开发月报</li><li>系统开发总结报告</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统测试人员<br>系统开发人员</td>
<td style="text-align:center">测试</td>
<td style="text-align:left">系统测试人员根据以下文档对系统进行测试：<br><ul><li>系统方案说明书</li><li>系统开发合同</li><li>系统设计说明书</li><li>测试计划</li></ul>系统测试人员再将评估结果撰写成系统测试报告</td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>用户</td>
<td style="text-align:center">系统运行期间</td>
<td style="text-align:left">用户通过系统开发人员撰写的文档运行系统：<br><ul><li>用户手册</li><li>操作指南</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>系统维护人员</td>
<td style="text-align:center">维护</td>
<td style="text-align:left">沟通文档：<ul><li>系统设计说明书</li><li>系统开发总结报告<ul><li>研制报告</li><li>研制报告</li><li>技术手册</li></ul></li></ul></td>
</tr>
<tr>
<td style="text-align:center">用户<br>维修人员</td>
<td style="text-align:center">运维</td>
<td style="text-align:left">用户将运行过程中的问题进行记载：<ul><li>系统运行报告</li><li>维护修改建议</li></ul>系统维护人员根据以下文档对系统进行维护和升级：<ul><li>维护修改建议</li><li>系统开发人员留下的技术手册等文档</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="数据流图和数据字典" data-numberify>数据流图和数据字典<a class="anchor ms-1" href="#数据流图和数据字典"></a></h2>
<p><a href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/#%e7%bb%93%e6%9e%84%e5%8c%96%e5%88%86%e6%9e%90%e6%96%b9%e6%b3%95">结构化设计篇——结构化分析方法</a></p>
<hr>
<h1 id="软件工程" data-numberify>软件工程<a class="anchor ms-1" href="#软件工程"></a></h1>
<p>跳转连接：<a href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/">软件设计师——软件工程篇</a></p>
<h2 id="软件过程模型" data-numberify>软件过程模型<a class="anchor ms-1" href="#软件过程模型"></a></h2>
<p>能力成熟度模型（从1开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始级</td>
<td style="text-align:left">杂乱无章，几乎没有明确定义的步骤。</td>
</tr>
<tr>
<td style="text-align:center">可重复级</td>
<td style="text-align:left">建立基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。</td>
</tr>
<tr>
<td style="text-align:center">已定义级</td>
<td style="text-align:left">将管理和工程文档化、标准化并综合成标准软件过程；<br>使用标准开发过程（或方法论）构建（或集成）系统。</td>
</tr>
<tr>
<td style="text-align:center">己管理级</td>
<td style="text-align:left">对软件过程和产品质量制定了的详细度量标准，且有定量的理解和控制。</td>
</tr>
<tr>
<td style="text-align:center">优化级</td>
<td style="text-align:left">加强了定量分析，通过过程质量和新观念、新技术使过程不断地改进。</td>
</tr>
</tbody>
</table>
<p>能力成熟度集成连续式模型（从0开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">能力等级</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未完成的</td>
<td style="text-align:left">未执行或未得到等级1中的所有目标。</td>
</tr>
<tr>
<td style="text-align:center">已执行的</td>
<td style="text-align:left">可标识的输入工作产品到输出工作产品的转换，实现特定目标。<p>关注：特定目标的完成。</p></td>
</tr>
<tr>
<td style="text-align:center">已管理的</td>
<td style="text-align:left">已管理的过程的制度化。<p>关注：针对单个过程实例的能力。</p></td>
</tr>
<tr>
<td style="text-align:center">已定义级的</td>
<td style="text-align:left">已定义的过程的制度化。<p>关注：过程的组织级标准化和部署。</p></td>
</tr>
<tr>
<td style="text-align:center">定量管理的</td>
<td style="text-align:left">可定量管理的过程的制度化。<p>说明：使用测量和质量保证来控制和改进。</p></td>
</tr>
<tr>
<td style="text-align:center">优化的</td>
<td style="text-align:left">优化的过程的制度化。<p>说明：使用量化手段改变和优化。</p></td>
</tr>
</tbody>
</table>
<p>各开发模型的适用范围：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瀑布模型</td>
<td style="text-align:left">将软件生存周期中的活动定为线性顺序链接的阶段模型</td>
<td style="text-align:left">需求明确、大致固定且变更少</td>
</tr>
<tr>
<td style="text-align:center">V模型</td>
<td style="text-align:left">瀑布模型的变体，强调测试贯穿项目的始终，是一种测试的开发模型</td>
<td style="text-align:left">需求明确、低风险</td>
</tr>
<tr>
<td style="text-align:center">增量模型</td>
<td style="text-align:left">融合瀑布模型和原型迭代，核心功能先完成，每轮迭代都会有新的增量，核心功能得到充分测试，强调每个增量均发布一个可操作的产品</td>
<td style="text-align:left">快速构造可运行的产品，产品升级，领域熟悉或已有原型</td>
</tr>
<tr>
<td style="text-align:center">演化模型</td>
<td style="text-align:left">迭代的过程模型，需求无法被完整定义，功能在使用过程中不断完善</td>
<td style="text-align:left">对软件需求缺乏准确认识的情况</td>
</tr>
<tr>
<td style="text-align:center">原型模型</td>
<td style="text-align:left">原型开发方法模型，目的是快速、低成本地构建原型系统</td>
<td style="text-align:left">需求不清或多变、领域陌生；不适合大规模系统</td>
</tr>
<tr>
<td style="text-align:center">螺旋模型</td>
<td style="text-align:left">结合瀑布和演化模型，强调引入风险分析，属于面向对象开发模型</td>
<td style="text-align:left">庞大、复杂、高风险的系统，开发人员有丰富的风险评估经验和知识</td>
</tr>
<tr>
<td style="text-align:center">喷泉模型</td>
<td style="text-align:left">面向对象模型，特点是迭代、无间隙和支持重用，各阶段无明显界限，可迭代交叉</td>
<td style="text-align:left">面向对象的开发过程</td>
</tr>
<tr>
<td style="text-align:center">统一过程</td>
<td style="text-align:left">用例驱动、以架构为中心、迭代和增量</td>
<td></td>
</tr>
</tbody>
</table>
<p>统一过程模型阶段里程碑和关注点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">里程碑</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始阶段</td>
<td style="text-align:left">生命周期目标</td>
<td style="text-align:left">项目的初创活动</td>
</tr>
<tr>
<td style="text-align:center">精化阶段</td>
<td style="text-align:left">生命周期架构</td>
<td style="text-align:left">需求分析和架构演进</td>
</tr>
<tr>
<td style="text-align:center">构建阶段</td>
<td style="text-align:left">初始运作功能</td>
<td style="text-align:left">系统的构建</td>
</tr>
<tr>
<td style="text-align:center">移交阶段</td>
<td style="text-align:left">产品发布</td>
<td style="text-align:left">软件提交方面的工作</td>
</tr>
</tbody>
</table>
<h2 id="软件需求" data-numberify>软件需求<a class="anchor ms-1" href="#软件需求"></a></h2>
<ul>
<li>
<p><strong>功能需求</strong>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p>
</li>
<li>
<p><strong>性能需求</strong>：考虑软件开发的技术性指标。</p>
<p>例如：</p>
<ul>
<li>存储容量限制；</li>
<li>执行速度；</li>
<li>响应时间；</li>
<li>吞吐量。</li>
</ul>
</li>
<li>
<p><strong>用户或人的因素</strong>：考虑用户的类型。</p>
<p>例如：</p>
<ul>
<li>各种用户对使用计算机的熟练程度，需要接受的训练；</li>
<li>用户理解、使用系统的难度；</li>
<li>用户错误操作系统的可能性。</li>
</ul>
</li>
<li>
<p><strong>环境需求</strong>：考虑未来软件应用的环境，包括硬件和软件。</p>
<ul>
<li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li>
<li>对软件的需求包括：操作系统、网络、数据库等。</li>
</ul>
</li>
<li>
<p><strong>界面需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>来自其他系统的输入；</li>
<li>到其他系统的输出；</li>
<li>对数据格式的特殊规定；</li>
<li>对数据存储介质的规定。</li>
</ul>
</li>
<li>
<p><strong>文档需求</strong>：考虑需要哪些文档，文档针对哪些读者。</p>
</li>
<li>
<p><strong>数据需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>输入、输出数据的格式；</li>
<li>接收、发送数据的频率；</li>
<li>数据的准确性和精度；</li>
<li>数据流量；</li>
<li>数据需保持的时间。</li>
</ul>
</li>
<li>
<p><strong>资源使用需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>软件运行时所需要的数据、其他软件、内存空间等资源；</li>
<li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li>
</ul>
</li>
<li>
<p><strong>安全保密要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>是否需要对访问系统或系统信息加以控制；</li>
<li>隔离用户数据的方法；</li>
<li>用户程序如何与其他程序和操作系统隔离</li>
<li>系统备份要求。</li>
</ul>
</li>
<li>
<p><strong>可靠性要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>系统的可靠性要求；</li>
<li>系统是否必须检测和隔离错误；</li>
<li>出错后，重启系统允许的时间。</li>
</ul>
</li>
<li>
<p><strong>软件成本消耗与开发进度需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>开发是否有规定的时间表；</li>
<li>软/硬件投资有无限制。</li>
</ul>
</li>
<li>
<p><strong>其他非功能性要求</strong>：</p>
<p>如采用某种开发模式，需要确定：</p>
<ul>
<li>质量控制标准；</li>
<li>里程碑和评审；</li>
<li>验收标准；</li>
<li>各种质量要求的优先级；</li>
<li>可维护性方面的要求。</li>
</ul>
</li>
</ul>
<h2 id="单元测试" data-numberify>单元测试<a class="anchor ms-1" href="#单元测试"></a></h2>
<p>在测试中应检查以下要点：</p>
<ul>
<li>
<p>模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。</p>
<p>在测试中应检查以下要点：</p>
<ul>
<li>测试模块的<u>输入参数</u>和<u>形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用其他模块时，所给出的<u>实际参数</u>和<u>被调用模块的形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用标准函数时，所用的<u>参数在属性、数目和顺序上是否正确</u>。</li>
<li><u>全局变量在各模块中的定义和用法是否一致。</u></li>
<li><u>输入是否仅改变了形式参数。</u></li>
<li><u>开/关的语句</u>是否正确。</li>
<li>规定的<u>I/O格式</u>是否与输入/输出语句一致。</li>
<li>在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。</li>
</ul>
</li>
<li>
<p>局部数据结构</p>
</li>
<li>
<p>重要的执行路径</p>
</li>
<li>
<p>出错处理</p>
</li>
<li>
<p>边界条件</p>
</li>
</ul>
<h2 id="集成测试" data-numberify>集成测试<a class="anchor ms-1" href="#集成测试"></a></h2>
<ul>
<li>
<p><strong>非增量集成</strong>：分别测试各个模块，再把这些模块组合起来进行整体测试。</p>
<ul>
<li>优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。</li>
<li>缺点：容易混乱，出现错误不容易查找和定位。</li>
</ul>
</li>
<li>
<p><strong>增量集成</strong>：以小增量的方式逐步进行构造和测试。</p>
<p>增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。</p>
</li>
</ul>
<p>增量集成策略：</p>
<ul>
<li>自项向下集成测试：从主控模块（主程序）开始，以深度优先或广度优先的方式。不需要驱动模块。</li>
<li>自底向上集成测试：从原子模块开始进行构造和测试。不需要桩模块。</li>
<li>回归测试</li>
<li>冒烟测试</li>
</ul>
<h2 id="测试方法" data-numberify>测试方法<a class="anchor ms-1" href="#测试方法"></a></h2>
<p>黑白盒测试法属于动态测试。设计测试用例时应包括合理的输入条件和不合理的输入条件。</p>
<h2 id="黑盒测试" data-numberify>黑盒测试<a class="anchor ms-1" href="#黑盒测试"></a></h2>
<p>等价类划分：从每个等价类中选取一个代表性数据作为测试用例。用少量代表性的测试用例取得较好的测试效果。</p>
<p>分为有效等价类和无效等价类。</p>
<p>定义等价类的原则如下。</p>
<ol>
<li>在<u>输入条件规定了取值范围或值的个数</u>的情况下，<u>可以定义1个有效等价类和2个无效等价类</u>。</li>
<li>在<u>输入条件规定了输入值的集合或规定了“必须如何”</u>的条件的情况下，<u>可以定义1个有效等价类和一个无效等价类</u>。</li>
<li>在输入条件是一个<u>布尔量</u>的情况下，<u>可以定义一个有效等价类和一个无效等价类</u>。</li>
<li>在<u>规定了输入数据的一组值（假定$n$个）</u>，并且程序要<u>对每一个输入值分别处理</u>的情况下，<u>可以定义$n$个有效等价类和1个无效等价类</u>。</li>
<li>在<u>规定了输入数据必须遵守的规则</u>的情况下，<u>可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</u>。</li>
<li>在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。</li>
</ol>
<p>无效等价类的划分：每个无效等价类的测试用例，<u>只违反一个输入的取值范围</u>。如果违反了多个输入的取值范围，那便是不好的测试用例。</p>
<p>例如，输入$x$的取值范围是$0 \sim 10$，输入$y$的取值范围是$-10 \sim -1$，那么可以定义三个等价类：</p>
<ul>
<li>有效等价类1：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类2：$x$的取值范围是$x &lt; 0 \ \ OR \ \ x &gt; 10$，输入$y$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类3：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$x &lt; -10 \ \ OR \ \ x &gt; -1$。</li>
</ul>
<p>除了等价类划分还有：</p>
<ul>
<li>边界值分析</li>
<li>错误推测</li>
<li>因果图</li>
</ul>
<h2 id="白盒测试" data-numberify>白盒测试<a class="anchor ms-1" href="#白盒测试"></a></h2>
<p>逻辑覆盖：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。</p>
<p>主要的逻辑覆盖标准有6种，它们的覆盖程度从低到高为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑覆盖</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语句覆盖</td>
<td style="text-align:left">每条语句执行一次</td>
</tr>
<tr>
<td style="text-align:center">分支（判定）覆盖</td>
<td style="text-align:left">每个分支获得一次True/False</td>
</tr>
<tr>
<td style="text-align:center">条件覆盖</td>
<td style="text-align:left">每个分支中的每个逻辑条件的所有可能取值满足一次</td>
</tr>
<tr>
<td style="text-align:center">判定/条件覆盖</td>
<td style="text-align:left">分支覆盖 + 条件覆盖</td>
</tr>
<tr>
<td style="text-align:center">条件组合覆盖</td>
<td style="text-align:left">每个判定中条件的各种可能值的组合都出现一次</td>
</tr>
<tr>
<td style="text-align:center">路径覆盖</td>
<td style="text-align:left">覆盖被测试程序中所有可能的路径</td>
</tr>
</tbody>
</table>
<p>除了逻辑覆盖还有：</p>
<ul>
<li>循环覆盖</li>
<li>基本路径测试</li>
</ul>
<h2 id="软件维护" data-numberify>软件维护<a class="anchor ms-1" href="#软件维护"></a></h2>
<p>正确性和完善性维护是针对来自系统内部的维护，适应性和预防性是针对来自系统外部的维护。</p>
<ul>
<li>
<p>正确性维护针对的是系统内部的错误。</p>
<p>来自系统内部的，与错误有关的都是属于正确性维护。</p>
</li>
<li>
<p>完善性维护针对的是系统内部与功能、性能等方面有关的维护。</p>
<p>来自系统内部的，与系统功能、性能等方面有关的改善都是完善性维护。完善性维护的需求可以来自外部，例如功能的扩展。</p>
</li>
<li>
<p>适应性维护是针对来自系统外部的技术、管理需求等方面的变化。</p>
<p>针对来自系统外部的变化，系统功能等方面没有缺失，仅仅只是适应当前环境变化所做的更改，都是属于适应性维护。</p>
</li>
<li>
<p>预防性维护针对的是未来的环境变化。</p>
</li>
</ul>
<h2 id="沟通路径" data-numberify>沟通路径<a class="anchor ms-1" href="#沟通路径"></a></h2>
<p>软件项目中沟通路径$m$的计算公式（人数$n$）：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="估算模型" data-numberify>估算模型<a class="anchor ms-1" href="#估算模型"></a></h2>
<p>COCOMO模型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型分类</th>
<th style="text-align:left">类型或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本COCOMO模型</td>
<td style="text-align:left">静态单变量模型，对整个软件系统进行估算</td>
</tr>
<tr>
<td style="text-align:center">中级COCOMO模型</td>
<td style="text-align:left">静态多变量模型，将系统模型分为系统和部件2个层次</td>
</tr>
<tr>
<td style="text-align:center">详细COCOMO模型</td>
<td style="text-align:left">将系统模型分为系统、子系统和模块3个层次</td>
</tr>
<tr>
<td style="text-align:center">COCOMOII</td>
<td style="text-align:left">层次结构，分为应用组装模型、早期设计阶段模型和体系结构阶段模型</td>
</tr>
</tbody>
</table>
<p>COCOMOII的使用时期及规模估算选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段性模型</th>
<th style="text-align:center">规模估算选择</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用组装模型</td>
<td style="text-align:center">对象点</td>
</tr>
<tr>
<td style="text-align:center">早期设计阶段模型</td>
<td style="text-align:center">功能点</td>
</tr>
<tr>
<td style="text-align:center">体系结构阶段模型</td>
<td style="text-align:center">代码行</td>
</tr>
</tbody>
</table>
<h2 id="甘特图和pert图" data-numberify>甘特图和PERT图<a class="anchor ms-1" href="#甘特图和pert图"></a></h2>
<p><a href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/#%e8%bf%9b%e5%ba%a6%e7%ae%a1%e7%90%86">软件工程篇——项目进度管理</a></p>
<h2 id="风险分类" data-numberify>风险分类<a class="anchor ms-1" href="#风险分类"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目风险</td>
<td style="text-align:left">威胁到项目计划。<p>风险因素：<br>预算、进度、人员、资源和利益相关者，项目复杂度、规模和结构的不确定性</p></td>
</tr>
<tr>
<td style="text-align:center">技术风险</td>
<td style="text-align:left">威胁到软件的质量及交付时间。<p>风险因素：<br>设计、实现、接口、验证和维护，规格说明的歧义性、技术的不确定性、技术陈旧和使用“前沿”技术</p></td>
</tr>
<tr>
<td style="text-align:center">市场风险</td>
<td style="text-align:left">开发了一个没有人真正需要的产品或系统。</td>
</tr>
<tr>
<td style="text-align:center">策略风险</td>
<td style="text-align:left">开发的产品不再符合公司的整体商业策略。</td>
</tr>
<tr>
<td style="text-align:center">销售风险</td>
<td style="text-align:left">开发了一个销售部门不知道如何去销售的产品。</td>
</tr>
<tr>
<td style="text-align:center">管理风险</td>
<td style="text-align:left">由于重点的转移或人员的变动而失去了高级管理层的支持。</td>
</tr>
<tr>
<td style="text-align:center">预算风险</td>
<td style="text-align:left">没有得到预算或人员的保证。</td>
</tr>
</tbody>
</table>
<p>风险管理总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">风险管理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">风险识别</td>
<td style="text-align:left">指出对项目计划的威胁。可通过建立风险条目检查表识别。</td>
</tr>
<tr>
<td style="text-align:center">风险预测</td>
<td style="text-align:left">从风险发生的可能性或概率、风险产生的后果评估可能发生的风险。</td>
</tr>
<tr>
<td style="text-align:center">风险评估</td>
<td style="text-align:left">从风险发生的概率和产生的影响评估风险。可用定义风险参照水准技术评估。</td>
</tr>
<tr>
<td style="text-align:center">风险控制</td>
<td style="text-align:left">目的是辅助项目建立处理风险的策略。策略是风险避免、风险监控和RMMM计划。</td>
</tr>
<tr>
<td style="text-align:center">风险避免</td>
<td style="text-align:left">应对风险的最好办法是主动地避免风险。</td>
</tr>
<tr>
<td style="text-align:center">风险监控</td>
<td style="text-align:left">项目管理者应监控某些可以提供风险高低变化指示的因素。</td>
</tr>
</tbody>
</table>
<h2 id="isoiec-9126-软件质量模型" data-numberify>ISO/IEC 9126 软件质量模型<a class="anchor ms-1" href="#isoiec-9126-软件质量模型"></a></h2>
<p>由3个层次组成：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>质量子特性</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p>该模型的质量特性和质量子特性：</p>
<table>
<tr>
    <th style="text-align: center;">
        质量特性
    </th>
    <th style="text-align: center;">
        质量子特性
    </th>
</tr>
<tr>
    <td style="text-align: center;" rowspan="6">
        <b>功能性</b>（Functionality）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适合性（Suitability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        准确性（Accurateness）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        互用性（Interoperability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        依从性（Compliance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        安全性（Security）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>可靠性</b>（Reliability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        成熟性（Maturity）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        容错性（Fault tolerance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易恢复性（Recoverability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>易使用性</b>（Usability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易理解性（Understandability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易学性（Learnability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易操作性（Operability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="3">
        <b>效率</b>（Efficiency）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        时间特性（Time behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        资源特性（Resource behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可维护性</b>（Maintainability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易分析性（Analyzability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易改变性（Changeability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        稳定性（Stability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易测试性（Testability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可移植性</b>（Portability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适应性（Adaptability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易安装性（Installability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        一致性（Conformance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易替换性（Replaceability）
    </td>
</tr>
</table>
<p>质量子特性的含义：</p>
<ul>
<li>功能性：
<ul>
<li><strong>适合性</strong>：与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。</li>
<li><strong>准确性</strong>：与能够得到正确或相符的结果或效果有关的软件属性。</li>
<li><strong>互用性</strong>：<u>与其他指定系统进行交互操作</u>的能力相关的软件属性。</li>
<li><strong>依从性</strong>：<u>使软件服从有关的标准、约定、法规及类似规定</u>的软件属性。</li>
<li><strong>安全性</strong>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li>
</ul>
</li>
<li>可靠性：
<ul>
<li><strong>成熟性</strong>：与由软件故障引起失效的频度有关的软件属性。</li>
<li><strong>容错性</strong>：与<u>在软件错误或违反指定接口的情况下维持指定的性能水平</u>的能力有关的软件属性。</li>
<li><strong>易恢复性</strong>：与<u>在故障发生后，重新建立其性能水平并恢复直接受影响数据</u>的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li>
</ul>
</li>
<li>易使用性：
<ul>
<li><strong>易理解性</strong>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li>
<li><strong>易学性</strong>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li>
<li><strong>易操作性</strong>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li>
</ul>
</li>
<li>效率：
<ul>
<li><strong>时间特性</strong>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li>
<li><strong>资源特性</strong>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li>
</ul>
</li>
<li>可维护性：
<ul>
<li><strong>易分析性</strong>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li>
<li><strong>易改变性</strong>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li>
<li><strong>稳定性</strong>：与修改造成未预料效果的风险有关的软件属性。</li>
<li><strong>易测试性</strong>：为确认经修改软件所需努力有关的软件属性。</li>
</ul>
</li>
<li>可移植性：
<ul>
<li><strong>适应性</strong>：与软件转移到不同环境时的处理或手段有关的软件属性。</li>
<li><strong>易安装性</strong>：与在指定环境下安装软件所需努力有关的软件属性。</li>
<li><strong>一致性</strong>：使软件服从与可移植性有关的标准或约定的软件属性。</li>
<li><strong>易替换性</strong>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="计算机网络" data-numberify>计算机网络<a class="anchor ms-1" href="#计算机网络"></a></h1>
<p>跳转连接：<a href="/p/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%af%87/">软件设计师——计算机网络篇</a></p>
<h2 id="网络分类" data-numberify>网络分类<a class="anchor ms-1" href="#网络分类"></a></h2>
<p>按通信距离分类：</p>
<table>
    <tr>
        <th style="text-align:center">
            网络分类
            </th>
        <th style="text-align:center">
            分布距离
        </th>
        <th style="text-align:center">
            计算机分布范围
        </th>
        <th style="text-align:center">
            传输速率
        </th>
    </tr>
    <tr>
        <td style="text-align:center" rowspan="4">
            <b>
                局域网
                <br>
                MAN
            </b>
        </td>
        <tr>
            <td>10m左右</td>
            <td>房间</td>
            <td rowspan="3">
                4Mbps ~ 1Gbps
            </td>
        </tr>
        <tr>
            <td>100m左右</td>
            <td>楼寓</td>
        </tr>
        <tr>
            <td>1000m左右</td>
            <td>校园</td>
        </tr>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                城域网
                <br>
                WAN
            </b>
        </td>
        <td>10km</td>
        <td>城市</td>
        <td>50Kbps ~ 100 Mbps</td>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                广域网
                <br>
                LAN
            </b>
        </td>
        <td>100km以上</td>
        <td>国家或全球</td>
        <td>9.6Kbps ~ 45Mbps</td>
    </tr>
</table>
<h2 id="isoosi-网络体系结构" data-numberify>ISO/OSI 网络体系结构<a class="anchor ms-1" href="#isoosi-网络体系结构"></a></h2>
<p><picture><img class="img-fluid " alt="OSI 参考模型" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875696461.png" loading="lazy" width="390" height="339" />
</picture>

</p>
<ul>
<li>通信子网对应于OSI中的低三层：
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ul>
</li>
<li>资源子网对应于OSI中的高三层：
<ul>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="ISO/OSI RM 内信息流动" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683877150679.png" loading="lazy" width="724" height="404" />
</picture>

</p>
<h2 id="网络的拓扑结构" data-numberify>网络的拓扑结构<a class="anchor ms-1" href="#网络的拓扑结构"></a></h2>
<ul>
<li>
<p>总线型结构：</p>
<p><picture><img class="img-fluid " alt="总线型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875429976.png" loading="lazy" width="223" height="139" />
</picture>

</p>
</li>
<li>
<p>星型结构：</p>
<p><picture><img class="img-fluid " alt="星型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875460651.png" loading="lazy" width="198" height="164" />
</picture>

</p>
</li>
<li>
<p>环型结构：</p>
<p><picture><img class="img-fluid " alt="环型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875485913.png" loading="lazy" width="166" height="157" />
</picture>

</p>
</li>
<li>
<p>树型结构：</p>
<p><picture><img class="img-fluid " alt="树型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875508387.png" loading="lazy" width="184" height="141" />
</picture>

</p>
</li>
<li>
<p>分布式结构：</p>
<p><picture><img class="img-fluid " alt="分布式结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875530047.png" loading="lazy" width="164" height="138" />
</picture>

</p>
</li>
</ul>
<h2 id="网络设备" data-numberify>网络设备<a class="anchor ms-1" href="#网络设备"></a></h2>
<p>按照ISO/OSI的分层将互连设备分类：</p>
<ul>
<li>
<p>物理层设备：</p>
<ul>
<li>中继器（Repeater）</li>
<li>集线器（Hub）：一种多端口的中继器。集线器不能自动寻址，但可以检测发送冲突。</li>
</ul>
</li>
<li>
<p>数据链路层设备：</p>
<ul>
<li>
<p>网桥（Bridge）</p>
</li>
<li>
<p>交换机（Switch）：一种多端口的网桥。</p>
<p>交换技术：</p>
<ul>
<li>端口交换</li>
<li>帧交换</li>
<li>信元交换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络层设备：路由器（Router）</p>
<p><picture><img class="img-fluid " alt="路由器类型" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683956321797.png" loading="lazy" width="554" height="235" />
</picture>

</p>
</li>
<li>
<p>应用层设备：网关（Gateway）</p>
</li>
</ul>
<h2 id="网络传输介质" data-numberify>网络传输介质<a class="anchor ms-1" href="#网络传输介质"></a></h2>
<ul>
<li>有线介质：
<ul>
<li>双绞线（Twisted-Pair）</li>
<li>同轴电缆（Coaxial）</li>
<li>光纤（Fiber Optic）</li>
</ul>
</li>
<li>无线介质：
<ul>
<li>微波</li>
<li>红外线和激光</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="lan-模型" data-numberify>LAN 模型<a class="anchor ms-1" href="#lan-模型"></a></h2>
<p><picture><img class="img-fluid " alt="LAN 层次与 ISO/OSI RM 的对应关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683879193227.png" loading="lazy" width="397" height="252" />
</picture>

</p>
<h2 id="以太网" data-numberify>以太网<a class="anchor ms-1" href="#以太网"></a></h2>
<ul>
<li>IEEE 802.3中定义的标准局域网，速度为10Mbps，传输介质为细同轴电缆；</li>
<li>IEEE 802.3u中定义的快速以太网，速度为100Mbps，传输介质为双绞线；</li>
<li>IEEE 802.3z中定义的千兆以太网，速度为1000Mbps，传输介质为光纤或双绞线。</li>
</ul>
<h2 id="tcpip-协议族" data-numberify>TCP/IP 协议族<a class="anchor ms-1" href="#tcpip-协议族"></a></h2>
<p>基本特性：</p>
<ul>
<li>逻辑编制：IP地址包括：
<ul>
<li>网络ID号：用来标识网络；</li>
<li>子网ID号：用来标识网络上的一个子网；</li>
<li>主机ID号：用来标识子网上的一台计算机。</li>
</ul>
</li>
<li>路由选择</li>
<li>域名（DNS）解析</li>
<li>错误检测</li>
<li>流量控制</li>
</ul>
<p>TCP/IP分层模型由4个层次构成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p><picture><img class="img-fluid " alt="TCP/IP 模型于 OSI 模型的对比" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683880948768.png" loading="lazy" width="697" height="339" />
</picture>

</p>
<ul>
<li>
<p>TCP（传输控制协议）：在IP提供的不可靠数据服务的基础上为应用程序提供了<u>可靠的、面向连接的、全双工的</u>数据传输服务。</p>
<p>采用三次握手来确认建立和关闭连接是否成功。</p>
</li>
<li>
<p>UDP（用户数据报协议）：一种<u>不可靠的、无连接的</u>协议，可以保证应用程序进程间的通信。</p>
</li>
</ul>
<h2 id="地址解析协议" data-numberify>地址解析协议<a class="anchor ms-1" href="#地址解析协议"></a></h2>
<ul>
<li>ARP（地址解析协议）：将IP地址转换为MAC地址（物理地址）。</li>
<li>RARP（反地址解析协议）：将MAC地址转换为IP地址。</li>
</ul>
<h2 id="动态主机配置协议-dhcp" data-numberify>动态主机配置协议 DHCP<a class="anchor ms-1" href="#动态主机配置协议-dhcp"></a></h2>
<p>DHCP客户端可以从DHCP服务器获得以下内容：</p>
<ul>
<li>本机IP地址</li>
<li>DNS服务器地址</li>
<li>DHCP服务器地址</li>
<li>默认网关的地址</li>
</ul>
<h2 id="无效地址" data-numberify>无效地址<a class="anchor ms-1" href="#无效地址"></a></h2>
<ul>
<li>
<p>Windows无效地址：169.254.X.X</p>
<p>169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。</p>
</li>
<li>
<p>Linux无效地址：0.0.0.0</p>
</li>
</ul>
<h2 id="域名和url" data-numberify>域名和URL<a class="anchor ms-1" href="#域名和url"></a></h2>
<pre tabindex="0"><code>主机名.本地名.组名.最高层域名
</code></pre><p>主机所在的网络级别较高：</p>
<pre tabindex="0"><code>本地名.组名.最高层域名
</code></pre><p>URL即统一资源定位器（统一资源定位符）：</p>
<pre tabindex="0"><code>协议名://主机名.域名.域名后缀.域名分类/目录/网页文件
</code></pre><h2 id="ip" data-numberify>IP<a class="anchor ms-1" href="#ip"></a></h2>
<p><strong>IPv4：</strong></p>
<p><picture><img class="img-fluid " alt="IPv4各类地址分配方案" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683896541328.png" loading="lazy" width="484" height="412" />
</picture>

</p>
<p>全<code>0</code>代表的是网络，全<code>1</code>代表的是广播。</p>
<p>IPv4能表示的地址个数为：</p>
<p>$$
2^{32} \approx 40亿
$$</p>
<p><picture><img class="img-fluid " alt="IP地址类默认的子网掩码" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683897195900.png" loading="lazy" width="912" height="144" />
</picture>

</p>
<p>**IPv6：**长达128位的地址空间，彻底解决IPv4地址不足的问题。</p>
<p>IPv6理论上能表示的地址个数：</p>
<p>$$
2^{128} = 3.4 \times 10^{38}
$$</p>
<h2 id="防火墙技术" data-numberify>防火墙技术<a class="anchor ms-1" href="#防火墙技术"></a></h2>
<p>防火墙技术是<u>建立在内外网络边界上的过滤封锁机制</u>，它认为：</p>
<ul>
<li><u>内部网络是安全和可信赖的</u>；</li>
<li><u>外部网络是不安全和不可信赖的</u>。</li>
</ul>
<p>防火墙的作用：<u>防止不希望的、未经授权地进出被保护的内部网络。</u></p>
<p>防火墙技术经历了三个发展阶段：</p>
<ol>
<li>包过滤防火墙</li>
<li>应用代理网关防火墙</li>
<li>状态检测技术防火墙</li>
</ol>
<h2 id="入侵检测" data-numberify>入侵检测<a class="anchor ms-1" href="#入侵检测"></a></h2>
<p>入侵检测系统（DS）作为防火墙之后的第二道安全屏障。</p>
<p>入侵检测系统有效的弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足。</p>
<p>入侵防御系统（IPS）是在入侵检测系统的基础上发展起来的，不仅能检测到网络中的攻击行为，同时主动对攻击行为发出响应，对攻击进行防御。</p>
<h2 id="网络攻击" data-numberify>网络攻击<a class="anchor ms-1" href="#网络攻击"></a></h2>
<p>攻击目标对于攻击者是个黑盒子。</p>
<p>网络攻击手段有：</p>
<ul>
<li>拒绝服务攻击（Dos攻击）：使计算机或网络无法提供正常的服务通过不断向计算机发起请求来实现的。</li>
<li>重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的。</li>
<li>口令入侵攻击。</li>
<li>特洛伊木马。</li>
<li>端口欺骗攻击。</li>
<li>网络监听。</li>
<li>IP欺骗攻击。</li>
<li>SQL注入攻击。</li>
</ul>
<h2 id="病毒" data-numberify>病毒<a class="anchor ms-1" href="#病毒"></a></h2>
<p>病毒类型：</p>
<ul>
<li>
<p>Worm（蠕虫病毒）：</p>
<ul>
<li>欢乐时光，</li>
<li>熊猫烧香，</li>
<li>红色代码，</li>
<li>爱虫病毒，</li>
<li>震网。</li>
</ul>
</li>
<li>
<p>Trojan（特洛伊木马）：通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息。</p>
<p>计算机感染特洛伊木马后的典型线型是<u>有未知程序试图建立网络连接</u>。</p>
<p>常见的木马如冰河。</p>
</li>
<li>
<p>Backdoor（后门病毒）。</p>
</li>
<li>
<p>Macro（宏病毒）：</p>
<p>宏病毒感染的对象主要是<u>文本文档</u>、<u>电子表格</u>等。</p>
</li>
</ul>
<hr>
<h1 id="算法设计与分析" data-numberify>算法设计与分析<a class="anchor ms-1" href="#算法设计与分析"></a></h1>
<p>跳转连接：<a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/">软件设计师——算法设计与分析篇</a></p>
<h2 id="算法设计方法" data-numberify>算法设计方法<a class="anchor ms-1" href="#算法设计方法"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法设计方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治法</td>
<td style="text-align:left"><ol><li>将原问题<strong>分解</strong>成多个<u>与原问题相同的子问题</u></li><li><strong>递归地求解</strong>各子问题</li><li>将子问题的解<strong>合并</strong>成原问题的解</li></ol></td>
<td style="text-align:left">原问题规模大且能分解为多个与原问题相同的子问题</td>
<td style="text-align:left"><ul><li>归并排序</li><li>快速排序</li><li>最大字段和问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">动态规划法</td>
<td style="text-align:left"><ol><li>找出并刻画最优解的结构特征</li><li>递归地定义最优解的值</li><li>自底向上方式计算最优值或构造最优解</li></ol></td>
<td style="text-align:left">求解具有某种最优性质的问题</td>
<td style="text-align:left"><ul><li>0-1 背包问题</li><li>矩阵连乘</li><li>最长公共序列（LCS）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">贪心法</td>
<td style="text-align:left">与动态规划类似，但贪心法考虑的是局部最优解</td>
<td style="text-align:left">并不保证得到全局最优解，但通常能得到近似最优解</td>
<td style="text-align:left"><ul><li>活动选择问题</li><li>背包问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">回溯法</td>
<td style="text-align:left">在解空间树中，按<u>深度优先策略</u>，从根结点出发搜索解空间树</td>
<td style="text-align:left"><ul><li>可以搜索问题的所有解或任一解</li><li>适用于求解组合数较大的问题</li><li>通过限界函数减少问题的搜索空间</li></ul></td>
<td style="text-align:left"><ul><li>0-1背包问题</li><li>n皇后问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">分支限界法</td>
<td style="text-align:left">与回溯法类似，在解空间树种按<u>广度优先</u>或<u>最小耗费</u>优先方式，搜索满足约束条件的一个解</td>
<td style="text-align:left"><ul><li>可以给出<u>在某种意义下的最优解</u></li><li>分为队列式和优先队列式，优先队列式通过最大堆或最小堆实现</li></u></ul></td>
<td style="text-align:left"><ul><li>0-1 背包问题</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="算法实例" data-numberify>算法实例<a class="anchor ms-1" href="#算法实例"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e7%ae%97%e6%b3%95%e5%ae%9e%e4%be%8b">算法设计与分析篇——算法实例</a></p>
<h2 id="查找算法" data-numberify>查找算法<a class="anchor ms-1" href="#查找算法"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">算法设计与分析篇——查找算法</a></p>
<p>查找算法在查找成功时的<u>平均查找长度</u>关键字和给定值比较次数的期望值：</p>
<p>$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$</p>
<ul>
<li>
<p>$P_i$为对表中第$i$个记录进行查找的概率，</p>
<p>一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；</p>
</li>
<li>
<p>$C_i$为查找成功时，已经进行过比较的关键字个数。</p>
</li>
</ul>
<p>静态查找表有以下查找方法：</p>
<ul>
<li>顺序查找；</li>
<li>折半查找；</li>
<li>分块查找。</li>
</ul>
<p>动态查找表有以下查找方法：</p>
<ul>
<li>二叉排序树；</li>
<li>平衡排序树；</li>
<li>B-树；</li>
<li>哈希表。</li>
</ul>
<p><strong>顺序查找</strong>中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：</p>
<p>$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<p><strong>折半查找</strong>的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：</p>
<p>$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$</p>
<p>当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。</p>
<h2 id="哈希函数" data-numberify>哈希函数<a class="anchor ms-1" href="#哈希函数"></a></h2>
<p><strong>哈希函数构造方法</strong>：</p>
<ul>
<li>直接定址法；</li>
<li>数字分析法；</li>
<li>平方取中法；</li>
<li>折叠法；</li>
<li>随机数法；</li>
<li>除留余数法</li>
</ul>
<p>哈希函数的构造要考虑到：</p>
<ul>
<li>压缩性：节省存储空间；</li>
<li>散列性：尽量减少冲突。</li>
</ul>
<p><strong>除留取余数法：</strong></p>
<p>$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$</p>
<p><strong>冲突处理方法：</strong></p>
<ul>
<li>开放地址法；</li>
<li>多重散列法（再哈希法）；</li>
<li>链地址法；</li>
<li>公共溢出区法……</li>
</ul>
<p><strong>开放地址法</strong>（三种寻找空散列地址的方法）：</p>
<ul>
<li>
<p>线性探测法（线性探测再散列）：</p>
<p>$$
H_i=(H(key)+d) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$d$取$0,1,2,&hellip;,m-1$；</li>
<li>$m$为散列表的长度。</li>
</ul>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
</li>
<li>
<p>二次探测法（二次探测再散列）：</p>
<p>$$
H_i=(H(key)+q^2) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$q$取$0,1,-1,2,-2,&hellip;,\pm k$，$k \le \cfrac{m}{2}$</li>
<li>$m$为散列表的长度</li>
</ul>
</li>
</ul>
<h2 id="排序算法" data-numberify>排序算法<a class="anchor ms-1" href="#排序算法"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">算法设计与分析篇——排序算法</a></p>
<p>排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$值相同，且$R_i$领先于$R_j$，排序后：</p>
<ul>
<li><strong>稳定排序</strong>：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；</li>
<li><strong>不稳定排序</strong>：排序后可能出现$R_j$领先于$R_i$的情况。</li>
</ul>
<p>根据记录存储的位置可分为：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存储在内存中进行排序的过程。</li>
<li><strong>外部排序</strong>：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">是否归位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(log_2{n})$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>是否归位：在排序过程中，能否确定某些元素的最终排序位置。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>软考图类汇总篇</title>
      <link>/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/</link>
      <pubDate>Sat, 20 May 2023 13:29:14 +0800</pubDate>
      
      <guid>/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/</guid>
      <description><![CDATA[数据流图（DFD） 数据流图是在逻辑上描述系统的功能、输入、输出和数据存储等。 数据流图中的基本图形元素包括： 基本元素 图形表示 数据流 加工 数据存储]]></description>
      <content:encoded><![CDATA[<h1 id="数据流图dfd" data-numberify>数据流图（DFD）<a class="anchor ms-1" href="#数据流图dfd"></a></h1>
<p>数据流图是在逻辑上描述系统的功能、输入、输出和数据存储等。</p>
<p>数据流图中的基本图形元素包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本元素</th>
<th style="text-align:center">图形表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据流</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据流" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">加工</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="加工" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">数据存储</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据存储" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">外部实体</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="外部实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>软件系统内部的<strong>数据处理模型</strong>，使用<u>数据流</u>、<u>加工</u>和<u>数据存储</u>构建。</p>
<ul>
<li>
<p><strong>数据流</strong>（Data Flow）：由一组固定成分的数据组成，表示数据的流向。</p>
<p><picture><img class="img-fluid " alt="数据流" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</p>
<p>在DFD种，数据流的流向由以下几种：</p>
<ul>
<li>从<u>加工</u>流向另一个<u>加工</u>；</li>
<li>从<u>加工</u>流向<u>数据存储</u>（写）；</li>
<li>从<u>数据存储</u>流向<u>加工</u>（读）；</li>
<li>从<u>外部实体</u>流向<u>加工</u>（输入）；</li>
<li>从<u>加工</u>流向<u>外部实体</u>（输出）。</li>
</ul>
<p>即数据流的<u>起点或终点必须至少有一个是加工</u>。</p>
<p>除了与数据存储有关的数据流（流向数据存储或从数据存储流出），DFD中的每个数据流都必须用一个定义明确的名字表示。</p>
</li>
<li>
<p><strong>加工</strong>（Process）：加工描述了输入数据流到输出数据流之间的变换，也就是<u>输入数据流经过什么处理后变成了输出数据流</u>。</p>
<p><picture><img class="img-fluid " alt="加工" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</p>
<p>每个加工都有一个名字和编号。</p>
<p>一个加工可以有多个输入数据流和多个输出数据流，但<u>至少有一个输入数据流和一个输出数据流</u>。</p>
<p>数据流图中常见的3种错误如下所示：</p>
<ul>
<li>
<p><strong>黑洞</strong>：加工只有输入，没有输出。</p>
<p>如下图加工1。</p>
</li>
<li>
<p><strong>白洞</strong>：加工只有输出但没有输入。</p>
<p>如下图加工2。</p>
</li>
<li>
<p><strong>灰洞</strong>：加工中输入数据不足以产生输出数据。</p>
<p>有几种可能的原因：</p>
<ul>
<li>一个错误的命名过程；</li>
<li>错误命名的输入或输出；</li>
<li>不完全的事实。</li>
</ul>
<p>如下图加工3。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="数据流图中常见错误" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683528176745.png" loading="lazy" width="793" height="542" />
</picture>

</p>
</li>
<li>
<p><strong>数据存储</strong>（Data Store）：存储和提供数据。</p>
<p><picture><img class="img-fluid " alt="数据存储" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</p>
<p>每个数据存储都有一个定义明确的名字标识。</p>
<p>数据存储可以：</p>
<ul>
<li>存储加工的输出数据：数据流流入数据存储，表示数据的写入操作；</li>
<li>提供加工的输入数据：数据流从数据存储流出，表示数据的读操作。</li>
<li>双向箭头的数据流指向数据存储，表示对数据的修改。</li>
</ul>
<p>DFD中的数据存储在具体实现时可以用以下方式实现：</p>
<ul>
<li>文件系统实现；</li>
<li>数据库系统实现。</li>
</ul>
<p>数据存储的存储介质可以是：</p>
<ul>
<li>磁盘、</li>
<li>磁带、</li>
<li>其他存储介质。</li>
</ul>
</li>
<li>
<p><strong>外部实体</strong>（External Agent，外部主体）：指<u>存在于软件系统之外的人员、组织、物体或外部系统</u>，它指出系统所需数据的<u>发源地（源）</u>和<u>系统所产生的数据的归宿地（宿）</u>。</p>
<p><picture><img class="img-fluid " alt="外部实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</p>
<p>例如：</p>
<ul>
<li>人员：学生、老师、员工、主观、医生、客户……</li>
<li>组织：供应商、采购部门……</li>
<li>物体：传感器、控制器、单车、车辆……</li>
<li>外部系统：支付系统、车辆交易系统、库存管理系统、道闸控制系统……</li>
</ul>
<p>在许多系统中，某个源和某个宿可以是同一个人员、组织、物体或外部系统，此时，在DFD中可以用同一个符号表示：</p>
<ul>
<li>当数据流从该符号流出时，表示它是源；</li>
<li>当数据流流向该符号时，表示它是宿；</li>
<li>当两者皆有时，表示它既是源又是宿。</li>
</ul>
<p>外部实体表示存在于系统之外的对象，用来帮助用户理解系统数据的来源和去向。</p>
</li>
</ul>
<p>数据流图必须确保：</p>
<ul>
<li>数据流的起点或终点必须至少有一个是加工。</li>
<li>加工至少有一个输入数据流和一个输出数据流。</li>
</ul>
<p>分层数据流图：</p>
<ol>
<li>
<p>顶层图：描述系统的输入和输出。</p>
<p>即描述系统从哪些外部实体接受数据流，以及系统发送数据流到哪些外部实体。</p>
<ul>
<li>顶层图只有一个加工，即待开发的软件系统。</li>
<li>顶层图中的数据流就是系统的输入/输出信息。</li>
<li>顶层图中通常没有数据存储。</li>
</ul>
</li>
<li>
<p>0层图：分解顶层图的加工。</p>
</li>
<li>
<p>再分解：将DFD中某些比较复杂的加工再次分解成一张DFD子图。</p>
</li>
</ol>
<hr>
<h1 id="实体联系图e-r-图erd" data-numberify>实体联系图（E-R 图，ERD）<a class="anchor ms-1" href="#实体联系图e-r-图erd"></a></h1>
<p>E-R图有以下几个成分（包含扩充的E-R模型成分）：</p>
<p><picture><img class="img-fluid " alt="E-R图中的主要构件" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682508598814.png" loading="lazy" width="1035" height="391" />
</picture>

</p>
<ul>
<li>
<p><strong>实体</strong>：用<strong>矩形</strong>表示。</p>
<ul>
<li>
<p><strong>弱实体</strong>：使用<strong>双线矩形框</strong>表示。将需要依赖其他实体存在的实体。</p>
<p>实体间的所有（Ownership，拥有）关系代表一个实体对另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提。</p>
<p>例如职工与家属的联系，家属总是属于某职工的（在关系模式中需要依赖职工而存在），所以家属是弱实体。</p>
</li>
<li>
<p><strong>特殊化</strong>：将一个实体集<u>按照某些特性区分为几个<strong>子实体</strong></u>。这种从普遍到特殊的过程即为特殊化。</p>
<p>子实体的图形表示如下：</p>
<p><picture><img class="img-fluid " alt="子实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684564987147.png" loading="lazy" width="256" height="145" />
</picture>

</p>
<p>子实体由称为子类，它会有一个超类，并且能继承超类的属性，超类的属性是实体集中所有子实体的相同属性。</p>
</li>
</ul>
</li>
<li>
<p><strong>联系</strong>：用<strong>棱形</strong>表示，并用无向边分别与有关实体连接起来，同时在无向边标注联系的类型。</p>
<p>联系的类型有两种：</p>
<ul>
<li>
<p>两个实体间的联系：</p>
<ul>
<li>$1:1$：一对一联系；</li>
<li>$1:n$：一对多联系；</li>
<li>$m:n$：多对多联系。</li>
</ul>
</li>
<li>
<p>两个以上实体间的联系：</p>
<p>例如3个实体间的联系有：</p>
<ul>
<li>$1:1:1$</li>
<li>$1:1:n$</li>
<li>$1ⓜ️n$</li>
<li>$rⓜ️n$</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>属性</strong>：用<strong>椭圆形</strong>表示，并用无向边将其与相应的实体连接起来</p>
<p>E-R模型中的属性有以下分类：</p>
<ul>
<li>简单属性：是原子的、不可再分的。</li>
<li>复合属性：可以细分为更小的部分。</li>
<li>单值属性：一个属性对应一个值。</li>
<li>多值属性：一个属性对应一组值。</li>
<li>NULL属性：实体在某个属性上没有值或属性值未知时，使用NULL值表示。</li>
<li>派生属性：派生属性可以从其他属性得来（通过运算等方式求出）。</li>
</ul>
</li>
</ul>
<h2 id="概念结构模型合并分-e-r-图" data-numberify>概念结构模型（合并分 E-R 图）<a class="anchor ms-1" href="#概念结构模型合并分-e-r-图"></a></h2>
<p>建立概念结构模型的步骤如下：</p>
<ol>
<li>
<p>选择局部应用：选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能。</p>
</li>
<li>
<p>逐一设计分E-R图。</p>
</li>
<li>
<p>E-R图合并：</p>
<p>合并时需要考虑各分E-R图之间的冲突：</p>
<ul>
<li><strong>属性冲突</strong>：同一属性在不同的分E-R图上的属性类型、取值范围和数据单位等可能会不一致。</li>
<li><strong>命名冲突</strong>：相同意义的属性在不同的分E-R图上可能会有不同的命名。</li>
<li><strong>结构冲突</strong>：同一实体在不同的分E-R图中可能会有不同的属性；同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又可能被抽象为属性，反之亦然。</li>
</ul>
</li>
</ol>
<h2 id="转换关系模式" data-numberify>转换关系模式<a class="anchor ms-1" href="#转换关系模式"></a></h2>
<ol>
<li>
<p>实体向关系模式的转换：</p>
<p>将E-R图中的实体逐一转换成为一个关系模式：</p>
<ul>
<li>实体名：对应关系模式的名称；</li>
<li>实体的属性：转换成关系模式的属性；</li>
<li>实体标识符：关系的码（键）。</li>
</ul>
<p>超类和子类的转换：超类和子类定义为两个关系模式，将超类的主键加到子类中。</p>
</li>
<li>
<p>联系向关系模式的转换：</p>
<ul>
<li>
<p>一对一联系的转换：</p>
<p>有两种方式：</p>
<ul>
<li>
<p>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码。</p>
<p>那么一个一对一联系需要转换成三个关系模式。</p>
</li>
<li>
<p>方式2（一般使用该方式）：将联系归并到关联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体码保持不变。</p>
<p>一个一对一联系仅需转换成两个关系模式。</p>
</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="联系向关系模式的转换示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682562445900.png" loading="lazy" width="304" height="358" />
</picture>

</p>
<ul>
<li>
<p>方式1：</p>
<p>厂长（<strong>姓名</strong>，性别，年龄）</p>
<p>工厂（<strong>厂号</strong>，厂名，地点）</p>
<p>管理（（厂长）<strong>姓名</strong>，厂号，任期）</p>
<blockquote>
<p>粗体代表该关系模式的码。管理的码可以为姓名或厂号。</p>
</blockquote>
</li>
<li>
<p>方式2：</p>
<p>厂长（姓名，性别，年龄）</p>
<p>工厂（厂号，厂名，地点，（厂长）姓名，任期）</p>
</li>
</ul>
</li>
<li>
<p>一对多联系的转换：</p>
<p>两种方式：</p>
<ul>
<li>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，<u>关系的码是多方实体的码</u>；</li>
<li>方式2（一般使用该方式）：将联系<u>归并到关联的两个实体的多方</u>，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变。</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="一对多联系转换的例子" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682563544291.png" loading="lazy" width="315" height="361" />
</picture>

</p>
<ul>
<li>
<p>方式1:</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格）</p>
<p>仓储（<strong>货号</strong>，仓库号，数量）</p>
</li>
<li>
<p>方式2：</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格，仓库号，数量）</p>
</li>
</ul>
</li>
<li>
<p>多对多联系的转换：</p>
<p>多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。</p>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="多对多联系转换的示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682564018777.png" loading="lazy" width="327" height="373" />
</picture>

</p>
<p>转换成：</p>
<p>学生（<strong>学号</strong>，姓名，性别，年龄）</p>
<p>课程（<strong>课程号</strong>，课程名，学时）</p>
<p>选修（<strong>（学号，课程号）</strong>，成绩）</p>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="uml" data-numberify>UML<a class="anchor ms-1" href="#uml"></a></h1>
<p>UML（Unified Modeling Language，统一建模语言）是面向对象软件的标准化建模语言。</p>
<p>UML中包含3种基本构造块：</p>
<ul>
<li>事物；</li>
<li>关系；</li>
<li>图。</li>
</ul>
<h2 id="事物" data-numberify>事物<a class="anchor ms-1" href="#事物"></a></h2>
<p>UML中有4种事物：</p>
<ul>
<li>
<p><strong>结构事物</strong>（Structural Thing）：模型的<u>静态部分</u>。</p>
<p><picture><img class="img-fluid " alt="结构事物的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682055522161.png" loading="lazy" width="708" height="294" />
</picture>

</p>
</li>
<li>
<p><strong>行为事物</strong>（Behavior Thing）：模型的<u>动态部分</u>。</p>
<p><picture><img class="img-fluid " alt="行为事物的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682055712246.png" loading="lazy" width="621" height="133" />
</picture>

</p>
</li>
<li>
<p>分组事物（Grouping Thing）：模型的<u>组织部分</u>。</p>
</li>
<li>
<p>注释事物（Annotational Thing）：模型的<u>解释部分</u>。</p>
</li>
</ul>
<h2 id="关系" data-numberify>关系<a class="anchor ms-1" href="#关系"></a></h2>
<p>UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：</p>
<ul>
<li>
<p><strong>依赖</strong>（Dependency）：是<u>两个事物间的语义关系，其中一个事物（<strong>独立事物</strong>）发生变化会影响另一个事物（<strong>依赖事物</strong>）的语义</u>。</p>
<p>在图形上，把一个依赖画成一条<u>可能有方向的虚线</u>，如图：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p>依赖有偶然性和临时性，即需要的时候依赖，不需要的时候不依赖。</p>
</li>
<li>
<p><strong>关联</strong>（Association）：是一种<u>结构关系</u>，它描述了一组链，<u>链是对象之间的连接</u>。</p>
<p>关联使用<u>实线</u>表示，在关联上可以标注重复度（Multiplicity）和角色（Role）。</p>
<p>描述了<u>整体和部分</u>间的结构关系的特殊类型的关联：</p>
<ul>
<li>
<p><strong>聚集</strong>（Aggregation，聚合）：<u>部分和整体的生命周期不一致</u>，整体消失了，部分仍然存在，<u>部分可以脱离整体存在</u>。</p>
<p>使用一端带<u>空心菱形</u>的实线表示。</p>
</li>
<li>
<p><strong>组合</strong>：<u>部分和整体的生命周期一致</u>，整体消失了，部分也消失了，<u>部分不可以脱离整体而存在</u>。</p>
<p>使用一端带<u>实心菱形</u>的实线表示。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="关联和聚集的图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<blockquote>
<p>聚合和组合中，带菱形的一端指向整体，另一端指向部分。</p>
<p>关联的关系强度比依赖的关系强度要强一点。</p>
</blockquote>
<ul>
<li>
<p>单向关联：用<u>带箭头实线</u>表示。</p>
</li>
<li>
<p>多重度：</p>
<p>进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示<u>关联中的数量关系</u>，即多重度。表示数量关系时，<u>用多重度说明数量或数量范围</u>，<u>表示有多少个实例（对象）能被连接起来</u>，即<u>一个类的实例能够与另一个类的多少个实例相关联</u>。</p>
</li>
<li>
<p>关联类：</p>
<p>当两个类之间的关联的重复度是多对多时，需要借助额外的属性来帮助表达它们之间的关系，而这个属性就需要定义在一个新的关联类中。关联类记录了这两个类之间的关联信息。关联中这些额外的属性用一条<u>垂直于关联的实线</u>表示，实线的一段连接接到关联的实线上，另一端指向这些属性。</p>
</li>
</ul>
</li>
<li>
<p><strong>泛化</strong>（Generalization）：是一种特殊/一般关系，<u>特殊元素（子元素）的对象可替代一般元素（父元素）的对象</u>。用这种方法，<u>子元素共享了父元素的结构和行为</u>。</p>
<p>在图形上，把一个泛化关系画成一条<u>带有空心箭头的实线</u>，它指向父元素：</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
<li>
<p><strong>实现</strong>（Realization）：是<u>类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约</u>。</p>
<p>在图形上，把一个实现关系画成一条<u>带有空心箭头的虚线</u>，箭头指向模板类，另一端于实现类连接。</p>
<p><picture><img class="img-fluid " alt="实现的图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682058026631.png" loading="lazy" width="167" height="61" />
</picture>

</p>
</li>
</ul>
<h2 id="uml图" data-numberify>UML图<a class="anchor ms-1" href="#uml图"></a></h2>
<h3 id="类图" data-numberify>类图<a class="anchor ms-1" href="#类图"></a></h3>
<p>类图（Class Diagram）<u>展现了一组对象、接口、协作和它们之间的关系</u>。在面向对象系统的建模中<u>最常见的图就是类图</u>。类图给出<u>系统的静态设计视图</u>。</p>
<p>类图中通常包括下述内容：</p>
<ul>
<li>
<p>类：</p>
<p><picture><img class="img-fluid " alt="类的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684650129674.png" loading="lazy" width="142" height="139" />
</picture>

</p>
<p>类中的方法和属性前面有以下三种修饰符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>public</code> 公有的</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>private</code> 私有的</td>
</tr>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:center"><code>protected</code> 受保护的</td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>package</code> 包的</td>
</tr>
</tbody>
</table>
<p>例如：</p>
  <table style="width: 200px; margin: auto;">
      <tr><th>Student</th></tr>
      <tr>
      <td>
      <p>
          <code>- id&nbsp;&nbsp;&nbsp;:&nbsp;int</code>
          <br>
          <code>+ name&nbsp;:&nbsp;String</code>
          <br>
          <code>+ age&nbsp;&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
      <tr>
      <td>
      <p>
          <code>+ getId()&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
  </table>
</li>
<li>
<p>接口：</p>
<p><picture><img class="img-fluid " alt="接口的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</p>
</li>
<li>
<p>协作：</p>
<p><picture><img class="img-fluid " alt="协作的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</p>
</li>
<li>
<p>关系：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="关联图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
<h3 id="对象图" data-numberify>对象图<a class="anchor ms-1" href="#对象图"></a></h3>
<p>对象图（Object Diagram）展现了<u>某一时刻一组对象以及它们之间的关系</u>，<u>描述了在类图中所建立的事物的实例的静态快照</u>。</p>
<p>对象图一般包括对象和链，如图：</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
<p>对象：对象图中的对象包含了类名、对象名和属性。</p>
<p>其图形化如下：</p>
<table style="width: 150px; text-align: center;">
    <tr>
    <th style="text-align: center;">
        对象名 : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>匿名对象（没有对象名）：</p>
<table style="width: 150px;">
    <tr>
    <th style="text-align: center;">
        : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>和类图一样，对象图给出<u>系统的静态设计视图</u>或<u>静态进程视图</u>，但它们是<u>从真实的或原型实例的角度建立的</u>。</p>
<h3 id="用例图" data-numberify>用例图<a class="anchor ms-1" href="#用例图"></a></h3>
<p>用例图（Use Case Diagram）通常包括以下内容：</p>
<ul>
<li>
<p>用例：是从<strong>用户角度</strong>描述<strong>系统的行为</strong>，它将<strong>系统的一个功能</strong>描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。</p>
<p>用例是一个类，它代表<strong>一类功能</strong>而不是使用该功能的某一具体实例。</p>
<p><picture><img class="img-fluid " alt="用例的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</p>
</li>
<li>
<p>参与者：是与系统交互的<strong>外部实体</strong>。</p>
<p>参与者用一个<u>人形图标</u>表示。</p>
</li>
<li>
<p>关系：</p>
<ul>
<li>
<p>用例之间的关系：</p>
<ul>
<li>
<p>包含关系：用带<code>&lt;&lt;include&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</p>
</li>
<li>
<p>扩展关系：用带<code>&lt;&lt;extend&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="扩展关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</p>
<p>扩展用例是指，一个用例中，符合某些特定情况才会触发的另一个用例。</p>
<p>即一个用例执行的时候，可能会发生一些特殊情况或可选情况，这种情况就是这个用例的扩展用例。</p>
</li>
</ul>
</li>
<li>
<p>参与者和用例之间的关联关系。</p>
</li>
<li>
<p>用例与用例以及参与者与参与者之间的泛化关系。</p>
</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
<h3 id="序列图" data-numberify>序列图<a class="anchor ms-1" href="#序列图"></a></h3>
<p>序列图（Sequence Diagram，<strong>顺序图</strong>）<u>描述了以时间顺序组织的对象之间的交互活动</u>，<u>强调消息时间顺序</u>。</p>
<p>序列图的组成：</p>
<ol>
<li>
<p>把参加交互的对象放在图的上方，沿水平方向排列。</p>
<p>通常把发起交互的对象放在左边，下级对象依次放在右边。</p>
</li>
<li>
<p>把这些对象发送和接收的消息，沿垂直方向，按时间顺序从上到下放置。</p>
</li>
</ol>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
<p>序列图的组成部分：</p>
<ul>
<li>
<p>对象：用方框框起来的<code>对象名:类名</code>，没有属性和方法等成分。</p>
</li>
<li>
<p><strong>对象生命线</strong>：表示<u>一个对象存在的时间段</u>。</p>
<p>如上图中对象下方垂直的虚线。</p>
<ul>
<li>对象可以在交互过程中创建：生命线从接收到构造型<code>create</code>消息开始；</li>
<li>也可以在交互过程中撤销：生命线从接收到构造型<code>destroy</code>消息结束，并且给出一个大$\times$的标记表明生命线的结束。</li>
</ul>
</li>
<li>
<p><strong>控制焦点</strong>：控制焦点表示<u>一个对象执行一个动作所经历的时间段</u>。</p>
<p>如上图中对象下方的空表矩形条框。</p>
</li>
<li>
<p><strong>消息</strong>：</p>
<p>普通的消息用<u>带箭头的实线</u>表示。所有消息的箭头都是指向接收对象。</p>
<ul>
<li>返回消息：用<u>带箭头的虚线</u>表示。</li>
<li>同步消息（调用消息）：指消息发送给接收对象后，需要等待接收对象返回后才可进行下一步操作。</li>
<li>异步消息：指消息发送给接收对象后，无需等待接收对象返回即可进行下一步操作。</li>
</ul>
</li>
</ul>
<p>序列图有两个不同于通信图的特性：</p>
<ul>
<li>序列图有对象生命线；</li>
<li>序列图有控制焦点。</li>
</ul>
<h3 id="通信图" data-numberify>通信图<a class="anchor ms-1" href="#通信图"></a></h3>
<p><u>通信图</u>（Communication Diagram，<strong>协作图</strong>）<u>强调收发消息的对象的结构组织</u>。通信图<u>强调参加交互的对象的组织</u>。</p>
<p>通信图的组成：</p>
<ol>
<li>将参加交互的<u>对象</u>作为图的<u>顶点</u>；</li>
<li>把连接这些对象的<u>链</u>表示为图的<u>弧</u>；</li>
<li>用对象发送和接收的<u>消息</u>来<u>修饰这些链</u>。</li>
</ol>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
<p>通信图有以下成分：</p>
<ul>
<li>
<p>对象：与序列图一样，是用一个方框框起来的<code>对象名:类名</code>。</p>
</li>
<li>
<p>路径（链接）：用实线表示，可以在链的末端附上一个路径构造型。</p>
<p>通常仅需显式地表示以下几种链的路径：</p>
<table>
<thead>
<tr>
<th style="text-align:center">构造型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;local&gt;&gt;</code></td>
<td style="text-align:center">局部</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;parameter&gt;&gt;</code></td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;global&gt;&gt;</code></td>
<td style="text-align:center">全局</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;self&gt;&gt;</code></td>
<td style="text-align:center">自身</td>
</tr>
</tbody>
</table>
<p>不必表示<code>association</code>（关联）。</p>
</li>
<li>
<p>序号：用来表示消息的时间顺序。是消息前的一个数字前缀，可使用带小数点的号码表示嵌套消息，嵌套可为任意深度。</p>
<p>如2表示第2个消息，2.1表示嵌套在消息2中的第1个消息。</p>
</li>
<li>
<p>消息：沿同一个链可以显示许多消息（可能发自不同方向），并且每个消息都有唯一的序号。</p>
</li>
</ul>
<p>通信图有两个不同于序列图的特性：</p>
<ul>
<li>通信图有路径；</li>
<li>通信图有序号。</li>
</ul>
<h3 id="状态图" data-numberify>状态图<a class="anchor ms-1" href="#状态图"></a></h3>
<p>状态图（State Diagram，状态转换图）关注<u>系统的动态视图</u>，<u>强调对象行为的事件顺序</u>。</p>
<p>状态图由以下组成：</p>
<ul>
<li>
<p><strong>状态</strong>：指对象的生命周期中某个条件或者状态，是<u>任何可以被观察到的系统行为模式</u>，<u>一个状态代表系统的一种行为模式</u>。</p>
<p>状态规定了系统内对事件的响应方式。</p>
<p>系统对事件的响应：</p>
<ul>
<li>可以是<u>做一个（或一系列）动作</u>；</li>
<li>可以是仅仅<u>改变系统本身的状态</u>；</li>
<li>可以是<u>即改变状态，又做动作</u>。</li>
</ul>
<p>状态转换图中定义的状态主要有：</p>
<ul>
<li><strong>初态</strong>（初始状态）：用一个<u>实心圆点</u>表示。一张状态图<u>只能有一个初态</u>。</li>
<li><strong>终态</strong>（最终状态）：用一个<u>实心圆点外加一个圆圈</u>表示。一张状态图<u>可以没有终态，也可以有多个</u>。</li>
<li><strong>中间状态</strong>。</li>
</ul>
<p>状态图中的状态用一个<u>圆角矩形</u>表示，可以用两条水平横线将其分为上中下3个部分：</p>
<ol>
<li>上面部分（必须）：状态的名称；</li>
<li>中间部分（可选）：状态变量的名称和值；</li>
<li>下面部分（可选）：活动表。</li>
</ol>
<p>状态还可分为：</p>
<ul>
<li>
<p>简单状态。</p>
</li>
<li>
<p>组合状态：含有子状态的状态，这个状态也称为其子状态的超状态。</p>
<p>子状态：嵌套在另外一个状态中的状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>转换</strong>（迁移）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生，而且某个特定的警界（监护）条件满足时进入目标状态。</p>
<p>状态转换用一条<u>带箭头的实线</u>表示。</p>
</li>
<li>
<p><strong>事件</strong>：是在某个特定时刻发生的事情，<u>它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象</u>。</p>
<ul>
<li>
<p><u>事件触发</u>状态转换：<u>状态变迁通常是由事件触发的。</u>状态之间带箭头实线上的事件发生时，状态转换开始（还可称之为状态“点火”或状态被“触发”）。</p>
<p>这种情况下应在表达状态转换的箭头线上标出触发转换的<u>事件表达式</u>：</p>
<pre tabindex="0"><code>事件说明 [守卫条件] / 动作表达式
</code></pre><p>事件说明的语法为：</p>
<pre tabindex="0"><code>事件名 (参数表)
</code></pre><p>守卫条件（监护条件）：一个布尔表达式。</p>
<ul>
<li>当且仅当事件发生且守卫条件为真时，状态转换才发生；</li>
<li>只有守卫条件没有事件说明时，只要守卫条件为真，状态转换就发生。</li>
</ul>
<p>动作表达式是一个过程表达式，当状态转换（事件）开始时执行。</p>
</li>
<li>
<p><u>自动触发</u>状态转换：如果箭头线上未标明事件，则表示<u>在源状态的内部活动执行完之后自动触发转换</u>。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图中的事件和转换" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684587930655.png" loading="lazy" width="717" height="135" />
</picture>

</p>
</li>
<li>
<p><strong>活动</strong>：指状态中的活动表中的活动。</p>
<p>语法如下：</p>
<pre tabindex="0"><code>事件名 (参数表) /动作表达式
</code></pre><p>事件名：可以是任何事件的名称。</p>
<p>在活动表中经常使用以下3中标准事件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>entry</code></td>
<td style="text-align:left"><u>入口动作</u>，指定<u>进入该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>exit</code></td>
<td style="text-align:left"><u>出口动作</u>，指定<u>退出该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>do</code></td>
<td style="text-align:left"><u>内部活动</u>，指定<u>在该状态下</u>的动作，占有有限时间，并可中断地工作</td>
</tr>
</tbody>
</table>
<p>活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
<p>当状态图对系统、类或用例的动态方面建模时，通常是对反应型对象建模。</p>
<h3 id="活动图" data-numberify>活动图<a class="anchor ms-1" href="#活动图"></a></h3>
<p>活动图（Activity Diagram）是一种特殊的状态图，它<u>展现了在系统内从一个活动到另一个活动的流程</u>。活动图<u>专注于系统的动态视图</u>，<u>强调对象间的控制流程</u>。</p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
<p>活动图一般包括：</p>
<ul>
<li>
<p>状态：</p>
<p>活动图的状态也包含初态和终态。其余的状态还可分为：</p>
<ul>
<li>动作状态：不能被分解，动作不能被中断。</li>
<li>活动状态：能够被进一步分解，可以被中断，其活动由其它的活动图来表示。</li>
</ul>
</li>
<li>
<p>流（转换）。</p>
</li>
<li>
<p>对象。</p>
</li>
</ul>
<p>活动图可以表示：</p>
<ul>
<li>分支（判断）：分支的流上用<code>[]</code>标记的是监护表达式；</li>
<li>（并发）分岔：将一个流分为多个可并发执行的流；</li>
<li>（并发）汇合：将分岔出去的多个流合并为同一个流。</li>
</ul>
<p>当对一个系统的动态方面建模时，有以下几种使用活动图的方式：</p>
<ul>
<li>对工作流建模；</li>
<li>对操作建模；</li>
<li>对业务的复杂流程建模。</li>
</ul>
<h3 id="构件图" data-numberify>构件图<a class="anchor ms-1" href="#构件图"></a></h3>
<p>构件图（Component Diagram，<strong>组件图</strong>）展现了<u>一组构件之间的组织和依赖</u>。构件图<u>专注于系统的静态实现视图</u>，它<u>与类图相关，通常把构件映射为一个或多个类、接口或协作</u>。</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
<p>构件图的成分有：</p>
<ul>
<li>构件：用<u>矩形</u>表示，在矩形<u>右上方有一个小标记</u>。</li>
<li>供接口：用一个<u><strong>圆圈</strong>和连接到构件上的实线</u>表示。构件提供接口给其它构件使用。</li>
<li>需接口：用一个<u><strong>半圆</strong>和连接到构件上的实线</u>表示。构件使用需接口表示需要调用其它构件提供接口。</li>
<li>依赖：将供接口（圆圈）和虚接口（半圆）连接到一起，表示两个构件通过这个接口相依赖。</li>
</ul>
<h3 id="部署图" data-numberify>部署图<a class="anchor ms-1" href="#部署图"></a></h3>
<p>部署图（Deployment Diagram）是用来<u>对面向对象系统的<strong>物理方面</strong>建模</u>的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图<u>对系统的静态部署视图进行建模</u>，它与构件图相关。</p>
<p>部署图<u>展现了系统的软件和硬件之间的关系，在实施阶段使用</u>。</p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
<blockquote>
<p><code>&lt;&lt;artifact&gt;&gt;</code>表示制品。</p>
</blockquote>
<h3 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h3>
<p>UML图分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table>
<p>类图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="类图中的类的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684650129674.png" loading="lazy" width="142" height="139" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="类图接口的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">协作</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="协作的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">依赖</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">关联</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="关联图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>用例图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用例</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">包含关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">扩展关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的扩展关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例与用例以及参与者与参与者之间的泛化关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>交互图中，顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="软件工程" data-numberify>软件工程<a class="anchor ms-1" href="#软件工程"></a></h1>
<h2 id="沟通路径" data-numberify>沟通路径<a class="anchor ms-1" href="#沟通路径"></a></h2>
<p>沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。</p>
<p>软件项目中沟通路径$m$的计算公式：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="gantt图" data-numberify>Gantt图<a class="anchor ms-1" href="#gantt图"></a></h2>
<p>Gantt图：一种<u>简单的水平条形图</u>，它<u>以日历为基准</u>描述项目任务。</p>
<ul>
<li>
<p>垂直轴：表示<u>多个不同的任务</u>，每个任务按照左侧任务名称垂直排列。</p>
</li>
<li>
<p>水平轴：表示<u>日历时间线</u>（如时、天、周、月和年等）。</p>
<p>每个水平条表示一个任务：</p>
<ul>
<li>每一水平条的<u>起点</u>：表示该任务的<u>开始时间</u>；</li>
<li>每一水平条的<u>终点</u>：表示该任务的<u>结束时间</u>；</li>
<li>每一水平条的<u>长度</u>：表示<u>完成该任务的持续时间</u>。</li>
</ul>
<p>当日历中同一时段存在多个水平条时，表示任务之间的并发。</p>
</li>
</ul>
<p>如图：</p>
<p><picture><img class="img-fluid " alt="Gantt图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683683731050.png" loading="lazy" width="795" height="282" />
</picture>

</p>
<ul>
<li>
<p>Gantt图优点：</p>
<p>能清晰地描述：</p>
<ul>
<li>每个任务的开始时间；</li>
<li>每个任务的结束时间；</li>
<li>任务的进展情况；</li>
<li>各个任务之间的并行性。</li>
</ul>
</li>
<li>
<p>Gantt图缺点：</p>
<ul>
<li>不能清晰地反映各任务之间的<u>依赖关系</u>；</li>
<li>难以确定<u>整个项目的关键所在</u>，即不能清晰地确定影响进度的<u>关键任务</u>；</li>
<li>不能反映<u>计划中有潜力的部分</u>。</li>
</ul>
</li>
</ul>
<h2 id="pert图" data-numberify>PERT图<a class="anchor ms-1" href="#pert图"></a></h2>
<p>PERT图是一个<u>有向图</u>：</p>
<ul>
<li>
<p><strong>弧</strong>：表示<strong>任务</strong>。</p>
<p>任务包含以下成分：</p>
<ul>
<li>
<p><u>完成该任务所需的时间</u>（任务持续时间）。</p>
</li>
<li>
<p><u>松弛时间</u>（Slack Time）：表示在<u>不影响整个工期的前提下完成该任务有多少机动余地</u>。</p>
<p>即松弛时间指当前任务的工期可以推迟的时间。</p>
</li>
</ul>
<p>空任务：用虚线箭头表示，表示任务间的关系所添加。完成空任务的所需时间为0。</p>
</li>
<li>
<p><strong>结点</strong>：表示<strong>事件</strong>。</p>
<p>事件是流入结点的任务的结束，或流出结点的任务的开始。事件<u>表示某个时间点</u>，本身不消耗时间和资源。</p>
<p>事件包含以下成分：</p>
<ul>
<li>事件号。</li>
<li>出现该事件的<strong>最早时刻</strong>：表示在此时刻之前从该事件出发的任务不可能开始。</li>
<li>出现该事件的<strong>最迟时刻</strong>：表示从该事件出发的任务最迟在此时刻开始，否则整个工程就不能如期完成。</li>
</ul>
<p><u>只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。</u></p>
<p>特殊的事件：</p>
<ul>
<li>开始事件：没有任何任务流向该事件；</li>
<li>结束事件：没有任务任务从该事件流出。</li>
</ul>
<p>一个项目是从开始事件开始到结束事件结束。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683684995281.png" loading="lazy" width="850" height="490" />
</picture>

</p>
<p>设：</p>
<ul>
<li>$T(e)$：完成任务$e$的所需时间；</li>
<li>$T_s(e)$：完成任务$e$的松弛时间；</li>
<li>$T_e(v)$：事件$v$的最早时刻；</li>
<li>$T_l(v)$：事件$v$的最迟时刻。</li>
</ul>
<p>PERT图各成分取值（不一定需要满足下面的关系，但是可以用下面的式子推出）：</p>
<ul>
<li>
<p>事件$V_{in}$的<u>最早时刻</u>$T_e(V_{in})$：</p>
<ul>
<li>
<p>只有一个任务流入时，设该任务的流出事件为$V_{out}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = T_e(V_{out}) + T
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}, V_{in}&gt;)$简写为了$T$。</p>
</blockquote>
<p>即：<u>该流入任务的流出事件的最早时刻</u> + <u>完成该流入任务的所需时间</u>。</p>
</li>
<li>
<p>多个任务流入时，设与每个任务相对应的流出事件为$V_{out}[ \ i \ ]$，则这些任务为$&lt;V_{out}[ \ i \ ], V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = Max(T_e(V_{out}[ \ i \ ]) + T_i)
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}[ \ i \ ], V_{in}&gt;)$简写为了$T_i$。</p>
</blockquote>
<p>即<u>流入该事件的每个任务计算出的最早时刻的最大值</u>。</p>
</li>
<li>
<p>开始事件$V_{start}$：</p>
<p>$$
T_e(V_{start}) = 0
$$</p>
</li>
</ul>
</li>
<li>
<p>事件$V_{out}$的<u>最迟时刻</u>$T_l(V_{out})$：</p>
<ul>
<li>
<p>只有一个任务流出时，设该任务的流入事件为$V_{in}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - (T + T_s)
$$</p>
<blockquote>
<p>这里将$T_s(&lt;V_{out}, V_{in}&gt;)$简写为$T_s$。</p>
</blockquote>
<p>即：<u>该流出任务的流入事件的最迟时刻</u> -（<u>该流出任务的所需时间</u> + <u>松弛时间</u>）。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - T
$$</p>
</li>
<li>
<p>多个任务流出时，设与每个任务相对应的流入事件为$V_{in}[ \ i \ ]$，则这些任务为$&lt;V_{out}, V_{in}[ \ i \ ]&gt;$：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - (T_i + S_i))
$$</p>
<blockquote>
<p>这里把$T(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$T_i$，把$T_s(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$S_i$。</p>
</blockquote>
<p>即<u>流出该事件的每个任务计算出的最晚时刻的最大值</u>。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - T_i)
$$</p>
</li>
<li>
<p>结束事件$V_{end}$：</p>
<p>$$
T_l(V_{end}) = T_e(V_{end})
$$</p>
<p>即<u>结束事件的最早时刻与最迟时刻相等</u>。</p>
</li>
</ul>
</li>
<li>
<p>设某任务的流入事件为$V_{in}$，流出事件为$V_{out}$，则该任务$&lt;V_{out}, V_{in}&gt;$的<u>松弛时间</u>$T_s(&lt;V_{out}, V_{in}&gt;)$。</p>
<p>$$
T_s = T_l(V_{in}) - T - T_e(V_{out})
$$</p>
<p>即，该任务的流入事件的最迟时刻 - 该任务的所需时间 - 该任务的流出事件的最早时刻</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图公式参照图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683719224977.png" loading="lazy" width="931" height="341" />
</picture>

</p>
<p>PERT图的路径：从开始事件到结束事件的一条通路。</p>
<p>PERT图的<strong>关键路径</strong>：指<u>所有的任务的松弛时间都为0的路径</u>。</p>
<p>关键路径的长度：指结束事件的最早（或最晚）时刻。</p>
<p><picture><img class="img-fluid " alt="PERT图的关键路径示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683706944555.png" loading="lazy" width="785" height="457" />
</picture>

</p>
<p>关键路径的特点：</p>
<ul>
<li>
<p>所有任务的松弛时间都为0。</p>
</li>
<li>
<p>每个事件的最早时刻和最迟时刻都是相等的。</p>
</li>
<li>
<p>所有任务持续时间的和，是PERT图所有路径中最大的，并且与结束事件的最早时刻（或最晚时刻）相等。</p>
<p>设关键路径中所有事件为$V_i$（$i = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_j, V_{j+1}&gt;$（$1 \le j \le n-1$）（表示$V_1$是开始事件，$V_2$是$V_1$往下的一个事件，以此类推，$V_n$是结束事件），那么该关键路径结束事件的最早时刻（或最晚时刻）为：</p>
<p>$$
T_e(V_n) = \sum_{i = 1}^{n-1} T_i
$$</p>
<blockquote>
<p>这里$T_i$代表$T(&lt;V_i, V_{i+1}&gt;)$。</p>
</blockquote>
</li>
</ul>
<p>最迟时刻的另一种求法（PERT图存在关键路径的情况下）：</p>
<p>已知某PERT图结束事件的最晚时刻（最早时刻），该PERT图中某一条路径（假设该路径没有分支）中所有事件为$V_j$（$j = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_k, V_{k+1}&gt;$（$1 \le k \le n-1$），该路径下任务的持续时间$T(&lt;V_{k-1}, V_k&gt;)$已知，（即$V_1$是开始事件，按照次序往下，$V_n$是结束事件），计算某一事件的最迟时刻$T_l(V_i)$（$1 \le i &lt; n$）：</p>
<p>$$
T_l(V_i) = T_l(V_n) - \sum_{j = i}^{n - 1} T_j
$$</p>
<blockquote>
<p>这里$T_j$代表$T(&lt;V_j, V_{j + 1}&gt;)$。</p>
</blockquote>
<p>即：<u>结束事件的最晚时刻</u> - <u>该事件到结束事件之间所有的任务的持续时间总和</u>。</p>
<blockquote>
<p>注意：如果事件$V_i$到结束事件之间存在多条路径，应该选择那条任务持续时间总和最大的路径。</p>
</blockquote>
<p>PERT图的优点：</p>
<ul>
<li>给出了每个任务的开始时间、结束时间和完成该任务所需的时间；</li>
<li>给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。</li>
</ul>
<p>PERT图不能清晰地描述任务之间的并行情况。</p>
<h2 id="项目活动图" data-numberify>项目活动图<a class="anchor ms-1" href="#项目活动图"></a></h2>
<p>项目活动图是一种有向图（与PERT图十分类似）：</p>
<ul>
<li>
<p>弧：表示活动。弧的权值表示活动的持续时间。</p>
</li>
<li>
<p>顶点：表示项目里程碑。</p>
<p>特殊的里程碑：</p>
<ul>
<li>开始里程碑：没有任何活动指向该里程碑；</li>
<li>结束里程碑：没有任何活动从该里程碑指出。</li>
</ul>
</li>
</ul>
<p>项目活动图的关键路径：按照PERT图的方法求出松弛时间为0的、从开始里程碑到结束里程碑的路径。</p>
<p>关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>瑞吉外卖项目实战</title>
      <link>/blog/2023/03/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</link>
      <pubDate>Tue, 21 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/blog/2023/03/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</guid>
      <description><![CDATA[项目笔记 项目笔记仓库：https://gitee.com/linner_cheng/reggie_note B站视频：黑马程序员Java项目实]]></description>
      <content:encoded><![CDATA[<h1 id="项目笔记" data-numberify>项目笔记<a class="anchor ms-1" href="#项目笔记"></a></h1>
<p>项目笔记仓库：<a href="https://gitee.com/linner_cheng/reggie_note" target="_blank" rel="noopener noreferrer">https://gitee.com/linner_cheng/reggie_note<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<p>B站视频：<a href="https://www.bilibili.com/video/BV13a411q753/?p=190&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click" target="_blank" rel="noopener noreferrer">黑马程序员Java项目实战《瑞吉外卖》<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<hr>
<h1 id="项目基础功能开发" data-numberify>项目基础功能开发<a class="anchor ms-1" href="#项目基础功能开发"></a></h1>
<p><a href="https://gitee.com/linner_cheng/reggie_note/tree/v1.0/" target="_blank" rel="noopener noreferrer">项目基础功能开发<i class="fas fa-external-link-square-alt ms-1"></i></a>。包含项目前台和后台功能开发还有项目部署。</p>
<hr>
<h1 id="redis" data-numberify>Redis<a class="anchor ms-1" href="#redis"></a></h1>
<p><a href="https://gitee.com/linner_cheng/reggie_note/tree/redis/" target="_blank" rel="noopener noreferrer">Redis<i class="fas fa-external-link-square-alt ms-1"></i></a>。包含Jedis和Spirng data redis。</p>
<hr>
<h1 id="项目优化" data-numberify>项目优化<a class="anchor ms-1" href="#项目优化"></a></h1>
<p><a href="https://gitee.com/linner_cheng/reggie_note/tree/v1.1/" target="_blank" rel="noopener noreferrer">Redis缓存<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p><a href="https://gitee.com/linner_cheng/reggie_note/tree/v1.2/" target="_blank" rel="noopener noreferrer">Sharding-JDBC读写分离<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p><a href="https://gitee.com/linner_cheng/reggie_note/tree/v1.3/" target="_blank" rel="noopener noreferrer">Swagger API文档<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Java 进阶</title>
      <link>/blog/2023/02/java-%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>/blog/2023/02/java-%E8%BF%9B%E9%98%B6/</guid>
      <description><![CDATA[反射 反射是Java中一种用于动态获取类或对象的信息以及动态调用对象方法的功能机制。在运行状态中，对于任意一个类，使用反射可以获取这个类的所有]]></description>
      <content:encoded><![CDATA[<h1 id="反射" data-numberify>反射<a class="anchor ms-1" href="#反射"></a></h1>
<p>反射是Java中一种用于动态获取类或对象的信息以及动态调用对象方法的功能机制。在运行状态中，对于任意一个类，使用反射可以获取这个类的所有属性和方法；对于任意一个对象，使用反射能够调用它的任意属性和方法。利用反射可以无视对象的修饰符，调用类里面的内容。利用反射可以跟配置文件结合起来使用，把要创建的对象信息和方法写在配置文件中。</p>
<p>使用反射包含以下步骤：</p>
<ol>
<li>获取class字节码文件对象。</li>
<li>利用反射可以操作类或对象的信息有：
<ul>
<li>构造方法（获取、创建对象）</li>
<li>成员变量（获取、赋值）</li>
<li>成员方法（获取、运行）</li>
</ul>
</li>
</ol>
<h2 id="获取字节码文件对象" data-numberify>获取字节码文件对象<a class="anchor ms-1" href="#获取字节码文件对象"></a></h2>
<p>Java中的每个类都是一个<code>Class</code>对象（字节码文件对象）。获取字节码文件对象共有以下三种方式：</p>
<ul>
<li>
<p>通过class字节码文件获取：<code>Class.forName(&quot;类的全类名&quot;)</code></p>
<p>类的全类名=类的包名.类名。</p>
<p>使用该方式，是通过<code>.java</code>源代码文件编译后生成的<code>.class</code>字节码文件获取。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.repo.Student&#34;</span><span class="o">);</span>
</span></span></code></pre></div></li>
<li>
<p>通过Class对象的class属性获取：<code>类名.class</code></p>
<p>该方式是对象已载入内存后使用的，需要使用<code>import</code>语句将对应的类导入（<code>.class</code>文件加载到内存后产生的<code>Class</code>对象也是唯一的）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Student</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</span></span></code></pre></div></li>
<li>
<p>通过对象获取：<code>对象.getClass()</code></p>
<p>通过创建对象后的<code>getClass()</code>方法来返回该对象的<code>Class</code>对象。该方法需要创建具体对象后才能使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</span></span></code></pre></div></li>
</ul>
<blockquote>
<blockquote>
<p>以上三种方法获取到的<code>Class</code>对象均为同一个对象。即，使用<code>==</code>分别判断以上三种方法获取到的对象均为<code>true</code>。</p>
</blockquote>
</blockquote>
<p>获取了<code>Class</code>对象后就可以获取到该类的各种信息。</p>
<h2 id="获取构造方法" data-numberify>获取构造方法<a class="anchor ms-1" href="#获取构造方法"></a></h2>
<p>获取构造方法即为获取<code>Constructor</code>对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[] getConstructors()</code></td>
<td style="text-align:left">获得所有的公共构造方法（<code>public</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></td>
<td style="text-align:left">获得所有的构造方法（包括<code>private</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code> Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td style="text-align:left">获取指定的公共构造方法</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td style="text-align:left">获取指定的构造方法（包括<code>private</code>）</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;创建了一个Student对象&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;创建了一个Student对象：&#34;</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;创建了一个Student对象：name=&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">NoSuchMethodException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.repo.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有公共构造方法对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span><span class="o">[]</span> <span class="n">constructors1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Constructor</span> <span class="n">constructor</span> <span class="o">:</span> <span class="n">constructors1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">constructor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=======================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有构造方法对象（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span><span class="o">[]</span> <span class="n">constructors2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredConstructors</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Constructor</span> <span class="n">constructor</span> <span class="o">:</span> <span class="n">constructors2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">constructor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=======================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定的构造方法对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 空参构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span> <span class="n">con1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">con1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 包含参数的构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span> <span class="n">con2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">con2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定的构造方法对象（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span> <span class="n">con3</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">con3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="通过反射创建对象" data-numberify>通过反射创建对象<a class="anchor ms-1" href="#通过反射创建对象"></a></h2>
<p>使用<code>Constructor</code>对象的<code>newInstance()</code>方法可以为反射的类创建对象。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">NoSuchMethodException</span><span class="o">,</span> <span class="n">InvocationTargetException</span><span class="o">,</span> <span class="n">InstantiationException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.reflect.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取无参的公共构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span> <span class="n">con1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用无参的构造方法创建对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Student</span> <span class="n">stu1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">con1</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stu1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取带参数的构造方法（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Constructor</span> <span class="n">con2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 暴力反射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果是private修饰的构造方法，需要临时修改构造方法的访问权限（取消检查访问权限）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">con2</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 使用带参数的构造方法创建对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Student</span> <span class="n">stu2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">con2</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">&#34;zhangsan&#34;</span><span class="o">,</span> <span class="mi">23</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stu2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="获取成员变量" data-numberify>获取成员变量<a class="anchor ms-1" href="#获取成员变量"></a></h2>
<p>获取成员变量即为获取<code>Field</code>对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Field[] getFields()</code></td>
<td style="text-align:left">返回所有公共成员变量对象（<code>public</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Field[] getDeclaredFields()</code></td>
<td style="text-align:left">返回所有成员变量对象（包括<code>private</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Field getField(String name)</code></td>
<td style="text-align:left">返回指定名称的公共成员变量对象（<code>public</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Field getDeclaredField(String name)</code></td>
<td style="text-align:left">返回指定名称的成员变量对象（包括<code>private</code>）</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">NoSuchFieldException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.reflect.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有公共成员变量对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span><span class="o">[]</span> <span class="n">fields1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getFields</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">field</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;====================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有成员变量（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span><span class="o">[]</span> <span class="n">fields2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">field</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;====================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定名称的公共成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span> <span class="n">nameField</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">nameField</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;====================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定名称的成员变量（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span> <span class="n">ageField</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ageField</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="利用反射获取和修改成员变量的值" data-numberify>利用反射获取和修改成员变量的值<a class="anchor ms-1" href="#利用反射获取和修改成员变量的值"></a></h2>
<p>可以使用以下<code>Field</code>对象方法对成员变量的值进行修改：</p>
<ul>
<li>
<p>赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
</span></span></code></pre></div><p>参数：</p>
<ul>
<li><code>obj</code>：要修改属性值的具体对象；</li>
<li><code>value</code>：具体要修改的值。</li>
</ul>
</li>
<li>
<p>获取值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span>
</span></span></code></pre></div><p>参数：</p>
<ul>
<li><code>obj</code>：要修改属性值的具体对象。</li>
</ul>
</li>
</ul>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="n">String</span> <span class="n">gender</span><span class="o">,</span> <span class="n">String</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">IllegalAccessException</span><span class="o">,</span> <span class="n">NoSuchFieldException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;张三&#34;</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="s">&#34;大三&#34;</span><span class="o">,</span> <span class="s">&#34;广州&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.reflect.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取并修改name的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span> <span class="n">nameField</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取name的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">nameField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 修改name的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">nameField</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">student</span><span class="o">,</span> <span class="s">&#34;李四&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">name</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">nameField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;===============&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取并修改私有变量的值（暴力反射）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span> <span class="n">addressField</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;address&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 临时取消访问权限（获取和修改私有变量的值都需要此操作）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">addressField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取私有变量address的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">addressField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 修改私有变量address的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">addressField</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">student</span><span class="o">,</span> <span class="s">&#34;北京&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">addressField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="获取成员方法" data-numberify>获取成员方法<a class="anchor ms-1" href="#获取成员方法"></a></h2>
<p>获取成员方法即为获取<code>Method</code>对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Method[] getMethods()</code></td>
<td style="text-align:left">返回所有公共成员方法对象（<code>public</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Method[] getDeclaredMethods()</code></td>
<td style="text-align:left">放回所有成员方法对象（包括<code>private</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td style="text-align:left">返回指定名称和形参的公共成员方法对象（<code>public</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes</code></td>
<td style="text-align:left">返回指定名称和形参的成员方法对象（包括<code>private</code>）</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">com.linner.reflect</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="n">String</span> <span class="n">gender</span><span class="o">,</span> <span class="n">String</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getGender</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setGender</span><span class="o">(</span><span class="n">String</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getAddress</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAddress</span><span class="o">(</span><span class="n">String</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;Student{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;, gender=&#39;&#34;</span> <span class="o">+</span> <span class="n">gender</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;, address=&#39;&#34;</span> <span class="o">+</span> <span class="n">address</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">&#34;正在睡觉&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">study</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">&#34;正在内卷&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">study</span><span class="o">(</span><span class="kt">int</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">&#34;已经卷了&#34;</span> <span class="o">+</span> <span class="n">time</span> <span class="o">+</span> <span class="s">&#34;分钟还在卷&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo1</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">NoSuchMethodException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.reflect.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有公共成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span><span class="o">[]</span> <span class="n">methods1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethods</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==============&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取所有成员方法（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span><span class="o">[]</span> <span class="n">methods2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==============&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定的公共成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 空参的公共成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">toStringMethod</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;toString&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">toStringMethod</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 带参数的公共成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">setNameMethod</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;setName&#34;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">setNameMethod</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==============&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取指定的成员方法（包括private）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 空参的成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">studyMethod1</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">&#34;study&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">studyMethod1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 带参数的成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">studyMethod2</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">&#34;study&#34;</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">studyMethod2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="通过反射运行成员方法" data-numberify>通过反射运行成员方法<a class="anchor ms-1" href="#通过反射运行成员方法"></a></h2>
<p>使用<code>Method</code>对象的<code>invoke()</code>方法可以运行成员方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span>
</span></span></code></pre></div><ul>
<li><code>obj</code>：具体调用成员方法的对象；</li>
<li><code>args</code>：调用成员方法传递的参数；</li>
<li>返回值：方法的返回值。</li>
</ul>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReflectDemo1</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">,</span> <span class="n">NoSuchMethodException</span><span class="o">,</span> <span class="n">InvocationTargetException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;张三&#34;</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="s">&#34;大三&#34;</span><span class="o">,</span> <span class="s">&#34;广州&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.reflect.Student&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用无参的成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">toStringMethod</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;toString&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">studentToString</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">toStringMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">studentToString</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用带参的私有成员方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span> <span class="n">studyMethod</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">&#34;study&#34;</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 临时取消访问权限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">studyMethod</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">studyMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">student</span><span class="o">,</span> <span class="mi">180</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h1 id="注解" data-numberify>注解<a class="anchor ms-1" href="#注解"></a></h1>
<p>Java注解是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到<strong>说明、配置</strong>的功能。</p>
<p>注解不会影响代码的实际逻辑（并不直接影响代码的语义），仅仅起到辅助性的作用（但是注解可以被看做是程序的工具或者类库。会反过来对正在运行的程序语义有所影响）。包含在<code>java.lang.annotation</code>包中。注解使用<code>@interface</code>来定义（类似于接口的定义）。为注解定义一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或<code>throw</code>语句，返回值类型被限定为原始数据类型、<code>String</code>、<code>Class</code>、<code>enums</code>、注解类型，或前面这些类型的数组，方法可以有默认值。注解可以从源文件、class文件或者在运行时通过反射机制多种方式被读取。</p>
<p>注解的实现的原理很大的一部分是基于反射实现。</p>
<p>一般来说，注解一般分为三种类型：</p>
<ul>
<li>元注解</li>
<li>标准注解</li>
<li>自定义注解</li>
</ul>
<h2 id="元注解" data-numberify>元注解<a class="anchor ms-1" href="#元注解"></a></h2>
<p>元注解是专职负责注解其他注解，主要是标明该注解的使用范围，生效范围。元注解并不能被修改，只能被用来定义自定义注解。</p>
<p>元注解包括以下四种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@Target</code></td>
<td style="text-align:left">定义注解的作用目标。即用来定义自定义注解具体作用在类上，方法上，还是变量上。具体值和作用对象如下：<br><code>ElementType.TYPE</code>：接口、类、枚举、注解<br><code>ElementType.FIELD</code>：字段、枚举的常量<br><code>ElementType.METHOD</code>：方法<br><code>ElementType.PARAMETER</code>：方法参数<br><code>ElementType.CONSTRUCTOR</code>：构造函数<br><code>ElementType.LOCAL_VARIABLE</code>：局部变量<br><code>ElementType.ANNOTATION_TYPE</code>：注解<br><code>ElementType.PACKAGE</code>：包</td>
</tr>
<tr>
<td style="text-align:center"><code>Retention</code></td>
<td style="text-align:left">定义注解的保留策略。该注解的值如下：<br><code>RetentionPolicy.SOURCE</code>：定义注解仅存在于源码中，在class字节码文件中不包含；<br><code>RetentionPolicy.CLASS</code>：该注解默认的保留策略，定义注解会在class字节码文件中存在，但运行时无法获得；<br><code>RetentionPolicy.RUNTIME</code>：定义注解会在class字节码文件中存在，在运行时可以通过反射获取到。</td>
</tr>
<tr>
<td style="text-align:center"><code>@Document</code></td>
<td style="text-align:left">说明该注解将被包含在javadoc中。</td>
</tr>
<tr>
<td style="text-align:center"><code>@Inherited</code></td>
<td style="text-align:left">说明子类可以继承该注解。</td>
</tr>
</tbody>
</table>
<h2 id="标准注解" data-numberify>标准注解<a class="anchor ms-1" href="#标准注解"></a></h2>
<p>Java 提供了三个标准注解，定义在<code>java.lang</code>中（这三个注解的作用更多是一种注释）。</p>
<ul>
<li>
<p><code>@Override</code>：表示当前方法覆盖了父类中的对应方法（重写方法）。</p>
</li>
<li>
<p><code>@Deprecated</code>：标记一个元素为已过期，避免或不推荐使用。</p>
<p>支持的元素类型为：<code>CONSTRUCTOR</code>, <code>FIELD</code>, <code>LOCAL_VARIABLE</code>, <code>METHOD</code>, <code>PACKAGE</code>, <code>PARAMETER</code>, <code>TYPE</code>。</p>
</li>
<li>
<p><code>@SuppressWarnings</code>：不输出对应的编译警告。</p>
</li>
</ul>
<h2 id="自定义注解" data-numberify>自定义注解<a class="anchor ms-1" href="#自定义注解"></a></h2>
<p>注解的定义类似于接口的定义，使用<code>@interface</code>来定义。定义注解类中的一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或<code>throw</code>语句，返回值类型被限定为原始数据类型、字符串String、Class、enums、注解类型，或前面这些类型的数组，方法可以有默认值。</p>
<p>自定义注解一般分为以下三个步骤：</p>
<ul>
<li>
<p>定义注解。</p>
<p>如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">Type</span><span class="o">)</span>   <span class="c1">// 表明该注解加载在类上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span> <span class="c1">// 表明运行时读取该注解
</span></span></span><span class="line"><span class="cl"><span class="c1">// 定义注解类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">MyAnnotationType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义注解方法（不能有参数或throw等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">String</span> <span class="nf">value</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>   <span class="c1">// 表明该注解加载在字段上（接口、类、枚举）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">MyAnnotationField</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="nf">name</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用default定义默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">length</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>使用注解。</p>
<p>如（在其他类上）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@MyAnnotationType</span><span class="o">(</span><span class="s">&#34;Annotation&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 或（有多个元素时需要指定元素名）：@MyAnnotation1(value = &#34;Annotation&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UsingAnnotations</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@MyAnnotationField</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;张三&#34;</span><span class="o">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">12</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@MyAnnotationField</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;李四&#34;</span><span class="o">)</span>   <span class="c1">// length将使用默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="n">b</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>读取注解。</p>
<p>如（定义一个类来读取）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationValues</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readValues</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Class</span> <span class="n">usingAnnotationsClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;UsingAnnotation&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取作用于类上的注解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">MyAnnotationType</span> <span class="n">mat</span> <span class="o">=</span> <span class="o">(</span><span class="n">MyAnnotationType</span><span class="o">)</span> <span class="n">usingAnnotationsClass</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">MyAnnotationType</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">mat</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 读取作用于属性上的注解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Field</span> <span class="n">a</span> <span class="o">=</span> <span class="n">usingAnnotationsClass</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">MyAnnotationField</span> <span class="n">maf</span> <span class="o">=</span> <span class="o">(</span><span class="n">MyAnnotationField</span><span class="o">)</span> <span class="n">a</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">MyAnnotationField</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maf</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maf</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="使用注解模拟-junit" data-numberify>使用注解模拟 Junit<a class="anchor ms-1" href="#使用注解模拟-junit"></a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationDemo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// @MyTest
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;test1...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@MyTest</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;test2...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// @MyTest
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test3</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;test3...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@MyTest</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test4</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;test4...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@MyTest</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test5</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;test5...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AnnotationDemo</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationDemo</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取Class对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;com.linner.annotation.AnnotationDemo&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断对象的所有方法上是否存在MyTest注解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="n">MyTest</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Linux 终端中文编码设置</title>
      <link>/blog/2022/09/linux-%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/09/linux-%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE/</guid>
      <description><![CDATA[Ubuntu 安装中文支持： apt-get install language-pack-zh-hans -y 查看系统语言包： locale -a 修改~/.bashrc，加入： export LC_ALL=zh_CN.UTF-8 export LANG=zh_CN.UTF-8 修改/etc/default/locale： LANG=&#34;zh_CN.UTF-8&#34; Debian 安装loc]]></description>
      <content:encoded><![CDATA[<h1 id="ubuntu" data-numberify>Ubuntu<a class="anchor ms-1" href="#ubuntu"></a></h1>
<p>安装中文支持：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">apt-get install language-pack-zh-hans -y
</span></span></code></pre></div><p>查看系统语言包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">locale -a
</span></span></code></pre></div><p>修改<code>~/.bashrc</code>，加入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LC_ALL</span><span class="o">=</span>zh_CN.UTF-8
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LANG</span><span class="o">=</span>zh_CN.UTF-8
</span></span></code></pre></div><p>修改<code>/etc/default/locale</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">LANG</span><span class="o">=</span><span class="s2">&#34;zh_CN.UTF-8&#34;</span>
</span></span></code></pre></div><h1 id="debian" data-numberify>Debian<a class="anchor ms-1" href="#debian"></a></h1>
<p>安装<code>locales</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">apt install locales -y
</span></span></code></pre></div><p>安装完成后可能会提示设置<code>locales</code>，如果安装完之后想要更改相关设置或者没有提示设置，可以使用如下命令重新设置<code>locales</code>相关信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dpkg-reconfigure locales
</span></span></code></pre></div><h1 id="zsh" data-numberify>ZSH<a class="anchor ms-1" href="#zsh"></a></h1>
<p>修改<code>~/.zshrc</code>，加入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LC_ALL</span><span class="o">=</span>zh_CN.UTF-8
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LANG</span><span class="o">=</span>zh_CN.UTF-8
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>集合论</title>
      <link>/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/</link>
      <pubDate>Fri, 02 Sep 2022 12:43:41 +0800</pubDate>
      
      <guid>/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/</guid>
      <description><![CDATA[集合的概念 A set is a group of objects. (simplest way) By a set we mean any collection M into a whole of definite disinct objects m (which we called elements of M) of our perception or thought. (Cantor&rsquo;s way) 集合（set）是由 &lt;u&gt;指定范围 &lt;/]]></description>
      <content:encoded><![CDATA[<h1 id="集合的概念" data-numberify>集合的概念<a class="anchor ms-1" href="#集合的概念"></a></h1>
<blockquote>
<ul>
<li>A <strong>set</strong> is a group of objects. (simplest way)</li>
<li>By a <strong>set</strong> we mean any collection M into a whole of definite disinct objects m (which we called <strong>elements</strong> of M) of our perception or thought. (Cantor&rsquo;s way)</li>
</ul>
</blockquote>
<p><strong>集合</strong>（set）是由 <code>&lt;u&gt;</code>指定范围 <code>&lt;/u&gt;</code>内的 <code>&lt;u&gt;</code>满足给定条件的所有对象 <code>&lt;/u&gt;</code>聚集在一起构成的，指定范围内的每一个对象称为这个集合的<strong>元素</strong>（element）。</p>
<ul>
<li>集合中的元素是<strong>无序</strong>的。</li>
<li>集合中的元素是<strong>不同</strong>的（即，同个集合中相同或重复的元素被认为是一个元素）。</li>
</ul>
<p>通常情况下，</p>
<ul>
<li>用带（或不带）下标的 <code>&lt;u&gt;</code>大写 <code>&lt;/u&gt;</code>英文字母表示 <code>&lt;u&gt;</code>集合 <code>&lt;/u&gt;</code>：$A,B,C,\dots,A_1,B_1,C_1,\dots$</li>
<li>用带（或不带）下标的 <code>&lt;u&gt;</code>小写 <code>&lt;/u&gt;</code>英文字母表示 <code>&lt;u&gt;</code>元素 <code>&lt;/u&gt;</code>：$a,b,c,\dots,a_1,b_1,c_1,\dots$</li>
</ul>
<p>ZFC 公理化集合论：</p>
<ul>
<li>外延公理，</li>
<li>空集存在公理，</li>
<li>无序对公理，</li>
<li>并集公理，</li>
<li>幂集公理，</li>
<li>无穷公理，</li>
<li>替换公理，</li>
<li>正则公理，</li>
<li>选择公理。</li>
</ul>
<hr>
<h2 id="常见的集合" data-numberify>常见的集合<a class="anchor ms-1" href="#常见的集合"></a></h2>
<ul>
<li>空集 $\emptyset$；</li>
<li>正整数集 $\mathbf{N^+}$ or $\mathbf{W}$：$1,2,3,\cdots$</li>
<li>自然数集 $\mathbf{N}$：$0,1,2,3,\cdots$</li>
<li>整数集 $\mathbf{Z}$：$\cdots,-2,-1,0,1,2,\cdots$</li>
<li>质数/素数集 $\mathbf{P}$：$2,3,5,7,\cdots$</li>
<li>有理数集 $\mathbf{Q}$；</li>
<li>无理数集 $\mathbf{I}$；</li>
<li>实数集 $\mathbf{R}$；</li>
<li>复数集 $\mathbf{C}$；</li>
<li>$\cdots\cdots$</li>
</ul>
<p>关系：</p>
<p>$$
\mathbf{W} \subseteq \mathbf{N} \subseteq \mathbf{Z} \subseteq \mathbf{Q} \subseteq \mathbf{R} \subseteq \mathbf{C}
$$</p>
<hr>
<h1 id="集合的表示方法" data-numberify>集合的表示方法<a class="anchor ms-1" href="#集合的表示方法"></a></h1>
<h2 id="枚举法" data-numberify>枚举法<a class="anchor ms-1" href="#枚举法"></a></h2>
<p><strong>枚举法</strong>又称<strong>列举法</strong>或<strong>显示法</strong>，是枚举出集合中的所有或部分元素（要能看出其他元素之间的规律）。</p>
<p>Example：</p>
<ul>
<li>枚举出集合中的所有元素：$A = {a,b,c,d}$；</li>
<li>枚举出集合中的部分元素：$B = {1,3,5,\cdots,2n+1,\cdots}$。</li>
</ul>
<hr>
<h2 id="叙述法" data-numberify>叙述法<a class="anchor ms-1" href="#叙述法"></a></h2>
<p><strong>叙述法</strong>又称<strong>隐式法</strong>，是通过刻画（或用自然语言描述）集合中元素所具备的某种特性来表示集合的方法，通常用符号 $P(x)$ 来表示不同对象 $x$ 所具有的性质 $P$ ，由 $P(x)$ 所定义的集合常记为</p>
<p>$$
{x|P(x)}。
$$</p>
<hr>
<h2 id="文氏图" data-numberify>文氏图<a class="anchor ms-1" href="#文氏图"></a></h2>
<p><strong>文氏图</strong>（<strong>Venn diagram</strong>）又叫<strong>维恩图</strong>，用于展示集合或类之间的大致关系。</p>
<p><picture><img class="img-fluid " alt="维恩图" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E7%BB%B4%E6%81%A9%E5%9B%BE.png" loading="lazy" width="1980" height="563" />
</picture>

</p>
<p>一般用方向表示全集，用圆形表示某一特定集合。</p>
<hr>
<h2 id="递归指定集合法" data-numberify>递归指定集合法<a class="anchor ms-1" href="#递归指定集合法"></a></h2>
<p>递归指定集合法是指通过计算规则定义集合中的元素的方法。</p>
<p>Example：</p>
<p>设 $a_0 = 1$，$a_{i+1}=2a_i(i \ge 0)$，定义 $S={a_0,a_1,\cdots,a_n,\cdots}={a_k|k\ge0}$，可以得出集合 $S$ 为</p>
<p>$$
S={1,2,2^2,\cdots,2^n,\cdots}。
$$</p>
<hr>
<h2 id="归纳法" data-numberify>归纳法<a class="anchor ms-1" href="#归纳法"></a></h2>
<ol>
<li>
<p>指出集合至少要包含的元素</p>
<ul>
<li>第一部分：基础，指出某些最 <code>&lt;u&gt;</code>基本元素 <code>&lt;/u&gt;</code>属于某集合；</li>
<li>第二部分：归纳，指出 <code>&lt;u&gt;</code>由基本元素构造新元素的方法 <code>&lt;/u&gt;</code>；</li>
</ul>
</li>
<li>
<p>指出集合至多要包含的元素</p>
<ul>
<li>第三部分：极小性，指出该 <code>&lt;u&gt;</code>集合的界限 <code>&lt;/u&gt;</code>。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="基数" data-numberify>基数<a class="anchor ms-1" href="#基数"></a></h1>
<p>Definition：</p>
<p>集合 $A$ 中的元素个数称为集合的<strong>基数</strong>（base number），记为 $|A|$。</p>
<p>对于任意集合 $A$ 来说，</p>
<ul>
<li>若 $|A|$ 是 <code>&lt;u&gt;</code>有限的 <code>&lt;/u&gt;</code>，称该集合为<strong>有限集</strong>（finite set）；</li>
<li>若 $|A|$ 是 <code>&lt;u&gt;</code>无限的 <code>&lt;/u&gt;</code>，称该集合为<strong>无限集</strong>（infinite set）。</li>
</ul>
<hr>
<h1 id="集合与元素的关系" data-numberify>集合与元素的关系<a class="anchor ms-1" href="#集合与元素的关系"></a></h1>
<p>元素与集合之间有两种关系：</p>
<ul>
<li>
<p>属于：如 “$a$ 是集合 $A$ 中的元素” 或 “$a$ 属于 $A$ ” 记为</p>
<p>$$
a \in A。
$$</p>
</li>
<li>
<p>不属于：如 “$a$ 不是是集合 $A$ 中的元素” 或 “$a$ 不属于 $A$” 记为</p>
<p>$$
a \notin A。
$$</p>
</li>
</ul>
<hr>
<h1 id="集合与集合的关系" data-numberify>集合与集合的关系<a class="anchor ms-1" href="#集合与集合的关系"></a></h1>
<h2 id="外延性原理" data-numberify>外延性原理<a class="anchor ms-1" href="#外延性原理"></a></h2>
<p>Theorem：</p>
<p>两个集合 $A$ 和 $B$ <strong>相等</strong>，当且仅当它们的<strong>元素完全相同</strong>，记为 $A\ =\ B$，否则 $A$ 和 $B$ <strong>不相等</strong>，记为 $A\ \neq\ B$。</p>
<hr>
<h2 id="包含关系" data-numberify>包含关系<a class="anchor ms-1" href="#包含关系"></a></h2>
<p>Definitions：</p>
<p>设 $A$，$B$ 是任意两个集合，</p>
<ul>
<li>
<p><strong>包含与不包含</strong>：如果 $B$ 的每个元素都是 $A$ 中的元素，则称 $B$ 是 $A$ 的<strong>子集</strong>（subset），也称 ${B}$ <strong>被</strong> ${A}$ <strong>包含</strong>或 ${A}$ <strong>包含</strong> ${B}$，记作 ${B \subseteq A}$ 或 $A \supseteq B$，称 $\subseteq$ 或 $\supseteq$ 为<strong>被包含关系</strong>（included relation）或<strong>包含关系</strong>（inclusion relation）；否则记作 ${B \nsubseteq A}$。</p>
<p>“$\subseteq$” 定义的数学语言描述为：</p>
<p>$$
B \subseteq A<br>
\Longleftrightarrow\ \forall x，
如果 x \subseteq B，
则 x \subseteq A。
$$</p>
<p>由子集的定义可推出 $A \subseteq A$。</p>
</li>
<li>
<p><strong>真包含</strong>：如果 $B \subseteq A$ 并且 $A \neq B$，则称 $B$ 是 $A$ 的<strong>真子集</strong>（proper subset），也称做 ${B}$ <strong>被</strong> ${A}$ <strong>真包含</strong>或 ${A}$ <strong>真包含</strong> ${B}$，记作 ${B \subset A}$，称 $\subset$ 为<strong>真包含关系</strong>（properly inclusion relation）。</p>
<p>“$\subset$” 定义的数学语言描述为：</p>
<p>$$
B \subset A \Longleftrightarrow 对 \forall x，若 x \in B，则 x \in A，并且 \exists y \in A，但 y \notin B。
$$</p>
</li>
</ul>
<hr>
<h2 id="相等关系" data-numberify>相等关系<a class="anchor ms-1" href="#相等关系"></a></h2>
<p>Theorem：</p>
<p>设 $A$，$B$ 为任意两个集合，则 ${A\ =\ B}\ \Longleftrightarrow\ {A \subseteq B}$ 并且 ${B \subseteq A}$。</p>
<hr>
<h1 id="常见特殊的集合" data-numberify>常见特殊的集合<a class="anchor ms-1" href="#常见特殊的集合"></a></h1>
<h2 id="空集" data-numberify>空集<a class="anchor ms-1" href="#空集"></a></h2>
<p>Definition：</p>
<p>不含任何元素的集合叫做<strong>空集</strong>（empty set），记作 $\emptyset$。</p>
<p>$$
\emptyset = {x|x \neq x}
$$</p>
<ul>
<li>空集是一切集合的子集。</li>
<li>空集是<strong>绝对唯一</strong>的。</li>
</ul>
<p>Example：</p>
<ul>
<li>$|\emptyset| = 0$，</li>
<li>$|{\emptyset}| = 1$。</li>
</ul>
<hr>
<h3 id="证明空集是绝对唯一的" data-numberify>证明空集是绝对唯一的<a class="anchor ms-1" href="#证明空集是绝对唯一的"></a></h3>
<blockquote>
<p>对 “唯一性” 的证明通常采用反证法（先假设 “不唯一”，得出矛盾，从而证明 “唯一性” 是正确的）。</p>
</blockquote>
<p>证明：</p>
<p>假设有两个不同的空集 $\emptyset_1$ 和 $\emptyset_2$ ，由空集是一切集合的子集得</p>
<p>$$
\empty_1 \subseteq \emptyset_2\ 和\ \emptyset_2 \subseteq \emptyset_1
$$</p>
<p>根据集合的相等关系，得 $\emptyset_1 = \emptyset_2$，与假设矛盾。因此空集是绝对唯一的。</p>
<hr>
<h2 id="全集" data-numberify>全集<a class="anchor ms-1" href="#全集"></a></h2>
<p>Definition：</p>
<p>在一个相对固定的范围内，包含此范围内所有元素的集合，称为<strong>全集</strong>或<strong>论集</strong>（universal set），用 $U$ 或 $E$ 表示。</p>
<p>在维恩图中一般用方形表示全集。</p>
<p><picture><img class="img-fluid " alt="全集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%85%A8%E9%9B%86.png" loading="lazy" width="1021" height="563" />
</picture>

</p>
<p>全集是<strong>相对唯一</strong>的。</p>
<hr>
<h2 id="m-元子集" data-numberify>m 元子集<a class="anchor ms-1" href="#m-元子集"></a></h2>
<p>Definition：</p>
<p>如果一个集合含有 $n$ 个元素，则称集合 $A$ 为 $n$ 元子集，称含有 $A$ 中 $m(0 \le m \le n)$个元素的子集为它的 $m$ 元子集。</p>
<p>对于任意 $n$ 元集合 $A$，它的 $m$ 元（$0 \le m \le n$）子集（包含空集）个数为 $C_n^m$ 个，所以不同的子集个数为：</p>
<p>$$
C_n^0 + C_n^1 + \cdots + C_n^n = (1 + 1)^n = 2^n。
\tag{1}
$$</p>
<hr>
<h2 id="幂集" data-numberify>幂集<a class="anchor ms-1" href="#幂集"></a></h2>
<p>Definition：</p>
<p>设 $A$ 为任意集合，把 $A$ 的所有不同子集构成的集合叫做 $A$ 的<strong>幂集</strong>（power set），记作 $P(A)$，即</p>
<p>$$
P(A)\ =\ {x|x \subseteq A}。
$$</p>
<p>由公式 $(1)$ 可得 $|A| = 2^n(n=|A|)$。</p>
<p>幂集也叫做<strong>集族</strong>（family of set）或<strong>集合的集合</strong>。</p>
<blockquote>
<p>对集族的研究在数学方面、知识库和表处理语言以及人工智能等方面都有十分重要的意义。</p>
</blockquote>
<hr>
<h1 id="集合的运算" data-numberify>集合的运算<a class="anchor ms-1" href="#集合的运算"></a></h1>
<h2 id="集合运算的定义" data-numberify>集合运算的定义<a class="anchor ms-1" href="#集合运算的定义"></a></h2>
<p>Definition：</p>
<p>设 $U$ 是全集，$A$、$B$ 是 $U$ 的两个子集，则</p>
<ol>
<li>
<p>“$\cup$” <strong>并运算</strong>（union operation）：$A \cup B = {x|x \in A\ or\ x \in B}$ 是 $A$ 与 $B$ 的<strong>并集</strong>（union）。</p>
<p><picture><img class="img-fluid " alt="并集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%B9%B6%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
<p>并集可代表两个集合 “相加”。</p>
</li>
<li>
<p>“$\cap$” <strong>交运算</strong>（intersection operation）：$A \cap B = {x|x \in A\ and\ B}$ 是 $A$ 与 $B$ 的<strong>交集</strong>（intersection）。</p>
<p><picture><img class="img-fluid " alt="交集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E4%BA%A4%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
</li>
<li>
<p>“$\overline{A}$” <strong>补运算</strong>（complement operation）：$\overline{A} = U - A$ 是集合 $A$ 的<strong>补集</strong>（complement）（也可记为 $A&rsquo;$、$~A$、$A^c$ 等）。$A$ 对于全集 $U$ 的补集是<strong>绝对补集</strong>。</p>
<p><picture><img class="img-fluid " alt="补集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E8%A1%A5%E9%9B%86.png" loading="lazy" width="1116" height="828" />
</picture>

</p>
</li>
<li>
<p>“$-$” <strong>差运算</strong>（subtraction operation）：$A-B={x|x \in A\ and\ x \notin B} = A \cap \overline{B}$ 是 $A$ 与 $B$ 的<strong>差集</strong>（subtraction)，又称 $B$ 在 $A$ 中的<strong>相对补集</strong>。</p>
<p><picture><img class="img-fluid " alt="差集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%B7%AE%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
<p>当 $A=U$ 时，$A-B=\overline{B}$。</p>
</li>
<li>
<p>“$\oplus$” <strong>对称差运算</strong>（symmetric difference operation）：$A \oplus B = {x|(x \in A\ and\ x \notin B)\ or\ (x\in B\ and\ x \notin A} = (A-B) \cup (B-A)$ 是 $A$ 与 $B$ 的<strong>对称差集</strong>（symmetric difference of set）。</p>
<p><picture><img class="img-fluid " alt="相对补集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E7%9B%B8%E5%AF%B9%E8%A1%A5%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
</li>
</ol>
<p>扩展：</p>
<p>设 $A_1,A_2,\cdots,A_n$ 是任意 $n$ 个集合，则</p>
<ul>
<li>
<p>这 $\mathbf n$ <strong>个集合的并集</strong>是包含那些<strong>至少是这组集合中一个集合成员的元素</strong>的集合，即</p>
<p>$$
\displaystyle \bigcup_{i=1}^{n}{A_i}
= A_1 \cup A_2 \cup \cdots \cup A_n
= {x|x \in A_1\ or\ x \in A_2 \cdots or\ x \in A_n}
$$</p>
</li>
<li>
<p>这 $\mathbf n$ <strong>个集合的交集</strong>是那些属于<strong>这组集合中所有集合成员的元素</strong>的集合，即</p>
<p>$$
\displaystyle \bigcap_{i=1}^{n}{A_i}
= A_1 \cap A_2 \cap \cdots \cap A_n
= {x|x \in A_1\ and\ x \in A_2 \cdots and\ x \in A_n}
$$</p>
</li>
</ul>
<p>当 $n$ 无限增大时，可记为</p>
<ul>
<li>$\displaystyle \bigcup^{\infin}_{i=1}A_i = A_1 \cup A_2 \cup \cdots$</li>
<li>$\displaystyle \bigcap^{\infin}_{i=1}A_i = A_1 \cap A_2 \cap \cdots$</li>
</ul>
<hr>
<h2 id="集合运算的基本等式" data-numberify>集合运算的基本等式<a class="anchor ms-1" href="#集合运算的基本等式"></a></h2>
<p>设 $U$ 为全集，$A$，$B$，$C$ 为任意集合，</p>
<table>
<thead>
<tr>
<th style="text-align:left">等式</th>
<th style="text-align:center">性质</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$A \cup A = A$<br>$A \cap A = A$</td>
<td style="text-align:center">幂等率</td>
</tr>
<tr>
<td style="text-align:left">$A \cup B = B \cup A$<br>$A \cap B = B \cap A$</td>
<td style="text-align:center">交换律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (B \cup C) = (A \cup B) \cup C$<br>$A \cap (B \cap C) = (A \cap B) \cap C$</td>
<td style="text-align:center">结合律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup \emptyset = A$<br>$A \cap U = A$</td>
<td style="text-align:center">同一律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup U = U$<br>$A \cap \emptyset = \emptyset$</td>
<td style="text-align:center">零律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$<br>$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$</td>
<td style="text-align:center">分配律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (A \cap B) = A$<br>$A \cap (A \cup B)$</td>
<td style="text-align:center">吸收律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A} \cap A = \emptyset$</td>
<td style="text-align:center">矛盾律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A} \cup A = U$</td>
<td style="text-align:center">排中律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{\overline{A}}=A$</td>
<td style="text-align:center">双重否定律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A \cup B} = \overline{A} \cap \overline{B}$<br>$\overline{A \cap B} = \overline{A}$</td>
<td style="text-align:center">德摩根律</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="分配律" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%88%86%E9%85%8D%E5%BE%8B-16308401576391.png" loading="lazy" width="3655" height="1381" />
</picture>

</p>
<p>证明德摩根律的等式之一：$\overline{A \cup B} = \overline{A} \cap \overline{B}$</p>
<p>证明：</p>
<ol>
<li>
<p>证明 $\overline{A \cup B} \subseteq \overline{A} \cap \overline{B}$</p>
<p>$\begin{aligned} \forall x \in \overline{A \cup B} \quad &amp; \Rightarrow\ x \notin A \cup B\ \Rightarrow\ x \notin A\ and\ x \notin B\ &amp; \Rightarrow x \in \overline{A}\ and\ x \in \overline{B}\ \Rightarrow\ x \in \overline{A} \cap \overline{B}， \end{aligned}$</p>
<p>即 $\overline{A \cup B} \subseteq \overline{A} \cap \overline{B}$；</p>
</li>
<li>
<p>证明 $\overline{A} \cap \overline{B} \subseteq \overline{A \cup B}$</p>
<p>$\begin{aligned} \forall x \in \overline{A} \cap \overline{B} \quad &amp; \Rightarrow\ x \in \overline{A}\ and\ x \in \overline{B}\ \Rightarrow\ x \notin A\ and\ x \notin B\ &amp; \Rightarrow\ x \notin A \cup B\ \Rightarrow\ x \in \overline{A} \cap \overline{B}， \end{aligned}$</p>
<p>即 $\overline{A} \cap \overline{B} \subseteq \overline{A \cup B}$。</p>
</li>
</ol>
<p>综上可得 $\overline{A \cup B} = \overline{A} \cap \overline{B}$。</p>
<hr>
<h1 id="无限集合" data-numberify>无限集合<a class="anchor ms-1" href="#无限集合"></a></h1>
<p>有限集合与无限集合的根本区别是：对于无限集合，表面上个数完全不相等的两个集合之间仍可能存在等势关系，如集合与真子集之间。</p>
<h2 id="等势" data-numberify>等势<a class="anchor ms-1" href="#等势"></a></h2>
<p><strong>冯·诺依曼的自然数定义</strong>：</p>
<p>基于基数，利用一个集合的序列来定义自然数。</p>
<ol>
<li>$\emptyset \in \mathbf{N}$；</li>
<li>若 $n \in \mathbf{N}$，则 $n&rsquo; \equiv n \cup {n} \in \mathbf{N}$。</li>
</ol>
<p>从而，这个 <code>&lt;u&gt;</code>集合序列的基数 <code>&lt;/u&gt;</code>可以来定义自然数：</p>
<ul>
<li>$0 \equiv \emptyset$；</li>
<li>$1 \equiv \emptyset \cup {\emptyset} = {\emptyset} = {0}$；</li>
<li>$2 \equiv {\emptyset} \cup {{\emptyset}} = {\emptyset, {\emptyset}} = {0,1}$；</li>
<li>$\cdots$</li>
<li>$n \equiv {0,1,2,3,\cdots,n-1}$；</li>
<li>$\cdots$</li>
<li>$\mathbf{N} \equiv {0,1,2,\cdots,n,\cdots}$。</li>
</ul>
<blockquote>
<p>实际上，任意含有 $n$ 个元素的集合都可以用 $n$ 表示。即，任意两个基数相同的集合之间都可以建立一一对应关系。</p>
</blockquote>
<hr>
<p>Definition：</p>
<p>设 $A$，$B$ 为两个集合，若在 $A$，$B$ 之间存在一种一一对应的关系：</p>
<p>$$
\Psi:\ A \rightarrow B
$$</p>
<p>则称 $A$ 与 $B$ 是<strong>等势的</strong>（equipotential），记作：</p>
<p>$$
A \sim B
$$</p>
<p>也称集合 $A$、$B$ <strong>等势</strong>（equipotent）。</p>
<p>由等势定义可得，如果 $A = B$，那么 $A \sim B$，反之则不一定成立。</p>
<p>Theorem：</p>
<ol>
<li>两个有限集合等式当且仅当它们有相同的元素个数。</li>
<li>有限集合不和其任何真子集等势。</li>
<li><code>&lt;u&gt;</code>可数集合可以与其可数的真子集等势 <code>&lt;/u&gt;</code>。</li>
</ol>
<hr>
<h2 id="可数集合" data-numberify>可数集合<a class="anchor ms-1" href="#可数集合"></a></h2>
<p>Definition：</p>
<p>凡与自然数集合 $\mathbf{N}$ 等势的集合，称之为<strong>可数集合</strong>（countable set），该类集合的基数记为 $\aleph_0$（aleph，阿列夫）。</p>
<p>Example：</p>
<p>证明以下集合是可数集合，</p>
<ol>
<li>
<p>$O^+ = {x|x \in \mathbf{N}，x是正奇数}$</p>
<p>在 $O^+$ 与 $\mathbf{N}$ 之间建立一个一一对应关系 $\varphi_1 : \mathbf{N} \rightarrow O^+$：</p>
<p>$$
\begin{matrix}
0&amp; 1&amp; 2&amp; \cdots&amp; n&amp; \cdots\
\downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow\
1&amp; 3&amp; 5&amp; \cdots&amp; 2n+1&amp; \cdots&amp;\
\end{matrix}
$$</p>
<p>所以 $O^+$ 是可数集合。</p>
</li>
<li>
<p>$P = {x|x \in \mathbf{N}，x是素数}$</p>
<p>在 $P$ 与 $\mathbf{N}$ 之间建立一个一一对应关系 $\varphi_2 : \mathbf{N} \rightarrow P$：</p>
<p>$$
\begin{matrix}
0&amp; 1&amp; 2&amp; 3&amp; 4&amp; \cdots\
\downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow\
2&amp; 3&amp; 5&amp; 7&amp; 11&amp; \cdots&amp;\
\end{matrix}
$$</p>
<p>所以 $P$ 是可数集合。</p>
</li>
<li>
<p>有理数集合 $\mathbf{Q}$</p>
<p>将 $\mathbf{Q}$ 中的所有元素都写成 $p/q$（$p$、$q$ 是整数，且 $q \neq 0$）的形式，从 $0/1^{[0]}$ 开始，将所有有理数与自然数一一配对（其中 $p/q^{[n]}$ 的上标 $[n]$ 代表对应于该有理数的自然数）：</p>
<p><picture><img class="img-fluid " alt="证明Q是可数集合" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E8%AF%81%E6%98%8EQ%E6%98%AF%E5%8F%AF%E6%95%B0%E9%9B%86%E5%90%88-16308441770882.jpg" loading="lazy" width="1362" height="360" />
</picture>

</p>
<p>所以 $\mathbf{Q}$ 是可数集合。</p>
</li>
</ol>
<hr>
<h2 id="不可数集合" data-numberify>不可数集合<a class="anchor ms-1" href="#不可数集合"></a></h2>
<p>Definition：</p>
<p>开区间 $(0,1)$ 称为不可数集合，凡<strong>与开区间 $(0,1)$ 等势</strong>的集合，都称为<strong>不可数集合</strong>，该类集合的基数记为 $\aleph$（或 $\aleph_1$）。</p>
<p>Example：</p>
<ol>
<li>
<p>闭区间 $[0,1]$ 是不可数集合。</p>
<p>证明：在 $[0,1]$ 和 $(0,1)$ 之间建立如下对应关系：</p>
<p>$$
R:
\begin{cases}
\begin{matrix}
0&amp; \rightarrow&amp; 1/4 \
1&amp; \rightarrow&amp; 1/2 \
\cfrac{1}{2^n}&amp; \rightarrow&amp; \cfrac{1}{2^{n+2}},&amp; n=1,2,3,\cdots \
n&amp; \rightarrow&amp; n,&amp; 其他 n \in (0,1)\
\end{matrix}
\end{cases}
$$</p>
<p>显然 $[0,1]$ 与 $(0,1)$ 是等势的，所以 $[0,1]$ 是不可数集合。</p>
</li>
<li>
<p>实数集 $\mathbf R$ 是不可数集合。</p>
<p>证明：在实数集 $\mathbf R$ 和开区间 $(0,1)$ 之间建立如下对应关系：</p>
<p>$$
n \rightarrow \tan{\pi\bigg(\cfrac{2n-1}{2}\bigg)}
$$</p>
<p>显然 $(0,1)$ 与 $\mathbf{R}$ 之间是等势的，所以 $\mathbf{R}$ 是一个不可数集合。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>SSH 公钥配置</title>
      <link>/blog/2022/08/ssh-%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/08/ssh-%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE/</guid>
      <description><![CDATA[创建.ssh目录并生成公钥: ssh-keygen -t rsa 所有选项全部回车, 使用默认选项即可. 然后切换到用户目录下的.ssh目录: cd ~/.ssh 该目录下默认有三个文件: id_rsa: 用户]]></description>
      <content:encoded><![CDATA[<p>创建<code>.ssh</code>目录并生成公钥:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh-keygen -t rsa
</span></span></code></pre></div><p>所有选项全部回车, 使用默认选项即可.</p>
<p>然后切换到用户目录下的<code>.ssh</code>目录:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> ~/.ssh
</span></span></code></pre></div><p>该目录下默认有三个文件:</p>
<ul>
<li><code>id_rsa</code>: 用户私钥, 不要复制发送给任何人.</li>
<li><code>id_rsa.pub</code>: 公钥, 将里面内容发送给客户端.</li>
<li><code>authorized_keys</code>: 信任的公钥.</li>
</ul>
<p>只需要将<code>id_rsa.pub</code>里的内容以 (<code>ssh-rsa</code>开头的一行内容) 复制到客户端的<code>authorized_keys</code>的目录下即可.</p>
<p>接着在客户端使用:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh username@ip -p port
</span></span></code></pre></div><p>即可连接到服务器.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Code Server 部署</title>
      <link>/blog/2022/07/code-server-%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/07/code-server-%E9%83%A8%E7%BD%B2/</guid>
      <description><![CDATA[下载code-server： wget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz 可以访问code-server GitHub 页面获取下载连接。 解压： tar -zxvf code-server-4.5.1-linux-amd64.tar.gz 将解压后的文件移动到/opt目录下，并重命名：]]></description>
      <content:encoded><![CDATA[<ol>
<li>
<p>下载code-server：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz
</span></span></code></pre></div><p>可以访问<a href="https://github.com/coder/code-server" title="code-server GitHub 页面" target="_blank" rel="noopener noreferrer">code-server GitHub 页面<i class="fas fa-external-link-square-alt ms-1"></i></a>获取下载连接。</p>
</li>
<li>
<p>解压：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">tar -zxvf code-server-4.5.1-linux-amd64.tar.gz
</span></span></code></pre></div></li>
<li>
<p>将解压后的文件移动到<code>/opt</code>目录下，并重命名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mv code-server-4.5.1-linux-amd64 /opt/code-server
</span></span></code></pre></div></li>
<li>
<p>创建软链到<code>/usr/bin</code>目录下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ln -s /opt/code-server/code-server /usr/bin/code-server
</span></span></code></pre></div></li>
<li>
<p>修改配置文件<code>~/.config/code-server/config.yaml</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">vim ~/.config/code-server/config.yaml
</span></span></code></pre></div></li>
<li>
<p>添加code-server服务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">vim /lib/systemd/system/codeweb.service
</span></span></code></pre></div><p>写入如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>Unit<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Description</span><span class="o">=</span>The nginx HTTP and reverse proxy server
</span></span><span class="line"><span class="cl"><span class="nv">After</span><span class="o">=</span>network.target remote-fs.target nss-lookup.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Service<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Type</span><span class="o">=</span>simple
</span></span><span class="line"><span class="cl"><span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/code-server
</span></span><span class="line"><span class="cl"><span class="nv">KillSignal</span><span class="o">=</span>SIGQUIT
</span></span><span class="line"><span class="cl"><span class="nv">TimeoutStopSec</span><span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="nv">KillMode</span><span class="o">=</span>process
</span></span><span class="line"><span class="cl"><span class="nv">PrivateTmp</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl"><span class="nv">StandardOutput</span><span class="o">=</span>syslog
</span></span><span class="line"><span class="cl"><span class="nv">StandardError</span><span class="o">=</span>inherit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Install<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</span></span></code></pre></div></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>搭建 frp 服务</title>
      <link>/blog/2022/07/%E6%90%AD%E5%BB%BA-frp-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/07/%E6%90%AD%E5%BB%BA-frp-%E6%9C%8D%E5%8A%A1/</guid>
      <description><![CDATA[下载frp： wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz 或者访问frp项目获取自己需要的版本。 解压： tar -zxvf frp_0.44.0_linux_amd64.tar.gz 进入目录后，配置frps.ini和frpc.ini： cd frp_0.44.0_linux_amd64 服务端： vim frps.ini 将文件]]></description>
      <content:encoded><![CDATA[<ol>
<li>
<p>下载frp：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz
</span></span></code></pre></div><p>或者访问<a href="https://github.com/fatedier/frp/" title="frp项目" target="_blank" rel="noopener noreferrer">frp项目<i class="fas fa-external-link-square-alt ms-1"></i></a>获取自己需要的版本。</p>
</li>
<li>
<p>解压：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">tar -zxvf frp_0.44.0_linux_amd64.tar.gz
</span></span></code></pre></div></li>
<li>
<p>进入目录后，配置<code>frps.ini</code>和<code>frpc.ini</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> frp_0.44.0_linux_amd64
</span></span></code></pre></div><ul>
<li>
<p>服务端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">vim frps.ini
</span></span></code></pre></div><p>将文件按照下面修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>common<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># frp监听的端口，默认是7000，可以改成其他的</span>
</span></span><span class="line"><span class="cl"><span class="nv">bind_port</span> <span class="o">=</span> <span class="m">7000</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 授权码，请改成更复杂的</span>
</span></span><span class="line"><span class="cl"><span class="nv">token</span> <span class="o">=</span> <span class="m">123456</span>  <span class="c1"># 这个token之后在客户端会用到</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># frp管理后台端口，请按自己需求更改</span>
</span></span><span class="line"><span class="cl"><span class="nv">dashboard_port</span> <span class="o">=</span> <span class="m">7500</span>
</span></span><span class="line"><span class="cl"><span class="c1"># frp管理后台用户名和密码，请改成自己的</span>
</span></span><span class="line"><span class="cl"><span class="nv">dashboard_user</span> <span class="o">=</span> admin
</span></span><span class="line"><span class="cl"><span class="nv">dashboard_pwd</span> <span class="o">=</span> admin
</span></span><span class="line"><span class="cl"><span class="nv">enable_prometheus</span> <span class="o">=</span> <span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># frp日志配置</span>
</span></span><span class="line"><span class="cl"><span class="nv">log_file</span> <span class="o">=</span> /var/log/frps.log
</span></span><span class="line"><span class="cl"><span class="nv">log_level</span> <span class="o">=</span> info
</span></span><span class="line"><span class="cl"><span class="nv">log_max_days</span> <span class="o">=</span> <span class="m">3</span>
</span></span></code></pre></div></li>
<li>
<p>客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">vim frpc.ini
</span></span></code></pre></div><p>将文件按照下面修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 客户端配置</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>common<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">server_addr</span> <span class="o">=</span> 服务器ip
</span></span><span class="line"><span class="cl"><span class="nv">server_port</span> <span class="o">=</span> <span class="m">7000</span> <span class="c1"># 与frps.ini的bind_port一致</span>
</span></span><span class="line"><span class="cl"><span class="nv">token</span> <span class="o">=</span> <span class="m">52010</span>  <span class="c1"># 与frps.ini的token一致</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 配置ssh服务</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>ssh<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">type</span> <span class="o">=</span> tcp
</span></span><span class="line"><span class="cl"><span class="nv">local_ip</span> <span class="o">=</span> 127.0.0.1 <span class="c1"># 默认本地ip</span>
</span></span><span class="line"><span class="cl"><span class="nv">local_port</span> <span class="o">=</span> <span class="m">22</span>
</span></span><span class="line"><span class="cl"><span class="nv">remote_port</span> <span class="o">=</span> <span class="m">6000</span>  <span class="c1"># 这个自定义，之后再ssh连接的时候要用</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>web<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">type</span> <span class="o">=</span> http
</span></span><span class="line"><span class="cl"><span class="nv">local_ip</span> <span class="o">=</span> 127.0.0.1
</span></span><span class="line"><span class="cl"><span class="nv">local_port</span> <span class="o">=</span> <span class="m">8080</span>
</span></span><span class="line"><span class="cl"><span class="nv">subdomain</span> <span class="o">=</span> test.hijk.pw  <span class="c1"># web域名</span>
</span></span><span class="line"><span class="cl"><span class="nv">remote_port</span> <span class="o">=</span> 自定义的远程服务器端口，例如8080
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>接着需要在防火墙开启相应的端口。</p>
</li>
<li>
<p>启动服务：</p>
<ul>
<li>
<p>服务端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./frps -s frps.ini
</span></span></code></pre></div><p>或者配置<code>frps.server</code>文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo vim /lib/systemd/system/frps.service
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>Unit<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Description</span><span class="o">=</span>The nginx HTTP and reverse proxy server
</span></span><span class="line"><span class="cl"><span class="nv">After</span><span class="o">=</span>network.target remote-fs.target nss-lookup.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Service<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Type</span><span class="o">=</span>simple
</span></span><span class="line"><span class="cl"><span class="c1"># 根据实际情况修改这条命令或者将frps、frps.ini移动到相应位置</span>
</span></span><span class="line"><span class="cl"><span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/frps -c /etc/frp/frps.ini
</span></span><span class="line"><span class="cl"><span class="nv">KillSignal</span><span class="o">=</span>SIGQUIT
</span></span><span class="line"><span class="cl"><span class="nv">TimeoutStopSec</span><span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="nv">KillMode</span><span class="o">=</span>process
</span></span><span class="line"><span class="cl"><span class="nv">PrivateTmp</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl"><span class="nv">StandardOutput</span><span class="o">=</span>syslog
</span></span><span class="line"><span class="cl"><span class="nv">StandardError</span><span class="o">=</span>inherit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Install<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</span></span></code></pre></div></li>
<li>
<p>客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./frpc -c frpc.ini
</span></span></code></pre></div><p>如果是Linux也可以配置<code>frpc.service</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>Unit<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Description</span><span class="o">=</span>Frp Client Service
</span></span><span class="line"><span class="cl"><span class="nv">After</span><span class="o">=</span>network.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Service<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Type</span><span class="o">=</span>simple
</span></span><span class="line"><span class="cl"><span class="c1">#User=nobody</span>
</span></span><span class="line"><span class="cl"><span class="nv">Restart</span><span class="o">=</span>on-failure
</span></span><span class="line"><span class="cl"><span class="nv">RestartSec</span><span class="o">=</span>5s
</span></span><span class="line"><span class="cl"><span class="c1"># 根据实际情况修改以下两条命令或者将frps、frps.ini移动到相应位置</span>
</span></span><span class="line"><span class="cl"><span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/frpc -c /etc/frp/frpc.ini
</span></span><span class="line"><span class="cl"><span class="nv">ExecReload</span><span class="o">=</span>/usr/bin/frpc reload -c /etc/frp/frpc.ini
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Install<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<p>更多请见<a href="https://frps.cn/11.html" title="Frp官方文档" target="_blank" rel="noopener noreferrer">Frp官方文档<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>经典查找算法</title>
      <link>/blog/2022/02/%E7%BB%8F%E5%85%B8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 27 Feb 2022 14:44:00 +0000</pubDate>
      
      <guid>/blog/2022/02/%E7%BB%8F%E5%85%B8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description><![CDATA[二分查找 二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。 算法步骤 以升序数列$L[0&hellip;n-1]$]]></description>
      <content:encoded><![CDATA[<h1 id="二分查找" data-numberify>二分查找<a class="anchor ms-1" href="#二分查找"></a></h1>
<p>二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。</p>
<h2 id="算法步骤" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤"></a></h2>
<p>以升序数列$L[0&hellip;n-1]$为例，假设要查找的数为$x$：</p>
<p>让$x$与数列中间位置的元素$L[\lfloor \frac n2 \rfloor]$进行比较，如果相等则返回该元素下标，否则：</p>
<ul>
<li>如果$x$比中间元素小，递归地对中间元素左边的数列（比二分查找小的元素）进行二分查找；</li>
<li>如果$x$比中间元素大，递归地对中间元素右边的数列（比二分查找大的元素）进行二分查找。</li>
</ul>
<h2 id="代码实现" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现"></a></h2>
<h3 id="python实现" data-numberify>Python实现<a class="anchor ms-1" href="#python实现"></a></h3>
<ol>
<li>递归实现：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;二分排序（递归实现）
</span></span></span><span class="line"><span class="cl"><span class="s2">    left=0,right=len(arr)-1&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">target</span> <span class="o">=</span> <span class="mi">66</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>非递归实现：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;二分排序（非递归实现）&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">target</span> <span class="o">=</span> <span class="mi">66</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ol>
<h3 id="c实现" data-numberify>C实现<a class="anchor ms-1" href="#c实现"></a></h3>
<ol>
<li>递归实现：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 100
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">||</span> <span class="n">arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">66</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;False</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>非递归实现：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 100
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">||</span> <span class="n">arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">66</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;False</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ol>
<hr>
<h1 id="散列表查找" data-numberify>散列表查找<a class="anchor ms-1" href="#散列表查找"></a></h1>
<p>散列表查找又叫哈希表查找，是通过记录存储位置和关键字构建一个确定的关系$f$，使得每个关键字$key$对应一个存储位置$f(key)$，称这个为散列技术。其中，$f$称为散列函数或者哈希函数。</p>
<p>通过散列技术将记录存储在一块连续的存储空间中，这块连续的空间称为散列表或者哈希表。</p>
<p>散列表最适合查找与给定的值相等的记录。</p>
<p>散列函数的冲突：</p>
<p>在使用散列表的过程中，可能会有两个关键字通过散列函数得到的存储地址是一样的，这个现象被称为冲突。此时就需要通过冲突解决办法来解决冲突。在解决冲突的同时也要保证查找和插入效率问题。同时为了避免冲突，散列函数的构造也是很重要的。</p>
<h2 id="算法步骤-1" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-1"></a></h2>
<h3 id="散列函数的构造方法" data-numberify>散列函数的构造方法<a class="anchor ms-1" href="#散列函数的构造方法"></a></h3>
<p>选取散列函数的参考：</p>
<ol>
<li>计算散列地址所需的时间；</li>
<li>关键字长度； </li>
<li> 散列表大小； </li>
<li>关键字的分布情况； </li>
<li>查找记录的频率。</li>
</ol>
<h4 id="直接定址法" data-numberify>直接定址法<a class="anchor ms-1" href="#直接定址法"></a></h4>
<p>直接定址法就是直接通过取关键字的某个线性值作为散列地址：</p>
<p>$$
f(key)=a \cdot key+b\quad(a,b为常数)
$$</p>
<p>例如，要存储0-100岁的人口统计表，就可以采用散列函数为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">f(key) = key
</span></span></code></pre></div><h4 id="数字分析法" data-numberify>数字分析法<a class="anchor ms-1" href="#数字分析法"></a></h4>
<p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布比较  均匀，就可以考虑这个方法。</p>
<p>Example：</p>
<p>假设某公司的员工登记表以员工的手机号作为关键字。手机号一共11位。前3位是接入号，对应不同运营商的子品牌；中间4位表示归属地；最后4位是用户号。不同手机号前7位相同的可能性很大，所以可以选择后4位作为散列地址，或者对后4位反转（1234 -&gt; 4321）、循环右移（1234 -&gt; 4123）、循环左移等等之后作为散列地址。</p>
<h4 id="平方取中法" data-numberify>平方取中法<a class="anchor ms-1" href="#平方取中法"></a></h4>
<p>假设关键字是1234，平方之后是1522756，再抽取中间3位227，用作散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<h4 id="折叠法" data-numberify>折叠法<a class="anchor ms-1" href="#折叠法"></a></h4>
<p>将关键字从左到右分割成位数相等的几部分，最后一部分位数不够时可以短些，然后将这几部分叠加求和，  并按散列表表长，取后几位作为散列地址。</p>
<p>比如关键字是9876543210，散列表表长是3位，将其分为四组，然后叠加求和：987 + 654 + 321 + 0 =  1962，取后3位962作为散列地址。</p>
<p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h4 id="x20除留取余数法" data-numberify>&#x20;除留取余数法<a class="anchor ms-1" href="#x20除留取余数法"></a></h4>
<p>此方法为最常用的构造散列函数方法。</p>
<p>除留取余数法：</p>
<p>$$
f(key)=key\enspace mod\enspace p\quad (p\le m),\ m为散列表长
$$</p>
<p>这种方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。</p>
<h4 id="随机数法" data-numberify>随机数法<a class="anchor ms-1" href="#随机数法"></a></h4>
<p>$$
f(key)=random(key),\quad random是随机函数
$$</p>
<p>当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p>
<h3 id="处理散列表冲突问题的方法" data-numberify>处理散列表冲突问题的方法<a class="anchor ms-1" href="#处理散列表冲突问题的方法"></a></h3>
<h4 id="开放地址法" data-numberify>开放地址法<a class="anchor ms-1" href="#开放地址法"></a></h4>
<p>开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。有三种寻找空散列地址的方法：</p>
<ol>
<li>
<p>线性探测法</p>
<p>$$
f&rsquo;(key)=(f(key)+d)% n,\quad 其中d取(0,1,2,&hellip;,n-1),\ n为散列表的长度
$$</p>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
<p>Example：</p>
<table>
<thead>
<tr>
<th><strong>下标</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关键字</strong></td>
<td>12</td>
<td>25</td>
<td></td>
<td></td>
<td>16</td>
<td></td>
<td></td>
<td>67</td>
<td>56</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>在如上所示的散列表中插入37。首先使用散列函数计算37的散列地址：$f&rsquo;(37)=f(37)%12=1$（这里假设$f(key)=key$）。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>而下标为1的位置已经存放了25，那就只能继续寻找下一个空散列地址：$f&rsquo;(37)=(f(37)+1)%12=2$。</p>
<p>2这个位置没有内容，所以得到：</p>
<table>
<thead>
<tr>
<th><strong>下标</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关键字</strong></td>
<td>12</td>
<td>25</td>
<td>37</td>
<td></td>
<td>16</td>
<td></td>
<td></td>
<td>67</td>
<td>56</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用线性探测来解决冲突问题，会造成冲突堆积。所谓的冲突堆积就是上例的37，它本来是属于下标1的元素，现在却占用了下标为2的空间。如果现在需要存放原本存放在下标为2的元素，就会再次发生冲突，这个冲突会一直传播下去，大大减低查找和插入效率。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>二次探测法</p>
<p>$$
f&rsquo;(key)=(f(key)+q^2)%n,\quad 其中q取(0,1,-1,2,-2,&hellip;,\frac n2,-\frac n2),\ n为散列表的长度
$$</p>
<p>二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。</p>
<p>Example：</p>
<table>
<thead>
<tr>
<th><strong>下标</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关键字</strong></td>
<td>12</td>
<td>25</td>
<td>37</td>
<td></td>
<td>16</td>
<td></td>
<td></td>
<td>67</td>
<td>56</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入元素7，通过二次探测的散列函数计算得到：$f&rsquo;(7)=f(7)%12=7$。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>但下标为7的位置已经存放了67，所以需要寻找下一个存储地址：$f&rsquo;(7)=(f(7)+1^2)%12=8$。</p>
<p>下标为8的位置已经存放了56，继续寻找： $f&rsquo;(7)=(f(7)+(-1^2))%12=6$。</p>
<p>6这个位置为空，得到：</p>
<table>
<thead>
<tr>
<th><strong>下标</strong></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关键字</strong></td>
<td>12</td>
<td>25</td>
<td>37</td>
<td></td>
<td>16</td>
<td></td>
<td>7</td>
<td>67</td>
<td>56</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>随机探测法</p>
<p>$$
f&rsquo;(key)=(f(key)+d)%m,\quad d为随机数,m为表长
$$</p>
<p>在实现中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避免或减少堆积。</p>
</li>
</ol>
<h4 id="多重散列法" data-numberify>多重散列法<a class="anchor ms-1" href="#多重散列法"></a></h4>
<p>多重散列法又叫再散列函数法。其公式如下：</p>
<p>$$
f&rsquo;(key)=RH(key)
$$</p>
<p>其中$RH$就是不同的散列函数，这些散列函数可以是任何散列函数。只要其中一个发生了冲突，就马上换一个散列函数，直到冲突解决。缺点就是增加了很多计算时间。</p>
<h4 id="链地址法" data-numberify>链地址法<a class="anchor ms-1" href="#链地址法"></a></h4>
<p>链地址法就是当冲突发生时，用链表来存放同义词（即存放在当前位置，每个位置使用链表存放同义词）。这个思路和图的邻接表存储方式很相似。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/02/%E7%BB%8F%E5%85%B8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/20170329114036533_Gh2zPBSsES.jpg" loading="lazy" width="314" height="294" />
</picture>

</p>
<h4 id="公共溢出区法" data-numberify>公共溢出区法<a class="anchor ms-1" href="#公共溢出区法"></a></h4>
<p>公共溢出区法就是把那些冲突的元素直接追加到另外一个溢出表中，如下图所示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/02/%E7%BB%8F%E5%85%B8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/20170329114409113__GJU2mNyy2.png" loading="lazy" width="743" height="721" />
</picture>

</p>
<p>在查找的时候，如果在基本表没有找到，那么就只能去溢出表中进行顺序查找。这个方法比较适合冲突元素少的情况。</p>
<h2 id="代码实现-1" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-1"></a></h2>
<h3 id="python实现-1" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-1"></a></h3>
<ul>
<li>除留取余数法构造散列函数，开放地址法-线性探测处理散列表冲突：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HashTable</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;除留取余数法构造哈希函数&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">insert_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 开放地址法-线性探测</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">address</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">search_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">star</span> <span class="o">=</span> <span class="n">address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="ow">or</span> <span class="n">address</span> <span class="o">==</span> <span class="n">star</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">address</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">list_a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">34</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">hash_table</span> <span class="o">=</span> <span class="n">HashTable</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_a</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">hash_table</span><span class="o">.</span><span class="n">insert_hash</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hash_table</span><span class="o">.</span><span class="n">elem</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">((</span><span class="n">hash_table</span><span class="o">.</span><span class="n">elem</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34; &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">hash_table</span><span class="o">.</span><span class="n">search_hash</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">hash_table</span><span class="o">.</span><span class="n">search_hash</span><span class="p">(</span><span class="mi">33</span><span class="p">))</span>
</span></span></code></pre></div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL 环境配置</title>
      <link>/blog/2022/02/mysql-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/02/mysql-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description><![CDATA[Ubuntu MySQL 8 安装： 首先更新本地存储库索引： sudo apt update 从 APT 存储库安装 MySQL： sudo apt install MySQL-server -y 查看 MySQL 版本，验证是否安装成功： mysql --version 检查 MySQL 是否正在运行： systemctl status mysql.service 如]]></description>
      <content:encoded><![CDATA[<h1 id="ubuntu" data-numberify>Ubuntu<a class="anchor ms-1" href="#ubuntu"></a></h1>
<p>MySQL 8 安装：</p>
<ol>
<li>
<p>首先更新本地存储库索引：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt update
</span></span></code></pre></div></li>
<li>
<p>从 APT 存储库安装 MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install MySQL-server -y
</span></span></code></pre></div></li>
<li>
<p>查看 MySQL 版本，验证是否安装成功：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mysql --version
</span></span></code></pre></div></li>
<li>
<p>检查 MySQL 是否正在运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">systemctl status mysql.service
</span></span></code></pre></div></li>
</ol>
<p>如果服务未运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo systemctl start mysql
</span></span></code></pre></div><hr>
<p>MySQL 安装完成后需要更改密码。</p>
<ol>
<li>
<p>查看默认账户和密码：</p>
<p>执行后找到 <code>user</code> 和 <code>password</code>，如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo vim /etc/mysql/debian.cnf
</span></span></code></pre></div><p>或：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo cat /etc/mysql/debian.cnf
</span></span></code></pre></div><p>找到如下：</p>
<pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">user     = debian-sys-maint
password = 12E0cDBeusG6vANp
</code></pre></li>
<li>
<p>使用默认账户登录：</p>
<p>然后输入默认密码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mysql -udebian-sys-maint -p
</span></span></code></pre></div><pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">12E0cDBeusG6vANp
</code></pre></li>
<li>
<p>输入以下命令修改 root 密码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">USER</span><span class="w"> </span><span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span><span class="w"> </span><span class="n">identified</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="n">mysql_native_password</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="s1">&#39;your_password&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>修改完成后执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">FLUSH</span><span class="w"> </span><span class="k">privileges</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">QUIT</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>最后重启 MySQL 后就可以使用 root 用户了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo service mysql restart
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mysql -uroot -p
</span></span></code></pre></div></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ubuntu 安装 Oh my zsh</title>
      <link>/blog/2022/01/ubuntu-%E5%AE%89%E8%A3%85-oh-my-zsh/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/ubuntu-%E5%AE%89%E8%A3%85-oh-my-zsh/</guid>
      <description><![CDATA[oh-my-zsh主页： https://ohmyz.sh/ 安装并设置zsh 安装zsh： sudo apt install zsh 查看系统中所有的shell： cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh 将zsh设置为]]></description>
      <content:encoded><![CDATA[<p>oh-my-zsh主页： <a href="https://ohmyz.sh/" title="https://ohmyz.sh/" target="_blank" rel="noopener noreferrer">https://ohmyz.sh/<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<h1 id="安装并设置zsh" data-numberify>安装并设置zsh<a class="anchor ms-1" href="#安装并设置zsh"></a></h1>
<p>安装zsh：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install zsh
</span></span></code></pre></div><p>查看系统中所有的shell：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cat /etc/shells
</span></span></code></pre></div><pre tabindex="0"><code class="language-纯文本" data-lang="纯文本"># /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
/usr/bin/screen
/bin/zsh
/usr/bin/zsh
</code></pre><p>将zsh设置为默认的shell：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo chsh -s /bin/zsh
</span></span></code></pre></div><p>重新连接到Ubuntu，然后查看当前默认shell：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$SHELL</span>
</span></span></code></pre></div><p>如果显示<code>/bin/zsh</code>则配置成功。</p>
<hr>
<h1 id="安装-oh-my-zsh" data-numberify>安装 oh-my-zsh<a class="anchor ms-1" href="#安装-oh-my-zsh"></a></h1>
<p>下载install.sh：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh
</span></span></code></pre></div><p>给install.sh添加权限：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">chmod +x install.sh
</span></span></code></pre></div><p>执行install.sh：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./install.sh
</span></span></code></pre></div><blockquote>
<p>📌在执行install.sh之前还需要安装git。否则会报错。</p>
<p>安装git：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install git
</span></span></code></pre></div></blockquote>
<hr>
<h1 id="配置zsh" data-numberify>配置zsh<a class="anchor ms-1" href="#配置zsh"></a></h1>
<p>zsh的配置文件为：<code>~/.zshrc</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">vim ~/.zshrc
</span></span></code></pre></div><h2 id="修改主题" data-numberify>修改主题<a class="anchor ms-1" href="#修改主题"></a></h2>
<p>主题配置项为：<code>ZSH_THEME</code>。</p>
<p>默认主题配置为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ZSH_THEME=&#34;robbyrussell&#34;
</span></span></code></pre></div><p>可以修改为其中之一：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ZSH_THEME=&#34;ys&#34;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ZSH_THEME=&#34;geoffgarside&#34;
</span></span></code></pre></div><p>还可以访问<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" title="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener noreferrer">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes<i class="fas fa-external-link-square-alt ms-1"></i></a> 查看更多主题。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>命题逻辑</title>
      <link>/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/</link>
      <pubDate>Sun, 23 Jan 2022 02:03:41 +0800</pubDate>
      
      <guid>/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/</guid>
      <description><![CDATA[命题的定义 具有确切真值的陈述句称为命题（proposition）。命题可以取一个 “值”，称为真值。真值只有 “真”（用 “T” or “1” 表示，即 T]]></description>
      <content:encoded><![CDATA[<h1 id="命题的定义" data-numberify>命题的定义<a class="anchor ms-1" href="#命题的定义"></a></h1>
<p>具有<u>确切真值的陈述句</u>称为<strong>命题</strong>（<strong>proposition</strong>）。命题可以取一个 “值”，称为<strong>真值</strong>。真值只有 “真”（用 “T” or “1” 表示，即 True）和 “假”（用 “F” or “0” 表示，即 False）。</p>
<blockquote>
<p>通常用带或不带下标的大写英文字母表示命题。</p>
</blockquote>
<hr>
<h2 id="非命题" data-numberify>非命题<a class="anchor ms-1" href="#非命题"></a></h2>
<p>一切没有判断内容的句子，如命令句（祈使句）、感叹句、疑问句、二义性的陈述句等都<u>不能作为命题</u>。</p>
<hr>
<h1 id="原子命题与复合命题" data-numberify>原子命题与复合命题<a class="anchor ms-1" href="#原子命题与复合命题"></a></h1>
<ul>
<li><strong>原子命题</strong>（<strong>简单命题</strong>）：不能再分解为更简单命题的命题。</li>
<li><strong>复合命题</strong>：可以分解为更为简单命题的命题。这些简单命题之间是通过联结词和标点符号复合而成。</li>
</ul>
<hr>
<h2 id="命题变元" data-numberify>命题变元<a class="anchor ms-1" href="#命题变元"></a></h2>
<p>一个特定的命题是一个<strong>常值命题</strong>，它不是具有值 “T”，就是具有值 “F”。</p>
<p>一个任意的没有赋予具体内容的原子命题就是一个<u>变量命题</u>，常称它为<strong>命题变量</strong>（或<strong>命题变元</strong>，<strong>propositional vatiable</strong>）。</p>
<p>命题变元<u>无具体的真值</u>，它的变域是集合 ${T,F}$（或 ${0,1}$）。</p>
<hr>
<h1 id="联结词" data-numberify>联结词<a class="anchor ms-1" href="#联结词"></a></h1>
<p>联结词是<strong>两个命题真值之间的联结</strong>，而不是命题内容之间的连接，因此复合命题的真值只取决于<u>构成它们的各简单命题的真值</u>，而与它们的内容无关，与二者之间是否有关系无关。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264217690456.jpg" loading="lazy" width="1268" height="208" />
</picture>

</p>
<hr>
<h2 id="否定联结词" data-numberify>否定联结词<a class="anchor ms-1" href="#否定联结词"></a></h2>
<p>设 $P$ 是任意一个命题，复合命题 <font color="green">“非 $P$”</font>（或 <font color="green">“$P$ 的否定”</font>）称为 $P$ 的<strong>否定式</strong>（<strong>negation</strong>），记作 <font color="red">$\neg P$</font>，“$\neg$” 为否定联结词。</p>
<p>$P$ 为真当且仅当 $\neg P$ 为假。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P$</th>
<th style="text-align:center">$\neg P$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“$\neg$” 是自然语言中的 “非”、“不”、“没有” 等的逻辑抽象。</p>
</blockquote>
<hr>
<h2 id="合取联结词" data-numberify>合取联结词<a class="anchor ms-1" href="#合取联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 并且 $Q$”</font>（或 <font color="green">“$P$ 和 $Q$”</font>）称为 $P$ 与 $Q$ 的<strong>合取式</strong>（<strong>conjunction</strong>），记作 <font color="red">$P \wedge Q$</font>，“$\wedge$” 为<strong>合取联结词</strong>。</p>
<p>$P \wedge Q$ 为真当且仅当 $P$、$Q$ 同为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \wedge Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16263438047401.jpg" loading="lazy" width="1246" height="252" />
</picture>

</p>
<hr>
<h2 id="析取联结词" data-numberify>析取联结词<a class="anchor ms-1" href="#析取联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 或 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>析取式</strong>（<strong>disjunction</strong>），记作 <font color="red">$P \vee Q$</font>，“$\vee$” 为<strong>析取联结词</strong>。</p>
<p>$P \vee Q$ 为真当且仅当 $P$、$Q$ 至少有一个为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>联结词 “$\vee$” 是自然语言中的 “或”、“或者” 等的逻辑抽象。</p>
<p>自然语言中的 “或” 有 “可兼或”（或称为同或）、“不可兼或”（即异或）两种。</p>
<p>严格来讲，析取联结词实际上代表的是可兼或。</p>
</blockquote>
<hr>
<h2 id="异或联结词" data-numberify>异或联结词<a class="anchor ms-1" href="#异或联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 或 $Q$”</font> 有时代表不可兼或，记作 <font color="red">$P \oplus Q$ 或 $P \overline{\vee} Q$</font>，“$\oplus$” 或 “$\overline{\vee}$” 为<strong>异或联结词</strong>。</p>
<p>$P \oplus Q$ 为真当且仅当 $P$、$Q$ 中有且仅有一个为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="蕴涵联结词" data-numberify>蕴涵联结词<a class="anchor ms-1" href="#蕴涵联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“如果 $P$，则 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>蕴涵式</strong>（<strong>implication</strong>），记作 $P \rightarrow Q$，“$\rightarrow$” 为<strong>蕴含联结词</strong>。</p>
<p>$P \rightarrow Q$ 为假当且仅当 $P$ 为真且 $Q$ 为假（$P$ 为假时，认为该蕴涵式为真）。</p>
<p>一般把蕴涵式 $P \rightarrow Q$ 中的 $P$ 称为该蕴涵式的<strong>前件</strong>，$Q$ 称为蕴涵式的<strong>后件</strong>。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264203339885.jpg" loading="lazy" width="1270" height="255" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264204420358.jpg" loading="lazy" width="1289" height="552" />
</picture>

</p>
<hr>
<h2 id="等价联结词" data-numberify>等价联结词<a class="anchor ms-1" href="#等价联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 当且仅当 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>蕴涵式</strong>（<strong>implication</strong>），记作 $P \leftrightarrow Q$，“$\leftrightarrow$” 为<strong>等价联结词</strong>。</p>
<p>$P \leftrightarrow Q$ 为真当且仅当 $P$、$Q$ 同为真假。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“$\leftrightarrow$” 是自然语言中的 “等价”、“充分必要条件”、“当且仅当” 等的逻辑抽象。</p>
</blockquote>
<hr>
<h2 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h2>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264212687867.jpg" loading="lazy" width="1139" height="479" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264213759514.jpg" loading="lazy" width="1138" height="303" />
</picture>

</p>
<p>命题联结词 “$\wedge$”、“$\vee$”、“$\leftrightarrow$” 具有对称性，而 “$\neg$”、“$\rightarrow$” 没有。</p>
<hr>
<h2 id="优先级" data-numberify>优先级<a class="anchor ms-1" href="#优先级"></a></h2>
<p>优先顺序：括号、否定、合取、析取、蕴涵、等价。同级的联结词，按出现的先后次序（从左到右）。</p>
<hr>
<h1 id="命题联结词的应用" data-numberify>命题联结词的应用<a class="anchor ms-1" href="#命题联结词的应用"></a></h1>
<h2 id="联结词与开关电路" data-numberify>联结词与开关电路<a class="anchor ms-1" href="#联结词与开关电路"></a></h2>
<p>设命题 $P$：开关 $S_1$ 闭合；命题 $Q$：开关 $S_2$ 闭合。则以下电路可用复合命题表示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264222756445.jpg" loading="lazy" width="1072" height="270" />
</picture>

</p>
<ol>
<li>“串联”：$P \wedge Q$；</li>
<li>“并联”：$P \vee Q$；</li>
<li>“断开”：$\neg P$。</li>
</ol>
<hr>
<h2 id="联结词与逻辑电路" data-numberify>联结词与逻辑电路<a class="anchor ms-1" href="#联结词与逻辑电路"></a></h2>
<ol>
<li>
<p>与门：$\wedge$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264225030176.jpg" loading="lazy" width="338" height="138" />
</picture>

</p>
</li>
<li>
<p>或门：$\vee$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264225922743.jpg" loading="lazy" width="336" height="139" />
</picture>

</p>
</li>
<li>
<p>非门：$\neg$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264226657751.jpg" loading="lazy" width="330" height="139" />
</picture>

</p>
</li>
</ol>
<hr>
<h2 id="联结词与网页检索" data-numberify>联结词与网页检索<a class="anchor ms-1" href="#联结词与网页检索"></a></h2>
<p>在<strong>布尔检索</strong>中，</p>
<ol>
<li>$\wedge$（一般用 AND 表示）用于匹配包含两个检索项的记录；</li>
<li>$\vee$（一般用 OR 表示）用于匹配包含两个检索项至少一个的记录；</li>
<li>$\neg$（一般用 NOT 表示）用于排除某个特定的检索项。</li>
</ol>
<hr>
<h2 id="联结词与位运算" data-numberify>联结词与位运算<a class="anchor ms-1" href="#联结词与位运算"></a></h2>
<ol>
<li>按位与：$\wedge$；</li>
<li>按位或：$\vee$；</li>
<li>按位取反：$\neg$。</li>
</ol>
<hr>
<h1 id="命题公式" data-numberify>命题公式<a class="anchor ms-1" href="#命题公式"></a></h1>
<p>复合命题是由原子命题与联结词构成的命题。所以，当其中的原子命题是<a href="#命题变元">命题变元</a>时，此复合命题也即为命题变元的函数，且该函数的值仍为 “真” 或 “假” 值，这样的函数可形象地称为 “<strong>真值函数</strong>” 或 “<strong>命题公式</strong>”，此命题公式没有确切的真值。</p>
<hr>
<h2 id="命题公式的定义" data-numberify>命题公式的定义<a class="anchor ms-1" href="#命题公式的定义"></a></h2>
<p><strong>命题演算的合式公式</strong>（<strong>Well Formed Formula</strong>，<strong>WFF</strong>），又称<strong>命题公式</strong>（简称公式），按如下规则生成：</p>
<ol>
<li>命题变元本身是一个公式；</li>
<li>如果 $G$ 是公式，则 $(\neg G)$ 也是公式；</li>
<li>如果 $G$、$H$ 是公式，则 $(G \wedge H)$、$(G \vee H)$、$(G \rightarrow H)$、$(G \leftrightarrow H)$ 也是公式；</li>
<li>仅由<u>有限步使用规则 1、2、3</u> 后所得到的包含命题变元、联结词和括号的符号串才是命题公式。</li>
</ol>
<p>如果 $G$ 是含有 $n$ 个命题变元 $P_1、P_2、P_3、\cdots、P_n$ 的公式，可记为：$G(P_1,P_2,P_3,\cdots,P_n)$ 或简写为 $G$。</p>
<hr>
<ul>
<li>原子命题变元是最简单的合式公式，称为原子合式公式，简称原子公式；</li>
<li>命题公式没有真值，只有对其命题变元进行真值指派后，方可确定命题公式的真值；</li>
<li>整个公式的最外层括号可以省略，公式中不影响运算次序的括号也可以省略；</li>
<li>在实际应用中，为了便于存储和运算，命题公式常用二元数方式来表达。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264271696146.jpg" loading="lazy" width="870" height="365" />
</picture>

</p>
<hr>
<h2 id="命题公式的解释" data-numberify>命题公式的解释<a class="anchor ms-1" href="#命题公式的解释"></a></h2>
<p>设 $P_1、P_2、P_3、\cdots、P_n$ 是出现在公式 $G$ 中的所有命题变元，给 $P_1、P_2、P_3、\cdots、P_n$ 指定一组真值，则这组真值称为 $G$ 的一个<strong>解释</strong>，常记为 <font color="red">$I$</font>。</p>
<ul>
<li>如果公式 $G$ 在解释 $I$ 下是真的，则称 <font color="green">$I$ 满足 $G$</font>，此时 $I$ 是 $G$ 的<strong>成真赋值</strong>；</li>
<li>如果 $G$ 在解释 $I$ 下是假的，则称 <font color="green">$I$ 弄假于 $G$</font>，此时 $I$ 是 $G$ 的<strong>成假赋值</strong>。</li>
</ul>
<hr>
<h2 id="命题公式的分类" data-numberify>命题公式的分类<a class="anchor ms-1" href="#命题公式的分类"></a></h2>
<ul>
<li><strong>永真公式</strong>（又叫<strong>重言式</strong>，<strong>tautology</strong>）：如果在它的所有解释之下其真值都为 “真”。</li>
<li><strong>永假公式</strong>（又叫<strong>矛盾式</strong>，<strong>contradiction</strong>）：如果在它的所有解释下其真值都为 “假”。</li>
</ul>
<hr>
<ul>
<li><strong>不可满足公式</strong>：即永假公式。</li>
<li><strong>可满足公式</strong>（<strong>satisfiable</strong>）：不为永假公式的公式。</li>
</ul>
<hr>
<ul>
<li>$G$ 是永真的当且仅当 $\neg G$ 是永假的；</li>
<li>$G$ 是可满足的当且仅当至少有一个解释 $I$，使 $G$ 在 $I$ 下为真；</li>
<li>若 $G$ 是永真式，则 $G$ 一定是可满足式，但反之可满足式不一定是永真式。</li>
</ul>
<hr>
<h2 id="等价的命题公式" data-numberify>等价的命题公式<a class="anchor ms-1" href="#等价的命题公式"></a></h2>
<p>设 $G$、$H$ 是两个命题公式，$P_1、P_2、P_3、\cdots、P_n$ 是出现在 $G$、$H$ 中所有的命题变元，如果对于 $P_1、P_2、P_3、\cdots、P_n$ 的 $2^n$ 个解释，$G$ 与 $H$ 的<strong>真值结果都相同</strong>，则称公式 $G$ 与 $H$ 是<strong>等价</strong>的，记作 <font color="red">$G = H$</font>（或 <font color="red">$G \Leftrightarrow H$</font>）。</p>
<hr>
<h3 id="公式等价的充分必要条件" data-numberify>公式等价的充分必要条件<a class="anchor ms-1" href="#公式等价的充分必要条件"></a></h3>
<p>对于任意两个公式 $G$ 和 $H$，<font color="red">$G = H$ 的充分必要条件是公式 $G \leftrightarrow H$ 是永真公式</font>。</p>
<p>Proof：</p>
<ul>
<li>必要性：假定 $G = H$，则 $G$、$H$ 在其任意解释 $I$ 下或同为真或同为假，于是由 “$\leftrightarrow$” 的意义知，公式 $G \leftrightarrow H$ 在其任何的解释 $I$ 下，其真值为 “真”，即 $G \leftrightarrow H$ 为永真公式。</li>
<li>充分性：假定公式 $G \leftrightarrow H$ 是永真公式，$I$ 是它的任意解释，在 $I$ 下，$G \leftrightarrow H$ 为真，因此，$G$，$H$ 或同为真或同为假，由于 $I$ 的任意性，故有 $G = H$。</li>
</ul>
<blockquote>
<p>可判定性：能否给出一个可行方法，完成对任意公式的判定问题（类型或等价判定）。</p>
</blockquote>
<p>命题公式是可判定的。</p>
<hr>
<h2 id="命题公式的基本等价关系" data-numberify>命题公式的基本等价关系<a class="anchor ms-1" href="#命题公式的基本等价关系"></a></h2>
<p>设 $G$、$H$、$S$ 为任意的命题公式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">性质</th>
<th style="text-align:left">等式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><b id="a2"></b>幂等律</td>
<td style="text-align:left">$G \vee G = G$<br/>$G \wedge G = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a3"></b>交换律</td>
<td style="text-align:left">$G \vee H = H \vee G$<br/>$G \wedge H = H \wedge G$</td>
</tr>
<tr>
<td style="text-align:center">结合律</td>
<td style="text-align:left">$G \vee (H \vee S) = (G \vee H) \vee S$<br/>$G \wedge (H \wedge S) = (G \wedge H) \wedge S$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a4"></b>同一律</td>
<td style="text-align:left">$G \wedge 0 = G$<br/>$G \vee 1 = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a5"></b>零律</td>
<td style="text-align:left">$G \vee 1 = 1$<br/>$G \wedge 0 = 0$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a6"></b>分配律</td>
<td style="text-align:left">$G \vee (H \wedge S) = (G \vee H) \wedge (G \vee S)$</br>$G \wedge (H \vee S) = (G \wedge H) \vee (G \wedge S)$</td>
</tr>
<tr>
<td style="text-align:center">吸收率</td>
<td style="text-align:left">$G \vee (G \wedge H) = G$<br/>$G \wedge (G \vee H) = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a7"></b>矛盾律</td>
<td style="text-align:left">$\neg G \wedge G = 0$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a8"></b>排中律</td>
<td style="text-align:left">$\neg G \vee G = 1$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a9"></b>双重否定律</td>
<td style="text-align:left">$\neg(\neg G) = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a10"></b>德摩根律</td>
<td style="text-align:left">$\neg(G \vee H) = \neg G \wedge \neg H$</br>$\neg(G \wedge H) = \neg G \vee \neg H$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a11"></b>蕴涵式</td>
<td style="text-align:left">$G \rightarrow H = \neg G \vee H$</td>
</tr>
<tr>
<td style="text-align:center">假言易位</td>
<td style="text-align:left">$G \rightarrow H = \neg H \rightarrow \neg G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a12"></b>等价式</td>
<td style="text-align:left">$G \leftrightarrow H = (G \rightarrow H) \wedge (H \rightarrow G) = (\neg G \vee H) \wedge (\neg H \vee G)$</td>
</tr>
<tr>
<td style="text-align:center">等价否定等式</td>
<td style="text-align:left">$G \leftrightarrow H = \neg G \leftrightarrow \neg H$</td>
</tr>
<tr>
<td style="text-align:center">归谬论</td>
<td style="text-align:left">$(G \rightarrow H) \wedge (G \rightarrow \neg H) = \neg G$</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="基本等价关系的应用" data-numberify>基本等价关系的应用<a class="anchor ms-1" href="#基本等价关系的应用"></a></h3>
<p>（1）判断公式类型</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264420672234.jpg" loading="lazy" width="620" height="374" />
</picture>

</p>
<p>（2）证明公式等价</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264420999525.jpg" loading="lazy" width="883" height="430" />
</picture>

</p>
<p>（3）开关电路化简</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264421759266.jpg" loading="lazy" width="646" height="360" />
</picture>

</p>
<p>（4）逻辑电路化简</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264422111932.jpg" loading="lazy" width="622" height="380" />
</picture>

</p>
<p>（5）其他</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264422514796.jpg" loading="lazy" width="1232" height="605" />
</picture>

</p>
<hr>
<h1 id="范式" data-numberify>范式<a class="anchor ms-1" href="#范式"></a></h1>
<ul>
<li>命题变元或命题变元的否定称为<strong>文字</strong>。</li>
<li><u>有限个</u>文字（$\ge 1$）的析取称为<strong>简单析取式</strong>（或<strong>子句</strong>）。
单个文字可构成子句。</li>
<li><u>有限个</u>文字（$\ge 1$）的合取称为<strong>简单合取式</strong>（或<strong>短语</strong>）。
单个文字可构成短语。</li>
<li>$P$ 与 $\neg P$ 称为<strong>互补对</strong>。</li>
</ul>
<hr>
<ul>
<li><u>有限个</u>（$\ge 1$）简单合取式（短语）的析取式称为<strong>析取范式</strong>（<strong>disjunctive normal form</strong>）。</li>
<li><u>有限个</u>（$\ge 1$）简单析取式（子句）的合取式称为<strong>合取范式</strong>（<strong>conjunctive normal form</strong>）。</li>
</ul>
<p>文字可以是子句、短语、析取范式、合取范式。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265483645877.png" loading="lazy" width="1226" height="340" />
</picture>

</p>
<ol>
<li>命题公式的析取范式可以指出公式何时为真，而合取范式可以指出公式何时为假，从而能够替代真值表。</li>
<li>命题公式的范式表达并不唯一。</li>
</ol>
<p>Example：</p>
<ol>
<li>
<p>$P$、$\neg P$ 可以是文字、短语、子句、析取范式、合取范式。</p>
</li>
<li>
<p>$P \vee Q \vee \neg R$ 是子句、合取范式、析取范式。</p>
<ul>
<li>
<p>将该式认为是子句，那么单个子句就可构成合取范式。</p>
</li>
<li>
<p>将 $P$、$Q$、$\neg R$ 认为是短语，那么三个短语析取可构成析取范式。</p>
</li>
<li>
<p>$(P \vee Q \vee \neg R)$ 是子句、合取范式。</p>
<p>加了括号后该式就被认为是一个整体，不能作为析取范式。</p>
</li>
</ul>
</li>
<li>
<p>$\neg P \wedge Q \wedge R$ 是短语、析取范式、合取范式。</p>
<ul>
<li>将该式认为是短语，那么单个短语就可构成析取范式。</li>
<li>将 $\neg P$、$Q$、$R$ 认为是子句，那么三个子句合取可构成合取范式。</li>
<li>$(\neg P \wedge Q \wedge R)$ 是短语、析取范式。</li>
</ul>
</li>
<li>
<p>$P \vee (Q \vee \neg R)$ 即不是析取范式也不是合取范式，但转换为 $P \vee Q \vee \neg R$ 后，即是析取范式又是合取范式。</p>
</li>
</ol>
<hr>
<h2 id="范式存在定理" data-numberify>范式存在定理<a class="anchor ms-1" href="#范式存在定理"></a></h2>
<p>联结词之间可以通过命题公式的基本等价关系进行相互转换，因此可以通过逻辑等价公式求出等价的析取范式和合取范式，具体步骤如下：</p>
<ol>
<li>将公式中的 $\rightarrow$、$\leftrightarrow$ 用联结词 $\neg$、$\wedge$、$\vee$ 来取代（使用<a href="#a11">蕴涵式</a>和<a href="#a12">等价式</a>）。</li>
<li>将否定联结词移到各个命题变元的前端，并消去多余的否定号（使用<a href="#a9">双重否定律</a>和<a href="#a10">德摩根律</a>）。</li>
<li>利用<a href="#a6">分配律</a>，可将公式化成一些合取式的析取，或化成一些析取式的合取。</li>
</ol>
<p>对任意一个公式，经过以上步骤（期间可用其他<a href="#命题公式的基本等价关系">等价公式</a>来化简），必能化成与其等价的析取范式和合取范式。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264518371675.jpg" loading="lazy" width="622" height="382" />
</picture>

</p>
<hr>
<h2 id="主范式" data-numberify>主范式<a class="anchor ms-1" href="#主范式"></a></h2>
<p>范式是不唯一的，对构成范式的子句或短语进一步进行规范化，形成唯一的主析取范式和主合取范式。</p>
<hr>
<h3 id="极大项和极小项" data-numberify>极大项和极小项<a class="anchor ms-1" href="#极大项和极小项"></a></h3>
<p>在含有 $n$ 个命题变元 $P_1、P_2、P_3、\cdots、P_n$ 的<u>短语或子句</u>中，若
<u>每个命题变元与其否定不同时存在</u>，但<u>二者之一恰好出现一次且仅一次</u>，并且<font color="green">出现的次序与 $P_1、P_2、P_3、\cdots、P_n$ 一致</font>，则</p>
<ul>
<li>称此<strong>短语</strong>为关于 $P_1、P_2、P_3、\cdots、P_n$ 的一个<strong>极小项</strong>，</li>
<li>称此<strong>子句</strong>为关于 $P_1、P_2、P_3、\cdots、P_n$ 的一个<strong>极大项</strong>。</li>
</ul>
<p>若有 $n$ 个命题，则应有 $2^n$ 个不同的极小项和 $2^n$ 个不同的极大项。</p>
<hr>
<p>对于极小项：</p>
<ul>
<li>没有两个不同的极小项是等价的。</li>
<li>每个极小项只有一组成假赋值，因此可用于给极大项编码。
编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。</li>
</ul>
<p>Example：</p>
<p>设命题变元 $P$、$Q$，</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265086173840.jpg" loading="lazy" width="1150" height="340" />
</picture>

</p>
<hr>
<p>对于极大项（与极小项相反的规定）：</p>
<ul>
<li>没有两个不同的极大项是等价的。</li>
<li>每个极大项只有一组成假赋值，因此可用于给极大项编码。
编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。</li>
</ul>
<p>Example：</p>
<p>设命题变元 $P$、$Q$，</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265087894491.jpg" loading="lazy" width="1146" height="339" />
</picture>

</p>
<hr>
<p>极小项的编码可对应为真情况时，相应的短语为真的真值序列。极大项的编码可对应为假情况时，相应的子句为假的真值序列。</p>
<p>极小项和极大项还有以下性质：</p>
<p>设有 $n$ 个命题变元，设 $i,j \in {0, 1, \cdots, 2^{n-1}}$ 且 $i \neq j$，$m_i、m_j$ 代表这 $n$ 个命题变元对应的极小项，$M_i、M_j$ 代表对应的命题变元的极大项。那么就有</p>
<ol>
<li>
<p>$m_i \wedge m_j = 0$，</p>
<p>$M_i \vee M_j = 1$；</p>
</li>
<li>
<p>$m_i = \neg M_i$，</p>
<p>$M_i = \neg m_i$；</p>
</li>
<li>
<p>$\displaystyle \bigvee_{i=0}^{2^n-1}{m_i} = 1$，</p>
<p>$\displaystyle \bigwedge_{i=0}^{2^n-1}{M_i} = 0$。</p>
</li>
</ol>
<hr>
<h3 id="主析取范式和主合取范式" data-numberify>主析取范式和主合取范式<a class="anchor ms-1" href="#主析取范式和主合取范式"></a></h3>
<ul>
<li>在给定的<u>析取范式</u>中，若<u>每一个短语都是极小项</u>，且按照编码<u>从小到大</u>的顺序排列，则称该范式为<strong>主析取范式</strong>(<strong>principal disjunctive normal form</strong>)。</li>
<li>在给定的<u>合取范式</u>中，若<u>每一个子句都是极大项</u>，且按照编码<u>从小到大</u>的顺序排列，则称该范式为<strong>主合取范式</strong>(<strong>principal conjunctive normal form</strong>)。</li>
</ul>
<p>如果一个主析取范式<u>不包含任何极小项</u>，则称该主析取范式为 “<strong>空</strong>”；如果一个<u>主合取范式不包含</u>任何极大项，则称主合取范式为 “<strong>空</strong>”。</p>
<hr>
<p>任何一个公式都有与之等价的主析取范式和主合取范式。</p>
<ul>
<li>如果某一公式的主析取范式包含所有的极小项，即主合取范式为空，则该公式为永真公式。</li>
<li>如果某一公式主合取范式包含所有的极大项，即主析取范式为空，则该公式为永假公式。</li>
<li>若有两个公式，它们具有相同的主析取范式或主合取范式，则两公式等价。</li>
</ul>
<hr>
<h2 id="主范式求解定理" data-numberify>主范式求解定理<a class="anchor ms-1" href="#主范式求解定理"></a></h2>
<ol>
<li>
<p>求出该公式所对应的析取范式和合取范式。</p>
</li>
<li>
<p>消去重复出现的命题变元，矛盾式或重言式。</p>
<ol>
<li>先利用<a href="#a2">幂等律</a>、<a href="#a7">矛盾律</a>和<a href="#a8">排中律</a>消去重复出现的命题元素；</li>
<li>再使用<a href="#a4">同一律</a>和<a href="#a5">零律</a>消去其中的常数。</li>
</ol>
</li>
<li>
<p>若析取（合取）范式的某一个短语（子句）$B_i$ 中缺少命题变元 $P$，则可用如下方式将 $P$ 补进去：</p>
<ul>
<li>求主析取范式：$B_i = B_i \wedge 1 = B_i \wedge (\neg P \vee P) = (B_i \wedge \neg P) \vee (B_i \wedge P)$；</li>
<li>求主合取范式：$B_i = B_i \vee 0 = B_i \vee (\neg P \wedge P) = (B_i \vee \neg P) \wedge (B_i \vee P)$。</li>
</ul>
</li>
<li>
<p>利用<a href="#a2">幂等律</a>将重复的极小项和极大项合并，并利用<a href="#a3">交换律</a>进行顺序调整，由此可转换成标准的主析取范式和主合取范式。</p>
</li>
</ol>
<p>主析取范式的极小项编码序列与主合取范式的极大项变编码序列是互补的。因此，只需求出主析取范式或主合取范式中其中之一，就可对应求出主合取范式或主析取范式。</p>
<hr>
<h3 id="公式转换法" data-numberify>公式转换法<a class="anchor ms-1" href="#公式转换法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265114352643.jpg" loading="lazy" width="962" height="466" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265112790430.jpg" loading="lazy" width="1014" height="389" />
</picture>

</p>
<hr>
<h3 id="真值表技术" data-numberify>真值表技术<a class="anchor ms-1" href="#真值表技术"></a></h3>
<p>从真值表按所给的算法求出主范式的方法，称为<strong>真值表技术</strong> (<strong>technique of truth table</strong>)。</p>
<p>方法：</p>
<ul>
<li>列出真值表，选出公式的真值结果为真的所有的行，在这样的每一行中，找到其每一个解释所对应的极小项，将这些极小项进行析取即可得到相应的主析取范式。</li>
<li>列出真值表，选出公式的真值结果为假的所有的行，在这样的每一行中，找到其每一个解释所对应的极大项，将这些极大项进行合取即可得到相应的主合取范式。</li>
</ul>
<hr>
<h1 id="推理" data-numberify>推理<a class="anchor ms-1" href="#推理"></a></h1>
<p><strong>推理</strong>是指从一组前提合乎逻辑的推出结论的思维过程。</p>
<hr>
<h2 id="基本推理形式" data-numberify>基本推理形式<a class="anchor ms-1" href="#基本推理形式"></a></h2>
<p>设 $G_1、G_2、\cdots、G_n、H$ 是命题公式，称 $H$ 是 $G_1、G_2、\cdots、G_n$ 的<strong>逻辑结果</strong>当且仅当<font color="green">对任意解释 $I$，如果 $I$ 使得 $G_1 \wedge G_2 \wedge \cdots \wedge G_n$ 为真，则 $I$ 也会使 $H$ 为真</font>，记为 $G_1、G_2、\cdots、G_n\ \Rightarrow\ H$，“$\Rightarrow$” 称为<strong>蕴涵关系</strong>，此时称 $G_1、G_2、\cdots、G_n\ \Rightarrow\ H$ 为有效的，否则称为无效的。</p>
<p>$G_1、G_2、\cdots、G_n$ 称为一组<strong>前提</strong>，有时用集合 $\Gamma$ 来表示，记为 $\Gamma = {G_1,G_2,\cdots,G_n}$，$H$ 称为<strong>结论</strong>。此时也称 $H$ 是前提集合 $\Gamma$ 的逻辑结果，记为 $\Gamma \Rightarrow H$。</p>
<hr>
<h2 id="推理的判定定理" data-numberify>推理的判定定理<a class="anchor ms-1" href="#推理的判定定理"></a></h2>
<p>公式 $H$ 是前提集合 $\Gamma = {G_1,G_2,\cdots,G_n}$ 的逻辑结果当且仅当 $(G_1 \wedge G_2 \wedge \cdots \wedge G_n) \rightarrow H$ 为永真公式。</p>
<p>判定方法：</p>
<ol>
<li>真值表技术，</li>
<li>公式转换法，</li>
<li>主析取范式法。</li>
</ol>
<p><picture><img class="img-fluid " alt="16265511416012" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265511416012.jpg" loading="lazy" width="620" height="370" />
</picture>

</p>
<hr>
<h2 id="基本蕴涵关系" data-numberify>基本蕴涵关系<a class="anchor ms-1" href="#基本蕴涵关系"></a></h2>
<p>设 $G$、$H$、$I$ 为任意命题公式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">简化规则</td>
<td style="text-align:left">$G \wedge H \Rightarrow G$<br/>$G \wedge H \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">添加规则</td>
<td style="text-align:left">$G \Rightarrow G \vee H$</td>
</tr>
<tr>
<td style="text-align:center">合取引入规则</td>
<td style="text-align:left">$G,H \Rightarrow G \wedge H$</td>
</tr>
<tr>
<td style="text-align:center">选言三段论</td>
<td style="text-align:left">$G \vee H, \neg G \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">假言推理规则</td>
<td style="text-align:left">$G \rightarrow H, G \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">否定后件式</td>
<td style="text-align:left">$G \rightarrow H, \neg H \Rightarrow \neg G$</td>
</tr>
<tr>
<td style="text-align:center">假言三段论</td>
<td style="text-align:left">$G \rightarrow H, H \rightarrow I \Rightarrow G \rightarrow I$</td>
</tr>
<tr>
<td style="text-align:center">二难推论</td>
<td style="text-align:left">$G \vee H, G \rightarrow I, H \rightarrow I \Rightarrow I$</td>
</tr>
</tbody>
</table>
<p>![])(16265520749814.jpg)</p>
<hr>
<h2 id="自然演绎法推理" data-numberify>自然演绎法推理<a class="anchor ms-1" href="#自然演绎法推理"></a></h2>
<ul>
<li>
<p>规则 $\mathbf{P}$（称为<strong>前提引用规则</strong>）：在推导过程中，可随时引入前提集合中的任意一个前提，引入附加前提时需作声明。</p>
</li>
<li>
<p>规则 $\mathbf{T}$（称为<strong>逻辑结果引用规则</strong>）：在推导过程中，可随时引入公式 $S$，该公式 $S$ 是由其前的一个或多个公式（可以是前提条件或推导出来的公式）推导出来的逻辑结果。</p>
</li>
<li>
<p>规则 $\mathbf{CP}$（称为<strong>附加前提规则</strong>）：如果能从给定的前提集合 $\Gamma$ 与公式 $P$ 推导出 $S$，则能从此前提集合 $\Gamma$ 推导出 $P \rightarrow S$。</p>
<p>原理：$P \rightarrow (Q \rightarrow R) = (P \wedge Q) \rightarrow R$。
使用场合：当结论公式是<u>蕴涵式或析取式</u>时使用。</p>
</li>
</ul>
<p>命题演算推理系统 = 三个推理规则 + 基本等价公式 + 基本蕴涵公式。</p>
<hr>
<p>从前提集合 $\Gamma$ 推出结论 $H$ 的一个<strong>演绎</strong>是构造命题公式的一个有限序列：</p>
<p>$$
H_1, H_2, H_3, \cdots, H_{n-1}, H_n
$$</p>
<p>其中，$H_i$ 或者是 $\Gamma$ 中的某个前提，或者是前面的某些 $H_j(j &lt; i)$ 的有效结论，并且 $H_n$ 就是 $H$，则称公式 $H$ 为该演绎的有效结论，或者称从前提 $\Gamma$ 能够演绎出结论 $H$ 来。</p>
<hr>
<h3 id="直接证明法" data-numberify>直接证明法<a class="anchor ms-1" href="#直接证明法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265912526773.jpg" loading="lazy" width="620" height="442" />
</picture>

</p>
<hr>
<h3 id="规则-cp-证明法" data-numberify>规则 CP 证明法<a class="anchor ms-1" href="#规则-cp-证明法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265902308226.jpg" loading="lazy" width="622" height="426" />
</picture>

</p>
<hr>
<h3 id="间接证明法" data-numberify>间接证明法<a class="anchor ms-1" href="#间接证明法"></a></h3>
<p>间接证明法又叫反证法、归谬法。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265935152814.jpg" loading="lazy" width="1206" height="620" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265936708923.jpg" loading="lazy" width="622" height="362" />
</picture>

</p>
<blockquote>
<p>反证法在逻辑推理中有时十分方便。反证法实际上是规则 CP 的一种变形，所以可以使用 CP 证明法来代替它。</p>
</blockquote>
<hr>
<h1 id="谓词逻辑" data-numberify>谓词逻辑<a class="anchor ms-1" href="#谓词逻辑"></a></h1>
<p>对简单命题进行分解，利用<u>个体词、谓词和量词</u>来描述简单命题句子，从而研究其中的逻辑关系，并研究个体与总体的内在联系和数量关系。</p>
<hr>
<h2 id="个体词" data-numberify>个体词<a class="anchor ms-1" href="#个体词"></a></h2>
<p>在原子命题中，可以<u>独立存在的客体</u>（句子中的主语、宾语等），称为<strong>个体词</strong>。</p>
<p>个体词可分为个体常量和个体变量，均在个体域内取值。</p>
<ol>
<li>表示具体或特定的个体词称为<strong>个体常量</strong>。一般用带或不带下标的小写英文字母 $a, b, c, \cdots, a_1, b_1, c_1, \cdots$ 等表示。</li>
<li>表示抽象的或泛指的个体词称为<strong>个体变量</strong>。一般用带或不带下标的小写英文字母 $x, y, z, \cdots, x_1, y_1, z_1, \cdots$ 等表示。</li>
</ol>
<hr>
<ul>
<li>个体词的取值范围称为<strong>个体域</strong>（或<strong>论域</strong>），常用 $D$ 表示。</li>
<li>宇宙间的所有个体域聚集在一起所构成的个体域称为<strong>全总个体域</strong>。无特别说明时，默认使用全总个体域。</li>
</ul>
<hr>
<h2 id="谓词" data-numberify>谓词<a class="anchor ms-1" href="#谓词"></a></h2>
<p>在原子命题中，用以刻划<u>客体的性质或客体之间的关系</u>即是<strong>谓词</strong>。</p>
<p>设 $D$ 为非空的个体域，定义在 $D^n$ 上取值为 ${0,1}$ 上的 $n$ 元函数，称为 $n$ 元命题函数或 $n$ 元谓词，记为 $P(x_1, x_2, \cdots, x_n)$。其中，个体变量 $x_1, x_2, \cdots, x_n \in D$。</p>
<ol>
<li>表示具体性质或关系的谓词称为<strong>谓词常量</strong>。</li>
<li>表示抽象的或泛指的性质或关系的谓词称为<strong>谓词变量</strong>。</li>
</ol>
<p>谓词均使用大写英文字母 $P, Q, R, \cdots, F, G, H, \cdots$ 来表示。</p>
<p>$D^n$ 表示 $n$ 个个体都在个体域 $D$ 上取值。</p>
<ul>
<li>谓词中个体词的顺序不能随意变更。</li>
<li>一元谓词用以描述某一个个体的某种<strong>特性</strong>，而 $n$ 元谓词（$n \ge 2$）则用以描述 $n$ 个个体之间的<strong>关系</strong>。</li>
<li>谓词 $P(x_1, x_2, \cdots, x_n)$ 包含了个体变量，因而本身并不是命题，只有用谓词常量取代 $P$，用个体常量取代 $x_1, x_2, \cdots, x_n$ 后才会称为命题。</li>
<li>一般将<u>没有任何个体变量</u>的谓词称为 <strong>0 元谓词</strong>（如，$F(a_1, a_2, \cdots, a_n$）。当 $F$ 为谓词常量时，0 元谓词就成为命题。命题逻辑中的所有命题都可以表示成 0 元谓词。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267215046524.jpg" loading="lazy" width="1204" height="546" />
</picture>

</p>
<hr>
<h2 id="量词" data-numberify>量词<a class="anchor ms-1" href="#量词"></a></h2>
<ul>
<li><strong>全称量词</strong>（$\forall x$）：所有的 $x$；任意的 $x$；一切的 $x$；每一个 $x$；……</li>
<li><strong>存在量词</strong>（$\exists x$）：有些 $x$；至少有一个 $x$；某一些 $x$；存在 $x$；……</li>
</ul>
<p>其中的 $x$ 称为作用变量。一般将其量词加在其谓词之前，记为 $(\forall x)F(x)$、$(\exists x)F(x)$。此时，$F(x)$ 称为全称量词和存在量词的<strong>辖域</strong>。</p>
<p>![16267650196113.jpg]</p>
<p>引入更准确的表达方式：以上符号化必须要特别注明个体域，在表达比较复杂的命题时会容易混淆。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267651119352.jpg" loading="lazy" width="622" height="392" />
</picture>

</p>
<p>其中，$T(x)$、$C(x)$、$H(x)$ 和 $N(x)$ 分别是各自个体变量的<strong>个性谓词</strong>。</p>
<hr>
<p>统一一个<strong>全总个体域</strong>，而对每一个句子中个体变量的变化范围用一元<strong>特性谓词</strong>刻划之。这种特性谓词在加入到命题函数中时必定遵循如下原则：</p>
<ul>
<li>对于<strong>全称量词</strong>（$\forall x$），刻划其对应个体域的特性谓词作为<strong>蕴涵式的前件</strong>加入。</li>
<li>对于<strong>存在量词</strong>（$\exists x$），刻划其对应个体域的特性谓词作为<strong>合取式的合取项</strong>加入。</li>
</ul>
<hr>
<h2 id="谓词逻辑的真值" data-numberify>谓词逻辑的真值<a class="anchor ms-1" href="#谓词逻辑的真值"></a></h2>
<ul>
<li>$(\forall x)G(x)$：对 $\forall x \in D$，$G(x)$ 都成立。
<ul>
<li>$(\forall x)G(x)$ 取值为 1 当且仅当对任意 $x \in D$，$G(x)$ 都取值为 1；</li>
<li>$(\forall x)G(x)$ 取值为 0 当且仅当存在 $x_0 \in D$，使得 $G(x_0)$ 取值为 0。</li>
</ul>
</li>
<li>$(\exists x)G(x)$：存在一个 $x_0 \in D$（是有一个的意思，即可以存在一个以上，且包括一个），使得 $G(x_0)$ 成立。
<ul>
<li>$(\exists x)G(x)$ 取值为 1 当且仅当存在 $x_0 \in D$，使得 $G(x_0)$ 取值为 1；</li>
<li>$(\exists x)G(x)$ 取值为 0 当且仅当对任意 $x \in D$，$G(x)$ 都取值为 0。</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267661575626.jpg" loading="lazy" width="1261" height="559" />
</picture>

</p>
<p>当个体域 $D = {x_0, x_1, \cdots, x_n}$ 是<strong>有限集合</strong>时，</p>
<ul>
<li>$(\forall x)G(x) = G(x_0) \wedge G(x_1) \wedge \cdots \wedge G(x_n)$；</li>
<li>$(\exists x)G(x) = G(x_0) \vee G(x_1) \vee \cdots \vee G(x_n)$。</li>
</ul>
<p>注意：量词对变元的约束往往与量词的次序有关。不同的量词次序，可以产生不同的真值。因此当多个量词同时出现时，不能随意颠倒它们的顺序，否则会改变原有的含义。</p>
<hr>
<h1 id="谓词合式公式" data-numberify>谓词合式公式<a class="anchor ms-1" href="#谓词合式公式"></a></h1>
<p>在基于谓词的形式化中，将使用如下四种符号：</p>
<ol>
<li><strong>常量符号</strong>：指所属个体域 $D$ 中的某个元素，用带或不带下标的小写英文字母 $a, b, c, \cdots, a_1, b_1, c_1, \cdots$ 来表示。</li>
<li><strong>变量符号</strong>：指所属个体域 $D$ 中的任意元素，用带或不带下标的小写英文字母 $x, y, z, \cdots, x_1, y_1, z_1, \cdots$ 来表示。</li>
<li><strong>函数符号</strong>：$n$ 元函数符号 $f(x_1, x_2, \cdots, x_n)$ 可以是所属个体域集合 $D^n \rightarrow D$ 的任意一个函数，用带或不带下标的小写英文字母 $f, g, h, \cdots, f_1, g_1, h_1, \cdots$ 来表示。</li>
<li><strong>谓词符号</strong>：$n$ 元谓词符号 $P(x_1, x_2, \cdots, x_n)$ 可以是所属个体域集合 $D_n \rightarrow {0, 1}$ 的任意一个谓词，用带或不带下标的大写英文字母 $P, Q, R, \cdots, P_1, Q_1, R_1, \cdots$ 来表示。</li>
</ol>
<p>函数可用于表达个体词之间的转换关系，可以更方便地表示谓词逻辑中的个体词。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267707683350.jpg" loading="lazy" width="1188" height="301" />
</picture>

</p>
<p>$n$ 元函数是个体域集合 $D^n$ 到 $D$ 的映射。</p>
<hr>
<h2 id="项的定义" data-numberify>项的定义<a class="anchor ms-1" href="#项的定义"></a></h2>
<p>谓词逻辑中的<strong>项</strong>（<strong>Term</strong>），被递归地定义为：</p>
<ul>
<li><u>任意的常量符号或任意的变量符号</u>是项。</li>
<li>若 $f(x_1, x_2, \cdots, x_n)$ 是 $n$ 元函数符号，$t_1, t_2, \cdots, t_n$ 是项，则 $f(t_1, t_2, \cdots, t_n)$ 是项。</li>
<li>仅由<u>有限次</u>使用以上两个规则产生的符号串才是项。</li>
</ul>
<hr>
<h2 id="合式公式的定义" data-numberify>合式公式的定义<a class="anchor ms-1" href="#合式公式的定义"></a></h2>
<p>若 $P(x_1, x_2, \cdots, x_n)$ 是 $n$ 元谓词， $t_1, t_2, \cdots, t_n$ 是项，则称 $P(t_1, t_2, \cdots, t_n)$ 为<strong>原子谓词公式</strong>，简称<strong>原子公式</strong>。</p>
<hr>
<p>满足下列条件的表达式，称为<strong>合式公式</strong>（<strong>well-formed formulae/wff</strong>），简称公式。</p>
<ol>
<li><u>原子公式</u>是合式公式。</li>
<li>若 $G$、$H$ 是合式公式，则 $(\neg G), (\neg H), (G \vee H), (G \wedge H), (G \rightarrow H), (G \leftrightarrow H)$ 也是合式公式。</li>
<li>若 $G$ 是合式公式，$x$ 是个体变量，则 $(\forall x)G$、$(\exists x)G$ 也是合式公式。</li>
<li>由<u>有限次</u>使用以上三个规则产生的表达式是合式公式。</li>
</ol>
<hr>
<ul>
<li>公式的最外层括号可省略。</li>
<li>量词后面的括号省略方式为：一个量词的辖域中仅出现一个原子公式，则此辖域的外层括号可省略，否则不能省略。</li>
<li>一个个体词只能接受一个量词的约束，否则就是没有意义的。</li>
</ul>
<hr>
<h2 id="自由变元与约束变元" data-numberify>自由变元与约束变元<a class="anchor ms-1" href="#自由变元与约束变元"></a></h2>
<p>给定一个合式公式 $G$，若变元 $x$ 出现<u>在使用变元的量词的辖域之内</u>，则称变元 $x$ 的出现为<strong>约束出现</strong>，此时的变元 $x$ 称为<strong>约束变元</strong>。若 $x$ 的出现<u>不是约束出现</u>，则称它为<strong>自由出现</strong>，此时的变元 $x$ 称为<strong>自由变元</strong>。</p>
<ul>
<li>若量词后有括号，则括号内的子公式就是该量词的辖域；</li>
<li>若量词后无括号，则与量词邻接的子公式为该量词的辖域。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267722145151.jpg" loading="lazy" width="1273" height="591" />
</picture>

</p>
<hr>
<p>为了区分同一公式中，变量符号相同但不是同为自由变元或约束变元的符号（这样的变量是不同的变量，仅是符号相同），可以分别使用不同的变量符号来表示。</p>
<ol>
<li>
<p>约束变元的命名规则：</p>
<ul>
<li>将量词中的变元以及该量词辖域中此变量的所有约束出现都用新的个体变元替换；</li>
<li>新的变元一定要有别于改名辖域中的其他变量。</li>
</ul>
</li>
<li>
<p>自由变元的命名规则：</p>
<ul>
<li>
<p>将公式中出现该自由变元的每一处都用新的个体变元替换；</p>
</li>
<li>
<p>新的变元不允许在源公式中以任何约束形式出现。</p>
<p>也可用个体常量代入。但是代入个体常量后，公式的含义就发生了变化，即公式从具有普遍意义变为仅针对该个体变量有意义。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="闭式" data-numberify>闭式<a class="anchor ms-1" href="#闭式"></a></h2>
<p>设 $G$ 是任意一个公式，若 $G$ 中无自由出现的个体变元，则称 $G$ 为封闭的合式公式，简称<strong>闭式</strong>。</p>
<p>闭式是一个命题。</p>
<hr>
<h2 id="谓词逻辑公式的解释" data-numberify>谓词逻辑公式的解释<a class="anchor ms-1" href="#谓词逻辑公式的解释"></a></h2>
<p>谓词逻辑中，公式 $G$ 的每一个解释 $I$ 由如下四部分组成：</p>
<ol>
<li><strong>非空的个体域</strong>集合 $D$。</li>
<li>$G$ 中的每个<strong>常量符号</strong>，指定 $D$ 中的某个特定元素。</li>
<li>$G$ 中的每个 $n$ 元<strong>函数符号</strong>，指定 $D^n$ 到 $D$ 中的某个特定的函数。</li>
<li>$G$ 中的每个 $n$ 元<strong>谓词符号</strong>，指定 $D^n$ 到 ${0,1}$ 中的某个特定的谓词。</li>
</ol>
<p>规定：公式中无自由变元，或将自由变元看成是常量符号。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16268605039802.jpg" loading="lazy" width="1141" height="592" />
</picture>

</p>
<hr>
<h2 id="谓词公式的分类" data-numberify>谓词公式的分类<a class="anchor ms-1" href="#谓词公式的分类"></a></h2>
<ol>
<li>
<p>如果公式 $G$ 在它<u>所有的解释下都取值为真</u>，则称 $G$ 为<strong>有效公式</strong>。</p>
<p>如 $(\forall x)(\forall y)(P(x, y) \wedge Q(x, y) \rightarrow P(x, y))$。</p>
</li>
<li>
<p>如果公式 $G$ 在它<u>所有的解释下都取值为假</u>，则称 $G$ 为<strong>矛盾公式</strong>。</p>
<p>如，$(\forall x)(\forall y)(\neg P(x, y) \wedge P(x, y))$。</p>
</li>
<li>
<p>如果<font color="green">至少有一种解释使得公式 $G$ 取值为真</font>，则称 $G$ 为<strong>可满足公式</strong>。</p>
</li>
</ol>
<hr>
<h2 id="谓词公式的可判定性" data-numberify>谓词公式的可判定性<a class="anchor ms-1" href="#谓词公式的可判定性"></a></h2>
<ul>
<li>
<p>一般情况下，谓词逻辑是不可判定的。</p>
</li>
<li>
<p>只含有一元谓词变项的公式是可判定的。</p>
</li>
<li>
<p>如下形式的公式：</p>
<p>$(\forall x_1) (\forall x_2) \cdots (\forall x_n) P(x_1, x_2, \cdots, x_n)$，</p>
<p>$(\exists x_1) (\exists x_2) \cdots (\exists x_n) P(x_1, x_2, \cdots, x_n)$。</p>
<p>若 $P$ 中无量词和其他自由变元时，是可判定的。</p>
</li>
<li>
<p>个体域有穷时的谓词公式是可判定的。</p>
</li>
</ul>
<hr>
<h2 id="谓词公式的等价关系" data-numberify>谓词公式的等价关系<a class="anchor ms-1" href="#谓词公式的等价关系"></a></h2>
<p>如果公式 $G \leftrightarrow H$ 是<strong>有效公式</strong>，则公式 $G$、$H$ 称为<strong>等价</strong>的，记为 $G=H$。</p>
<hr>
<p>设 $G(P_1, P_2, \cdots, P_n)$ 是命题演算<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>中的<a href="#命题公式">命题公式</a>，$P_1, P_2, \cdots, P_n$ 是出现在 $G$ 中的命题变元，当用任意的谓词公式 $G_i(1\le i \le n)$ 分别代入 $P_i$ 后，得到的新谓词公式 $G(G_1, G_2, \cdots, G_n)$​ 称为原公式的<strong>代入实例</strong>。</p>
<p>定理：永真公式的任意一个代入实例必为有效公式。</p>
<hr>
<p>##谓词演算中的基本等价公式</p>
<p><a href="#命题公式的基本等价关系">命题演算中的基本等价公式</a>在谓词演算中依然成立。</p>
<table>
<thead>
<tr>
<th style="text-align:center">性质</th>
<th style="text-align:left">等式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">改名规则</td>
<td style="text-align:left"><code>(\exists x)G(x) = (\exists y)G(y)</code><br/><code>(\forall x)G(x) = (\forall y)G(y)</code></td>
</tr>
<tr>
<td style="text-align:center">量词转换律<br/>or<br/>量词否定等价式</td>
<td style="text-align:left"><code>\neg (\exists x)G(x) = (\forall x)G(x)</code><br/><code>\neg (\forall x) \neg G(x) = (\exists x) \neg G(x)</code></td>
</tr>
</tbody>
</table>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>命题公式、范式和推理都是针对命题演算，它们的对象都是命题。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>经典字符串匹配</title>
      <link>/blog/2022/01/%E7%BB%8F%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Fri, 21 Jan 2022 00:15:00 +0000</pubDate>
      
      <guid>/blog/2022/01/%E7%BB%8F%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
      <description><![CDATA[经典字符串匹配 BF暴力匹配算法 暴力匹配，即Brute Force，简称BF算法。BF算法是一种简单朴素的模式匹配算法，常用于在一个主串S内查找]]></description>
      <content:encoded><![CDATA[<h1 id="经典字符串匹配" data-numberify>经典字符串匹配<a class="anchor ms-1" href="#经典字符串匹配"></a></h1>
<h1 id="bf暴力匹配算法" data-numberify>BF暴力匹配算法<a class="anchor ms-1" href="#bf暴力匹配算法"></a></h1>
<p>暴力匹配，即Brute Force，简称BF算法。BF算法是一种简单朴素的模式匹配算法，常用于在一个主串S内查找一个子串T的出现位置。</p>
<h2 id="算法步骤" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤"></a></h2>
<p>假设有主串S与子串P，主串S的长度为N，子串T的长度为M。</p>
<ol>
<li>将S和T左对齐，并比较其第一个元素。</li>
<li>若匹配，则继续比较下一个元素，一直到第M个元素。</li>
<li>若不匹配则T向右移动一个位置。</li>
<li>接着根据步骤3和4进行比较，直到匹配到或者T移动了N-M且仍未匹配到。</li>
</ol>
<h2 id="代码实现" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现"></a></h2>
<h3 id="python实现" data-numberify>Python实现<a class="anchor ms-1" href="#python实现"></a></h3>
<p>实现1：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">BFMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 匹配阶段</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配，s和p的指针均向前一步</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 不匹配，i后退到下一个要匹配的位置，j后头到p开头</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;abcdefghijkl&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s2">&#34;ijk&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">BFMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;False&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div><p>实现2：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">BFMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 最多移动len(s)-len(p)+1次</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果s的前len(s)-len(p)+1个与p均没有匹配</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 那么直接判断为不匹配，无需比较后len(p)-1个</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span>           <span class="c1"># 当前比较的字符</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 相等继续比较下一个</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 不相等停止比较</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 如果完全相等，返回当前位置</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">index</span> <span class="o">-</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;abcdefghijkl&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s2">&#34;ijk&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">BFMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;False&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现" data-numberify>C实现<a class="anchor ms-1" href="#c实现"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">BFMatch</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len_s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">p</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len_p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len_s</span> <span class="o">&lt;</span> <span class="n">len_p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 之匹配s的前len_s-len_p+1个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果s[len(s)-len(p)] != p[0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 那么就不用继续匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// i-j代表s与p对齐的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">len_s</span><span class="o">-</span><span class="n">len_p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">len_p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define S &#34;abcdefghijkl&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#define P &#34;ijk&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">p</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">P</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">BFMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;False</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="kmp快速匹配算法" data-numberify>KMP快速匹配算法<a class="anchor ms-1" href="#kmp快速匹配算法"></a></h1>
<p>快速模式匹配算法，即Knuth Morris Pratt（简称KMP）算法，是解决字符串匹配问题的经典算法。</p>
<p>KMP算法是在 BF 算法基础上改进得到的算法。BF算法的实现过程是用子串与主串中的字符一一配对，算法执行效率不高。对于主串S和子串P，BF算法如果遇到了不匹配的情况，主串S和子串P的指针都会回退，而且子串会回退到子串首部。KMP算法的实现过程接近人为进行模式匹配的过程。它只需回退子串，并且是根据情况回退，并不一定要回退到子串首部。</p>
<h2 id="算法步骤-1" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-1"></a></h2>
<p>假设有主串S与子串P，主串S的长度为N，子串T的长度为M。</p>
<ol>
<li>求字串P的部分匹配表。</li>
<li>将S和T左对齐，并比较其第一个元素。</li>
<li>若匹配，则继续比较下一个元素，一直到第M个元素。</li>
<li>若不匹配，根据部分匹配表回退P的指针。</li>
<li>接着根据步骤3和4进行比较，直到匹配到或者T移动了N-M且仍未匹配到。</li>
</ol>
<h3 id="失配指针求解" data-numberify>失配指针求解<a class="anchor ms-1" href="#失配指针求解"></a></h3>
<p>让KMP尽量减少回移的关键在于，用一个部分匹配表（也称失配移动表）记录每次需要回退的位置。部分匹配表是一个与原字符串长度相等的整数数组。表中的元素是字符串中相对于元素的前缀集合和后缀集合的交集中的长度最大的字符串的</p>
<p>假设一个长度为n的模式串为$P=a_0a_1&hellip;a_{n-1}$，其中$a_i(0\le i&lt;n)$是单个字符， $Next[\ n+1\ ]$为其部分匹配表。</p>
<p>那么对于$a_{i-1}$：</p>
<ul>
<li>
<p>前缀集合：</p>
<p>$$
P_1={a_0,a_0a_1,\cdots,a_0&hellip;a_{i-1}}
$$</p>
</li>
<li>
<p>后缀集合：</p>
<p>$$
P_2={a_{i-1},a_{i-2}a_{i-1},\cdots,a_1&hellip;a_{i-1}}
$$</p>
</li>
<li>
<p>失配指针：</p>
<p>$$
Next[i] =
\begin{cases}
-1 &amp; 当\ i=0 时 \
max &amp; { k|0&lt;k&lt;j 且 &ldquo;p_0\cdots p_{k-1}&rdquo; = &ldquo;p_{j-k}\cdots p_{j-1}&rdquo; } \
0 &amp; 其他情况
\end{cases}
$$</p>
<p>即：</p>
<ul>
<li>$Next[0] = -1$；</li>
<li>$Next[i] = maxLength(P_1 \cap P_2),\ i \neq 0$。</li>
</ul>
</li>
</ul>
<p>过程代码演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_next_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">next_val</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;第&#34;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;趟：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;^&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;初始化&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">next_val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_next</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;求部分匹配表（失配指针）&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># 指向主串的指针</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>   <span class="c1"># 指向模式串的指针，一开始</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_val</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="c1"># 要返回的next数组</span>
</span></span><span class="line"><span class="cl">    <span class="n">get_next_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">next_val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># next[0]==-1，只需要求后面的len(p)-1个值即可</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配成功，相同前缀长度增加1</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>    
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">next_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">            <span class="n">get_next_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">next_val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配不成功则在前面的子串中继续搜索，直至找不到</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">next_val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">next_val</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s2">&#34;abababc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">get_next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">第 1 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">初始化
</span></span><span class="line"><span class="cl">[-1, -1, -1, -1, -1, -1, -1]
</span></span><span class="line"><span class="cl">第 2 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl"> abababc
</span></span><span class="line"><span class="cl"> ^
</span></span><span class="line"><span class="cl">[-1, 0, -1, -1, -1, -1, -1]
</span></span><span class="line"><span class="cl">第 3 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">  abababc
</span></span><span class="line"><span class="cl">  ^
</span></span><span class="line"><span class="cl">[-1, 0, 0, -1, -1, -1, -1]
</span></span><span class="line"><span class="cl">第 4 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">  abababc
</span></span><span class="line"><span class="cl">   ^
</span></span><span class="line"><span class="cl">[-1, 0, 0, 1, -1, -1, -1]
</span></span><span class="line"><span class="cl">第 5 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">  abababc
</span></span><span class="line"><span class="cl">    ^
</span></span><span class="line"><span class="cl">[-1, 0, 0, 1, 2, -1, -1]
</span></span><span class="line"><span class="cl">第 6 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">  abababc
</span></span><span class="line"><span class="cl">     ^
</span></span><span class="line"><span class="cl">[-1, 0, 0, 1, 2, 3, -1]
</span></span><span class="line"><span class="cl">第 7 趟：
</span></span><span class="line"><span class="cl">abababc
</span></span><span class="line"><span class="cl">  abababc
</span></span><span class="line"><span class="cl">      ^
</span></span><span class="line"><span class="cl">[-1, 0, 0, 1, 2, 3, 4]
</span></span></code></pre></div><h2 id="代码实现-1" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-1"></a></h2>
<h3 id="python实现-1" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-1"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_next</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;求部分匹配表（失配指针）&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># 指向主串的指针</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>   <span class="c1"># 指向模式串的指针</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_val</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="c1"># 要返回的next数组</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># next[0]==-1，只需要求后面的len(p)-1个值即可</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配成功，相同前缀长度增加1</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>    
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">next_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配不成功则在前面的子串中继续搜索，直至找不到</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">next_val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">next_val</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">KMP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 求next数组</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="o">=</span> <span class="n">get_next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 匹配阶段</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;ababababca&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s2">&#34;abababc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">KMP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;False&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div><p>优化代码：去除<code>get_next()</code>，边匹配边计算部分匹配表</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">KMP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">p_i</span><span class="p">,</span> <span class="n">p_j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 边计算部分匹配表，边匹配</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 求部分匹配表</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">p_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">p_j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">p_j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="nb">next</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_j</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_j</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">p_j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 匹配阶段</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;ababababca&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="s2">&#34;abababc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">KMP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;False&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c语言" data-numberify>C语言<a class="anchor ms-1" href="#c语言"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">KMP</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len_s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">p</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len_p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len_s</span> <span class="o">&lt;</span> <span class="n">len_p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建和初始化部分匹配表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">len_p</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_p</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 边计算部分匹配表，边匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p_j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_s</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len_p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求部分匹配表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">p_i</span> <span class="o">&lt;</span> <span class="n">len_p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">p_j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">p</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">p_j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">next</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">p_j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">p_j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 匹配阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">len_p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define LEN(S) sizeof(S)-1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define S &#34;ababababca&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#define P &#34;abababc&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">p</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">P</span><span class="p">)]</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">KMP</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nf">LEN</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="nf">LEN</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;False</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>两数交换算法</title>
      <link>/blog/2022/01/%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/</guid>
      <description><![CDATA[临时变量 通过建立一个临时变量来实现两数交换： def swap(x, y): print(x, y) tmp = x x = y y = tmp print(x, y) return x, y if __name__ == &#39;__main__&#39;: swap(1, 2) 缺点： 需要消耗额外的内存。 优点： 不限制类型，大]]></description>
      <content:encoded><![CDATA[<h1 id="临时变量" data-numberify>临时变量<a class="anchor ms-1" href="#临时变量"></a></h1>
<p>通过建立一个临时变量来实现两数交换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div><p>缺点：</p>
<p>需要消耗额外的内存。</p>
<p>优点：</p>
<p>不限制类型，大多数类型都能使用该操作。</p>
<hr>
<h1 id="加减交换" data-numberify>加减交换<a class="anchor ms-1" href="#加减交换"></a></h1>
<p>通过加减法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div><p>假设两个数保存在x和y中：</p>
<ol>
<li>
<p>先将y中的值加到x中。</p>
<p>即这两个数一同保存在同一内存空间x中。</p>
</li>
<li>
<p>然后用x的值减去y的值，再将其保存到内存y中。</p>
<p>x-y即为x最初的值。</p>
</li>
<li>
<p>最后再用x的值减去y的值，赋给内存x。</p>
<p>x最初的值已经在y中，所以x-y的值为y最初的值。</p>
</li>
</ol>
<p>缺点：</p>
<p>该方法只适用于数值不大的数，如果数值过大，可能会越界（对于某些语言来说）。</p>
<hr>
<h1 id="异或交换" data-numberify>异或交换<a class="anchor ms-1" href="#异或交换"></a></h1>
<p>通过异或的操作实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div><p>缺点：</p>
<p>只能对整数类型执行位操作，不能对实数类型进行位操作。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python 基础</title>
      <link>/blog/2022/01/python-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/python-%E5%9F%BA%E7%A1%80/</guid>
      <description><![CDATA[Python 语法 注释 Python 的注释风格： # 行注释 &#39;&#39;&#39; 块注释1 &#39;&#39;&#39; &#34;&#34;&#34; 块注释2 &#34;&#34;&#34; 注释中的内容将不会被执行。 标识符 首字母必须是大写或小写的英文字母或者下划线 _。 其他部]]></description>
      <content:encoded><![CDATA[<h1 id="python-语法" data-numberify>Python 语法<a class="anchor ms-1" href="#python-语法"></a></h1>
<h2 id="注释" data-numberify>注释<a class="anchor ms-1" href="#注释"></a></h2>
<p>Python 的注释风格：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 行注释</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">块注释1
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">块注释2
</span></span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>注释中的内容将不会被执行。</p>
<hr>
<h2 id="标识符" data-numberify>标识符<a class="anchor ms-1" href="#标识符"></a></h2>
<ul>
<li>
<p>首字母必须是大写或小写的英文字母或者下划线 <code>_</code>。</p>
</li>
<li>
<p>其他部分由大写或小写的英文字母、数字和下划线组成。</p>
</li>
<li>
<p>大小写敏感（区分大小写）。</p>
</li>
</ul>
<p>Python3 中允许使用非 ASCII 标识符，即中文也可作为标识符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">变量</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">变量</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span></code></pre></div><hr>
<h2 id="关键字" data-numberify>关键字<a class="anchor ms-1" href="#关键字"></a></h2>
<p>Python <strong>关键字</strong>（<strong>keyword</strong>）不能作为标识符使用，关键字又称<strong>保留字</strong>。</p>
<p>使用 <code>keyword</code> 模块输出 Python 的所有关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">keyword</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;as&#39;</span><span class="p">,</span> <span class="s1">&#39;assert&#39;</span><span class="p">,</span> <span class="s1">&#39;break&#39;</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;continue&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">,</span> <span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="s1">&#39;elif&#39;</span><span class="p">,</span> <span class="s1">&#39;else&#39;</span><span class="p">,</span> <span class="s1">&#39;except&#39;</span><span class="p">,</span> <span class="s1">&#39;finally&#39;</span><span class="p">,</span> <span class="s1">&#39;for&#39;</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span> <span class="s1">&#39;if&#39;</span><span class="p">,</span> <span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="s1">&#39;nonlocal&#39;</span><span class="p">,</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;pass&#39;</span><span class="p">,</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;try&#39;</span><span class="p">,</span> <span class="s1">&#39;while&#39;</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="s1">&#39;yield&#39;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h2 id="变量的赋值" data-numberify>变量的赋值<a class="anchor ms-1" href="#变量的赋值"></a></h2>
<p>Python 中的变量并不需要声明，直接赋值后就可使用。还可以同时为多个变量赋值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">pai</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.72</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
</span></span></code></pre></div><hr>
<h2 id="代码规范" data-numberify>代码规范<a class="anchor ms-1" href="#代码规范"></a></h2>
<p>Python 代码中的所有块都是使用空格缩进来表示。同一块中的所有语句都必须包含相同的缩进空格数，一般使用 4 个空格作为缩进，并且最好在代码编辑器中设置将 Tab 转化为空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出数字 1~9 的平方数</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 块的开始</span>
</span></span><span class="line"><span class="cl">    <span class="n">square</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    <span class="n">total</span> <span class="o">+=</span> <span class="n">square</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># 块的结束</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出数字 1~9 的所有平方数的总和</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</span></span></code></pre></div><p>缩进相同的一组语句构成一个代码块，或称之为代码组。</p>
<hr>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行是程序代码的一部分，但并不是 Python 语法的一部分。空行的作用在于分割两段不同功能或含义的代码，便于日后代码的维护或重构，有无空行并不影响程序运行。</p>
<hr>
<p>反斜杠 <code>\</code> 作为续行符，表示下一行是上一行的延续。对于过长的语句，Python 使用反斜杠、换行再加上缩进来将长语句分为多行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">total</span> <span class="o">=</span> <span class="n">item_one</span> <span class="o">+</span> \
</span></span><span class="line"><span class="cl">        <span class="n">item_two</span> <span class="o">+</span> \
</span></span><span class="line"><span class="cl">        <span class="n">item_three</span>
</span></span></code></pre></div><p>在 <code>[]</code>,<code>{}</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\</code> 来换行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">total</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;item_one&#39;</span><span class="p">,</span> <span class="s1">&#39;item_two&#39;</span><span class="p">,</span> <span class="s1">&#39;item_three&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;item_four&#39;</span><span class="p">,</span> <span class="s1">&#39;item_five&#39;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<p>Python 可以在同一行中使用多条语句，语句之间使用分号 <code>;</code> 分割。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span><span class="p">;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">123</span>
</span></span></code></pre></div><hr>
<h1 id="标准数据类型" data-numberify>标准数据类型<a class="anchor ms-1" href="#标准数据类型"></a></h1>
<p>Python 支持 6 种基本数据类型：</p>
<ul>
<li>
<p><strong>Number</strong> —— 数字类型</p>
</li>
<li>
<p><strong>String</strong> —— 字符串类型</p>
</li>
<li>
<p><strong>List</strong> —— 列表</p>
</li>
<li>
<p><strong>Tuple</strong> —— 元组</p>
</li>
<li>
<p><strong>Set</strong> —— 集合</p>
</li>
<li>
<p><strong>Dictionary</strong> —— 字典</p>
</li>
</ul>
<p>List、Dictionary、Set 是 Python 内置的数据结构。</p>
<p>Python 变量分为可变和不可变数据类型，以下是它们的定义：</p>
<ul>
<li>
<p><strong>不可变（immutable）数据类型</strong>：当该数据类型对应的变量的值发生了改变，它对应的内存地址也会发生改变（重新分配内存空间），如 Number、String、Tuple。即，数据中的元素不能被更改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 测试 Number 类型是否是不可变数据类型</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>      <span class="c1"># 赋值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>      <span class="c1"># 改变值</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 可能输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1562536992 &lt;class &#39;int&#39;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1562537024 &lt;class &#39;int&#39;&gt;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>可变（mutable）数据类型</strong>：当该数据类型对应的变量的值发生了改变，它对应的内存地址不发生改变，如 List、Dictionary、Set。即，数据中的元素可以被更改。</p>
</li>
</ul>
<p>可迭代对象：List、Tuple、Set 、 Dictionary 和 String。</p>
<hr>
<h2 id="number类型" data-numberify>Number类型<a class="anchor ms-1" href="#number类型"></a></h2>
<p>Python 支持的数字类型：</p>
<ul>
<li>
<p><strong>int</strong> —— 整数类型。</p>
</li>
<li>
<p><strong>float</strong> —— 浮点数类型（实数类型），如 <code>3.14</code>、<code>3E-2</code>。</p>
</li>
<li>
<p><strong>bool</strong> —— 布尔类型（<code>True</code> 和 <code>False</code>）。</p>
</li>
<li>
<p><strong>complex</strong> —— 复数类型，如 <code>1.1 + 2.2j</code>、<code>complex(a, b)</code>。</p>
</li>
</ul>
<p>Python 2 中有 long 型，Python 3 中没有。</p>
<hr>
<h3 id="数字函数" data-numberify>数字函数<a class="anchor ms-1" href="#数字函数"></a></h3>
<p>数字函数需要导入 math 模块：<code>import math</code></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abs(x)</code></td>
<td>返回数字 <code>x</code>（可以是复数）的绝对值（内置函数，不用导入 math 模块）。</td>
</tr>
<tr>
<td><code>ceil(x)</code></td>
<td>返回数字 <code>x</code> 的上入整数（向上取整）。</td>
</tr>
<tr>
<td><code>cmp(x, y)</code></td>
<td>如果 <code>x &lt; y</code> 返回 <code>-1</code>，如果 <code>x == y</code> 返回 <code>0</code>，如果 <code>x &gt; y</code> 返回 <code>1</code>。
Python 3 已废弃，使用 <code>(x&gt;y)-(x&lt;y)</code> 替换。</td>
</tr>
<tr>
<td><code>exp(x)</code></td>
<td>返回 <code>e</code> 的 <code>x</code> 次幂 $e^x$。</td>
</tr>
<tr>
<td><code>fabs(x)</code></td>
<td>返回数字 <code>x</code>（不能是复数）的绝对值。</td>
</tr>
<tr>
<td><code>floor(x)</code></td>
<td>返回数字的下舍整数（向下取整）。</td>
</tr>
<tr>
<td><code>log(x[, y])</code></td>
<td><code>log(x)</code> —— 返回 <code>x</code> 的自然对数；
<code>log(x, y)</code> —— 返回以 <code>y</code> 为基数的 <code>x</code> 的对数：$\log_y{x}$。</td>
</tr>
<tr>
<td><code>log10(x)</code></td>
<td>返回以 10为基数的 <code>x</code> 的对数。</td>
</tr>
<tr>
<td><code>max(x1, x2,...)</code></td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td><code>min(x1, x2,...)</code></td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td><code>modf(x)</code></td>
<td>返回 <code>x</code> 的整数部分与小数部分，两部分的数值符号与 <code>x</code> 相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td><code>pow(x, y[, z])</code></td>
<td><code>pow(x, y)</code> —— <code>x**y</code> 运算后的值；
<code>pow(x, y, z)</code> —— 相当于 <code>pow(x, y) % z</code>。
通过内置方法调用，会把参数作为整型，而 math 会把参数转换为 float。</td>
</tr>
<tr>
<td><code>round(x [, n])</code></td>
<td>返回浮点数 <code>x</code> 的四舍五入值，如给出 <code>n</code> 值，则代表舍入到小数点后的位数。
<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td>
</tr>
<tr>
<td><code>sqrt(x)</code></td>
<td>返回数字 <code>x</code> 的平方根。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="string类型" data-numberify>String类型<a class="anchor ms-1" href="#string类型"></a></h2>
<p>Python 的字符串（String）有以下特点：</p>
<ul>
<li>
<p>字符串常量可以使用单引号 <code>'</code> 和双引号 <code>&quot;</code> 指定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str1</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str2</span> <span class="o">=</span> <span class="s1">&#39;World&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="s1">&#39;!&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="n">World</span> <span class="err">!</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str1</span> <span class="o">=</span> <span class="s1">&#39;打印 &#34;双引号&#34; &#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str1</span> <span class="o">+=</span> <span class="s2">&#34;要用 &#39;单引号&#39; 将其括起来&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">打印</span> <span class="s2">&#34;双引号&#34;</span> <span class="n">要用</span> <span class="s1">&#39;单引号&#39;</span> <span class="n">将其括起来</span>
</span></span></code></pre></div></li>
<li>
<p>使用三个引号可指定一个多行字符串常量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str1</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;这是一个段落，
</span></span></span><span class="line"><span class="cl"><span class="s2">... 可以由多行组成&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">这是一个段落</span><span class="err">，</span>
</span></span><span class="line"><span class="cl"><span class="n">可以由多行组成</span>
</span></span></code></pre></div></li>
<li>
<p>转义符用 <code>\</code>  开头。单个反斜杠依然可以作为续行符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;str</span><span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span><span class="s1">... ing&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span>
</span></span></code></pre></div></li>
<li>
<p>使用 <code>r</code> 或 <code>R</code> 可以让反斜杠不发生转义。这样的字符串被称为原始字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;this is a line with \n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">this</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">line</span> <span class="k">with</span> \<span class="n">n</span>
</span></span></code></pre></div></li>
<li>
<p>按字面意义级联字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;this &#39;</span> <span class="s1">&#39;is &#39;</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">this</span> <span class="ow">is</span> <span class="n">string</span>
</span></span></code></pre></div></li>
<li>
<p>字符串可以用 <code>+</code> 运算符连接在一起，用 <code>*</code> 运算符重复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;this &#39;</span> <span class="o">+</span> <span class="s1">&#39;is &#39;</span> <span class="o">+</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">this</span> <span class="ow">is</span> <span class="n">string</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Hello World!&#39;</span> <span class="o">*</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
</span></span></code></pre></div></li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>字符串的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。字符串被截取后返回一个包含所需字符的新字符串。遵循<strong>左闭右开</strong>原则。</p>
<p><strong>尾下标</strong>从 <code>1</code> 开始。</p>
<p><strong>步长</strong>是指输出字符串中第 $n$ 个字符后，接着输出第 $(n + 步长)$ 个字符，直至到达尾下标指定处。</p>
<p>省略步长代表按字符串顺序输出，省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;123456789&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    <span class="c1"># 输出字符串第一个字符</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>    <span class="c1"># 输出从第三个开始到第五个的字符</span>
</span></span><span class="line"><span class="cl"><span class="mi">345</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># 输出第一个到倒数第二个的所有字符</span>
</span></span><span class="line"><span class="cl"><span class="mi">12345678</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>    <span class="c1"># 输出从第三个开始后的所有字符</span>
</span></span><span class="line"><span class="cl"><span class="mi">3456789</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>    <span class="c1"># 输出从第一个开始到第三个的字符</span>
</span></span><span class="line"><span class="cl"><span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span>
</span></span><span class="line"><span class="cl"><span class="mi">24</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">[:])</span>    <span class="c1"># 同时省略头下标和尾，创建了一个str的副本</span>
</span></span></code></pre></div></li>
<li>
<p>字符串不能改变。即，字符串的切片不能被赋值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">TypeError</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span> <span class="nb">object</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">support</span> <span class="n">item</span> <span class="n">assignment</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;String&#39;</span>  <span class="c1"># 修改字符串只能重新进行赋值</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span>
</span></span></code></pre></div></li>
<li>
<p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p>
</li>
</ul>
<p>在Python2中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 unicode 字符串。使用的语法是在字符串前面加上前缀 <code>u</code>。</p>
<p>在Python3中，所有的字符串都是 Unicode 字符串。</p>
<hr>
<h3 id="转义符" data-numberify>转义符<a class="anchor ms-1" href="#转义符"></a></h3>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code>（在代码行尾时）</td>
<td>续行符。</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠符号。</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>单引号。</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号。</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>响铃
<code>print(&quot;\a&quot;)</code>执行后电脑有响声。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格（Backspace）。</td>
</tr>
<tr>
<td><code>\000</code></td>
<td>空。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>纵向制表符。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>横向制表符。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车，将 <code>\r</code> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <code>\r</code> 后面的内容完全替换完成。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页。</td>
</tr>
<tr>
<td><code>\yyy</code></td>
<td>八进制数，<code>y</code> 代表 0~7 的字符，如 <code>\012</code> 代表换行。</td>
</tr>
<tr>
<td><code>\xyy</code></td>
<td>十六进制数，以 <code>\x</code> 开头，<code>y</code> 代表的字符，例 <code>\x0a</code> 代表换行。</td>
</tr>
<tr>
<td><code>\other</code></td>
<td>其它的字符以普通格式输出。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="格式化字符串" data-numberify>格式化字符串<a class="anchor ms-1" href="#格式化字符串"></a></h3>
<p><code>print()</code> 函数能够使用 <code>%</code> 来进行格式化字符串的输出。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mf">3.14</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.140000e+00</span>
</span></span></code></pre></div><p>字符串格式化符号：</p>
<table>
<thead>
<tr>
<th><strong>符  号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%c</code></td>
<td>格式化字符及其 ASCII 码。</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>格式化字符串。</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>格式化整数。</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>格式化无符号整型。</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>格式化无符号八进制数。</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>格式化无符号十六进制数。</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>格式化无符号十六进制数（大写）。</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>格式化浮点数字，可指定小数点后的精度。</td>
</tr>
<tr>
<td><code>%e</code> 或 <code>%E</code></td>
<td>用科学计数法格式化浮点数。
<code>%e</code> 中显示的字母为小写，<code>%E</code> 则为大写。</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>%f和%e的简写。</td>
</tr>
<tr>
<td><code>%G</code></td>
<td>%f 和 %E 的简写。</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>用十六进制数格式化变量的地址。</td>
</tr>
</tbody>
</table>
<p>格式化操作符辅助符号：</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>定义宽度或者小数点精度。</td>
</tr>
<tr>
<td><code>-</code></td>
<td>用做左对齐。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>在正数前面显示加号。</td>
</tr>
<tr>
<td><code>&lt;sp&gt;</code></td>
<td>在正数前面显示空格。</td>
</tr>
<tr>
<td><code>#</code></td>
<td>在八进制数前面显示零 <code>'0'</code>，在十六进制前面显示 <code>'0x'</code> 或者 <code>'0X'</code>（取决于用的是 <code>'x'</code> 还是 <code>'X'</code>）。</td>
</tr>
<tr>
<td><code>0</code></td>
<td>显示的数字前面填充 <code>'0'</code> 而不是默认的空格。</td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>'%%'</code> 输出一个单一的 <code>'%'</code>。</td>
</tr>
<tr>
<td><code>(var)</code></td>
<td>映射变量(字典参数)。</td>
</tr>
<tr>
<td><code>m.n.</code></td>
<td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)。</td>
</tr>
</tbody>
</table>
<p>辅助符号在格式字符串 <code>%</code> 和符号中间使用，如需指定其它参数需要在字符串后的 <code>%</code> 使用括号 <code>()</code> 指定参数和要显示的值。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%*d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">         <span class="mi">2</span>
</span></span></code></pre></div><hr>
<h3 id="f-string" data-numberify>f-string<a class="anchor ms-1" href="#f-string"></a></h3>
<p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。f-string格式化字符串以 <code>f</code> 开头，后面跟着字符串，字符串中的表达式用大括号 <code>{}</code> 包起来，它会将变量或表达式计算后的值替换进去。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="sa">f</span><span class="s1">&#39;Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>  <span class="c1"># 替换变量</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Hello World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="si">}</span><span class="s1">&#39;</span>         <span class="c1"># 使用表达式</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;3&#39;</span>
</span></span></code></pre></div><hr>
<h3 id="strformat" data-numberify>str.format()<a class="anchor ms-1" href="#strformat"></a></h3>
<p><code>str.format()</code> 是用于格式化字符串的字符串方法。旧式的格式化最终会从该语言中移除，应该更多的使用 <code>str.format()</code>。</p>
<p><code>format()</code> 将 <code>str</code> 中的格式化字段（<code>{}</code> 及其里面包含的字符）替换为 <code>format()</code> 中的参数。它的用法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>      <span class="c1"># 按照参数顺序</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{1}</span><span class="s1"> and </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>    <span class="c1"># 指定参数位置（从 0 开始）</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="ow">and</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> and </span><span class="si">{b}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>  <span class="c1"># 指定关键字</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span>
</span></span></code></pre></div><p><code>!a</code>（使用 <code>ascii()</code>)，<code>!s</code>（使用 <code>str()</code>）和 <code>!r</code>（使用 <code>repr()</code>）可以用于在格式化某个值之前对其进行转化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">math</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;常量 PI 的值近似为： </span><span class="si">{}</span><span class="s1">。&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">常量</span> <span class="n">PI</span> <span class="n">的值近似为</span><span class="err">：</span> <span class="mf">3.141592653589793</span><span class="err">。</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;常量 PI 的值近似为： </span><span class="si">{!r}</span><span class="s1">。&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">常量</span> <span class="n">PI</span> <span class="n">的值近似为</span><span class="err">：</span> <span class="mf">3.141592653589793</span><span class="err">。</span>
</span></span></code></pre></div><p>可以使用 <code>:</code>，在右边指定输出形式，在 <code>:</code> 左边的是 <code>format()</code> 参数位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">math</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;常量 PI 的值近似为 </span><span class="si">{0:.3f}</span><span class="s1">。&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">常量</span> <span class="n">PI</span> <span class="n">的值近似为</span> <span class="mf">3.142</span><span class="err">。</span>
</span></span></code></pre></div><p>在 <code>:</code> 后传入一个整数, 可以保证该域至少有这么多的宽度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:10}</span><span class="s1"> ==&gt; </span><span class="si">{1:10d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span>          <span class="o">==&gt;</span>          <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span>          <span class="o">==&gt;</span>          <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span>          <span class="o">==&gt;</span>          <span class="mi">3</span>
</span></span></code></pre></div><p>传入一个字典，然后使用方括号 <code>[]</code> 来访问键值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b: </span><span class="si">{0[b]:d}</span><span class="s1">; a: </span><span class="si">{0[a]:d}</span><span class="s1">; c: </span><span class="si">{0[c]:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">;</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span><span class="p">:</span> <span class="mi">3</span>
</span></span></code></pre></div><p>也可以通过在变量前使用 <code>**</code> 来实现相同的功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b: </span><span class="si">{b:d}</span><span class="s1">; a: </span><span class="si">{a:d}</span><span class="s1">; c: </span><span class="si">{c:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">table</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">;</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span><span class="p">:</span> <span class="mi">3</span>
</span></span></code></pre></div><hr>
<h3 id="字符串方法" data-numberify>字符串方法<a class="anchor ms-1" href="#字符串方法"></a></h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str.capitalize()</code></td>
<td>将字符串的第一个字符转换为大写。</td>
</tr>
<tr>
<td><code>str.center(width[, fillchar])</code></td>
<td>返回一个指定的宽度 <code>width</code> 居中的字符串。
<code>fillchar</code> 为填充的字符，默认为空格。</td>
</tr>
<tr>
<td><code>str.count(sub[, start= 0, end=len(string)])</code></td>
<td>返回 <code>sub</code> 在 <code>str</code> 的指定范围里面出现的次数。
<code>sub</code> —— 搜索的子字符串。
<code>start</code> —— 字符串开始搜索的位置。默认为第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 字符串中结束搜索的位置。默认为字符串的最后一个位置。</td>
</tr>
<tr>
<td><code>str.encode(encoding='UTF-8',errors='strict')</code></td>
<td>以 <code>encoding</code> 指定的编码格式编码字符串，如果出错默认报一个<code>ValueError</code> 的异常，除非 <code>errors</code> 指定的是 <code>'ignore'</code> 或者 <code>'replace'</code>。</td>
</tr>
<tr>
<td><code>bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code></td>
<td>以指定的编码格式解码 <code>bytes</code> 对象。
<code>encoding</code> —— 要使用的编码，默认为 <code>&quot;utf-8&quot;</code>。
<code>errors</code> —— 设置不同错误的处理方案。默认为 <code>&quot;strict&quot;</code>，意为编码错误引起一个 <code>UnicodeError</code>。 其他可能的值有 <code>&quot;ignore&quot;</code>，<code>&quot;replace&quot;</code>，<code>&quot;xmlcharrefreplace&quot;</code>，<code>&quot;backslashreplace&quot;</code> 以及通过 <code>codecs.register_error()</code> 注册的任何值。
Python3 中没有 <code>decode()</code> 方法，但可以使用 <code>bytes</code> 对象的 <code>decode()</code> 方法来解码给定的 <code>bytes</code> 对象，这个 <code>bytes</code> 对象可以由 <code>str.encode()</code> 来编码返回<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#i1UVu5eTHv7TvT3SWHoFXr" title="↩" target="_blank" rel="noopener noreferrer">↩<i class="fas fa-external-link-square-alt ms-1"></i></a>。</td>
</tr>
<tr>
<td><code>str.endswith(suffix[, start=0, end=len(string)])</code></td>
<td>检查字符串指定范围是否以 <code>suffix</code> 结束，如果是，返回 <code>True</code>，否则返回 <code>False</code>。
<code>suffix</code> —— 可以是一个字符串或者是一个元素。
<code>start</code> —— 指定的开始位置。默认为字符串第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 指定的结束位置。默认为字符串的最后一个字符。</td>
</tr>
<tr>
<td><code>str.expandtabs(tabsize=8)</code></td>
<td>把字符串 <code>str</code> 中的 Tab 符号 <code>\t</code> 转为空格。
<code>tabsize</code> —— Tab 符号的长度，默认为 8。</td>
</tr>
<tr>
<td><code>str.find(sub[, beg=0, end=len(str)])</code></td>
<td>检测 <code>sub</code> 是否包含在字符串 <code>str</code> 的指定范围中，如果包含则返回开始的索引值，否则返回 <code>-1</code>。
<code>sub</code> —— 字符串。
<code>beg</code> —— 指定的开始位置。默认为字符串第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 指定的结束位置。默认为字符串的最后一个字符。</td>
</tr>
<tr>
<td><code>str.index(sub[, beg=0, end=len(string)])</code></td>
<td>同 <code>find()</code>方法一样，只不过如果 <code>sub</code> 不在字符串中会报一个异常。</td>
</tr>
<tr>
<td><code>str.isalnum()</code></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isalpha()</code></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 <code>True</code>, 否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isdigit()</code></td>
<td>如果字符串只包含数字则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.islower()</code></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isnumeric()</code></td>
<td>如果字符串中只包含数字字符，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isspace()</code></td>
<td>如果字符串中只包含空白，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.istitle()</code></td>
<td>如果字符串是标题化的（见 <code>title()</code>），则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isupper()</code></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.join(sequence)</code></td>
<td>字符串 <code>str</code> 作为分隔符，将 <code>sequence</code> 中所有的元素（的字符串表示）合并为一个新的字符串。</td>
</tr>
<tr>
<td><code>len(string)</code></td>
<td>返回字符串长度。</td>
</tr>
<tr>
<td><code>str.ljust(width[, fillchar])</code></td>
<td>返回一个原字符串左对齐，并使用 <code>fillchar</code> 填充至长度 <code>width</code> 的新字符串，<code>fillchar</code> 默认为空格。如果指定的长度小于原字符串的长度则返回原字符串。</td>
</tr>
<tr>
<td><code>str.lower()</code></td>
<td>转换字符串中所有大写字符为小写。</td>
</tr>
<tr>
<td><code>str.lstrip([chars])</code></td>
<td>截掉字符串左边的空格或指定字符。
<code>chars</code> —— 指定截取的字符。</td>
</tr>
<tr>
<td><code>str.maketrans(intab, outtab)</code></td>
<td>创建字符映射的转换表。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#mqWsc4jJBXazkgF45wd4Ym" title="↩" target="_blank" rel="noopener noreferrer">↩<i class="fas fa-external-link-square-alt ms-1"></i></a><code>intab</code> —— 字符串，表示需要转换的字符。
<code>outtab</code> —— 字符串表示转换的目标。</td>
</tr>
<tr>
<td><code>max(str)</code></td>
<td>返回字符串 <code>str</code> 中最大的字母。</td>
</tr>
<tr>
<td><code>min(str)</code></td>
<td>返回字符串 <code>str</code> 中最小的字母。</td>
</tr>
<tr>
<td><code>str.replace(old, new[, max])</code></td>
<td>将字符串中的 <code>old</code> 替换成 <code>new</code>，如果 <code>max</code> 指定，则替换不超过 <code>max</code> 次。</td>
</tr>
<tr>
<td><code>str.rfind(sub[, beg=0,end=len(string)])</code></td>
<td>类似于 <code>find()</code> 函数，不过是从右边开始查找。即，返回字符串最后一次出现的位置，如果没有匹配项则返回 <code>-1</code>。</td>
</tr>
<tr>
<td><code>str.rindex(sub[, beg=0, end=len(string)])</code></td>
<td>类似于 <code>index()</code>，不过是从右边开始。即，返回子字符串 <code>sub</code> 在字符串中最后出现的位置，如果没有匹配的字符串会报异常。</td>
</tr>
<tr>
<td><code>str.rjust(width[, fillchar])</code></td>
<td>返回一个原字符串右对齐，并使用 <code>fillchar</code>（默认空格）填充至长度 <code>width</code> 的新字符串。</td>
</tr>
<tr>
<td><code>str.rstrip([chars])</code></td>
<td>删除字符串末尾的指定字符 <code>chars</code>，默认为空格。</td>
</tr>
<tr>
<td><code>str.split([str1=&quot;&quot;, num=string.count(str1)])</code></td>
<td>以参数 <code>str1</code> 为分隔符截取字符串，如果 <code>num</code> 有指定值，则仅截取 <code>num+1</code> 个子字符串<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#aV1m8VHmVaQtoTLyZoCoTi" title="↩" target="_blank" rel="noopener noreferrer">↩<i class="fas fa-external-link-square-alt ms-1"></i></a>。</td>
</tr>
<tr>
<td><code>str.splitlines([keepends])</code></td>
<td>按照行（<code>'\r'</code>，<code>'\r\n'</code>，<code>\n'</code>）分隔，返回一个包含各行作为元素的列表。如果参数 <code>keepends</code> 为 <code>False</code>，返回的列表则不包含换行符；如果为 <code>True</code>，则保留换行符。</td>
</tr>
<tr>
<td><code>str.startswith(substr[, beg=0, end=len(string)])</code></td>
<td>检查字符串是否是以指定子字符串 <code>substr</code> 开头，是则返回 <code>True</code>，否则返回 <code>False</code>。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td><code>str.strip([chars])</code></td>
<td>在字符串上执行 <code>lstrip()</code> 和 <code>rstrip()</code>。即移除字符串头尾指定的字符 <code>chars</code>（默认为空格）。</td>
</tr>
<tr>
<td><code>str.swapcase()</code></td>
<td>将字符串中大写转换为小写，小写转换为大写。</td>
</tr>
<tr>
<td><code>str.title()</code></td>
<td>返回 “标题化” 的字符串，即转化为所有单词都是以大写开始，其余字母均为小写的形式。</td>
</tr>
<tr>
<td><code>str.translate(table[, deletechars=&quot;&quot;])</code></td>
<td>根据 <code>str</code> 给出的表（包含 256 个字符）转换 <code>str</code> 的字符，要过滤掉的字符放到 <code>deletechars</code> 参数中。</td>
</tr>
<tr>
<td><code>str.upper()</code></td>
<td>转换字符串中的小写字母为大写。</td>
</tr>
<tr>
<td><code>str.zfill (width)</code></td>
<td>返回长度为 <code>width</code> 的字符串，原字符串右对齐，前面填充 <code>0</code>。</td>
</tr>
<tr>
<td><code>str.isdecimal()</code></td>
<td>检查字符串是否只包含十进制字符（只存在于 <code>unicode</code> 对象。），如果是返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<p><code>encode()</code> 和 <code>decode()</code> 用法实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str_utf8</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&#34;UTF-8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str_gbk</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&#34;GBK&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;UTF-8 编码：&#34;</span><span class="p">,</span> <span class="n">str_utf8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">编码</span><span class="err">：</span> <span class="sa">b</span><span class="s1">&#39;Hello World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;GBK 编码：&#34;</span><span class="p">,</span> <span class="n">str_gbk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">GBK</span> <span class="n">编码</span><span class="err">：</span> <span class="sa">b</span><span class="s1">&#39;Hello World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;UTF-8 解码：&#34;</span><span class="p">,</span> <span class="n">str_utf8</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span><span class="s1">&#39;strict&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">解码</span><span class="err">：</span> <span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;GBK 解码：&#34;</span><span class="p">,</span> <span class="n">str_gbk</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;GBK&#39;</span><span class="p">,</span><span class="s1">&#39;strict&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">GBK</span> <span class="n">解码</span><span class="err">：</span> <span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
</span></span></code></pre></div><p><code>maketrans()</code> 的用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">intab</span> <span class="o">=</span> <span class="s2">&#34;aeiou&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">outtab</span> <span class="o">=</span> <span class="s2">&#34;12345&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">trantab</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="n">intab</span><span class="p">,</span> <span class="n">outtab</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&#34;this is string example....wow!!!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">trantab</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">th3s</span> <span class="mi">3</span><span class="n">s</span> <span class="n">str3ng</span> <span class="mi">2</span><span class="n">x1mpl2</span><span class="o">....</span><span class="n">w4w</span><span class="err">!!!</span>
</span></span></code></pre></div><p><code>split()</code> 的用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&#34;this is string example....wow!!!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="p">))</span>       <span class="c1"># 以空格为分隔符</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;this&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;example....wow!!!&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>   <span class="c1"># 以 i 为分隔符</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;th&#39;</span><span class="p">,</span> <span class="s1">&#39;s is string example....wow!!!&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">))</span>     <span class="c1"># 以 w 为分隔符</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;this is string example....&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;!!!&#39;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h3 id="byte样式字符串" data-numberify>byte样式字符串<a class="anchor ms-1" href="#byte样式字符串"></a></h3>
<p>在字符串前面加上字符 <code>b</code>，可以得到该字符串的字节类型对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="sa">b</span><span class="s1">&#39;Hello World!&#39;</span>
</span></span></code></pre></div><p>使用 16 进制 ASCII 码赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x48\x65\x6C\x6C\x20\x57\x6F\x72\x6C\x64\x21</span><span class="s1">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="sa">b</span><span class="s1">&#39;Hell World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x01\x02\x03</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03</span><span class="s1">&#39;</span>
</span></span></code></pre></div><p>Python 会自动将可读的部分按照转换为文字。如果数据是不可读的，则使用 16 进制来表示。</p>
<p>byte 对象的元素是字节：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">bt</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;Hello World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">bt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="mi">108</span>
</span></span></code></pre></div><p>可以使用 <code>bin()</code> 查看每个字节在内存中的存储方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">bin</span><span class="p">(</span><span class="n">bt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;0b1101100&#39;</span>
</span></span></code></pre></div><p>除字面量表示之外，还可以用 <code>bytes()</code> 函数来得到字节类型。</p>
<hr>
<h2 id="list" data-numberify>List<a class="anchor ms-1" href="#list"></a></h2>
<p>列表（List）由一系列按特定顺序排列的元素组成，它是写在方括号 <code>[]</code> 之间、用逗号分隔开的元素列表。列表其实更像是 Python 中的线性数据结构的实现，它具有绝大多数常见的线性数据结构的操作。</p>
<ul>
<li>
<p>列表中元素的类型可以不相同，它支持数字，字符串，甚至可以包含列表（嵌套）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}]</span>
</span></span></code></pre></div></li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>列表的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。遵循<strong>左闭右开</strong>原则。</p>
<p><strong>尾下标</strong>从 <code>1</code> 开始。</p>
<p><strong>步长</strong>是指输出字符串中第 $n$ 个元素后，接着输出第 $(n + 步长)$ 个元素，直至到达尾下标指定处。</p>
<p>省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        <span class="c1"># 输出列表第一个元素</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>      <span class="c1"># 从第二个开始输出到第三个元素</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>      <span class="c1"># 输出从第三个元素开始的所有元素</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">[:])</span>        <span class="c1"># 同时省略头下标和尾，创建了一个list的副本</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tinylist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="p">(</span><span class="nb">list</span> <span class="o">+</span> <span class="n">tinylist</span><span class="p">)</span>    <span class="c1"># 连接列表</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">double</span> <span class="o">=</span> <span class="n">tinylist</span> <span class="o">*</span> <span class="mi">2</span>    <span class="c1"># 重复列表</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">double</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>      <span class="c1"># 步长为-1，表示逆向</span>
</span></span><span class="line"><span class="cl"><span class="p">[{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mf">3.4</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">):]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span>    <span class="c1"># 在列表末尾插入元素</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="mi">6</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>列表中的元素是可更改的，并且列表长度也是可改变的。List 内置了许多方法来支持这种特性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>列表可以用 <code>+</code> 运算符拼接，用 <code>*</code> 运算符重复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">+</span> <span class="n">list2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">*</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></div></li>
</ul>
<p>虽然列表和字符串有一些特性很相似，但它们是两个完全不同的类型。</p>
<p>删除列表或列表元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="nb">list</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h3 id="列表方法" data-numberify>列表方法<a class="anchor ms-1" href="#列表方法"></a></h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>list.append(obj)</code></td>
<td>在列表末尾添加新的对象 <code>obj</code>，无返回值。相当于 <code>list[len(list):] = [x]</code></td>
</tr>
<tr>
<td><code>list.count(obj)</code></td>
<td>返回 <code>obj</code> 在列表中出现的次数。</td>
</tr>
<tr>
<td><code>list.extend(seq)</code></td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。
<code>seq</code> —— 元素列表，可以是列表、元组、集合、字典，若为字典，则仅会将键（key）作为元素依次添加至原列表的末尾。</td>
</tr>
<tr>
<td><code>list.index(x[, start[, end]])</code></td>
<td>从列表中找出某个值第一个匹配项的索引位置。如果没有找到对象则抛出异常。
<code>x</code>—— 查找的对象；
<code>start</code> —— 可选，查找的起始位置；
<code>end</code> —— 可选，查找的结束位置。</td>
</tr>
<tr>
<td><code>list.insert(index, obj)</code></td>
<td>将对象插入列表，无返回值。
<code>index</code> —— 对象 <code>obj</code> 需要插入的索引位置；
<code>obj</code> —— 要插入列表中的对象。</td>
</tr>
<tr>
<td><code>list.pop([index=-1])</code></td>
<td>移除列表中 <code>index</code> 指定的元素（默认最后一个元素），并且返回该元素的值。</td>
</tr>
<tr>
<td><code>list.remove(obj)</code></td>
<td>移除列表中值与 <code>obj</code> 相同的第一个匹配项，无返回值。</td>
</tr>
<tr>
<td><code>list.reverse()</code></td>
<td>反向列表中元素。</td>
</tr>
<tr>
<td><code>list.sort(key=None, reverse=False)</code></td>
<td>对原列表进行排序。
<code>key</code> —— 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序；↩
<code>reverse</code> —— 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</td>
</tr>
<tr>
<td><code>list.clear()</code></td>
<td>清空列表，类似于 <code>del list[:]</code>。</td>
</tr>
<tr>
<td><code>list.copy()</code></td>
<td>返回复制后的新列表，类似于 <code>list[:]</code>。</td>
</tr>
</tbody>
</table>
<p><code>list.sort()</code> 指定排序元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 获取列表的第二个元素</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">takeSecond</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 列表</span>
</span></span><span class="line"><span class="cl"><span class="n">random</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 指定第二个元素排序</span>
</span></span><span class="line"><span class="cl"><span class="n">random</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">takeSecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 输出类别</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;排序列表：&#39;</span><span class="p">,</span> <span class="n">random</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)]</span>
</span></span></code></pre></div><p>Python 列表的特性可以很方便地将其封装成其他线性数据结构。</p>
<hr>
<h3 id="列表推导式" data-numberify>列表推导式<a class="anchor ms-1" href="#列表推导式"></a></h3>
<p>列表推导式是指在方括号 <code>[]</code> 中使用 <code>for</code> 语句生成一串序列，这个 <code>for</code> 语句可以有零到多个 <code>for</code> 或 <code>if</code> 子句。返回结果是一个根据表达从其后的 <code>for</code> 和 <code>if</code> 上下文环境中生成出来的列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mi">355</span><span class="o">/</span><span class="mi">113</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;3.1&#39;</span><span class="p">,</span> <span class="s1">&#39;3.14&#39;</span><span class="p">,</span> <span class="s1">&#39;3.142&#39;</span><span class="p">,</span> <span class="s1">&#39;3.1416&#39;</span><span class="p">,</span> <span class="s1">&#39;3.14159&#39;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h2 id="tuple" data-numberify>Tuple<a class="anchor ms-1" href="#tuple"></a></h2>
<p>元组（tuple）与列表类似，不同之处在于元组的元素可修改。元组写在小括号 <code>()</code> 里，元素之间用逗号隔开。</p>
<ul>
<li>
<p>元素的类型可以不相同。</p>
</li>
<li>
<p>元组中只包含一个元素时，需要在元素后面添加逗号 <code>,</code> ，否则括号会被当作运算符使用。</p>
</li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>列表的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。遵循<strong>左闭右开</strong>原则。</p>
</li>
<li>
<p>元组元素不可修改是指元组中每个元素的指向永远不变。
无法对元组的元素进行增删操作，但并非所有类型的元素都不可修改。</p>
<ul>
<li>
<p>对于不可变数据类型的元素，的确不能修改。</p>
</li>
<li>
<p>对于可变数据类型的元素，可以按照其规则修改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>可以用 <code>+</code> 运算符拼接，用 <code>*</code> 运算符重复。</p>
</li>
</ul>
<p>元组的某些操作可以参照列表，除了增加和删除元素的操作。</p>
<hr>
<p>元组支持推导式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="set" data-numberify>Set<a class="anchor ms-1" href="#set"></a></h2>
<p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。集合的基本功能是进行成员关系测试和删除重复元素。可以使用大括号 <code>{}</code> 或者构造函数 <code>set()</code> 创建集合。</p>
<ul>
<li>
<p>集合是一个无序不重复元素的集。</p>
</li>
<li>
<p>元素的类型可以不相同。</p>
</li>
<li>
<p>元素是可更改的。</p>
</li>
<li>
<p>创建空集：</p>
<p>使用不带参数的构造函数 <code>set()</code> 创建，不可使用 <code>{}</code> 创建（<code>{}</code> 代表空字典）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">set</span><span class="p">()</span>
</span></span></code></pre></div></li>
<li>
<p>不包含多余的重复元素。在集合中，不会多次出现的相同元素。</p>
</li>
<li>
<p>不可使用索引或截取等操作。</p>
</li>
<li>
<p>可以使用集合运算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">set1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">set2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span><span class="p">)</span>      <span class="c1"># set1 和 set2 的差集</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">|</span> <span class="n">set2</span><span class="p">)</span>      <span class="c1"># set1 和 set2 的并集</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">&amp;</span> <span class="n">set2</span><span class="p">)</span>      <span class="c1"># set1 和 set2 的交集</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">set1</span> <span class="o">^</span> <span class="n">set2</span><span class="p">)</span>      <span class="c1"># set1 和 set2 的对称差集</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<hr>
<p>集合支持推导式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">25</span><span class="p">}</span>
</span></span></code></pre></div><hr>
<p>集合的成员测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">avengers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;captain america&#39;</span><span class="p">,</span> <span class="s1">&#39;iron man&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;thor&#39;</span><span class="p">,</span> <span class="s1">&#39;doctor strange&#39;</span><span class="p">,</span> <span class="s1">&#39;star-Lord&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="s1">&#39;hulk&#39;</span><span class="p">,</span> <span class="s1">&#39;black widow&#39;</span><span class="p">,</span> <span class="s1">&#39;black panther&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="s1">&#39;spider man&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="s1">&#39;spider man&#39;</span> <span class="ow">in</span> <span class="n">avengers</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;蜘蛛侠是复仇者&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;蜘蛛侠不是复仇者&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="s1">&#39;thanos&#39;</span> <span class="ow">in</span> <span class="n">avengers</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;灭霸是复仇者&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;灭霸不是复仇者&#39;</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h3 id="集合方法" data-numberify>集合方法<a class="anchor ms-1" href="#集合方法"></a></h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set.add()</code></td>
<td>为集合添加元素。</td>
</tr>
<tr>
<td><code>set.clear()</code></td>
<td>移除集合中的所有元素。</td>
</tr>
<tr>
<td><code>set.copy()</code></td>
<td>拷贝一个集合。</td>
</tr>
<tr>
<td><code>set.difference(set1, set2, ...)</code></td>
<td>返回集合 $(set - set1)\cap(set - set2)\cap\cdots$。</td>
</tr>
<tr>
<td><code>set.difference_update(set1, set2, ...)</code></td>
<td>移除集合 <code>set</code> 中的元素，该元素在指定的集合 <code>set1, set2, ...</code> 也存在。
即，将集合 <code>set</code> 更新为集合 $(set - set1)\cap(set - set2)\cap\cdots$。</td>
</tr>
<tr>
<td><code>set.discard(value)</code></td>
<td>删除集合 <code>set</code> 中指定的元素 <code>value</code>。
与 <code>remove()</code> 不同的是，如果 <code>value</code> 不存在 <code>set</code> 中，并不会发生错误。</td>
</tr>
<tr>
<td><code>set.intersection(set1, set2, ...)</code></td>
<td>返回集合 $set \cap set1 \cap set2 \cap \cdots$。</td>
</tr>
<tr>
<td><code>set.intersection_update(set1, set2, ...)</code></td>
<td>将集合 <code>set</code> 更新为集合 $set \cap set1 \cap set2 \cap \cdots$。</td>
</tr>
<tr>
<td><code>set1.isdisjoint(set2)</code></td>
<td>判断集合 <code>set1</code> 和 <code>set2</code> 是否包含相同的元素，如果没有返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set1.issubset(set2)</code></td>
<td>判断集合 <code>set1</code> 是否是集合 <code>set2</code> 的子集。如果是，则返回 <code>True</code>；否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set1.issuperset(set2)</code></td>
<td>判断集合 <code>set1</code> 是否是集合 <code>set2</code> 的父集。如果是，则返回 <code>True</code>；否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set.pop()</code></td>
<td>随机移除元素，并返回该元素。</td>
</tr>
<tr>
<td><code>set.remove(item)</code></td>
<td>移除指定元素 <code>item</code>。如果 <code>item</code> 不存在 <code>set</code> 中，会发生错误。</td>
</tr>
<tr>
<td><code>set1.symmetric_difference(set2)</code></td>
<td>返回集合  <code>set1</code> 和 <code>set2</code> 的对称差集 $set1 \oplus set2$。</td>
</tr>
<tr>
<td><code>set1.symmetric_difference_update(set2)</code></td>
<td>将集合 <code>set1</code> 更新为 $set1 \oplus set2$。</td>
</tr>
<tr>
<td><code>set.union(set1, set2...)</code></td>
<td>返回集合 $set \cup set1 \cup set2 \cup \cdots$。</td>
</tr>
<tr>
<td><code>set.update(added_set)</code></td>
<td>添加新的元素或集合到当前集合中。
<code>added_set</code> —— 可以是元素或集合。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="dictionary" data-numberify>Dictionary<a class="anchor ms-1" href="#dictionary"></a></h2>
<p>字典是一种映射类型，用 <code>{}</code> 标识，是一个无序的 <code>key:value</code> （键 - 值对）的集合。字典当中的元素是通过键来存取的，而不是通过偏移存取。字典还可以使用构造函数 <code>dict()</code> 创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 一般方法：</span>
</span></span><span class="line"><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;name&#39;</span><span class="p">:</span>   <span class="s1">&#39;tom&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;age&#39;</span><span class="p">:</span>    <span class="mi">20</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="mi">185</span><span class="p">,</span>    <span class="c1"># cm</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">71</span>      <span class="c1"># kg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：{&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 20, &#39;height&#39;: 185, &#39;weight&#39;: 71}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 构造函数：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1.</span>
</span></span><span class="line"><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span> <span class="o">=</span>   <span class="s1">&#39;lucy&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">age</span> <span class="o">=</span>    <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="o">=</span> <span class="mi">169</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">weight</span> <span class="o">=</span> <span class="mi">56</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：{&#39;name&#39;: &#39;lucy&#39;, &#39;age&#39;: 18, &#39;height&#39;: 169, &#39;weight&#39;: 56}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2.</span>
</span></span><span class="line"><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;jiessie&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="mi">178</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="mi">63</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：{&#39;name&#39;: &#39;jiessie&#39;, &#39;age&#39;: 25, &#39;height&#39;: 178, &#39;weight&#39;: 63}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 for 循环：</span>
</span></span><span class="line"><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：{2: 4, 4: 16, 6: 36}</span>
</span></span></code></pre></div><p>更多构造字典的方法↩。</p>
<ul>
<li>
<p>键（key）必须使用不可变类型，且是唯一的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span><span class="mi">6</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mi">6</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">dic</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span>
</span></span></code></pre></div></li>
<li>
<p>值（value）可以是任何类型的元素。</p>
</li>
<li>
<p>使用键作为索引。</p>
</li>
<li>
<p>使用 <code>in</code> 操作符判断键是否存在字典中，如 <code>key in dict</code> ，如果键在字典dict里返回 <code>True</code>，否则返回 <code>False</code>。<code>not in</code> 操作符与 <code>in</code> 相反。</p>
</li>
</ul>
<hr>
<h3 id="字典方法" data-numberify>字典方法<a class="anchor ms-1" href="#字典方法"></a></h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>radiansdict.clear()</code></td>
<td>删除字典内所有元素，无返回值。</td>
</tr>
<tr>
<td><code>radiansdict.copy()</code></td>
<td>返回一个字典的浅复制。</td>
</tr>
<tr>
<td><code>radiansdict.fromkeys(seq[, value])</code></td>
<td>创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值（可选）。</td>
</tr>
<tr>
<td><code>radiansdict.get(key, default=None)</code></td>
<td>返回指定键 <code>key</code> 的值，如果键不在字典中返回 <code>default</code> 设置的默认值。</td>
</tr>
<tr>
<td><code>radiansdict.items()</code></td>
<td>以列表返回一个视图对象，视图对象中的元素以键-值对 <code>(key, value)</code> 的形式显示。
视图对象不是列表，不支持索引，其中的元素是键-值对。字典的视图对象都是只读的，但字典改变，视图也会跟着变化。</td>
</tr>
<tr>
<td><code>radiansdict.keys()</code></td>
<td>返回一个只包含键的视图对象。</td>
</tr>
<tr>
<td><code>radiansdict.setdefault(key, default=None)</code></td>
<td>和 <code>get()</code> 类似，如果 <code>key</code> 存在于 <code>radiandict</code> 中，就返回其值；但如果 <code>key</code> 不存在于字典中，将会添加键并将值设为 <code>default</code>。</td>
</tr>
<tr>
<td><code>radiansdict.update(dict2)</code></td>
<td>把字典 <code>dict2</code> 的键-值对更新到 <code>dict</code> 里，无返回值。</td>
</tr>
<tr>
<td><code>radiansdict.values()</code></td>
<td>返回一个只包含值的视图对象。</td>
</tr>
<tr>
<td><code>radiansdict.pop(key[, default])</code></td>
<td>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。否则，返回 <code>default</code> 值。如果 <code>key</code> 不存在字典中，返回 <code>default</code> 值（<code>default</code> 值必须给出，否则会报错。</td>
</tr>
<tr>
<td><code>radiansdict.popitem()</code></td>
<td>随机返回并删除字典中的最后一对键和值 <code>(key, value)</code>。
如果字典已经为空，却调用了此方法，就报出 KeyError 异常。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="函数操作" data-numberify>函数操作<a class="anchor ms-1" href="#函数操作"></a></h2>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>len(obj)</code></td>
<td>返回对象的元素个数</td>
</tr>
<tr>
<td><code>max(x1[, x2[, x3[, ...]]])</code></td>
<td>返回参数中最大值，参数还可以是集合、列表或元组。</td>
</tr>
<tr>
<td><code>min(x1[, x2[, x3[, ...]]])</code></td>
<td>返回参数中最小值，参数还可以是集合、列表或元组。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="数据类型转换" data-numberify>数据类型转换<a class="anchor ms-1" href="#数据类型转换"></a></h2>
<p>将数据类型作为函数名即可进行数据类型的转换。以下内置的数据类型转换函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int(x, base = 10)</code></td>
<td>将 <code>x</code> 转换为一个整数。
<code>x</code> —— 字符串或数字；
<code>base</code> —— 基数（进制数），默认 10。</td>
</tr>
<tr>
<td><code>float(x = 0.0)</code></td>
<td>将 <code>x</code> 转换为一个浮点数。
<code>x</code> —— 字符串或数字，默认为 <code>0.0</code>。</td>
</tr>
<tr>
<td><code>complex(real[, imag])</code></td>
<td>创建一个值为 <code>real + imag * j </code> 的复数。
<code>real</code> —— 为字符串时不需要指定第二个参数，还可以为 int 或 float；
<code>imag</code> —— int、float。</td>
</tr>
<tr>
<td><code>str(object = '')</code></td>
<td>将对象 <code>object</code> 转换为字符串，默认为空字符串。</td>
</tr>
<tr>
<td><code>repr(object)</code></td>
<td>将对象 <code>object</code> 转换为表达式字符串。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#7imkekufL7cP1iNPsFJUPW" title="↩" target="_blank" rel="noopener noreferrer">↩<i class="fas fa-external-link-square-alt ms-1"></i></a></td>
</tr>
<tr>
<td><code>eval(expression[, globals[, locals]])</code></td>
<td>用来执行字符串中的有效表达式，并返回表达式的值。
<code>expression</code> —— 表达式字符串；
<code>globals</code> —— 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象；
<code>locals</code> —— 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</td>
</tr>
<tr>
<td><code>tuple(iterable)</code></td>
<td>将序列 <code>iterable</code> 转换为一个元组。
<code>iterable</code> —— 可迭代对象，如列表、字典、元组等等。</td>
</tr>
<tr>
<td><code>list(seq)</code></td>
<td>将序列 <code>seq</code> 转换为一个列表。
<code>seq</code> —— 元组或字符串。</td>
</tr>
<tr>
<td><code>set([iterable])</code></td>
<td>将 <code>iterable</code> 转换为可变集合，默认创建空集。
<code>iterable</code> —— 可迭代对象。</td>
</tr>
<tr>
<td><code>dict(**kwarg)</code>、
<code>class dict(mapping, **kwarg) </code>、
<code>class dict(iterable, **kwarg)</code></td>
<td>创建一个字典，默认创建空集。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#fMV3hFyFYXDnjis1W11TRq" title="↩" target="_blank" rel="noopener noreferrer">↩<i class="fas fa-external-link-square-alt ms-1"></i></a><code>**kwargs</code> —— 关键字，如 <code>key=value</code>；
<code>mapping</code> —— 元素的容器；
<code>iterable</code> —— 可迭代对象。</td>
</tr>
<tr>
<td><code>frozenset([iterable])</code></td>
<td>将 <code>iterable</code> 转换为不可变集合，默认创建空集。
<code>iterable</code> —— 可迭代的对象。</td>
</tr>
<tr>
<td><code>chr(i)</code></td>
<td>将一个整数 <code>i</code>（<code>in rang(256)</code>）转换为一个字符。
返回值是当前整数对应的 ASCII 字符。</td>
</tr>
<tr>
<td><code>ord(c)</code></td>
<td>将一个字符 <code>c</code> 转换为它的整数值（ASCII 数值，或者 Unicode 数值）。
<code>c</code> —— 字符（长度为 1 的字符串）。
如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。</td>
</tr>
<tr>
<td><code>hex(x)</code></td>
<td>将整数 <code>x</code> 转换为一个十六进制字符串（以 <code>0x</code> 为前缀）。</td>
</tr>
<tr>
<td><code>oct(x)</code></td>
<td>将整数 <code>x</code> 转换为一个八进制字符串。
Python2.x 版本的 8 进制以 <code>0</code> 作为前缀表示；
Python3.x 版本的 8 进制以 <code>0o</code> 作为前缀表示。</td>
</tr>
</tbody>
</table>
<p><code>repr</code> 的用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">dic</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;[1, 2, 3]&#39;</span>
</span></span></code></pre></div><p><code>dict()</code> 的用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">dict</span><span class="p">()</span>                         <span class="c1"># 创建空字典</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>     <span class="c1"># 传入关键字</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;t&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>   <span class="c1"># 映射函数方式来构造字典</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>    <span class="c1"># 可迭代对象方式来构造字典</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span></code></pre></div><hr>
<h2 id="其他操作" data-numberify>其他操作<a class="anchor ms-1" href="#其他操作"></a></h2>
<p>使用 Python 的 <code>type()</code> 函数查看变量的类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">int</span><span class="s1">&#39;&gt; &lt;class &#39;</span><span class="nb">float</span><span class="s1">&#39;&gt; &lt;class &#39;</span><span class="nb">bool</span><span class="s1">&#39;&gt; &lt;class &#39;</span><span class="nb">complex</span><span class="s1">&#39;&gt;</span>
</span></span></code></pre></div><p>使用 <code>isinstance</code> 判断数据类型是否正确：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">111</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span></code></pre></div><p><code>isinstance()</code> 和 <code>type()</code> 的区别在于：</p>
<ul>
<li>
<p><code>type()</code> 不会认为子类是一种父类类型。</p>
</li>
<li>
<p><code>isinstance()</code> 会认为子类是一种父类类型。即，子类和父类被认为是同一类型。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">pass</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span> 
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="c1"># B 是 A 的子类</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">pass</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span> 
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">(),</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">())</span> <span class="o">==</span> <span class="n">A</span> 
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">(),</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">())</span> <span class="o">==</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span></code></pre></div><hr>
<p>Python3 中，bool 是 int 的子类，<code>True</code> 和 <code>False</code> 可以和数字相加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kc">True</span> <span class="o">==</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kc">False</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span></code></pre></div><p>可以通过 <code>is</code> 来判断：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kc">True</span> <span class="ow">is</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span></code></pre></div><hr>
<p>使用 <code>del</code> 删除对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">del</span> <span class="n">var</span>        <span class="c1"># 删除一个对象</span>
</span></span><span class="line"><span class="cl"><span class="k">del</span> <span class="n">var_1</span><span class="p">,</span> <span class="n">var_2</span>  <span class="c1"># 删除多个对象</span>
</span></span></code></pre></div><hr>
<p><code>print</code> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str1</span> <span class="o">=</span> <span class="s1">&#39;Hello &#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">str2</span> <span class="o">=</span> <span class="s1">&#39;World!&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span>
</span></span><span class="line"><span class="cl"><span class="n">World</span><span class="err">!</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
</span></span></code></pre></div><hr>
<h1 id="运算符" data-numberify>运算符<a class="anchor ms-1" href="#运算符"></a></h1>
<h2 id="算术运算符" data-numberify>算术运算符<a class="anchor ms-1" href="#算术运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>加
操作对象为字符串、列表或元组时，表示将两个对象拼接在一起。</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘
<code>a * b</code>，若 <code>a</code> 为字符串、列表或元组，<code>b</code> 为整数时，表示将 <code>b</code> 个 <code>a</code> 拼接在一起。</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂，如 <code>a**b</code> 返回 <code>a</code> 的 <code>b</code> 次方</td>
</tr>
<tr>
<td><code>//</code></td>
<td>整除，向下取整</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="比较关系运算符" data-numberify>比较（关系）运算符<a class="anchor ms-1" href="#比较关系运算符"></a></h2>
<p>所有比较运算符返回 <code>1</code>（或 <code>True</code>）表示真，返回 <code>0</code>（或 <code>False</code>）表示假。</p>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>相等</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于
Python 3 已不支持 <code>&lt;&gt;</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于 - 返回x是否大于等于y。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于 - 返回x是否小于等于y。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="赋值运算符" data-numberify>赋值运算符<a class="anchor ms-1" href="#赋值运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加法赋值运算符</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减法赋值运算符</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘法赋值运算符</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除法赋值运算符</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模赋值运算符</td>
</tr>
<tr>
<td><code>**=</code></td>
<td>幂赋值运算符</td>
</tr>
<tr>
<td><code>//=</code></td>
<td>取整除赋值运算符</td>
</tr>
<tr>
<td><code>:=</code></td>
<td>海象运算符，可在表达式内部为变量赋值，然后直接进行判断。<strong>Python3.8 版本新增运算符</strong>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="位运算符" data-numberify>位运算符<a class="anchor ms-1" href="#位运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>按位与运算符：
参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0。</td>
</tr>
<tr>
<td><code>|</code></td>
<td>按位或运算符：
只要对应的两个二进位有一个为 1 时，结果位就为 1。</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或运算符：
当两对应的二进位相异时，结果为 1。</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反运算符：
对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1。<code>~x</code> 类似于 <code>x-1</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移动运算符：
运算数的各二进位全部左移若干位，由 <code>&lt;&lt;</code> 右边的数指定移动的位数，高位丢弃，低位补 0。</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移动运算符：
把 <code>&gt;&gt;</code> 左边的运算数的各二进位全部右移若干位，<code>&gt;&gt;</code> 右边的数指定移动的位数。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="逻辑运算符" data-numberify>逻辑运算符<a class="anchor ms-1" href="#逻辑运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Expressions</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>and</code></td>
<td><code>x and y</code></td>
<td>布尔 “与”
如果 <code>x</code> 为 <code>False</code>，<code>x and y</code> 返回 <code>x</code> 的值，否则返回 <code>y</code> 的计算值。</td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>x or y</code></td>
<td>布尔 “或”
如果 <code>x</code> 是 <code>True</code>，它返回 <code>x</code> 的值，否则它返回 <code>y</code> 的计算值。</td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>not x</code></td>
<td>布尔 “非”
如果 <code>x</code> 为 <code>True</code>，返回 <code>False</code>；如果 <code>x</code> 为 <code>False</code>，它返回 <code>True</code>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="成员运算符" data-numberify>成员运算符<a class="anchor ms-1" href="#成员运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in</code></td>
<td>如果在指定的序列中找到值返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>not in</code></td>
<td>如果在指定的序列中没有找到值返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="身份运算符" data-numberify>身份运算符<a class="anchor ms-1" href="#身份运算符"></a></h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is</code></td>
<td>判断两个标识符是不是引用自一个对象。
<code>x is y</code>，类似 <code>id(x) == id(y)</code>。
如果引用的是同一个对象则返回 <code>True</code>，否则返回 <code>False</code></td>
</tr>
<tr>
<td><code>is not</code></td>
<td>判断两个标识符是不是引用自不同对象。
<code>x is not y</code>，类似 <code>id(a) != id(b)</code>。
如果引用的不是同一个对象则返回结果 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<p><code>is</code> 和 <code>==</code> 的区别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> 
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span></code></pre></div><hr>
<h2 id="运算符优先级" data-numberify>运算符优先级<a class="anchor ms-1" href="#运算符优先级"></a></h2>
<p>优先级按从高到底排列：</p>
<table>
<thead>
<tr>
<th>Operators</th>
<th>Explains</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位翻转，一元加号和减号（最后两个的方法名为 +@ 和 -@）</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，求余数和取整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加法减法</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> <code>|</code></td>
<td>按位异或，按位与</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>比较运算符</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于运算符</td>
</tr>
<tr>
<td><code>=</code> <code>%=</code> <code>/=</code> <code>//=</code> <code>-=</code> <code>+=</code> <code>*=</code> <code>**=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>and</code> <code>or</code></td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="if条件控制" data-numberify>if条件控制<a class="anchor ms-1" href="#if条件控制"></a></h1>
<p><code>if</code> 语句的形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">condition_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_block_1</span>
</span></span><span class="line"><span class="cl"><span class="k">elif</span> <span class="n">condition_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_block_2</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_block_3</span>
</span></span></code></pre></div><p><code>if</code> 语句的条件通常由关系运算符或返回值为布尔值的语句组成，使用逻辑运算符在一条 <code>if</code> 语句中连接多个条件。</p>
<hr>
<h2 id="条件运算符" data-numberify>条件运算符<a class="anchor ms-1" href="#条件运算符"></a></h2>
<p>Python 提供了条件运算符（三目运算符）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">statement_1</span> <span class="k">if</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">statement</span>
</span></span></code></pre></div><ul>
<li>
<p>如果 <code>condition</code> 为 <code>True</code>，执行 <code>statement_1</code> 并且返回 <code>staement_1</code> 的结果。</p>
</li>
<li>
<p>如果 <code>condition</code> 为 <code>False</code>，执行 <code>statement_2</code> 并且返回 <code>statement_2</code> 的结果。</p>
</li>
</ul>
<hr>
<h1 id="循环语句" data-numberify>循环语句<a class="anchor ms-1" href="#循环语句"></a></h1>
<p>Python 有 <code>while</code> 和 <code>for</code> 两种循环语句。</p>
<hr>
<h2 id="while条件循环" data-numberify>while条件循环<a class="anchor ms-1" href="#while条件循环"></a></h2>
<p><code>while</code> 循环的一般用法是，当指定条件成立时执行一次 <code>while</code> 后的代码块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">while</span> <span class="n">condition</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block</span>
</span></span></code></pre></div><p><code>while</code> 语句后可接 <code>else</code> 语句。当指定条件不成立时，执行一次 <code>while</code> 后面的 <code>else</code> 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">while</span> <span class="n">condition</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block_1</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block_2</span>
</span></span></code></pre></div><hr>
<h2 id="for循环遍历" data-numberify>for循环遍历<a class="anchor ms-1" href="#for循环遍历"></a></h2>
<p><code>for</code> 循环的一般用法是，遍历任何可迭代对象。每次循环，都会从指定的可迭代对象中选取一个赋给指定的变量。如此循环下去，直到遍历完指定的可迭代对象中所有元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">variables</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block</span>
</span></span></code></pre></div><p><code>for</code> 语句后可接 <code>else</code> 语句。当指定的可迭代对象为空时，执行一次 <code>for</code> 后面的 <code>else</code> 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block_1</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block_2</span>
</span></span></code></pre></div><hr>
<p><code>for</code> 循环经常与 <code>range()</code> 函数一起使用。当需要遍历数字序列时，可以使用 <code>range()</code> 函数生成数列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 输出数字 5~12</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>    <span class="c1"># 输出一个换行符</span>
</span></span></code></pre></div><hr>
<h3 id="遍历技巧" data-numberify>遍历技巧<a class="anchor ms-1" href="#遍历技巧"></a></h3>
<p>在字典中遍历时，关键字和对应的值可以使用 <code>items()</code> 方法同时解读出来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39; = &#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">one</span>  <span class="o">=</span>  <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">two</span>  <span class="o">=</span>  <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">three</span>  <span class="o">=</span>  <span class="mi">3</span>
</span></span></code></pre></div><p>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;: &#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="p">:</span>  <span class="n">one</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="p">:</span>  <span class="n">two</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="p">:</span>  <span class="n">three</span>
</span></span></code></pre></div><p>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">questions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;quest&#39;</span><span class="p">,</span> <span class="s1">&#39;favorite color&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">answers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;lancelot&#39;</span><span class="p">,</span> <span class="s1">&#39;the holy grail&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">questions</span><span class="p">,</span> <span class="n">answers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;What is your </span><span class="si">{0}</span><span class="s1">?  It is </span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">What</span> <span class="ow">is</span> <span class="n">your</span> <span class="n">name</span><span class="err">?</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">lancelot</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">What</span> <span class="ow">is</span> <span class="n">your</span> <span class="n">quest</span><span class="err">?</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">holy</span> <span class="n">grail</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">What</span> <span class="ow">is</span> <span class="n">your</span> <span class="n">favorite</span> <span class="n">color</span><span class="err">?</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">blue</span><span class="o">.</span>
</span></span></code></pre></div><p>反向遍历序列，可以调用 <code>reversed()</code> 函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">9876543210</span>
</span></span></code></pre></div><p>要按顺序遍历一个序列，使用 <code>sorted()</code> 函数返回一个已排序的序列，并不修改原值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">basket</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;pear&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;banana&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">basket</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">apple</span>
</span></span><span class="line"><span class="cl"><span class="n">banana</span>
</span></span><span class="line"><span class="cl"><span class="n">orange</span>
</span></span><span class="line"><span class="cl"><span class="n">pear</span>
</span></span></code></pre></div><hr>
<h3 id="列表推导式-1" data-numberify>列表推导式<a class="anchor ms-1" href="#列表推导式-1"></a></h3>
<p>列表推导式（又称列表解析式）的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="n">if_or_for_statement</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># if_or_for_statement是一个if判断语句或for循环</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果是if语句，那么只有条件位真时val才会在列表中</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</span></span></code></pre></div><p>列表推导式中的<code>for</code>语句和<code>if</code>语句是可嵌套的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span>
</span></span></code></pre></div><p>上面语句的执行顺序是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span><span class="o">*</span><span class="n">y</span>
</span></span></code></pre></div><p>列表推导式除了<code>list</code>还可以被转化成其它对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x0000026F7A655BA0</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="break-and-continue" data-numberify>break and continue<a class="anchor ms-1" href="#break-and-continue"></a></h2>
<ul>
<li>
<p><code>break</code> 语句 —— 跳出（终止）循环。不执行当前循环块中 <code>break</code> 语句以下的语句，并且将控制转移到当前循环语句的下一条语句。</p>
</li>
<li>
<p><code>continue</code> 语句 —— 进入下一轮循环。不执行当前循环块中 <code>continue</code> 语句以下的语句，并且将控制转义到循环语句的开头。</p>
</li>
</ul>
<p><code>break</code> 和 <code>continue</code> 在循环语句中使用。一般在循环中的 <code>if</code> 条件语句中使用。即，达到某个条件便结束或进入下一次循环。</p>
<hr>
<h2 id="pass语句" data-numberify>pass语句<a class="anchor ms-1" href="#pass语句"></a></h2>
<p><code>pass</code> 语句是空语句，即不执行任何操作。<code>pass</code> 是为了保持 Python 程序结构的完整性。</p>
<p><code>pass</code> 一般作为占位语句，当操作都在条件语句或循环语句中完成时，在语句块中使用 <code>pass</code> 占位。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">condition_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">condition_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span></code></pre></div><hr>
<h1 id="迭代器与生成器" data-numberify>迭代器与生成器<a class="anchor ms-1" href="#迭代器与生成器"></a></h1>
<h2 id="迭代器" data-numberify>迭代器<a class="anchor ms-1" href="#迭代器"></a></h2>
<p>迭代是一种访问集合元素的方式。迭代器是一个可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p>
<p>字符串、列表或元组对象都可用于创建迭代器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>     <span class="c1"># 创建迭代器对象</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>    <span class="c1"># 输出迭代器的下一个元素</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span></code></pre></div><p>迭代器对象可以使用常规 <code>for</code> 语句进行遍历：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>    <span class="c1"># 创建迭代器对象</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span></code></pre></div><p>使用 <code>next()</code> 迭代：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>         <span class="c1"># 引入 sys 模块</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>    <span class="c1"># 创建迭代器对象</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</span></span></code></pre></div><hr>
<h3 id="创建迭代器" data-numberify>创建迭代器<a class="anchor ms-1" href="#创建迭代器"></a></h3>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。</p>
<ul>
<li>
<p><code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code>方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</p>
</li>
<li>
<p><code>__next__()</code> 方法（Python 2 里是 <code>next()</code>）会返回下一个迭代器对象。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyNumbers</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="bp">self</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">myclass</span> <span class="o">=</span> <span class="n">MyNumbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">myiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">myclass</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">myiter</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：1 2 3 4 5 6 7 8 9 10</span>
</span></span></code></pre></div><hr>
<h3 id="迭代结束标志" data-numberify>迭代结束标志<a class="anchor ms-1" href="#迭代结束标志"></a></h3>
<p><code>StopIteration</code> 异常用于标识迭代的完成，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 迭代 10 次后停止</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyNumbers</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="bp">self</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
</span></span><span class="line"><span class="cl">      <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">raise</span> <span class="ne">StopIteration</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">myclass</span> <span class="o">=</span> <span class="n">MyNumbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">myiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">myclass</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">myiter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：1 2 3 4 5 6 7 8 9 10</span>
</span></span></code></pre></div><hr>
<h2 id="生成器" data-numberify>生成器<a class="anchor ms-1" href="#生成器"></a></h2>
<p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作。</p>
<p>在调用生成器运行的过程中，每次遇到 <code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># 生成器函数 - 斐波那契</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># f 是一个迭代器，由生成器返回生成</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34; &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：1 1 2 3 5 8 13 21 34 55 89</span>
</span></span></code></pre></div><hr>
<h1 id="函数" data-numberify>函数<a class="anchor ms-1" href="#函数"></a></h1>
<p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。</p>
<p>函数的定义形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">function_name</span><span class="p">(</span><span class="n">arguments</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;explain&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># end function_name</span>
</span></span></code></pre></div><ul>
<li>
<p><code>explain</code> 是使用文档字符串存放的函数说明。</p>
</li>
<li>
<p><code>return</code> 代表一个函数的结束，并且返回一个值给调用方，这个值放在 <code>return</code> 后面，可以是具体的值也可以是一条有确切值的表达式。不带值或表达式的 <code>return</code> 相当于返回 <code>None</code>。当函数不需要返回值时，可以省略 <code>return</code>。</p>
</li>
</ul>
<p>调用一个函数时需要使用该函数名并根据其定义指定参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">function_name</span><span class="p">(</span><span class="n">arguments</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;explain&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">statements_block</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># end function_name</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">function_name</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="参数" data-numberify>参数<a class="anchor ms-1" href="#参数"></a></h2>
<ul>
<li>
<p><strong>不可变类型的参数传递</strong>：类似 C++ 的值传递。传递的只是参数的值，没有影响参数对象本身。如果在 <code>fun(a)</code> 内部修改 <code>a</code> 的值，则是新生成一个 <code>a</code> 的对象。即，修改参数之前函数内部参数的地址和函数外部参数的地址相同，一旦修改了变量，参数的地址将会发生变化。如 Number、String、Tuple。</p>
</li>
<li>
<p><strong>可变类型的参数传递</strong>：类似 C++ 的引用传递。如 <code>fun(la)</code>，则是将 <code>la</code> 真正的传过去，修改后 <code>fun</code> 外部的 <code>la</code> 也会受影响。无论是否对参数进行修改，参数地址都不会发生改变。如 List、Dictionary、Set。</p>
</li>
</ul>
<p>参数类型：</p>
<ul>
<li>
<p><strong>必须参数</strong>：须以正确的顺序传入函数。调用时，必须参数的数量必须和声明时一样。</p>
</li>
<li>
<p><strong>关键字参数</strong>：函数调用时使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p><strong>默认参数</strong>：调用函数时，如果没有传递参数，则会使用默认参数。默认参数在定义函数时定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p><strong>不定长参数</strong>：</p>
<ul>
<li>
<p>加了星号 <code>*</code> 的参数会以元组的形式导入，存放所有未命名的变量参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">atg1</span><span class="p">,</span> <span class="o">*</span><span class="n">vartuple</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">atg1</span><span class="p">,</span> <span class="n">vartuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：1 (2, 3)</span>
</span></span></code></pre></div></li>
<li>
<p>加了两个星号 <code>**</code> 的参数会以字典的形式导入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">atg1</span><span class="p">,</span> <span class="o">**</span><span class="n">vartuple</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">atg1</span><span class="p">,</span> <span class="n">vartuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：1 {&#39;a&#39;: 2, &#39;b&#39;: 3}</span>
</span></span></code></pre></div></li>
<li>
<p>如果参数单独出现星号 <code>*</code> 后的参数必须用关键字传入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span> 
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>   <span class="c1"># 报错</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">TypeError</span><span class="p">:</span> <span class="n">f</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">2</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">3</span> <span class="n">were</span> <span class="n">given</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 正常</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>强制位置参数</strong>：Python3.8 新增了一个函数形参语法 <code>/ </code> 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 形参 a 和 b 必须使用指定位置参数，c 可以是位置形参或关键字形参</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="lambda匿名函数" data-numberify>lambda匿名函数<a class="anchor ms-1" href="#lambda匿名函数"></a></h2>
<p>Python 使用 <code>lambda</code> 来创建匿名函数。</p>
<ul>
<li>
<p><code>lambda</code> 的主体是一个表达式，而不是一个代码块（比 <code>def</code> 简单很多）。仅仅能在 <code>lambda</code> 表达式中封装有限的逻辑进去。</p>
</li>
<li>
<p><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
</li>
<li>
<p>虽然 <code>lambda</code> 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
</li>
</ul>
<p><code>lambda</code> 函数的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">lambda</span> <span class="p">[</span><span class="n">arg1</span> <span class="p">[,</span><span class="n">arg2</span><span class="p">,</span><span class="o">.....</span><span class="n">argn</span><span class="p">]]:</span> <span class="n">expression</span>
</span></span></code></pre></div><p>用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span></code></pre></div><hr>
<h1 id="模块" data-numberify>模块<a class="anchor ms-1" href="#模块"></a></h1>
<p>模块是一个包含函数定义和变量的文件，其后缀名是 <code>.py</code>。</p>
<ul>
<li>
<p>模块可以被别的程序引入，以使用该模块中的函数等功能。</p>
</li>
<li>
<p>Python 标准库也是一个个内置的模块。</p>
<p>这些模块会根据不同的操作系统进行不同的配置，不同的操作系统可能会有一些不同的模块。</p>
</li>
<li>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用，可以使用 <code>dir()</code> 查看。</p>
<p>在导入模块后，可以通过 <code>modname.itemname</code> 这样的表示法来访问模块内的函数。</p>
</li>
<li>
<p>模块可以被导入其他模块。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
</li>
<li>
<p>模块除了方法定义，还可以包括可执行的代码。</p>
<p>这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行。</p>
</li>
</ul>
<hr>
<h2 id="包" data-numberify>包<a class="anchor ms-1" href="#包"></a></h2>
<p>包是一种管理 Python 模块命名空间的形式，采用 “点模块名称”。如一个模块的名称是 <code>A.B</code>， 那么他表示一个包 <code>A</code> 中的子模块 <code>B</code>。优点是不用担心不同模块之间的名称冲突。</p>
<p>包结构实例：</p>
<pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre><p>包还提供一个额外的属性 <code>__path__</code>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的 __init__.py，得在其他 __init__.py 被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。这个功能并不常用，一般用来扩展包里面的模块。</p>
<hr>
<h2 id="import语句" data-numberify>import语句<a class="anchor ms-1" href="#import语句"></a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">module1</span><span class="p">[,</span> <span class="n">module2</span><span class="p">[,</span><span class="o">...</span> <span class="n">moduleN</span><span class="p">]</span>
</span></span></code></pre></div><p>当解释器遇到 <code>import</code> 语句，如果模块在当前的搜索路径就会被导入。<code>import</code> 命令一般放在脚本顶端，如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Filename: support.py</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_hello</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Hello World！&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Filename: test.py</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 导入模块</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">hello</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 . 运算符调用模块中的函数</span>
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">.</span><span class="n">print_hello</span><span class="p">()</span>
</span></span></code></pre></div><p>对于同一个模块，无论执行了多少次 <code>import</code> 语句，一个模块只会被导入一次。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表，由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块（很像环境变量）。搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 <code>sys</code> 模块中的 <code>path</code> 变量。</p>
<p>以 Windows 系统为例（在 VS2017 中安装的 Python3）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Program Files (x86)</span><span class="se">\\</span><span class="s1">Microsoft Visual Studio</span><span class="se">\\</span><span class="s1">Shared</span><span class="se">\\</span><span class="s1">Python36_64</span><span class="se">\\</span><span class="s1">python36.zip&#39;</span><span class="p">,</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Program Files (x86)</span><span class="se">\\</span><span class="s1">Microsoft Visual Studio</span><span class="se">\\</span><span class="s1">Shared</span><span class="se">\\</span><span class="s1">Python36_64</span><span class="se">\\</span><span class="s1">DLLs&#39;</span><span class="p">,</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Program Files (x86)</span><span class="se">\\</span><span class="s1">Microsoft Visual Studio</span><span class="se">\\</span><span class="s1">Shared</span><span class="se">\\</span><span class="s1">Python36_64</span><span class="se">\\</span><span class="s1">lib&#39;</span><span class="p">,</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Program Files (x86)</span><span class="se">\\</span><span class="s1">Microsoft Visual Studio</span><span class="se">\\</span><span class="s1">Shared</span><span class="se">\\</span><span class="s1">Python36_64&#39;</span><span class="p">,</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Program Files (x86)</span><span class="se">\\</span><span class="s1">Microsoft Visual Studio</span><span class="se">\\</span><span class="s1">Shared</span><span class="se">\\</span><span class="s1">Python36_64</span><span class="se">\\</span><span class="s1">lib</span><span class="se">\\</span><span class="s1">site-packages&#39;</span><span class="p">]</span>
</span></span></code></pre></div><p><code>sys.path</code> 输出是一个列表，其中第一项是空串，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>如果要引入一些不在搜索路径中的模块，可以在脚本中修改 <code>sys.path</code>。</p>
<p>如果要经常使用一个模块中的函数，可以赋给它一个本地名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">module</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">func</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="from--import语句" data-numberify>from &hellip; import语句<a class="anchor ms-1" href="#from--import语句"></a></h2>
<p>使用 <code>from ... import</code> 语句可以从模块中导入一个指定的部分到当前命名空间中。这种导入的方法不会把被导入的模块的名称放在当前的字符表中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="n">item1</span><span class="p">[,</span> <span class="n">item2</span><span class="p">[,</span> <span class="o">...</span> <span class="n">itemN</span><span class="p">]]</span>
</span></span></code></pre></div><p>这样只会把 <code>modname</code> 中的指定的部分 <code>item1[, item2[, ... itemN]]</code> 导入到当前命名空间中，并且可以直接使用它们的名称来调用它们（无需使用 <code>.</code> 运算符）。<code>item1[, item2[, ... itemN]]</code> 可以是子模块、函数、类或变量等。</p>
<p>使用 <code>from package import item</code> 这种形式的时候，<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。</p>
<p>把一个模块的所有内容全都导入到当前的命名空间（不推荐使用），但是那些由单一下划线 <code>_</code> 开头的名字不在此例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="o">*</span>
</span></span></code></pre></div><p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p>
<p>为了解决这个问题，需要提供一个精确包的索引。导入语句遵循如下规则：</p>
<p>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>以下实例在 file:sounds/effects/_<em>init</em>_.py 中包含如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;echo&#34;</span><span class="p">,</span> <span class="s2">&#34;surround&#34;</span><span class="p">,</span> <span class="s2">&#34;reverse&#34;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h2 id="from--import--as语句" data-numberify>from &hellip; import &hellip; as语句<a class="anchor ms-1" href="#from--import--as语句"></a></h2>
<p><code>import ... as</code> 可以将导入的模块、函数或者变量等重命名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">name</span> <span class="k">as</span> <span class="nn">new_name</span>
</span></span></code></pre></div><p>该语句也可以接在 <code>from</code> 语句后面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="n">name</span> <span class="k">as</span> <span class="n">new_name</span>
</span></span></code></pre></div><hr>
<h2 id="__name__-属性" data-numberify>\_\_name\_\_ 属性<a class="anchor ms-1" href="#__name__-属性"></a></h2>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。可以用 <code>__name__</code> 属性来使该程序块仅在该模块自身运行时执行（被其它程序或模块引入时不执行）。</p>
<p>每个模块都有一个 <code>__name__</code> 属性，当其值是 <code>'__main__'</code> 时，表明该模块自身在运行，否则是被引入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Filename: using_name.py</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;程序自身在运行&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;我来自另一模块&#39;</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">python</span> <span class="n">using_name</span><span class="o">.</span><span class="n">py</span>
</span></span><span class="line"><span class="cl"><span class="n">程序自身在运行</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">python</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">using_name</span>
</span></span><span class="line"><span class="cl"><span class="n">我来自另一模块</span>
</span></span></code></pre></div><hr>
<h2 id="dir-函数" data-numberify>dir() 函数<a class="anchor ms-1" href="#dir-函数"></a></h2>
<p>内置的函数 <code>dir()</code> 可以找到指定模块内定义的所有名称，以一个字符串列表的形式返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">math</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">math</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__loader__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__package__&#39;</span><span class="p">,</span> <span class="s1">&#39;__spec__&#39;</span><span class="p">,</span> <span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span> <span class="s1">&#39;atan2&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span> <span class="s1">&#39;copysign&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;erfc&#39;</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;expm1&#39;</span><span class="p">,</span> <span class="s1">&#39;fabs&#39;</span><span class="p">,</span> <span class="s1">&#39;factorial&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span> <span class="s1">&#39;frexp&#39;</span><span class="p">,</span> <span class="s1">&#39;fsum&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;gcd&#39;</span><span class="p">,</span> <span class="s1">&#39;hypot&#39;</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;isclose&#39;</span><span class="p">,</span> <span class="s1">&#39;isfinite&#39;</span><span class="p">,</span> <span class="s1">&#39;isinf&#39;</span><span class="p">,</span> <span class="s1">&#39;isnan&#39;</span><span class="p">,</span> <span class="s1">&#39;ldexp&#39;</span><span class="p">,</span> <span class="s1">&#39;lgamma&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;log10&#39;</span><span class="p">,</span> <span class="s1">&#39;log1p&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">,</span> <span class="s1">&#39;modf&#39;</span><span class="p">,</span> <span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="s1">&#39;pi&#39;</span><span class="p">,</span> <span class="s1">&#39;pow&#39;</span><span class="p">,</span> <span class="s1">&#39;radians&#39;</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">,</span> <span class="s1">&#39;trunc&#39;</span><span class="p">]</span>
</span></span></code></pre></div><p>如果没有给定参数，<code>dir()</code> 函数会罗列出当前定义的所有名称。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="s1">&#39;__builtins__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__loader__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__package__&#39;</span><span class="p">,</span> <span class="s1">&#39;__spec__&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
</span></span></code></pre></div><hr>
<h1 id="输入输出" data-numberify>输入输出<a class="anchor ms-1" href="#输入输出"></a></h1>
<h2 id="标准输出" data-numberify>标准输出<a class="anchor ms-1" href="#标准输出"></a></h2>
<p>在 Python 中使用 <code>print()</code> 来将其参数输出到标准输出上。默认的标准输出是屏幕。</p>
<p>可以使用 <code>str.format()</code> 函数等方式⤴ 来格式化输出值。</p>
<p>可以使用 <code>repr()</code> 或 <code>str()</code> 函数来将输出的值转成字符串。</p>
<ul>
<li>
<p><code>str()</code>：函数返回一个用户易读的表达形式。</p>
</li>
<li>
<p><code>repr()</code>：产生一个解释器易读的表达形式。</p>
</li>
</ul>
<hr>
<h2 id="标准输入" data-numberify>标准输入<a class="anchor ms-1" href="#标准输入"></a></h2>
<p>Python 提供了 <code>input()</code> 内置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<p>Python3.x 中 <code>input()</code> 函数接受一个标准输入数据，返回为 string 类型。Python3.x 没有 <code>raw_input()</code>。</p>
<p><code>input()</code> 函数的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">input</span><span class="p">([</span><span class="n">prompt</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># prompt —— 输出到标准输出的提示信息</span>
</span></span></code></pre></div><p>用法示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;输入一个整数：&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">输入一个整数</span><span class="err">：</span><span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">str</span><span class="s1">&#39;&gt;      # input() 返回的是 string</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>      <span class="c1"># 使用 int() 类型转换</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">int</span><span class="s1">&#39;&gt; 123    # 此时 a 才是 int</span>
</span></span></code></pre></div><p><code>input()</code> 接收多个值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1">#输入三角形的三边长</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;请输入三角形三边的长：&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#计算三角形的半周长p</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#计算三角形的面积s</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span><span class="o">**</span><span class="mf">0.5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#输出三角形的面积</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;三角形面积为：&#34;</span><span class="p">,</span> <span class="nb">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;.2f&#39;</span><span class="p">))</span>
</span></span></code></pre></div><hr>
<h2 id="读写文件" data-numberify>读写文件<a class="anchor ms-1" href="#读写文件"></a></h2>
<p><code>open()</code> 将会返回一个 <code>file</code> 对象，基本语法格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">[,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># filename —— 包含了要访问的文件名称的字符串值</span>
</span></span><span class="line"><span class="cl"><span class="c1"># mode —— 打开文件的模式的字符串值，默认文件访问模式为只读（r）</span>
</span></span></code></pre></div><p>打开文件的模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>t</code></td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td><code>x</code></td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td><code>b</code></td>
<td>二进制模式。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>打开一个文件进行更新（可读可写）。</td>
</tr>
<tr>
<td><code>U</code></td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td><code>r</code></td>
<td>以只读方式打开文件（默认模式）。文件的指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>rb</code></td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>r+</code></td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>rb+</code></td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>w</code></td>
<td>打开一个文件只用于写入。
如果该文件已存在，则清空原文件内容，并从开头开始编辑。
如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td><code>wb</code></td>
<td>以二进制格式打开一个文件只用于写入。
打开方式与 <code>w</code> 相同（会覆盖原有的文件）。</td>
</tr>
<tr>
<td><code>w+</code></td>
<td>打开一个文件用于读写。
打开方式与 <code>w</code> 相同。</td>
</tr>
<tr>
<td><code>wb+</code></td>
<td>以二进制格式打开一个文件用于读写。
打开方式与 <code>w</code> 相同。</td>
</tr>
<tr>
<td><code>a</code></td>
<td>打开一个文件用于追加。
如果该文件已存在，文件指针将会放在文件的结尾。
即，新的内容将会被写入到已有内容之后。
如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td><code>ab</code></td>
<td>以二进制格式打开一个文件用于追加。
打开方式与 <code>a</code> 相同。</td>
</tr>
<tr>
<td><code>a+</code></td>
<td>打开一个文件用于读写。
打开方式与 <code>a</code> 相同。</td>
</tr>
<tr>
<td><code>ab+</code></td>
<td>以二进制格式打开一个文件用于追加。
打开方式与 <code>a</code> 相同。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>模式</th>
<th><code>r</code></th>
<th><code>r+</code></th>
<th><code>w</code></th>
<th><code>w+</code></th>
<th><code>a</code></th>
<th><code>a+</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>写</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>创建</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>覆盖</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在开始</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在结尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<p><code>open()</code> 函数的完整语法格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">[,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="kc">None</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># file —— 必需，文件路径（相对或者绝对路径）。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># mode —— 可选，文件打开模式</span>
</span></span><span class="line"><span class="cl"><span class="c1"># buffering —— 设置缓冲</span>
</span></span><span class="line"><span class="cl"><span class="c1"># encoding —— 一般使用 utf8</span>
</span></span><span class="line"><span class="cl"><span class="c1"># errors —— 报错级别</span>
</span></span><span class="line"><span class="cl"><span class="c1"># newline —— 区分换行符</span>
</span></span><span class="line"><span class="cl"><span class="c1"># closefd —— 传入的 file 参数类型</span>
</span></span><span class="line"><span class="cl"><span class="c1"># opener —— 自定义打开文件方式</span>
</span></span></code></pre></div><hr>
<p>打开文件后，要进行的就是写入和读取操作，这些操作都是对 <code>file</code> 对象进行操作。</p>
<p><code>file</code> 对象方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file.close()</code></td>
<td>关闭文件。关闭后文件不能再进行读写操作。
在执行完文件的读写操作后，有必要执行该方法。</td>
</tr>
<tr>
<td><code>file.flush()</code></td>
<td>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td><code>file.fileno()</code></td>
<td>返回一个整型的文件描述符（file descriptor FD 整型），可以用在如 <code>os</code> 模块的 <code>read</code> 方法等一些底层操作上。</td>
</tr>
<tr>
<td><code>file.isatty()</code></td>
<td>如果文件连接到一个终端设备返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>file.next()</code></td>
<td>返回文件下一行。</td>
</tr>
<tr>
<td><code>file.read([size=-1])</code></td>
<td>从文件读取指定的字节数，默认为 <code>-1</code>，为负数时表示读取所有。</td>
</tr>
<tr>
<td><code>file.readline([size=-1])</code></td>
<td>读取整行（<code>size</code> 默认为 <code>-1</code>，为负数表示读取整行），包括 <code>'\n'</code> 字符。
如果指定了 <code>size</code> 则读取该行的前 <code>size</code> 字符。
第一次调用时读取第一行，第二次调用时读取第二行，以此类推。</td>
</tr>
<tr>
<td><code>file.readlines([sizeint])</code></td>
<td>读取所有行并返回列表，若给定 <code>sizeint</code> &gt; 0，则是设置一次读多少字节，这是为了减轻读取压力。</td>
</tr>
<tr>
<td><code>file.seek(offset[, whence=0])</code></td>
<td>设置文件当前位置。
<code>offset</code> —— 开始的偏移量。
<code>whence</code> —— 给 <code>offset</code> 参数一个定义，表示要从哪个位置开始偏移；<code>0</code> 代表从文件开头开始算起，<code>1</code>代表从当前位置开始算起，<code>2 </code>代表从文件末尾算起。默认为 <code>0</code>。</td>
</tr>
<tr>
<td><code>file.tell()</code></td>
<td>返回文件当前位置。</td>
</tr>
<tr>
<td><code>file.truncate([size=file.tell()])</code></td>
<td>截取文件，截取的字节通过 <code>size</code> 指定，默认为当前文件位置。</td>
</tr>
<tr>
<td><code>file.write(str)</code></td>
<td>将字符串写入文件，返回的是写入的字符长度。
如果文件打开模式带 <code>b</code>，那写入文件内容时，<code>str</code> 要用 <code>encode()</code> 方法转为 <code>bytes</code> 形式，否则报错：TypeError: a bytes-like object is required, not &lsquo;str&rsquo;。</td>
</tr>
<tr>
<td><code>file.writelines(sequence)</code></td>
<td>向文件写入一个序列字符串列表（这一序列字符串可以是由迭代对象产生的，如一个字符串列表），如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<hr>
<p><code>file.write()</code> 用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;test1&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;从文件中读取到的字符串：&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 从文件中读取到的字符串： test1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb+&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;test1&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;从二进制文件中读取到的内容：&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;将其转化为字符串输出：&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 从二进制文件中读取到的内容： b&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将其转化为字符串输出： test1</span>
</span></span></code></pre></div><hr>
<h1 id="os模块" data-numberify>os模块<a class="anchor ms-1" href="#os模块"></a></h1>
<p>os 模块提供了非常丰富的方法用来处理文件和目录。以下是一些常用的方法：</p>
<hr>
<p><code>os.access(path, mode)</code></p>
<p>检验权限模式（使用当前的 UID/GID 尝试访问路径）。</p>
<ul>
<li>
<p><code>path</code> —— 要用来检测是否有访问权限的路径。</p>
</li>
<li>
<p><code>mode</code> —— 参数取值如下：</p>
<ul>
<li>
<p><code>os.F_OK</code> —— 测试 <code>path</code> 是否存在；</p>
</li>
<li>
<p><code>os.R_OK</code> —— 测试 <code>path</code> 是否可读；</p>
</li>
<li>
<p><code>os.W_OK</code> —— 测试 <code>path</code> 是否可写；</p>
</li>
<li>
<p><code>os.X_OK</code> —— 测试 <code>path</code> 是否可执行。</p>
</li>
<li>
<p>在相应模式下，如果存在/可读/写/执行返回 <code>True</code> ，否则返回 <code>False</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>os.chdir(path)</code></td>
<td>改变当前工作目录到 <code>path</code> 指定的路径。如果允许访问返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>os.chflags(path, flags)</code></td>
<td>设置路径 <code>path</code> 的标记为数字标记。多个标记可以使用 OR 来组合起来。
<code>flags</code> —— 参数取值如下：
<code>stat.UF_NODUMP</code> —— 非转储文件；
<code>stat.UF_IMMUTABLE</code> —— 文件是只读的；
<code>stat.UF_APPEND</code> —— 文件只能追加内容；
<code>stat.UF_NOUNLINK</code> —— 文件不可删除；
<code>stat.UF_OPAQUE</code> —— 目录不透明，需要通过联合堆栈查看；
以下参数值是超级用户可设置的：
<code>stat.SF_ARCHIVED</code> —— 可存档文件；
<code>stat.SF_IMMUTABLE</code> —— 文件是只读的；
<code>stat.SF_APPEND</code> —— 文件只能追加内容；
<code>stat.SF_NOUNLINK</code> —— 文件不可删除；
<code>stat.SF_SNAPSHOT</code> —— 快照文件。</td>
</tr>
<tr>
<td><code>os.chmod(path, mode)</code></td>
<td>更改权限</td>
</tr>
<tr>
<td><code>os.chown(path, uid, gid)</code></td>
<td>更改文件所有者</td>
</tr>
<tr>
<td><code>os.chroot(path)</code></td>
<td>改变当前进程的根目录</td>
</tr>
<tr>
<td><code>os.close(fd)</code></td>
<td>关闭文件描述符 fd</td>
</tr>
<tr>
<td><code>os.closerange(fd_low, fd_high)</code></td>
<td>关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td><code>os.dup(fd)</code></td>
<td>复制文件描述符 fd</td>
</tr>
<tr>
<td><code>os.dup2(fd, fd2)</code></td>
<td>将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td><code>os.fchdir(fd)</code></td>
<td>通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td><code>os.fchmod(fd, mode)</code></td>
<td>改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td><code>os.fchown(fd, uid, gid)</code></td>
<td>修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td><code>os.fdatasync(fd)</code></td>
<td>强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td><code>os.fdopen(fd[, mode[, bufsize]])</code></td>
<td>通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td><code>os.fpathconf(fd, name)</code></td>
<td>返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td><code>os.fstat(fd)</code></td>
<td>返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td><code>os.fstatvfs(fd)</code></td>
<td>返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td>
</tr>
<tr>
<td><code>os.fsync(fd)</code></td>
<td>强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td><code>os.ftruncate(fd, length)</code></td>
<td>裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td><code>os.getcwd()</code></td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td><code>os.getcwdb()</code></td>
<td>返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td><code>os.isatty(fd)</code></td>
<td>如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td><code>os.lchflags(path, flags)</code></td>
<td>设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td><code>os.lchmod(path, mode)</code></td>
<td>修改连接文件权限</td>
</tr>
<tr>
<td><code>os.lchown(path, uid, gid)</code></td>
<td>更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td><code>os.link(src, dst)</code></td>
<td>创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td><code>os.listdir(path)</code></td>
<td>返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td><code>os.lseek(fd, pos, how)</code></td>
<td>设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td><code>os.lstat(path)</code></td>
<td>像stat(),但是没有软链接</td>
</tr>
<tr>
<td><code>os.major(device)</code></td>
<td>从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td><code>os.makedev(major, minor)</code></td>
<td>以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td><code>os.makedirs(path[, mode])</code></td>
<td>递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td><code>os.minor(device)</code></td>
<td>从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td><code>os.mkdir(path[, mode])</code></td>
<td>以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td><code>os.mkfifo(path[, mode])</code></td>
<td>创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td><code>os.mknod(filename[, mode=0600, device])</code></td>
<td>创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td><code>os.open(file, flags[, mode])</code></td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td><code>os.openpty()</code></td>
<td>打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td><code>os.pathconf(path, name)</code></td>
<td>返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td><code>os.pipe()</code></td>
<td>创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td><code>os.popen(command[, mode[, bufsize]])</code></td>
<td>从一个 command 打开一个管道</td>
</tr>
<tr>
<td><code>os.read(fd, n)</code></td>
<td>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td><code>os.readlink(path)</code></td>
<td>返回软链接所指向的文件</td>
</tr>
<tr>
<td><code>os.remove(path)</code></td>
<td>删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td><code>os.removedirs(path)</code></td>
<td>递归删除目录。</td>
</tr>
<tr>
<td><code>os.rename(src, dst)</code></td>
<td>重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td><code>os.renames(old, new)</code></td>
<td>递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td><code>os.rmdir(path)</code></td>
<td>删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td><code>os.stat(path)</code></td>
<td>获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td><code>os.stat_float_times([newvalue])</code></td>
<td>决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td><code>os.statvfs(path)</code></td>
<td>获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td><code>os.symlink(src, dst)</code></td>
<td>创建一个软链接</td>
</tr>
<tr>
<td><code>os.tcgetpgrp(fd)</code></td>
<td>返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td><code>os.tcsetpgrp(fd, pg)</code></td>
<td>设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td><code>os.tempnam([dir[, prefix]])</code></td>
<td><strong>Python3 中已删除。</strong> 返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td><code>os.tmpfile()</code></td>
<td><strong>Python3 中已删除。</strong> 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td><code>os.tmpnam()</code></td>
<td><strong>Python3 中已删除。</strong> 为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td><code>os.ttyname(fd)</code></td>
<td>返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td><code>os.unlink(path)</code></td>
<td>删除文件路径</td>
</tr>
<tr>
<td><code>os.utime(path, times)</code></td>
<td>返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></td>
<td>输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td><code>os.write(fd, str)</code></td>
<td>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
<tr>
<td><code>os.path</code> 模块</td>
<td>获取文件的属性信息。</td>
</tr>
<tr>
<td><code>os.pardir()</code></td>
<td>获取当前目录的父目录，以字符串形式显示目录名。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="错误和异常" data-numberify>错误和异常<a class="anchor ms-1" href="#错误和异常"></a></h1>
<p>Python 中的语法错误也可称之为解析错。即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span>             <span class="c1"># 0 不能作为除数，触发异常</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
</span></span><span class="line"><span class="cl"><span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">spam</span><span class="o">*</span><span class="mi">3</span>             <span class="c1"># spam 未定义，触发异常</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
</span></span><span class="line"><span class="cl"><span class="ne">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s1">&#39;spam&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;2&#39;</span> <span class="o">+</span> <span class="mi">2</span>               <span class="c1"># int 不能与 str 相加，触发异常</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">TypeError</span><span class="p">:</span> <span class="n">can</span> <span class="n">only</span> <span class="n">concatenate</span> <span class="nb">str</span> <span class="p">(</span><span class="ow">not</span> <span class="s2">&#34;int&#34;</span><span class="p">)</span> <span class="n">to</span> <span class="nb">str</span>
</span></span></code></pre></div><p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>
<hr>
<h2 id="异常处理" data-numberify>异常处理<a class="anchor ms-1" href="#异常处理"></a></h2>
<h3 id="tryexcept" data-numberify>try/except<a class="anchor ms-1" href="#tryexcept"></a></h3>
<p>异常捕捉可以使用 <code>try/except</code> 语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 执行一次 try 子句，并尝试捕捉异常</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果没有异常发生，忽略 except 子句</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 当捕捉到异常时，将执行对应的 except 子句</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。但最多只有一个分支会被执行。</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_1</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_2</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_3</span>
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span><span class="p">:</span> <span class="c1"># 省略异常的名称，将被当作通配符使用</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_n</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 一次处理多个异常</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_1</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="p">(</span><span class="n">Error1</span><span class="p">,</span> <span class="n">Error2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="c1"># 这里是一个元素为“异常”的元组</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_2</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;请输入一个数字: &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;您输入的不是数字，请再次尝试输入！&#34;</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;myfile.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;OS error: </span><span class="si">{0}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Could not convert data to an integer.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Unexpected error:&#34;</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="c1"># 再次将触发的异常抛出</span>
</span></span></code></pre></div><hr>
<h3 id="tryexcept--else" data-numberify>try/except &hellip; else<a class="anchor ms-1" href="#tryexcept--else"></a></h3>
<p><code>try/except</code> 语句还有一个可选的 <code>else</code> 子句，如果使用这个子句，那么必须放在所有的 <code>except</code> 子句之后。<code>else</code> 子句将在 <code>try</code> 子句没有发生任何异常的时候执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_1</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_2</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_3</span>
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_n</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_e</span>
</span></span></code></pre></div><p>判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot open&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;has&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()),</span> <span class="s1">&#39;lines&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>使用 <code>else</code> 子句比把所有的语句都放在 <code>try</code> 子句里面要好，这样可以避免一些意想不到，而 <code>except</code> 又无法捕获的异常。异常处理并不仅仅处理那些直接发生在 <code>try</code> 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p>
<hr>
<h3 id="try-finally" data-numberify>try-finally<a class="anchor ms-1" href="#try-finally"></a></h3>
<p><code>try-finally</code> 语句无论是否发生异常都将执行 <code>finally</code> 子句的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_1</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_2</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">Error2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_3</span>
</span></span><span class="line"><span class="cl"><span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_n</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_e</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">statement_f</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">runoob</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;file.log&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">read_data</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">FileNotFoundError</span> <span class="k">as</span> <span class="n">fnf_error</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">fnf_error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这句话，无论异常是否发生都会执行。&#39;</span><span class="p">)</span>
</span></span></code></pre></div><p><code>finally</code> 子句通常用作定义任何情况下都会执行的清理行为。</p>
<p>如果一个异常在 <code>try</code> 子句里（或者在 <code>except</code> 和 <code>else</code> 子句里）被抛出，而又没有任何的 <code>except </code>把它截住，那么这个异常会在 <code>finally</code> 子句执行后被抛出。</p>
<hr>
<h2 id="抛出异常" data-numberify>抛出异常<a class="anchor ms-1" href="#抛出异常"></a></h2>
<p>Python 使用 <code>raise</code> 语句抛出一个指定的异常。<code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<code>raise</code> 语法格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">raise</span> <span class="p">[</span><span class="ne">Exception</span> <span class="p">[,</span> <span class="n">args</span> <span class="p">[,</span> <span class="n">traceback</span><span class="p">]]]</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;x 不能大于 5。x 的值为: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></span></code></pre></div><p>执行以上代码会触发异常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-latex" data-lang="latex"><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">  File &#34;test.py&#34;, line 3, in &lt;module&gt;
</span></span><span class="line"><span class="cl">    raise Exception(&#39;x 不能大于 5。x 的值为: <span class="nb">{}</span>&#39;.format(x))
</span></span><span class="line"><span class="cl">Exception: x 不能大于 5。x 的值为: 10
</span></span></code></pre></div><hr>
<h2 id="用户自定义异常" data-numberify>用户自定义异常<a class="anchor ms-1" href="#用户自定义异常"></a></h2>
<p>异常类都是直接或间接地继承自 <code>Exception</code> 类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>         <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>         <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span> <span class="k">except</span> <span class="n">MyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My exception occurred, value:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">My</span> <span class="n">exception</span> <span class="n">occurred</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="s1">&#39;oops!&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
</span></span><span class="line"><span class="cl"><span class="n">__main__</span><span class="o">.</span><span class="n">MyError</span><span class="p">:</span> <span class="s1">&#39;oops!&#39;</span>
</span></span></code></pre></div><hr>
<h2 id="预定义清理行为" data-numberify>预定义清理行为<a class="anchor ms-1" href="#预定义清理行为"></a></h2>
<p><code>with</code> 语句可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;myfile.txt&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34;&#34;</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="assert-断言" data-numberify>assert 断言<a class="anchor ms-1" href="#assert-断言"></a></h2>
<p>Python <code>assert</code>（断言）用于判断一个表达式，在表达式条件为 <code>false</code> 的时候触发异常。</p>
<p>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。</p>
<p>语法格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">assert</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="c1"># expression 值为 True 时，正常执行；</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 为 False 时，触发异常</span>
</span></span></code></pre></div><p>它等价于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="ne">AssertionError</span>
</span></span></code></pre></div><p><code>assert</code> 后面也可以紧跟参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">assert</span> <span class="n">expression</span> <span class="p">[,</span> <span class="n">arguments</span><span class="p">]</span>
</span></span></code></pre></div><p>等价于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="kc">True</span>     <span class="c1"># 条件为 true 正常执行</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="kc">False</span>    <span class="c1"># 条件为 false 触发异常</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">AssertionError</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span><span class="o">==</span><span class="mi">1</span>    <span class="c1"># 条件为 true 正常执行</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span><span class="o">==</span><span class="mi">2</span>    <span class="c1"># 条件为 false 触发异常</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">AssertionError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="mi">1</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1 不等于 2&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="n">不等于</span> <span class="mi">2</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="k">assert</span> <span class="p">(</span><span class="s1">&#39;linux&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">),</span> <span class="s2">&#34;该代码只能在 Linux 下执行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ... 接下来要执行的代码</span>
</span></span></code></pre></div><hr>
<h1 id="面向对象" data-numberify>面向对象<a class="anchor ms-1" href="#面向对象"></a></h1>
<ul>
<li>
<p><strong>类</strong>（Class）：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li>
<p><strong>方法</strong>：类中定义的函数。</p>
</li>
<li>
<p><strong>类变量</strong>：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li>
<p><strong>数据成员</strong>：类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li>
<p><strong>方法重写</strong>：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li>
<p><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li>
<p><strong>实例变量</strong>：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</p>
</li>
<li>
<p><strong>继承</strong>：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。继承是模拟 “是一个（is-a）” 关系。</p>
</li>
<li>
<p><strong>实例化</strong>：创建一个类的实例，类的具体对象。</p>
</li>
<li>
<p><strong>对象</strong>：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<hr>
<h2 id="类定义和类对象" data-numberify>类定义和类对象<a class="anchor ms-1" href="#类定义和类对象"></a></h2>
<h2 id="创建类" data-numberify>创建类<a class="anchor ms-1" href="#创建类"></a></h2>
<p>创建类的语法格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ClassName</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</span></span></code></pre></div><hr>
<h2 id="创建实例对象" data-numberify>创建实例对象<a class="anchor ms-1" href="#创建实例对象"></a></h2>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>在 Python 中，类的实例化类似函数调用方式，其语法格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">obj</span> <span class="o">=</span> <span class="n">ClassName</span><span class="p">([</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
</span></span></code></pre></div><hr>
<h2 id="访问对象属性" data-numberify>访问对象属性<a class="anchor ms-1" href="#访问对象属性"></a></h2>
<p>类的属性是指在类中定义的变量和方法等。</p>
<p>属性引用使用 <code>obj.name</code> 语法。类对象创建后，类命名空间中所有的命名（如变量、方法等）都是有效属性名。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">var1</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">var2</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is my class.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">var1</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">var2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1 2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># This is my class.</span>
</span></span></code></pre></div><hr>
<h2 id="__init__-和self" data-numberify>\_\_init\_\_() 和self<a class="anchor ms-1" href="#__init__-和self"></a></h2>
<p>在类定义中有一个特殊的方法，构造方法 <code>__init__()</code>。如果类定义了 <code>__init__()</code> 方法，那么在类实例化时，会自动调用该方法。</p>
<p>在类定义中，<code>self</code> 代表类的实例，而非类。<code>self</code> 必须存在，且位于其他形参前面。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是 <code>self</code>。</p>
<p><code>self</code> 的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定使用 <code>self</code>。</p>
<p>在类的内部，使用 <code>def</code> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <code>self</code>, 且为第一个参数。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Complex</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;复数类&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">print_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:f}{:+f}</span><span class="s1">i&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span> <span class="c1"># 实例化</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>   <span class="c1"># 输出：3.0 -4.5</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="o">.</span><span class="n">print_complex</span><span class="p">()</span> <span class="c1"># 输出：3.000000-4.500000i</span>
</span></span></code></pre></div><p>在 Python 调用 <code>__init__()</code> 来创建实例时，将自动传入实参 <code>self</code>。每个与类相关联的方法调用都自动传递实参 <code>self</code>。</p>
<p>在类的内部使用属性和方法，需要使用 <code>self.attrs</code> 或 <code>self.method()</code>。</p>
<hr>
<h2 id="修改属性值" data-numberify>修改属性值<a class="anchor ms-1" href="#修改属性值"></a></h2>
<p>通常有两种方法可以修改属性值，一种是直接使用 <code>obj.name</code> 语法修改，另一种是通过方法对属性值进行修改。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span><span class="p">():</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">make</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">year</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;初始化描述汽车的属性&#34;&#34;&#34;</span> 
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">make</span> <span class="o">=</span> <span class="n">make</span> 
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span> 
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">odometer_reading</span> <span class="o">=</span> <span class="mi">0</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get_descriptive_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;返回整洁的描述性信息&#34;&#34;&#34;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">long_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">make</span> 
</span></span><span class="line"><span class="cl">          <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">long_name</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">read_odometer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;打印一条指出汽车里程的消息&#34;&#34;&#34;</span> 
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This car has &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">odometer_reading</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">              <span class="o">+</span> <span class="s2">&#34; miles on it.&#34;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">update_odometer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mileage</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34; 
</span></span></span><span class="line"><span class="cl"><span class="s2">        将里程表读数设置为指定的值
</span></span></span><span class="line"><span class="cl"><span class="s2">        禁止将里程表读数往回调
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">mileage</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">odometer_reading</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">       <span class="bp">self</span><span class="o">.</span><span class="n">odometer_reading</span> <span class="o">=</span> <span class="n">mileage</span> 
</span></span><span class="line"><span class="cl">     <span class="k">else</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">      <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;You can&#39;t roll back an odometer!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">increment_odometer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">miles</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">     <span class="s2">&#34;&#34;&#34;将里程表读数增加指定的量&#34;&#34;&#34;</span> 
</span></span><span class="line"><span class="cl">     <span class="bp">self</span><span class="o">.</span><span class="n">odometer_reading</span> <span class="o">+=</span> <span class="n">miles</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_new_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">(</span><span class="s1">&#39;audi&#39;</span><span class="p">,</span> <span class="s1">&#39;a4&#39;</span><span class="p">,</span> <span class="mi">2016</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1"># 通过方法获取属性</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_new_car</span><span class="o">.</span><span class="n">get_descriptive_name</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl"><span class="n">my_new_car</span><span class="o">.</span><span class="n">read_odometer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2016 Audi A4 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># This car has 0 miles on it.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 通过方法对属性值进行修改</span>
</span></span><span class="line"><span class="cl"><span class="n">my_used_car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">(</span><span class="s1">&#39;subaru&#39;</span><span class="p">,</span> <span class="s1">&#39;outback&#39;</span><span class="p">,</span> <span class="mi">2013</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">my_used_car</span><span class="o">.</span><span class="n">get_descriptive_name</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_used_car</span><span class="o">.</span><span class="n">update_odometer</span><span class="p">(</span><span class="mi">23500</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="n">my_used_car</span><span class="o">.</span><span class="n">read_odometer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">my_used_car</span><span class="o">.</span><span class="n">increment_odometer</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="n">my_used_car</span><span class="o">.</span><span class="n">read_odometer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2013 Subaru Outback </span>
</span></span><span class="line"><span class="cl"><span class="c1"># This car has 23500 miles on it. </span>
</span></span><span class="line"><span class="cl"><span class="c1"># This car has 23600 miles on it.</span>
</span></span></code></pre></div><hr>
<h2 id="继承" data-numberify>继承<a class="anchor ms-1" href="#继承"></a></h2>
<p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。派生类的定义如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</span></span></code></pre></div><p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。</p>
<p>如果基类定义在另一个模块中，需要使用 <code>.</code> 运算符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 类定义</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">people</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 定义基本属性</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 定义私有属性,私有属性在类外部无法直接进行访问</span>
</span></span><span class="line"><span class="cl">    <span class="n">__weight</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 定义构造方法</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">__weight</span> <span class="o">=</span> <span class="n">w</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> 说: 我 </span><span class="si">%d</span><span class="s2"> 岁。&#34;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 单继承示例</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">student</span><span class="p">(</span><span class="n">people</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">grade</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 调用父类的构函</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">grade</span> <span class="o">=</span> <span class="n">g</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 覆写父类的方法</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> 说: 我 </span><span class="si">%d</span><span class="s2"> 岁了，我在读 </span><span class="si">%d</span><span class="s2"> 年级&#34;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grade</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="n">student</span><span class="p">(</span><span class="s1">&#39;ken&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>
</span></span></code></pre></div><hr>
<h3 id="多继承" data-numberify>多继承<a class="anchor ms-1" href="#多继承"></a></h3>
<p>Python 有限地支持<strong>多继承</strong>，多继承的类定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</span></span></code></pre></div><p>若是父类中有相同的方法名，而在子类使用时未指定，Python 会根据圆括号中父类的顺序从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 接上一个例子</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 另一个类，多重继承之前的准备</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">speaker</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">topic</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">t</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;我叫 </span><span class="si">%s</span><span class="s2">，我是一个演说家，我演讲的主题是 </span><span class="si">%s</span><span class="s2">&#34;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 多重继承</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">sample</span><span class="p">(</span><span class="n">speaker</span><span class="p">,</span><span class="n">student</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">student</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">speaker</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">test</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="s2">&#34;Tim&#34;</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s2">&#34;Python&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">test</span><span class="o">.</span><span class="n">speak</span><span class="p">()</span>   <span class="c1"># 方法名同，默认调用的是在括号中排前地父类的方法</span>
</span></span></code></pre></div><hr>
<h3 id="方法重写" data-numberify>方法重写<a class="anchor ms-1" href="#方法重写"></a></h3>
<p>可以在子类中重写其父类的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>        <span class="c1"># 定义父类</span>
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="nf">myMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;调用父类方法&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span> <span class="c1"># 定义子类</span>
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="nf">myMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;调用子类方法&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>          <span class="c1"># 子类实例</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">myMethod</span><span class="p">()</span>         <span class="c1"># 子类调用重写方法</span>
</span></span><span class="line"><span class="cl"><span class="nb">super</span><span class="p">(</span><span class="n">Child</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">myMethod</span><span class="p">()</span> <span class="c1"># 用子类对象调用父类已被覆盖的方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 调用子类方法</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 调用父类方法</span>
</span></span></code></pre></div><hr>
<h3 id="子类继承父类构造函数说明" data-numberify>子类继承父类构造函数说明<a class="anchor ms-1" href="#子类继承父类构造函数说明"></a></h3>
<p>如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。</p>
<p>子类不重写 <code>__init__</code>，实例化子类时，会自动调用父类定义的 <code>__init__</code>。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Father</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;name: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Father &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 重写了 getName 但并没有重写 __init__</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Son</span><span class="p">(</span><span class="n">Father</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Son &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">son</span> <span class="o">=</span> <span class="n">Son</span><span class="p">(</span><span class="s1">&#39;runoob&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">son</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># name: runoob</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Son runoob</span>
</span></span></code></pre></div><hr>
<p>如果重写了<code>__init__</code> 时，实例化子类，就不会调用父类已经定义的 <code>__init__</code>。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Father</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span> <span class="s2">&#34;name: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Father &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 重写了 __init__ 和 getName</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Son</span><span class="p">(</span><span class="n">Father</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span> <span class="s2">&#34;hi&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span>  <span class="n">name</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Son &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">son</span><span class="o">=</span><span class="n">Son</span><span class="p">(</span><span class="s1">&#39;runoob&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">(</span><span class="n">son</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># hi</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Son runoob</span>
</span></span></code></pre></div><hr>
<p>如果重写了 <code>__init__</code> 时，要继承父类的构造方法，可以在 <code>__init__</code> 的定义中使用 <code>super</code> 关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">super</span><span class="p">(</span><span class="n">子类</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">参数1</span><span class="p">,</span> <span class="n">参数2</span><span class="p">,</span> <span class="o">....</span><span class="p">)</span>
</span></span></code></pre></div><p>另一种写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">父类名称</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">参数1</span><span class="p">,</span> <span class="n">参数2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Father</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;name: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Father &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Son</span><span class="p">(</span><span class="n">Father</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">(</span><span class="n">Son</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hi&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span>  <span class="n">name</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;Son &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">son</span><span class="o">=</span><span class="n">Son</span><span class="p">(</span><span class="s1">&#39;runoob&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">(</span><span class="n">son</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># name: runoob</span>
</span></span><span class="line"><span class="cl"><span class="c1"># hi</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Son runoob</span>
</span></span></code></pre></div><hr>
<h2 id="类的私有属性与私有方法" data-numberify>类的私有属性与私有方法<a class="anchor ms-1" href="#类的私有属性与私有方法"></a></h2>
<p>私有属性不能在类的外部被使用或直接访问。使用两个下划线开头，声明该属性为私有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">__private_attrs</span>
</span></span></code></pre></div><p>在类内部的方法中使用私有属性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="bp">self</span><span class="o">.</span><span class="n">__private_attrs</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">JustCounter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">__secretCount</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 私有变量</span>
</span></span><span class="line"><span class="cl">    <span class="n">publicCount</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># 公开变量</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">__secretCount</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">publicCount</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__secretCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">counter</span> <span class="o">=</span> <span class="n">JustCounter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">publicCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">__secretCount</span><span class="p">)</span>  <span class="c1"># 报错，实例不能访问私有变量</span>
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;test.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">16</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">__secretCount</span><span class="p">)</span>  <span class="c1"># 报错，实例不能访问私有变量</span>
</span></span><span class="line"><span class="cl"><span class="ne">AttributeError</span><span class="p">:</span> <span class="s1">&#39;JustCounter&#39;</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;__secretCount&#39;</span>
</span></span></code></pre></div><hr>
<p>私有方法只能在类的内部调用 ，不能在类的外部调用。使用两个下划线开头，声明该方法为私有方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">__private_method</span><span class="p">(</span><span class="bp">self</span><span class="p">[,</span> <span class="o">...</span><span class="p">]):</span>
</span></span></code></pre></div><p>在类内部的方法中使用私有方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="bp">self</span><span class="o">.</span><span class="n">__private_methods</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Site</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>   <span class="c1"># public</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">__url</span> <span class="o">=</span> <span class="n">url</span>   <span class="c1"># private</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">who</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;name  : &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;url : &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">__foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>          <span class="c1"># 私有方法</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这是私有方法&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>            <span class="c1"># 公共方法</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这是公共方法&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">__foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="s1">&#39;菜鸟教程&#39;</span><span class="p">,</span> <span class="s1">&#39;www.runoob.com&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="o">.</span><span class="n">who</span><span class="p">()</span>        <span class="c1"># 正常输出</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>        <span class="c1"># 正常输出</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span><span class="o">.</span><span class="n">__foo</span><span class="p">()</span>      <span class="c1"># 报错</span>
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">name</span>  <span class="p">:</span>  <span class="n">菜鸟教程</span>
</span></span><span class="line"><span class="cl"><span class="n">url</span> <span class="p">:</span>  <span class="n">www</span><span class="o">.</span><span class="n">runoob</span><span class="o">.</span><span class="n">com</span>
</span></span><span class="line"><span class="cl"><span class="n">这是公共方法</span>
</span></span><span class="line"><span class="cl"><span class="n">这是私有方法</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;c:/Users/27120/Documents/MyDocuments/Code/test.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">20</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>      
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="n">__foo</span><span class="p">()</span>      <span class="c1"># 报错，外部不能调用私有方法</span>
</span></span><span class="line"><span class="cl"><span class="ne">AttributeError</span><span class="p">:</span> <span class="s1">&#39;Site&#39;</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;__foo&#39;</span>
</span></span></code></pre></div><hr>
<h2 id="类的专有方法" data-numberify>类的专有方法<a class="anchor ms-1" href="#类的专有方法"></a></h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__init__ </code></td>
<td>构造函数，在生成对象时调用</td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数，释放对象时使用</td>
</tr>
<tr>
<td><code>__repr__</code></td>
<td>打印，转换</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>按照索引赋值</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>按照索引获取值</td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>获得长度</td>
</tr>
<tr>
<td><code>__cmp__</code></td>
<td>比较运算</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>加运算</td>
</tr>
<tr>
<td><code>__sub__</code></td>
<td>减运算</td>
</tr>
<tr>
<td><code>__mul__</code></td>
<td>乘运算</td>
</tr>
<tr>
<td><code>__truediv__</code></td>
<td>除运算</td>
</tr>
<tr>
<td><code>__mod__</code></td>
<td>求余运算</td>
</tr>
<tr>
<td><code>__pow__</code></td>
<td>乘方</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="运算符重载" data-numberify>运算符重载<a class="anchor ms-1" href="#运算符重载"></a></h3>
<p>可以对类的专有方法进行重载：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vector</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">      <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="s1">&#39;Vector (</span><span class="si">%d</span><span class="s1">, </span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Vector(7,8)</span>
</span></span></code></pre></div><hr>
<h1 id="命名空间" data-numberify>命名空间<a class="anchor ms-1" href="#命名空间"></a></h1>
<p>命名空间（Namespace）是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p>
<p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p>
<p>一般有三种命名空间：</p>
<ol>
<li>
<p><strong>内置名称（built-in names）</strong>：Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</p>
</li>
<li>
<p><strong>全局名称（global names）</strong>：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</p>
</li>
<li>
<p><strong>局部名称（local names）</strong>：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量（类中定义的也是）。</p>
</li>
</ol>
<ul>
<li>
<p>命名空间查找顺序：局部的命名空间 $\rightarrow$ 全局命名空间 $\rightarrow$ 内置命名空间。</p>
</li>
<li>
<p>如果找不到变量，将放弃查找并引发一个 <code>NameError</code> 异常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ne">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s1">&#39;runoob&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</span></span></code></pre></div></li>
<li>
<p>命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p>
</li>
</ul>
<p>因此，无法从外部命名空间访问内部命名空间的对象。</p>
<hr>
<h1 id="作用域" data-numberify>作用域<a class="anchor ms-1" href="#作用域"></a></h1>
<p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。变量的访问权限取决于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有 4 种，分别是：</p>
<ol>
<li>
<p><strong>L（Local）</strong>：最内层，包含局部变量。如一个函数/方法内部。</p>
</li>
<li>
<p><strong>E（Enclosing）</strong>：包含了非局部（non-local）也非全局（non-global）的变量。
如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 non-local。</p>
</li>
<li>
<p><strong>G（Global）</strong>：当前脚本的最外层。如当前模块的全局变量。</p>
</li>
<li>
<p><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等，最后被搜索。</p>
</li>
</ol>
<p>作用域查找顺序： L $\rightarrow$ E $\rightarrow$ G $\rightarrow$ B。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">g_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 全局作用域</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">o_count</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 闭包函数外的函数中</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">i_count</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># 局部作用域</span>
</span></span></code></pre></div><p>内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">builtins</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">builtins</span><span class="p">)</span>
</span></span></code></pre></div><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 <code>if</code>/<code>elif</code>/<code>else</code>、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的：</p>
<hr>
<h2 id="全局变量和局部变量" data-numberify>全局变量和局部变量<a class="anchor ms-1" href="#全局变量和局部变量"></a></h2>
<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p>
<hr>
<h2 id="global和nonlocal" data-numberify>global和nonlocal<a class="anchor ms-1" href="#global和nonlocal"></a></h2>
<p><code>global</code> 和 <code>nonlocal</code> 的作用是让内部作用域修改外部作用域变量。</p>
<p><code>global</code> —— 修改全局变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fun1</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">global</span> <span class="n">num</span>  <span class="c1"># 需要使用 global 关键字声明</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="n">num</span> <span class="o">=</span> <span class="mi">123</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">fun1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 123</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 123</span>
</span></span></code></pre></div><p><code>nonlocal</code> —— 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">nonlocal</span> <span class="n">num</span>   <span class="c1"># nonlocal关键字声明</span>
</span></span><span class="line"><span class="cl">        <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">inner</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">outer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 输出：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 100</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 100</span>
</span></span></code></pre></div><hr>
<p>不使用 <code>global</code> 或 <code>nonlocal</code> 修改外部作用域变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">test</span><span class="p">()</span>
</span></span></code></pre></div><p>结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;test.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">7</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;test.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="ne">UnboundLocalError</span><span class="p">:</span> <span class="n">local</span> <span class="n">variable</span> <span class="s1">&#39;a&#39;</span> <span class="n">referenced</span> <span class="n">before</span> <span class="n">assignment</span>
</span></span></code></pre></div><p>局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。</p>
<hr>
<p>for x in range(1,5)</p>
<p>if x &gt; 2</p>
<p>for y in range(1,4)</p>
<p>if y &lt; 3</p>
<p>x*y</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python 进阶 — 正则表达式篇</title>
      <link>/blog/2022/01/python-%E8%BF%9B%E9%98%B6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/python-%E8%BF%9B%E9%98%B6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87/</guid>
      <description><![CDATA[正则表达式语法 —— Python 正则表达式是一个特殊的字符序列，能方便地检查一个字符串是否与某种模式匹配。 正则表达式可以拼接。 正则表达式可以包含普通或者]]></description>
      <content:encoded><![CDATA[<h1 id="正则表达式语法--python" data-numberify>正则表达式语法 —— Python<a class="anchor ms-1" href="#正则表达式语法--python"></a></h1>
<p>正则表达式是一个特殊的字符序列，能方便地检查一个字符串是否与某种模式匹配。</p>
<ul>
<li>
<p>正则表达式可以拼接。</p>
</li>
<li>
<p>正则表达式可以包含普通或者特殊字符。</p>
<ul>
<li>
<p>绝大部分普通字符，是最简单的正则表达式。它们就匹配自身。</p>
</li>
<li>
<p>特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
</li>
<li>
<p>重复修饰符（<code>*</code>、<code>+</code>、<code>?</code>、<code>{m,n}</code>, 等）不能直接嵌套。避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="特殊字符" data-numberify>特殊字符<a class="anchor ms-1" href="#特殊字符"></a></h2>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>（点）在默认模式，匹配除了换行的任意字符。                                                                                                                                                                                                                                <br>如果指定了标签 <code>DOTALL</code>，它将匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义特殊字符（允许你匹配 <code>'*'</code>、<code>'?'</code>，或者其他正则表达式中使用的特殊字符），或者表示一个特殊序列。</td>
</tr>
<tr>
<td><code>[…]</code></td>
<td>用于表示一个字符集合。<br> 字符可以单独列出：<code>[abc]</code>，匹配 <code>'a'</code>、<code>'b'</code>、<code>'c'</code>。<br>可以表示字符范围，通过用 <code>'-'</code> 将两个字符连起来：<code>[a-z]</code> 将匹配任何小写 ASCII 字符； 可以指定多个范围：<code>[a-zA-Z]</code> 将匹配所有英文字符。 如果 <code>-</code> 进行了转义 （比如 <code>[a-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>'-'</code>。  <br>特殊字符在集合中，失去它的特殊含义：<code>[(+*)]</code> 只会匹配这几个文法字符 <code>'('</code>、<code>'+'</code>、<code>'*'</code> 或 <code>')'</code>。 <br>字符类如 <code>\w</code> 或者 <code>\S</code> 在集合内可以接受，它们可以匹配的字符由 <code>ASCII</code> 或者 <code>LOCALE</code> 模式决定。<br> 不在集合范围内的字符可以通过取反（<code>'^'</code> 作为首字符）来进行匹配：<code>[^a]</code> 将匹配除了 <code>'a'</code> 之外的所有字符。 <code>'^'</code> 如果不在集合首位，就没有特殊含义。<br>在集合内要匹配一个字符 <code>']'</code>，有两种方法，要么将它进行转义，要么就把它放到集合首位（如 <code>[()[]{}]</code> 和 <code>[]()[{}]</code>）。                                                                                      <br>嵌套集合和集合操作支持可能在未来添加。如果有多以的情况发生，将会抛出 <code>FutureWarning</code>。</td>
</tr>
<tr>
<td><code>|</code></td>
<td><code>A|B</code>， <code>A</code> 和 <code>B</code> 可以是任意正则表达式，创建一个正则表达式，匹配 <code>A</code> 或者 <code>B</code>。任意个正则表达式可以用 <code>'|'</code> 连接。它可以在集合或组合内使用。 <code>'|'</code> 操作符绝不贪婪：扫描目标字符串时，由 <code>'|'</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。即，一旦 <code>A</code> 匹配成功， <code>B</code> 就不再进行匹配，即便它能产生一个更好的匹配。 如果要匹配 <code>'|'</code> 字符，使用 <code>|</code>， 或者把它包含在字符集里 <code>[|]</code>。</td>
</tr>
<tr>
<td><code>(…)</code></td>
<td>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="定位符" data-numberify>定位符<a class="anchor ms-1" href="#定位符"></a></h3>
<p>定位符用来描述字符串或单词的边界。</p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>（插入符号）匹配字符串的开头， 并且在 <code>MULTILINE</code> 模式也匹配换行后的首个符号。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串尾或者在字符串尾的换行符的前一个字符，在 <code>MULTILINE</code> 模式下也会匹配换行符之前的文本。<br>在 <code>'foo1\nfoo2\n'</code> 中搜索 <code>foo.$</code>，通常匹配 <code>'foo2'</code>，但在 <code>MULTILINE</code> 模式下可以匹配到 <code>'foo1'</code>。<br> 在 <code>'foo\n'</code> 中搜索 <code>$</code> 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>只匹配字符串的开始。相当于默认模式下的 <code>^</code>。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个单词边界。即，匹配空字符串，但只在单词开始或结尾的位置。<br>通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界。<br>如果使用了 <code>LOCALE</code> 标志，则词的边界由当前语言区域设置。<br> 在字符集合内表示退格（如 <code>[\b]</code>）。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非单词边界匹配。即，匹配除了单词边界外的任何其他位置。<code>\B</code> 是 <code>\b</code> 的取非。<br>如果使用了 <code>LOCALE</code> 标志，则词的边界由当前语言区域设置。</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>只匹配字符串尾。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="重复修饰符限定符" data-numberify>重复修饰符（限定符）<a class="anchor ms-1" href="#重复修饰符限定符"></a></h3>
<ul>
<li>
<p><code>{m}</code></p>
<p>对其之前的正则式指定匹配 m 个重复；少于 m 的话就会导致匹配失败。</p>
</li>
</ul>
<p>贪婪修饰符：</p>
<ul>
<li>
<p><code>*</code></p>
<p>对它前面的正则式匹配 0 到任意次重复， 尽量多地匹配字符串。
等价于：<code>{0,}</code>。</p>
</li>
<li>
<p><code>+</code></p>
<p>对它前面的子表达式匹配 1 到任意次重复， 尽量多地匹配字符串。
等价于：<code>{1,}</code>。</p>
</li>
<li>
<p><code>?</code></p>
<p>对它前面的子表达式匹配 0 到 1 次重复， 尽量多地匹配字符串。
等价于：<code>{0,1}</code>。</p>
</li>
<li>
<p><code>{m,}</code></p>
<p>对它前面的子表达式进行 m 到任意次重复， 尽量多地匹配字符串。</p>
</li>
<li>
<p><code>{m,n}</code>（中间不要有空白字符）</p>
<p>对它前面的子表达式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。</p>
</li>
</ul>
<p>非贪婪修饰符：</p>
<ul>
<li>
<p><code>*?</code>、<code>+?</code>、<code>??</code>、<code>{m,}?</code>、<code>{m,n}?</code>：</p>
<p>在修饰符之后添加 <code>?</code> 将使样式以非贪婪方式，或者 :dfn: 最小方式进行匹配； 尽量少的字符将会被匹配。</p>
</li>
</ul>
<hr>
<h3 id="扩展标记法" data-numberify>扩展标记法<a class="anchor ms-1" href="#扩展标记法"></a></h3>
<ul>
<li>
<p><code>(?…)``'?'</code> 仅跟随 <code>'('</code> 并无含义。<code>'?'</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P&lt;name&gt;...)</code> 是唯一的例外。</p>
</li>
<li>
<p><code>(?aiLmsux)</code></p>
<p>在 <code>(?</code> 后带 <code>'a'</code>、 <code>'i'</code>、<code>'L'</code>、<code>'m'</code>、<code>'s'</code>、<code>'u'</code>、<code>'x'</code> 中的一个或多个。<code>(?aimsx)</code> 将会匹配空字符串。</p>
<p>这些字符代表内联标记（与 <code>re</code> 模块中的 RegexFlag 标志常量对应）。</p>
<ul>
<li>
<p><code>'a'</code> —— <code>re.A</code> 模式；</p>
</li>
<li>
<p><code>'i'</code> —— <code>re.I</code> 模式；</p>
</li>
<li>
<p><code>'L'</code> —— <code>re.L</code> 模式；</p>
</li>
<li>
<p><code>'m'</code> —— <code>re.M</code> 模式；</p>
</li>
<li>
<p><code>'s'</code> —— <code>re.S</code> 模式；</p>
</li>
<li>
<p><code>'u'</code> —— <code>re.U</code> 模式；</p>
</li>
<li>
<p><code>'x'</code> —— <code>re.X</code> 模式。</p>
</li>
</ul>
</li>
<li>
<p><code>(?:…)</code></p>
<p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串不能在执行匹配后被获取或是之后在模式中被引用。</p>
</li>
<li>
<p><code>(?aiLmsux-imsx:…)``'?'</code> 后面 <code>'-'</code> 前面带 <code>'a'</code>、 <code>'i'</code>、<code>'L'</code>、<code>'m'</code>、<code>'s'</code>、<code>'u'</code>、<code>'x'</code> 中的 0 个或多个。<code>'-'</code> 后面 <code>':'</code> 前面带 <code>'i'</code>、<code>'m'</code>、<code>'s'</code>、<code>'x'</code> 中的一到多个。表示设置或者去除（<code>'-'</code> 后指定去除的标记）相应标记。</p>
<p>与 <code>(?aiLmsux)</code> 一样，这些字符分别代表了不同的内联标记。</p>
<p><code>'a'</code>、<code>'L'</code> 和 <code>'u'</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>'-'</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。Python3.7 接受 <code>'a'</code>、<code>'L'</code> 和 <code>'u'</code> 存在于一个组合。
这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。</p>
</li>
<li>
<p><code>(?P&lt;name&gt;…)</code></p>
<p>（命名组合）类似正则组合，但是匹配到的子串组在外部可以通过定义的 <code>name</code> 来获取的（也可以通过数字获取）。组合名必须是有效的 Python 标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。
命名组合可以在三种上下文中引用：</p>
<table>
<thead>
<tr>
<th><strong>引用组合 &ldquo;quote&rdquo; 的上下文</strong></th>
<th><strong>引用方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>在正则式自身内</td>
<td><code>(?P=quote)</code> 或 <code>\1</code></td>
</tr>
<tr>
<td>处理匹配对象 <code>m</code></td>
<td><code>m.group('quote')</code> 或 <code>m.end('quote')</code>（等）</td>
</tr>
<tr>
<td>传递到 <code>re.sub()</code> 里的 <code>repl</code> 参数中</td>
<td><code>\g&lt;quote&gt;</code> 或 <code>\g&lt;1&gt;</code> 或 <code>\1</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>(?P=name)</code></p>
<p>反向引用一个命名组合；它匹配前面名为 <code>name</code> 的命名组中匹配到的串同样的字串（如上所示）。</p>
</li>
<li>
<p><code>(?#…)</code></p>
<p>注释，里面的内容会被忽略。</p>
</li>
<li>
<p><code>(?=…)</code></p>
<p>lookahead assertion，匹配 <code>…</code> 的内容，但是并不消费样式的内容。如，<code>abc(?=def)</code> 当 <code>'abc'</code> 后面是 <code>'def'</code> 的时候，才匹配 <code>'abc'</code>。</p>
</li>
<li>
<p><code>(?!…)</code></p>
<p>negative lookahead assertion（前视取反），匹配 <code>…</code> 不符合的情况。如，<code>abc(?!def)</code> 当 <code>'abc'</code> 后面不是 <code>'def'</code> 的时候，才匹配 <code>'abc'</code>。</p>
</li>
<li>
<p><code>(?&lt;=…)</code></p>
<p>:dfn:positive lookbehind assertion（正向后视断定），匹配字符串的当前位置，它的前面匹配 <code>…</code> 的内容到当前位置。如，<code>(?&lt;=abc)def</code> 当 <code>'def'</code> 前面是 <code>'abc'</code> 时匹配 <code>'def'</code>，该样式是从 <code>'d'</code> 开始往回搜索的。
包含的匹配样式必须是定长的（ <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a{3,4}</code> 不可以）。</p>
</li>
<li>
<p><code>(?&lt;!…)</code></p>
<p>negative lookbehind assertion （后视断定取非），匹配当前位置之前不是 <code>…</code> 的样式。</p>
<p>包含的样式匹配必须是定长的。</p>
<p>由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。</p>
</li>
<li>
<p><code>(?(id/name)yes-pattern|no-pattern)</code></p>
<p>如果给定的 <code>id</code> 或 <code>name</code> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>（<code>no-pattern</code> 可选，可以被忽略）。</p>
</li>
</ul>
<hr>
<h3 id="普通字符" data-numberify>\\+普通字符<a class="anchor ms-1" href="#普通字符"></a></h3>
<p><code>\</code> + （ASCII 数字或字母）：</p>
<table>
<thead>
<tr>
<th><strong>序列</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\number</code></td>
<td>匹配数字代表的组合。每个正则表达式中的括号是一个组合，组合从 <code>1</code> 开始编号。<br> 如：<code>(.+) \1</code> 匹配 <code>'the the'</code> 或者 <code>'55 55'</code>。<br> 这个特殊序列只能用于匹配前面 99 个组合。<br> 如果 <code>number</code> 的第一个数位是 0， 或者 <code>number</code> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>只匹配字符串开始。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>（单词边界定位符）匹配空字符串，但只在单词开始或结尾的位置。<br> 在字符集合内表示退格（如 <code>[\b]</code>）。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>（非单词边界定位符）匹配空字符串，但不能在词的开头或者结尾。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>对于 Unicode（str）样式：<br> 匹配任何 Unicode 十进制数（就是在 Unicode 字符目录 [Nd] 里的字符，包括了 <code>[0-9]</code> ，和很多其他的数字字符）。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[0-9]</code> 。<br> 对于8位（bytes）样式：<br> 匹配任何十进制数（<code>[0-9]</code>）。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任何非十进制数字的字符（<code>\d</code> 取非）。<br> 如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^0-9]</code> 。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>对于 Unicode（str）样式：<br> 匹配任何 Unicode 空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <code>ASCII</code> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。<br>对于8位（bytes）样式：<br> 匹配ASCII中的空白字符（<code>[ \t\n\r\f\v]</code>） 。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符（<code>\s</code> 取非）。<br> 如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>对于 Unicode（str）样式：<br> 匹配 Unicode 词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[a-zA-Z0-9_]</code> 。<br>对于8位（bytes）样式：<br> 匹配 ASCII 字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <code>LOCALE</code> 标记，就匹配当前语言区域的数字和字母和下划线。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符的字符（与 <code>\w</code> 正相反）。<br> 如果使用了 <code>ASCII</code> 标志，就等价于 <code>[^a-zA-Z0-9_]</code>。<br>如果使用了 <code>LOCALE</code> 标志，则会匹配当前区域中既非字母数字也非下划线的字符。</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>只匹配字符串尾。<br>如果普通字符不是 ASCII 数位或者 ASCII 字母，那么正则样式将匹配第二个字符（如，<code>\$</code> 匹配字符 <code>'$'</code>）。</td>
</tr>
</tbody>
</table>
<p>绝大部分 Python 的标准转义字符也被正则表达式分析器支持：</p>
<pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">\a      \b      \f      \n
\N      \r      \t      \u
\U      \v      \x      \\
</code></pre><p><code>'\u'</code>、<code>'\U'</code> 和 <code>'\N'</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<hr>
<h1 id="re-模块" data-numberify>re 模块<a class="anchor ms-1" href="#re-模块"></a></h1>
<p>Python 的 <code>re</code> 模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<hr>
<h2 id="函数" data-numberify>函数<a class="anchor ms-1" href="#函数"></a></h2>
<h3 id="匹配一项" data-numberify>匹配一项<a class="anchor ms-1" href="#匹配一项"></a></h3>
<p>在 <code>re</code> 模块中，有三个函数用于查找并返回一个匹配对象：</p>
<ol>
<li>
<p><code>re.match()</code> —— 返回一个从字符串的起始位置匹配的对象。</p>
</li>
<li>
<p><code>re.search()</code> —— 返回整个字符串中任意位置第一个成功的匹配。</p>
</li>
<li>
<p><code>re.fullmatch()</code> —— 整个字符串与正则表达式完全匹配。</p>
</li>
</ol>
<hr>
<h4 id="match-函数" data-numberify>match() 函数<a class="anchor ms-1" href="#match-函数"></a></h4>
<p><code>re.match()</code> 尝试从字符串的起始位置匹配一个模式，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pattern</code></td>
<td>匹配的正则表达式。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>标志位，用于控制正则表达式的匹配方式。</td>
</tr>
</tbody>
</table>
<p>返回值：</p>
<p>匹配成功，<code>re.match()</code> 函数返回一个匹配对象（<code>Match</code>）；否则返回 <code>None</code>。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>  <span class="c1"># 在起始位置匹配</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="s1">&#39;efg&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>  <span class="c1"># 不在起始位置匹配</span>
</span></span><span class="line"><span class="cl"><span class="kc">None</span>
</span></span></code></pre></div><hr>
<h4 id="search-函数" data-numberify>search() 函数<a class="anchor ms-1" href="#search-函数"></a></h4>
<p><code>re.search()</code> 扫描整个字符串并返回第一个成功的匹配，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>参数用法与 <code>re.match()</code> 类似。匹配成功，<code>re.search()</code> 方法返回一个匹配对象（<code>Match</code>）；否则返回 <code>None</code>。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>  <span class="c1"># 在起始位置匹配</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;efg&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>  <span class="c1"># 不在起始位置匹配</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;efg&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div><hr>
<h4 id="fullmatch-函数" data-numberify>fullmatch() 函数<a class="anchor ms-1" href="#fullmatch-函数"></a></h4>
<p><code>fullmatch()</code> 将整个字符串与正则表达式匹配，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>参数用法与 <code>re.match()</code> 类似。如果 <code>string</code> 与 <code>pattern</code> 完全匹配，那么返回一个匹配对象（<code>Match</code>）；否则返回 <code>None</code>。</p>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>    <span class="c1"># 在起始位置匹配</span>
</span></span><span class="line"><span class="cl"><span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;abcdefg&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>  <span class="c1"># 匹配整个字符串</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;abcdefg&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div><hr>
<h3 id="匹配多项" data-numberify>匹配多项<a class="anchor ms-1" href="#匹配多项"></a></h3>
<p>有两个函数用于查找并返回匹配的多个匹配对象：</p>
<ol>
<li>
<p><code>re.findall</code> —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的列表。</p>
</li>
<li>
<p><code>re.finditer</code> —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的迭代器。</p>
</li>
</ol>
<hr>
<h4 id="finall" data-numberify>finall()<a class="anchor ms-1" href="#finall"></a></h4>
<p><code>finall()</code> 在字符串中找到正则表达式所匹配的所有子串，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pattern</code></td>
<td>匹配的正则表达式。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>标志位，用于控制正则表达式的匹配方式。</td>
</tr>
</tbody>
</table>
<p>返回值：</p>
<p>返回一个列表，包含了所有匹配对象；如果没有任何匹配项，则返回空列表。</p>
<hr>
<h4 id="finditer" data-numberify>finditer()<a class="anchor ms-1" href="#finditer"></a></h4>
<p>与 <code>finall()</code> 类似，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>该函数返回的是迭代器。</p>
<p>如果可能存在大量的匹配项的话，建议使用 <code>finditer()</code>。</p>
<hr>
<h3 id="split-正则分割" data-numberify>split() 正则分割<a class="anchor ms-1" href="#split-正则分割"></a></h3>
<p><code>re.split()</code> 按照能够匹配的子串对字符串进行分割，其语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">[,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></div><p>参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pattern</code></td>
<td>匹配的正则表达式。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td><code>maxsplit</code></td>
<td>最大分割次数，<code>maxsplit=1</code> 分割一次，默认为 <code>0</code>，不限制次数。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>标志位，用于控制正则表达式的匹配方式。</td>
</tr>
</tbody>
</table>
<p>返回值：</p>
<p>返回一个用 <code>patterm</code> 模式匹配的字符分割的字符串列表。如果查找不到任何匹配，则返回一个仅包含 <code>string</code> 的列表。</p>
<p><code>str</code> 模块下也有一个 <code>split()</code> 函数，但它并不支持正则分割。</p>
<hr>
<h3 id="替换" data-numberify>替换<a class="anchor ms-1" href="#替换"></a></h3>
<p>有两个替换函数：<code>re.sub()</code> 和 <code>re.subn()</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pattern</code></td>
<td>匹配的正则表达式。</td>
</tr>
<tr>
<td><code>repl</code></td>
<td>替换内容，可以是字符串，也可以是函数。如果 <code>repl</code> 为函数，只能有一个匹配对象作为参数。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td><code>count</code></td>
<td>最大替换次数。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>标志位，用于控制正则表达式的匹配方式。</td>
</tr>
</tbody>
</table>
<p><code>repl</code> 替换掉 <code>string</code> 中被 <code>pattern</code> 匹配的字符。</p>
<p>返回值：</p>
<p><code>re.sub()</code> 返回一个替换后的字符串。如果 <code>string</code> 中没有任何匹配项，则返回 <code>string</code>。</p>
<p><code>re.subn()</code> 返回一个元组，包含了替换后的字符串和替换次数：<code>(str, n)</code>。</p>
<hr>
<h3 id="excape-转义函数" data-numberify>excape() 转义函数<a class="anchor ms-1" href="#excape-转义函数"></a></h3>
<p><code>re.exvape()</code> 函数可以转义参数 <code>pattern</code> 中的特殊字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">exvape</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
</span></span></code></pre></div><p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span>\<span class="o">.</span><span class="n">python</span>\<span class="o">.</span><span class="n">org</span>
</span></span></code></pre></div><p>Python3.3：<code>_</code> 不再被转义。</p>
<p>Python3.7：只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>!</code>、<code>&quot;</code>、<code>%</code>、<code>'</code>、<code>,</code>、<code>/</code>、<code>:</code>、<code>;</code>&lt;&rsquo;、<code>=</code>&gt;&rsquo;、<code>@</code> 和 ` 将不再会被转义。</p>
<p>使用 <code>re.exvape()</code> 函数很容易出现转义错误的问题，所以并不建议使用它转义。</p>
<hr>
<h3 id="purge-清除正则表达式缓存" data-numberify>purge() 清除正则表达式缓存<a class="anchor ms-1" href="#purge-清除正则表达式缓存"></a></h3>
<p><code>re.purge()</code> 用于清除正则表达式的缓存。它没有参数，没有返回值。</p>
<hr>
<h2 id="regexflag-标志常量" data-numberify>RegexFlag 标志常量<a class="anchor ms-1" href="#regexflag-标志常量"></a></h2>
<ul>
<li>
<p>re.ASCII：</p>
<ul>
<li>
<p>简写：<code>re.A</code>。</p>
</li>
<li>
<p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配 ASCII 编码支持的字符，而不是 Unicode。这只对 Unicode 样式（Python3 默认）有效，会被 byte 样式忽略。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;中文字符和ASCII&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;ASCII&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>对应内联标记：<code>(?a)</code> 。</p>
</li>
</ul>
</li>
<li>
<p>re.DEBUG：</p>
<ul>
<li>
<p>显示编译时的 debug 信息，没有内联标记。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">,</span> <span class="s1">&#39;显示debug信息&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">MAX_REPEAT</span> <span class="mi">0</span> <span class="n">MAXREPEAT</span>
</span></span><span class="line"><span class="cl">  <span class="n">ANY</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;显示debug信息&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>对应内联标记：<code>(?i)</code> 。</p>
</li>
</ul>
</li>
<li>
<p>re.IGNORECASE：</p>
<ul>
<li>
<p>简写：<code>re.I</code>。</p>
</li>
<li>
<p>进行忽略大小写匹配。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-z]&#39;</span><span class="p">,</span> <span class="s1">&#39;大写字母：ABCDE 小写字母：abcde&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>re.LOCALE：</p>
<ul>
<li>
<p>简写：<code>re.L</code>。</p>
</li>
<li>
<p>语言依赖，由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对 byte 样式有效。这个标记官方并不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对 8 位字节有效。</p>
</li>
<li>
<p>对应内联标记：<code>(?L)</code> 。</p>
</li>
</ul>
</li>
<li>
<p>re.MULTILINE：</p>
<ul>
<li>
<p>简写：<code>re.M</code>。</p>
</li>
<li>
<p>多行模式，样式字符 <code>'^'</code> 匹配每一个行开始（字符串的开始和换行符后紧跟的符号）；样式字符 <code>'$'</code> 匹配每一个行结尾（字符串结尾和换行符前面的符号）。</p>
<p>默认情况下不支持换行符特性，<code>'^'</code> 匹配字符串开始，<code>'$'</code> 匹配字符串结尾。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^.*$&#39;</span><span class="p">,</span> <span class="s1">&#39;第1行</span><span class="se">\n</span><span class="s1">第2行</span><span class="se">\n</span><span class="s1">第3行&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;第1行&#39;</span><span class="p">,</span> <span class="s1">&#39;第2行&#39;</span><span class="p">,</span> <span class="s1">&#39;第3行&#39;</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>对应内联标记：<code>(?m)</code>。</p>
</li>
</ul>
</li>
<li>
<p>re.DOTALL：</p>
<ul>
<li>
<p>简写：<code>re.S</code>。</p>
</li>
<li>
<p>让 <code>'.'</code> 特殊字符匹配全部字符，包括换行符。</p>
<p>默认情况下，<code>'.'</code> 仅匹配除了换行符的其他任意字符。</p>
</li>
<li>
<p>对应内联标记：<code>(?s)</code> 。</p>
</li>
</ul>
</li>
<li>
<p>re.VERBOSE：</p>
<ul>
<li>
<p>简写：<code>re.X</code>。</p>
</li>
<li>
<p>冗长模式，允许在正则表达式中换行和添加注释。
该模式下空白符号会被忽略，除非在一个字符集合中或者由反斜杠转义，或者在 <code>*?</code>、<code>(?:</code>、<code>(?P&lt;…&gt;</code> 分组之内。
当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&#39;&#39;\d +  # the integral part
</span></span></span><span class="line"><span class="cl"><span class="s1">...               \.    # the decimal point
</span></span></span><span class="line"><span class="cl"><span class="s1">...               \d *  # some fractional digits&#39;&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>           <span class="s1">&#39;圆周率：3.14&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;3.14&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>对应内联标记：<code>(?x)</code> 。</p>
</li>
</ul>
</li>
<li>
<p>re.UNICODE：</p>
<ul>
<li>
<p>简写：<code>re.U</code>。</p>
</li>
<li>
<p>匹配 Unicode 编码支持的字符，是 Python3 默认的字符串模式。虽然保留着，但对 Python3 来说是个冗余的常量。</p>
</li>
</ul>
</li>
<li>
<p>re.TEMPLATE：</p>
<ul>
<li>
<p>简写：<code>re.T</code>。</p>
</li>
<li>
<p><code>re</code> 模块的源码是这样描述该常量的（官方文档中并没有具体的描述）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">TEMPLATE</span> <span class="o">=</span> <span class="n">T</span> <span class="o">=</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">SRE_FLAG_TEMPLATE</span> <span class="c1"># disable backtracking</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<hr>
<h2 id="正则对象-pattern" data-numberify>正则对象 Pattern<a class="anchor ms-1" href="#正则对象-pattern"></a></h2>
<p>使用 <code>compile()</code> 和 <code>template()</code> 可以将正则表达式编译为正则表达式对象（Pattern，正则对象）。</p>
<p><code>re.compile()</code> 的语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pattern</code></td>
<td>要转化为正则对象的正则表达式。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>标志位，用于控制正则表达式的匹配方式。 可以通过位的 OR（<code>'|'</code>）操作来结合多个模式。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">pattern_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;abcdefg&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">_sre</span><span class="o">.</span><span class="n">SRE_Match</span> <span class="nb">object</span><span class="p">;</span> <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="k">match</span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="o">&gt;</span>
</span></span></code></pre></div><p>使用正则对象和函数：</p>
<ol>
<li>
<p>正则对象和函数是一致的。</p>
<p>模块的底层实现中，<code>re.compile()</code> 与其他 <code>re</code> 函数内部调用的是同一个函数 <code>re._compile()</code>。</p>
</li>
<li>
<p>如果需要多次使用某个正则表达式的话，使用 <code>re.compile()</code> 和保存这个正则对象以便复用，可以让程序更加高效。通过 <code>re.compile()</code> 编译后的样式，和模块级的函数会被缓存。</p>
</li>
</ol>
<hr>
<h3 id="正则对象方法" data-numberify>正则对象方法<a class="anchor ms-1" href="#正则对象方法"></a></h3>
<p>正则对象支持以下方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Pattern.search(string[, pos[, endpos]])</code></td>
<td>扫描整个 <code>string</code> 寻找第一个匹配的位置， 并返回一个相应的匹配对象（<code>Match</code>）。如果没有匹配，就返回 <code>None</code>。<br><code>pos</code> —— 字符串中开始搜索的位置索引，默认为 <code>0</code>，它不完全等价于字符串切片。<code>^</code> 样式字符匹配行开头，但不会匹配索引规定开始的位置。<br><code>endpos</code> —— 字符串搜索的结束。只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。<br>如果 <code>endpos</code> 小于 <code>pos</code>，就不会有匹配产生。<br>pattern_obj.search(string, 0, 50)<code>等价于</code>pattern_obj.search(string[:50], 0)`。</td>
</tr>
<tr>
<td><code>Pattern.match(string[, pos[, endpos]])</code></td>
<td>如果 <code>string</code> 的开始位置能够找到这个正则样式 <code>Pattern</code> 的任意个匹配，就返回一个相应的匹配对象（<code>Match</code>）。如果不匹配，就返回 <code>None</code>。<br>可选参数 <code>pos</code> 和 <code>endpos</code> 指定 <code>string</code> 的查找范围，与 <code>Pattern.search()</code> 含义相同。</td>
</tr>
<tr>
<td><code>Pattern.fullmatch(string[, pos[, endpos]])</code></td>
<td>如果整个 <code>string</code> 匹配这个正则表达式，就返回一个相应的匹配对象（<code>Match</code>）。如果不匹配，就返回 <code>None</code>。<br>可选参数 <code>pos</code> 和 <code>endpos</code> 指定 <code>string</code> 的查找范围。</td>
</tr>
<tr>
<td><code>Pattern.findall(string[, pos[, endpos]])</code></td>
<td>类似 <code>re.findall()</code>，使用了编译后样式，在 <code>string</code> 中找到 <code>Pattern</code> 所匹配的所有子串，以列表形式返回所有匹配项。<br>可选参数 <code>pos</code> 和 <code>endpos</code> 指定 <code>string</code> 的查找范围。</td>
</tr>
<tr>
<td><code>Pattern.finditer(string[, pos[, endpos]])</code></td>
<td>类似函数 <code>finiter()</code> ， 使用了编译后样式，在 <code>string</code> 中找到 <code>Pattern</code> 所匹配的所有子串，以迭代器形式返回所有匹配项。<br>可选参数 <code>pos</code> 和 <code>endpos</code> 指定 <code>string</code> 的查找范围。</td>
</tr>
<tr>
<td><code>Pattern.split(string, maxsplit=0)</code></td>
<td>等价于 <code>split()</code> 函数，使用了编译后的样式，按照能够匹配的子串对字符串进行分割。<br> <code>maxsplit</code> —— 最大分割次数。</td>
</tr>
<tr>
<td><code>Pattern.sub(repl, string, count=0)</code></td>
<td>等价于 <code>sub()</code> 函数，使用了编译后的样式，使用 <code>repl</code> 替换掉 <code>string</code> 中被 <code>Pattern</code> 匹配的字符。<br><code>count</code> —— 最大替换次数。<br>返回一个替换后的字符串。如果 <code>string</code> 中没有任何匹配项，则返回 <code>string</code>。</td>
</tr>
<tr>
<td><code>Pattern.subn(repl, string, count=0)</code></td>
<td>等价于 <code>subn()</code> 函数，使用了编译后的样式，使用 <code>repl</code> 替换掉 <code>string</code> 中被 <code>Pattern</code> 匹配的字符。<br><code>count</code> —— 最大替换次数。<br>返回一个元组，包含了替换后的字符串和替换次数。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="正则对象属性" data-numberify>正则对象属性<a class="anchor ms-1" href="#正则对象属性"></a></h3>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Pattern.flags</code></td>
<td>正则匹配标记。<br>可以传递给 <code>compile()</code> 的参数。任何 <code>(?…)</code> 内联标记，隐性标记（<code>re.U</code>）的结合。</td>
</tr>
<tr>
<td><code>Pattern.groups</code></td>
<td>捕获到的模式串中组的数量。</td>
</tr>
<tr>
<td><code>Pattern.groupindex</code></td>
<td>映射由 <code>(?P&lt;id&gt;)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</td>
</tr>
<tr>
<td><code>Pattern.pattern</code></td>
<td>编译对象的原始样式字符串。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="匹配对象" data-numberify>匹配对象<a class="anchor ms-1" href="#匹配对象"></a></h2>
<p>匹配对象（Match）是调用 <code>re</code> 模块中的函数或方法匹配后返回的对象。</p>
<p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <code>re.match()</code> 和 <code>re.search()</code> 返回 <code>None</code>。可以简单的用 <code>if</code> 语句来判断是否匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span> <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span></code></pre></div><hr>
<h3 id="匹配对象方法" data-numberify>匹配对象方法<a class="anchor ms-1" href="#匹配对象方法"></a></h3>
<p>匹配对象支持以下方法：</p>
<ul>
<li>
<p><code>Match.expand(template)</code>：</p>
<ul>
<li>对 <code>template</code> 进行反斜杠（<code>'\'</code>）转义替换并且返回。</li>
</ul>
</li>
<li>
<p><code>Match.group([group1, ...])</code>：</p>
<ul>
<li>
<p>返回一个或者多个匹配的子组。</p>
</li>
<li>
<p>如果只有一个参数，结果就是一个字符串；
如果有多个参数，结果就是一个元组（每个参数对应一个项）；
如果没有参数，<code>group1</code> 默认为 <code>0</code>（整个匹配都被返回）。</p>
</li>
<li>
<p>如果一个 <code>groupN</code> 参数值为 <code>0</code>，相应的返回值就是整个匹配字符串；
如果它是一个范围 [1..99]，结果就是相应的括号组字符串。</p>
</li>
<li>
<p>如果一个组号是负数，或者大于样式中定义的组数，会抛出一个 <code>IndexError</code>。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+) (\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Python PHP Java C++&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>    <span class="c1"># 返回整个匹配</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Python PHP&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># 返回第一个括号组</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Python&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="c1"># 返回第二个括号组</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;PHP&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 多个参数返回一个元组</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;PHP&#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>如果正则表达式使用了 <code>(?P&lt;name&gt;…)</code> 语法， <code>groupN</code> 参数可以是索引值，也可以是组名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;name_1&gt;\w+) (?P&lt;name_2&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Python PHP&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;name_1&#39;</span><span class="p">,</span> <span class="s1">&#39;name_2&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;PHP&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;PHP&#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(..)+&#39;</span><span class="p">,</span> <span class="s1">&#39;a1b2c3&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;c3&#39;</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>Match.getitem(g)</code>：</p>
<ul>
<li>
<p>Python3.6 新增功能。</p>
</li>
<li>
<p>等价于 <code>m.group(g)</code>，允许更方便地引用一个匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;name_1&gt;\w+) (?P&lt;name_2&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Python PHP&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Python PHP&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Python&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;PHP&#39;</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>Match.groups(default=None)</code>：</p>
<ul>
<li>
<p>返回一个元组，包含所有匹配的子组，在样式中出现的从 1 到任意多的组合。<code>default</code> 参数用于不参与匹配的情况，默认为 <code>None</code>。</p>
</li>
<li>
<p>Example：
使小数部分可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <code>default</code> 参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)\.(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;14&#39;</span><span class="p">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;(\d+)\.?(\d+)?&#34;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>    <span class="c1"># 第二个子组默认为 None</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># 第二个子组被设置为指定的默认值 &#39;0&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>Match.groupdict(default=None)</code>：</p>
<ul>
<li>
<p>返回一个字典，包含了所有的命名子组。key 就是组名。 <code>default</code> 参数用于不参与匹配的组合；默认为 <code>None</code>。</p>
</li>
<li>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;name_1&gt;\w+) (?P&lt;name_2&gt;\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Python PHP&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;name_1&#39;</span><span class="p">:</span> <span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="s1">&#39;name_2&#39;</span><span class="p">:</span> <span class="s1">&#39;PHP&#39;</span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>Match.start([group])</code> 和 <code>Match.end([group])</code>：</p>
<ul>
<li>
<p>返回 <code>group</code> 匹配到的字串在原字符串的开始和结束索引。<code>group</code> 默认为 <code>0</code>（意思是整个匹配的子串）。如果 <code>group</code> 存在，但未产生匹配，就返回 <code>-1</code> 。</p>
</li>
<li>
<p>从 email 地址中移除掉 <code>remove_this</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">email</span> <span class="o">=</span> <span class="s2">&#34;tony@tiremove_thisger.net&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&#34;remove_this&#34;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;tony@tiger.net&#39;</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>Match.span([group])</code>：</p>
<ul>
<li>对于一个匹配 <code>m</code> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。
如果 <code>group</code> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。
<code>group</code> 默认为 <code>0</code>，就是整个匹配。</li>
</ul>
</li>
</ul>
<hr>
]]></content:encoded>
    </item>
    
    <item>
      <title>vbs 后台运行 bat</title>
      <link>/blog/2022/01/vbs-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-bat/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/vbs-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C-bat/</guid>
      <description><![CDATA[假设有三个 bat 程序需要后台运行（称为 A.bat、B.bat、C.bat）： Set ws = CreateObject(&#34;Wscript.Shell&#34;) ws.run &#34;cmd /c A.bat&#34;,0 ws.run &#34;cmd /c B.bat&#34;,0 ws.run &#34;cmd /c C.bat&#34;,0]]></description>
      <content:encoded><![CDATA[<p>假设有三个 bat 程序需要后台运行（称为 <code>A.bat</code>、<code>B.bat</code>、<code>C.bat</code>）：</p>
<pre tabindex="0"><code class="language-vbs" data-lang="vbs">Set ws = CreateObject(&#34;Wscript.Shell&#34;)
ws.run &#34;cmd /c A.bat&#34;,0
ws.run &#34;cmd /c B.bat&#34;,0
ws.run &#34;cmd /c C.bat&#34;,0
</code></pre>]]></content:encoded>
    </item>
    
    <item>
      <title>经典排序算法</title>
      <link>/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description><![CDATA[冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 时间复]]></description>
      <content:encoded><![CDATA[<h1 id="冒泡排序" data-numberify>冒泡排序<a class="anchor ms-1" href="#冒泡排序"></a></h1>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>时间复杂度：$O(n^2)$</p>
<h2 id="算法步骤" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤"></a></h2>
<p>假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。</p>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。</p>
</li>
<li>
<p>对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。</p>
<p>第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。</p>
</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172310783.gif" loading="lazy" width="826" height="257" />
</picture>

</p>
<h2 id="代码实现" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现"></a></h2>
<h3 id="python实现" data-numberify>Python实现<a class="anchor ms-1" href="#python实现"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现" data-numberify>C实现<a class="anchor ms-1" href="#c实现"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="优化算法" data-numberify>优化算法<a class="anchor ms-1" href="#优化算法"></a></h2>
<h3 id="有序标志" data-numberify>有序标志<a class="anchor ms-1" href="#有序标志"></a></h3>
<p>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
<ul>
<li>
<p>Python实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 有序flag，初始为True</span>
</span></span><span class="line"><span class="cl">        <span class="n">isSorted</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 发生交换，序列定为无序</span>
</span></span><span class="line"><span class="cl">                <span class="n">isSorted</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 序列有序，停止循环</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">isSorted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>C实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 有序flag，初始为True
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="n">isSorted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 发生交换，序列定为无序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">isSorted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 序列有序，停止循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isSorted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="数列有序区" data-numberify>数列有序区<a class="anchor ms-1" href="#数列有序区"></a></h3>
<p>通常，有序区的长度和排序的轮数是相等的。如，第一轮排序后的有序区长度是1，第二轮排序后是2 ……</p>
<p>但实际上，数列的有序区长度可能会大于这个长度，并且每轮增加的有序区长度也不一定仅为1。</p>
<p>该优化算法解决了这个问题，通过在每一轮排序的最后，记录下最后一次元素交换的位置（该位置也就是无序数列的边界，再往后就是有序区），而每轮的交换只要交换到无序区边界。</p>
<ul>
<li>
<p>Python实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 无序数列的边界</span>
</span></span><span class="line"><span class="cl">    <span class="n">sortBorder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 有序flag，初始为True</span>
</span></span><span class="line"><span class="cl">        <span class="n">isSorted</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 每次仅需交换到无序区边界</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sortBorder</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 把无序数列的边界更新为最后一次交换元素的位置</span>
</span></span><span class="line"><span class="cl">                <span class="n">sortBorder</span> <span class="o">=</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 发生交换，序列定为无序</span>
</span></span><span class="line"><span class="cl">                <span class="n">isSorted</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 序列有序，停止循环</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">isSorted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">89</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>C实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sortBorder</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 有序flag，初始为True
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="n">isSorted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 把无序数列的边界更新为最后一次交换元素的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">sortBorder</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 发生交换，序列定为无序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">isSorted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 序列有序，停止循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isSorted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
<hr>
<h1 id="选择排序" data-numberify>选择排序<a class="anchor ms-1" href="#选择排序"></a></h1>
<p>选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。</p>
<h2 id="算法步骤-1" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-1"></a></h2>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复步骤2，直到所有元素均排序完毕。</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172350447.gif" loading="lazy" width="811" height="248" />
</picture>

</p>
<h2 id="代码实现-1" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-1"></a></h2>
<h3 id="python实现-1" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-1"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 记录最小数的索引</span>
</span></span><span class="line"><span class="cl">        <span class="n">minIndex</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">minIndex</span> <span class="o">=</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># i 不是最小数时，将 i 和最小数进行交换</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">minIndex</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">minIndex</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="n">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-1" data-numberify>C实现<a class="anchor ms-1" href="#c实现-1"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>     <span class="c1">// 走访未排序的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 找到最小值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// i 不是最小数时，将 i 和最小数进行交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="插入排序" data-numberify>插入排序<a class="anchor ms-1" href="#插入排序"></a></h1>
<p>插入排序（Insertion Sort）是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序的有一种优化算法，叫做拆半插入。</p>
<h2 id="算法步骤-2" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-2"></a></h2>
<p>假设序列的长度为$n$，其待排序序列第一个元素的位置为$m$（$1 \le m \le n$，元素位置从0开始）。</p>
<ol>
<li>
<p>将元素$m$与已排序序列中的每个元素进行比较。如果已排序元素比元素$m$大，将元素$m$中比已排序序列大的元素往后移，直到前面没有比元素$m$大的元素（或前面已经没有元素）。将元素m插入。</p>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p>
</li>
<li>
<p>从头到尾依次扫描未排序序列，直到没有未排序元素。</p>
</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172376035.gif" loading="lazy" width="811" height="505" />
</picture>

</p>
<h2 id="代码实现-2" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-2"></a></h2>
<h3 id="python实现-2" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-2"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">preIndex</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 找出要插入的位置</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">preIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">preIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 将比current大的元素往后移</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">preIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">preIndex</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">preIndex</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 将current插入到适当的位置</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">preIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-2" data-numberify>C实现<a class="anchor ms-1" href="#c实现-2"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="希尔排序" data-numberify>希尔排序<a class="anchor ms-1" href="#希尔排序"></a></h1>
<h2 id="算法步骤-3" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-3"></a></h2>
<p>希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的增量序列根据增量分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h2 id="算法步骤-4" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-4"></a></h2>
<ol>
<li>选择一个增量序列$t_1,t_2,&hellip;,t_k$，其中$t_i &lt; t_{i-1}(1 \le i \le k),t_k = 1$；</li>
<li>按增量序列个数$k$，对序列进行$k$趟排序；</li>
<li>每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172408969.gif" loading="lazy" width="277" height="344" />
</picture>

</p>
<p>详细过程（引用自博客：<a href="https://blog.csdn.net/weixin_43715360/article/details/120140579" title="一个很懒的人" target="_blank" rel="noopener noreferrer">一个很懒的人<i class="fas fa-external-link-square-alt ms-1"></i></a>）：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/ff8014a4eddb45289d60ec4552cf2ea8.png" loading="lazy" width="1328" height="869" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9ad210308fdd44f9931f5717561db7aa.png" loading="lazy" width="1117" height="419" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/82e279c4fccb459ca4119d6385657eb6.png" loading="lazy" width="1206" height="200" />
</picture>

</p>
<h2 id="代码实现-3" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-3"></a></h2>
<h3 id="python实现-3" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-3"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">shellSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将增量d初始化为len(arr)//2</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 分别用插入排序排序每个以d为增量的分组</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">d</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">-=</span> <span class="n">d</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 每次将增量d缩小1/2</span>
</span></span><span class="line"><span class="cl">        <span class="n">d</span> <span class="o">//=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">shellSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-3" data-numberify>C实现<a class="anchor ms-1" href="#c实现-3"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shellSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将增量d初始化为len/2，每次将增量d缩小1/2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 分别用插入排序排序每个以d为增量的分组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">d</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">shellSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="归并排序" data-numberify>归并排序<a class="anchor ms-1" href="#归并排序"></a></h1>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归；</li>
<li>自下而上的迭代。</li>
</ol>
<h2 id="算法步骤-5" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-5"></a></h2>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172440073.gif" loading="lazy" width="811" height="505" />
</picture>

</p>
<p>图片演示：</p>
<ol>
<li>
<p>递归演示：</p>
<p><picture><img class="img-fluid " alt="" src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-5066-20161218163120151-452283750.png" loading="lazy" />
</picture>

</p>
</li>
<li>
<p>合并演示：</p>
<p><picture><img class="img-fluid " alt="" src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-2034-20161218194508761-468169540.png" loading="lazy" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-7614-20161218194621308-588010220.png" loading="lazy" />
</picture>

</p>
</li>
</ol>
<h2 id="代码实现-4" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-4"></a></h2>
<h3 id="python-实现" data-numberify>Python 实现<a class="anchor ms-1" href="#python-实现"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 结束递归</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算中间位置下标</span>
</span></span><span class="line"><span class="cl">    <span class="n">middle</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将序列切分为两半</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="n">middle</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 进行归并排序</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">mergeSort</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># 将较小的元素放在前面</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将某一序列中剩下的元素全部放入</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">left</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-4" data-numberify>C实现<a class="anchor ms-1" href="#c实现-4"></a></h3>
<p>非递归实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分为约log_2(len)次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">seg</span> <span class="o">+=</span> <span class="n">seg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 每次对下标区间为[low,high)的子序列进行归并排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">seg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前排序区间：[low,high)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">seg</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                <span class="n">high</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 第1段：[low,mid)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">low</span><span class="p">,</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 第2段：[mid,high)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对子序列进行归并排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将两个序列中较小的放在前面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">start2</span> <span class="o">&lt;</span> <span class="n">end2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">start2</span><span class="p">]</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">a</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将某一序列中剩下的元素全部放入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;</span> <span class="n">end1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&lt;</span> <span class="n">end2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>递归实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge_sort_recursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 结束递归
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前排序区间：[start,end]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第1段：[start,mid]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第2段：[mid+1,end]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对第1段进行递归地排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对第2段进行递归地排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="p">]</span> <span class="o">?</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="快速排序" data-numberify>快速排序<a class="anchor ms-1" href="#快速排序"></a></h1>
<p>快速排序在平均状况下，排序$n$个项目是$O(n\log {n})$。最坏运行情况是$O(n^2)$，但这种状况并不常见，比如说数列为顺序数列的情况下。一般，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<p>事实上，快速排序通常明显比其他$O(n\log {n})$算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<h2 id="算法步骤-6" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-6"></a></h2>
<ol>
<li>从序列中选择一个元素作为“基准”（pivot）。</li>
<li>将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。</li>
<li>分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。</li>
<li>分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）执行1~3操作。</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172485719.gif" loading="lazy" width="811" height="252" />
</picture>

</p>
<h2 id="代码实现-5" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-5"></a></h2>
<h3 id="python实现-4" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-4"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 设置基准</span>
</span></span><span class="line"><span class="cl">    <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 索引从基准的下一个元素开始</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 遍历:[index,right]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 将小于基准值的元素全部放到左边</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将基准归位</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 此时index位置上的是比基准值大的元素</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 或者等于right+1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 即1&lt;=index&lt;=right+1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 只有index-1才是基准真正的位置</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 设定参数值</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">else</span> <span class="n">left</span>
</span></span><span class="line"><span class="cl">    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> \
</span></span><span class="line"><span class="cl">        <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">else</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 先进行“治”操作并取得分区索引</span>
</span></span><span class="line"><span class="cl">        <span class="n">partitionIndex</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 分别对左右两个分区递归地进行快速排序</span>
</span></span><span class="line"><span class="cl">        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">partitionIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">partitionIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-5" data-numberify>C实现<a class="anchor ms-1" href="#c实现-5"></a></h3>
<p>递归实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">quick_sort_recursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先从右边起找出比基准小的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把比基准小的放到基准左边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 再从左边起找出比基准大的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 把比基准大的放到基准右边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将基准归位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分别递归地排序左右两个分区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">quick_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">quick_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">quick_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>非递归实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_stack</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Range</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 申请一个新的栈元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Range</span> <span class="nf">new_Range</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Range</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// s模拟栈，p为数量，r[p++]为push，r[--p]为pop0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Range</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">Range</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Range</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 范围为[0,len-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pop出当前要排序的范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Range</span> <span class="n">range</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">--</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 设置基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 先从右边起找出比基准小的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">right</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 把比基准小的放到基准左边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 再从左边起找出比基准大的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 把比基准大的放到基准右边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将基准归位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 分别设置左右两个分区的范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_Range</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_Range</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="堆排序" data-numberify>堆排序<a class="anchor ms-1" href="#堆排序"></a></h1>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p>
<p>堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<p>堆排序是不稳定的。</p>
<h2 id="算法步骤-7" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-7"></a></h2>
<ol>
<li>
<p>将待排序的数组构造出一个堆 <code>H[0……n-1]</code>；</p>
</li>
<li>
<p>把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；</p>
<p>此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。</p>
</li>
<li>
<p>把新的数组顶端数据调整到相应位置；</p>
</li>
<li>
<p>重复步骤 2~3，直到堆的尺寸为 1。</p>
</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172508258.gif" loading="lazy" width="547" height="364" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" loading="lazy" />
</picture>

</p>
<h2 id="代码实现-6" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-6"></a></h2>
<h3 id="python实现-5" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-5"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 子结点</span>
</span></span><span class="line"><span class="cl">    <span class="n">son</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 最大值元素位置</span>
</span></span><span class="line"><span class="cl">    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将最大值置为堆顶结点</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">son</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">son</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">largest</span> <span class="o">=</span> <span class="n">son</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 重新构造子堆</span>
</span></span><span class="line"><span class="cl">            <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># int(len(arr)/2)递减至0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">heapSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">global</span> <span class="n">arrLen</span>
</span></span><span class="line"><span class="cl">    <span class="n">arrLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 构造堆</span>
</span></span><span class="line"><span class="cl">    <span class="n">buildMaxHeap</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># len(arr)-1递减至1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 交换堆顶和最下层最右元素</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 将原堆顶移出并重新调整堆</span>
</span></span><span class="line"><span class="cl">        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">heapSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-6" data-numberify>C实现<a class="anchor ms-1" href="#c实现-6"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">son</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最大值元素位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将最大值置为堆顶结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">son</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">son</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">largest</span> <span class="o">=</span> <span class="n">son</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 重新构造子堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 交换堆顶和最下层最右元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将原堆顶移出并重新调整堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">heapSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="计数排序" data-numberify>计数排序<a class="anchor ms-1" href="#计数排序"></a></h1>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<h2 id="算法步骤-8" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-8"></a></h2>
<ol>
<li>找出待排序的数组中最大和最小的元素。</li>
<li>统计数组中每个值为 <code>i</code>的元素出现的次数，存入数组 <code>C</code>的第 <code>i</code>项。</li>
<li>对所有的计数累加（从 <code>C</code>中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素 <code>i</code>放在新数组的第 <code>C(i)</code> 项，每放一个元素就将 <code>C(i)</code> 减去 <code>1</code>。</li>
</ol>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="" src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" loading="lazy" />
</picture>

</p>
<h2 id="代码实现-7" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-7"></a></h2>
<h3 id="python实现-6" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-6"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">countingSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 找出最大值</span>
</span></span><span class="line"><span class="cl">    <span class="nb">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 构建一个长度为max+1的数组</span>
</span></span><span class="line"><span class="cl">    <span class="n">bucket</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计数</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 反向填充</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bucket</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">            <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">countingSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-7" data-numberify>C实现<a class="anchor ms-1" href="#c实现-7"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">countingSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 找出最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造和初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">bucketLen</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">bucket</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">bucketLen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucketLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bucketLen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 反向填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucketLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">countingSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="桶排序" data-numberify>桶排序<a class="anchor ms-1" href="#桶排序"></a></h1>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<ul>
<li>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</li>
<li>最慢的情况：当输入的数据被分配到了同一个桶中。</li>
</ul>
<h2 id="算法步骤-9" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-9"></a></h2>
<ol>
<li>
<p>将数列中的数均匀地分布到每个桶中（有时候并不是均匀分布）。</p>
</li>
<li>
<p>将每个桶中的数进行排序。</p>
<p>这里的排序可以使用桶排序也可以使用其它方法排序。</p>
</li>
<li>
<p>按照顺序将所有桶中的数据取出。</p>
</li>
</ol>
<p>图片演示：</p>
<p>将元素分布在桶中：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172566530.png" loading="lazy" width="311" height="131" />
</picture>

</p>
<p>元素在每个桶中排序：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1662172573696.png" loading="lazy" width="311" height="131" />
</picture>

</p>
<h2 id="代码实现-8" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-8"></a></h2>
<h3 id="python实现-7" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-7"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">quick_sort</span> <span class="kn">import</span> <span class="n">quickSort</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bucketSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bucketsize</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bucketsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 确定最大最小值</span>
</span></span><span class="line"><span class="cl">    <span class="n">maxValue</span> <span class="o">=</span> <span class="n">minValue</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">minValue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">minValue</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">maxValue</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxValue</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 桶数量</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxValue</span> <span class="o">-</span> <span class="n">minValue</span><span class="p">)</span> <span class="o">//</span> <span class="n">bucketsize</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 对应的桶</span>
</span></span><span class="line"><span class="cl">    <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1"># 把数据放入相应的桶</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">minValue</span><span class="p">)</span> <span class="o">//</span> <span class="n">bucketsize</span>
</span></span><span class="line"><span class="cl">        <span class="n">buckets</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1"># 桶内排序并合并数据</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 桶排序</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># bucketSort(j, bucketsize-1)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 快速排序</span>
</span></span><span class="line"><span class="cl">            <span class="n">quickSort</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 还可以换其它方法排序</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">bucketSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-8" data-numberify>C实现<a class="anchor ms-1" href="#c实现-8"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_list</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">bucket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">List</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">append</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">[</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">((</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span><span class="p">[</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bucketSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bucketsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 确定最大最小值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">min</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 桶数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bucketsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对应的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">List</span><span class="o">*</span> <span class="n">buckets</span> <span class="o">=</span> <span class="p">(</span><span class="n">List</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">List</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bucket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 方案一：动态数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 把数据放入相应的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bucketsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 方案二：二维数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// int* size = (int*)malloc(count * sizeof(int));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// // 计算最大宽度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for (int i = 0; i &lt; count; i++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     size[i] = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for (int i = 0; i &lt; len; i++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     size[(arr[i] - min) / bucketsize]++;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// int maxSize = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for (int i = 0; i &lt; count; i++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     if (size[i] &gt; maxSize)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         maxSize = size[i];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// // 把数据放入相应的桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for (int i = 0; i &lt; len; i++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     int index = (arr[i] - min) / bucketsize;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     if (!buckets[index].len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         buckets[index].bucket = (int*)malloc(maxSize * sizeof(int));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     buckets[index].bucket[buckets[index].len++] = arr[i];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// free(size);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 桶内快排并合并数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">quickSort</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bucket</span><span class="p">,</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bucket</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">index</span> <span class="o">+=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">free</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bucket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bucket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">buckets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bucketSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<h1 id="基数排序" data-numberify>基数排序<a class="anchor ms-1" href="#基数排序"></a></h1>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序还可以用于其它数据类型的排序（但其本质上还是整型，如字符型）。</p>
<p>基数排序用到了桶的概念，是桶排序的扩展，它是根据键值的每位数字来分配桶。</p>
<h2 id="算法步骤-10" data-numberify>算法步骤<a class="anchor ms-1" href="#算法步骤-10"></a></h2>
<p>有两类基数排序：</p>
<ol>
<li>最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列；</li>
<li>最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位。</li>
</ol>
<blockquote>
<p>📌如果位没有数的话，补0。</p>
</blockquote>
<p>动画演示：</p>
<p><picture><img class="img-fluid " alt="LSD基数排序演示" src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" loading="lazy" />
</picture>

</p>
<h2 id="代码实现-9" data-numberify>代码实现<a class="anchor ms-1" href="#代码实现-9"></a></h2>
<h3 id="python实现-8" data-numberify>Python实现<a class="anchor ms-1" href="#python实现-8"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">getBit</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">//</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">getMax</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">max</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">radixSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 获取最大值</span>
</span></span><span class="line"><span class="cl">    <span class="nb">max</span> <span class="o">=</span> <span class="n">getMax</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 根据最大位数排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">max</span> <span class="o">//</span> <span class="n">index</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 桶排序</span>
</span></span><span class="line"><span class="cl">        <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">bit_num</span> <span class="o">=</span> <span class="n">getBit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">buckets</span><span class="p">[</span><span class="n">bit_num</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span> <span class="o">*=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">radixSort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="c实现-9" data-numberify>C实现<a class="anchor ms-1" href="#c实现-9"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_list</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">bucket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">List</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">append</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">[</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">((</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span><span class="p">[</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pl</span><span class="o">-&gt;</span><span class="n">bucket</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getBit</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">radixSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据最大位数排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 方案一：动态数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">max</span> <span class="o">/</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 桶排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">List</span> <span class="n">buckets</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">append</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="nf">getBit</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">)],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">arr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bucket</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">index</span> <span class="o">+=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nf">free</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bucket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bucket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 方案二：二维数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// for (int i = 1; max / i; i *= 10)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     // 计算最大宽度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     int size[10] = { 0 };
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     for (int j = 0; j &lt; len; j++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         size[getBit(arr[j], i)]++;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     int maxSize = size[0];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     for (int j = 0; j &lt; 10; j++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         if (size[j] &gt; maxSize)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             maxSize = size[j];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     // 桶排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     List buckets[10] = { {NULL, 0} };
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     for (int j = 0; j &lt; len; j++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         int index = getBit(arr[j], i);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         if (!buckets[index].len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             buckets[index].bucket = (int*)malloc(maxSize*sizeof(int));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         buckets[index].bucket[buckets[index].len++] = arr[j];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     int index = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     for (int j = 0; j &lt; 10; j++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         if (buckets[j].len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             for (int k = 0; k &lt; buckets[j].len; k++)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//                 arr[index + k] = buckets[j].bucket[k];
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             index += buckets[j].len;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             free(buckets[j].bucket);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             buckets[j].bucket = NULL;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//             buckets[j].len = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//         }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">radixSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    
    <item>
      <title>SQL 语句</title>
      <link>/blog/2022/01/sql-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/2022/01/sql-%E8%AF%AD%E5%8F%A5/</guid>
      <description><![CDATA[基本概念 SQL（Structured Query Language，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进]]></description>
      <content:encoded><![CDATA[<h1 id="基本概念" data-numberify>基本概念<a class="anchor ms-1" href="#基本概念"></a></h1>
<p><strong>SQL</strong>（<strong>Structured Query Language</strong>，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。</p>
<blockquote>
<p>标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。</p>
</blockquote>
<hr>
<h2 id="数据库" data-numberify>数据库<a class="anchor ms-1" href="#数据库"></a></h2>
<p><strong>数据库</strong>（<strong>database</strong>）是一个用于保存有组织的数据的容器或数据集合。</p>
<p>每个数据库都有唯一的标识符。</p>
<hr>
<h3 id="表" data-numberify>表<a class="anchor ms-1" href="#表"></a></h3>
<p><strong>表</strong>（<strong>table</strong>）是某种特定类型数据的结构化清单，用于存储某种特定类型的数据。</p>
<p>在同一个数据库中的每个表都有一个唯一的标识符来标识自己。因此，在同个数据库中，不能拥有两个名称相同的表，但在不同的数据库中可以使用相同的表名。</p>
<hr>
<h3 id="模式" data-numberify>模式<a class="anchor ms-1" href="#模式"></a></h3>
<p><strong>模式</strong>（<strong>schema</strong>）是一种关于数据库和表的布局及特性的信息。它是用来描述数据库中表的特性（如，存储的数据类型、数据的分解方式、各部分的信息的命名），或描述整个数据库（和其中表的关系）。</p>
<hr>
<h3 id="行和列" data-numberify>行和列<a class="anchor ms-1" href="#行和列"></a></h3>
<h4 id="列" data-numberify>列<a class="anchor ms-1" href="#列"></a></h4>
<p><strong>列</strong>（<strong>column</strong>）是表中的一个字段（即，表的组成部分）。所有的表都是由一个或多个列组成的。列存储表中的某部分信息，且这部分信息必须是同一种数据类型（<strong>datatype</strong>）。</p>
<p>数据类型限制（或允许）该列中存储的数据的种类。它还能帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。</p>
<p>利用特定的列，可以对数据进行分类和过滤。所以，数据分解十分重要。</p>
<p>数据类型及其名称是 SQL 不兼容的重要原因之一。对于不同的 DBMS，大多数基本数据类型都得到了一致的支持，但许多高级数据类型却没有。</p>
<hr>
<h4 id="行" data-numberify>行<a class="anchor ms-1" href="#行"></a></h4>
<p>表中每一条记录的数据都是按<strong>行</strong>（<strong>row</strong>）存储的。</p>
<hr>
<h4 id="主键" data-numberify>主键<a class="anchor ms-1" href="#主键"></a></h4>
<p><strong>主键</strong>（<strong>primary key</strong>）是用来唯一标识表中每一行的列（如国际标准书号 ISBN 就可作为主键），可以是一列或多列。</p>
<p>满足以下条件的列即可作为主键：</p>
<ol>
<li>
<p>任意两行都不具有相同的主键值。</p>
</li>
<li>
<p>每一行都必须具有一个主键值（主键列不允许空值 NULL）。</p>
</li>
<li>
<p>主键列中的值不允许修改或更新。</p>
</li>
<li>
<p>主键值不能重用（即使某行从表中删除，它的主键依然不能赋给以后的新行）。</p>
</li>
</ol>
<p>在使用多列作为主键时，上述条件必须应用到所有列，即所有列值的组合必须是唯一的（但不同列中可以存在相同的值）。</p>
<hr>
<h2 id="关系数据库" data-numberify>关系数据库<a class="anchor ms-1" href="#关系数据库"></a></h2>
<p>关系数据库由关系表组成，而关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联。</p>
<p>常见的两个关系表都会有至少一个相同类型且表示相同的列，对于其中一个表，该列是这个表的主键，从而能使另一个表甚至关系数据库中的其他表通过这个主键对应到这个表中的行。</p>
<p>一个优秀的关系数据库通常具有以下优点：</p>
<ul>
<li>
<p>关系库中的每个表中的每个行的信息重复很少，减少了时间和空间的浪费。</p>
</li>
<li>
<p>如果信息有更新，仅需更新对应的表中的数据。</p>
</li>
<li>
<p>数据是一致的（没有重复的数据），使得处理数据和生成报表更简单。</p>
</li>
</ul>
<p>总结：关系数据库的<strong>可伸缩性</strong>（<strong>scale</strong>）远比非关系数据库要好。</p>
<blockquote>
<p>可伸缩是指，能够适应不断增加的工作量而不失败。</p>
</blockquote>
<hr>
<h2 id="数据库管理系统" data-numberify>数据库管理系统<a class="anchor ms-1" href="#数据库管理系统"></a></h2>
<p><strong>数据库管理系统</strong>（<strong>DataBase Management System</strong>，<strong>DBMS</strong>）是一种用于创建和操纵数据库的软件。</p>
<p>绝大多数 DBMS 都支持 ANSI SQL，但一些 DBMS 有自己的扩展。不同的 SQL 实现有自己的名称（如 Oracle 的 PL/SQL、微软 SQL Server 的 Transact-SQL 等）。</p>
<p>DBMS 可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。</p>
<p>数据库管理系统、数据库和表的关系：</p>
<hr>
<h2 id="sql-语句分类" data-numberify>SQL 语句分类<a class="anchor ms-1" href="#sql-语句分类"></a></h2>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。</p>
<p>关键字：<code>create</code>、<code>drop</code>、<code>alter</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。</p>
<p>关键字：<code>insert</code>、<code>delete</code>、<code>update</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。</p>
<p>关键字：<code>select</code>、<code>where</code> 等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。</p>
<p>关键字：<code>GRANT</code>、<code>REVOKE</code> 等。</p>
</li>
</ol>
<hr>
<h2 id="sql-语法" data-numberify>SQL 语法<a class="anchor ms-1" href="#sql-语法"></a></h2>
<ul>
<li>
<p>SQL语句可以单行或多行书写，以分号结尾。</p>
</li>
<li>
<p>可使用空格和缩进来增强语句的可读性。</p>
</li>
<li>
<p>大多数数据库的 SQL 语句不区分大小写，关键字建议使用大写（可以提高运行速度）。</p>
</li>
</ul>
<hr>
<h2 id="字段" data-numberify>字段<a class="anchor ms-1" href="#字段"></a></h2>
<p><strong>字段</strong>（<strong>filed</strong>）基本上与列的意思相同，但字段这个术语通常在计算字段这种场合下使用。</p>
<hr>
<h1 id="select-语句" data-numberify>SELECT 语句<a class="anchor ms-1" href="#select-语句"></a></h1>
<p>任何 SQL 语句都是<strong>查询</strong>（<strong>query</strong>）。但此术语一般指 SELECT 语句。</p>
<hr>
<ul>
<li>
<p>检索列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 从 tab_name 中检索出filed1, filed2 等列（字段）
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 可以检索单个列或多个列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>列的顺序是按照指令中指出的列名的顺序显示。行的顺序是按照存储在物理内存中的顺序显示。</p>
<hr>
</li>
<li>
<p>使用<strong>通配符</strong> <code>*</code> 检索表中的所有列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 检索出 tab_name 中所有的列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>一般情况下，返回的列是按照存储在物理内存中的顺序显示的，并没有特定顺序。可能是按照数据被添加到表中的顺序显示（在没有增删数据的情况下），也可能不是（在有数据进行过更新或删除，这个顺序将会受到 DBMS 重用回收存储空间的方式的影响）。</p>
<p>使用通配符可以很方便地显示表中所有的列（包括名字未知的列），但这么做可能会降低检索速度和应用程序的性能（因为程序会检索所有表中的所有列）。</p>
</li>
</ul>
<hr>
<h2 id="all-和-distinct" data-numberify>ALL 和 DISTINCT<a class="anchor ms-1" href="#all-和-distinct"></a></h2>
<p>可以在列名前指定 <code>ALL</code>（默认）和 <code>DISTINCT</code> 关键字，它们表示：</p>
<ul>
<li>
<p><code>ALL</code> —— 列出当前指定的列的所有行。</p>
</li>
<li>
<p><code>DISTINCT</code> —— 列出由当前所有列组合的不重复的行。</p>
</li>
</ul>
<p>可以对聚集函数使用 <code>ALL</code> 和 <code>DISTINCT</code> 关键字指定。</p>
<ul>
<li>
<p><code>ALL</code> —— 默认选项，包含所有的行，对聚集函数指定 <code>ALL</code>（可忽略）表示对所有的行执行计算。</p>
</li>
<li>
<p><code>DISTINCT</code> —— 指定 <code>DISTINCT</code>，包含不重复的行。</p>
<ul>
<li>
<p>对聚集函数指定 <code>DISTINCT</code> 表示只对不重复的行进行计算。</p>
</li>
<li>
<p>使用 <code>DISTINCT</code> 必须明确指出列名，而不能使用 <code>*</code>。</p>
</li>
</ul>
</li>
</ul>
<p>列出不重复的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 不重复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p><code>DISTINCT</code> 作用于所有指定的列，该 SELECT 语句会返回所有不重复的 <code>filed1, filed2, ...</code> 组合的行。使用 <code>DISTINCT *</code> 可以返回由所有列组合的不重复的行。</p>
<hr>
<h2 id="限制返回的行" data-numberify>限制返回的行<a class="anchor ms-1" href="#限制返回的行"></a></h2>
<p>各 DBMS 实现并不相同：</p>
<ul>
<li>
<p>SQL Server：使用 <code>TOP</code> 关键字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">TOP</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p>DB2：<code>FETCH FIRST n ROWS ONLY</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FETCH</span><span class="w"> </span><span class="k">FIRST</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">ROWS</span><span class="w"> </span><span class="k">ONLY</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p>Oracle：基于 <code>ROWNUM</code>（行计数器）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">ROWNUM</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p>MySQL、MariaDB、PostgreSQL and SQLite：使用 <code>LIMIT</code> 子句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回从第 m 行开始的前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数，m 是任一非负整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在 MySQL、MariaDB 和 SQLite 中，上条指令可简化为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 返回从第 m 行开始的前 n 行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 是任一正整数，m 是任一非负整数
</span></span></span><span class="line"><span class="cl"><span class="c1">-- m 指定开始的行数，n 指定返回的行数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>行是从 0 开始计数。</p>
</li>
</ul>
<hr>
<h2 id="order-by-排序数据" data-numberify>ORDER BY 排序数据<a class="anchor ms-1" href="#order-by-排序数据"></a></h2>
<ol>
<li>
<p>使用 <code>ORDER BY</code> 子句取一个或多个列的名字，据此对数据进行排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- order1, order2, ... 是排序的依据
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 该语句会先对 order1 进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 仅在具有多行相同 order1 值时，才按照 order2 排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">order1</span><span class="p">,</span><span class="w"> </span><span class="n">order2</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><p><code>ORDER BY</code> 子句必须是 SELECT 语句中的最后一条子句。默认是升序排序（从 A 到 Z）。</p>
<hr>
</li>
<li>
<p>按相对列位置进行排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- n1、n2 …… 是小于或等于指定的列的总数的正整数
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n1、n2 …… 这组数中的每两个数都不相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><p>按相对位置排序的好处是不用输入列名，但有可能会造成错用列进行排序（特别是在对 SELECT 清单进行更改时）。</p>
</li>
</ol>
<p>实际列名排序和相对列位置排序可混合使用。</p>
<blockquote>
<p>📌最好的排序方式是，对冗长的列名重命名，然后使用列名进行排序。这样可以减少错误的出现。</p>
</blockquote>
<hr>
<h3 id="指定排序方向" data-numberify>指定排序方向<a class="anchor ms-1" href="#指定排序方向"></a></h3>
<p>指定排序的关键字：<code>ASC</code> —— 升序排序、<code>DESC</code> —— 降序排序。<code>ASC</code> 和 <code>DESC</code> 必须对每一列进行指定，因为它们只会对直接位于其前面的列名指定排序方式。可以对某一列指定 <code>ASC</code>（或 <code>DESC</code>）后对其它列指定 <code>DESC</code>（或 <code>ASC</code>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- order1, order2, ... 是排序的依据，且都被指定了升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">order1</span><span class="w"> </span><span class="k">ASC</span><span class="p">,</span><span class="w"> </span><span class="n">order2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span></code></pre></div><ol>
<li>
<p><code>DESC</code> 关键字指定降序排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- order1, order2, ... 是排序的依据，且都被指定了降序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">order1</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">order2</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>对某些列指定升序排序，对另外某些列指定升序排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- asc_order1, asc_order2, ... 都是指定升序排序
</span></span></span><span class="line"><span class="cl"><span class="c1">-- desc_order1, desc_order2, ... 都是指定降序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">asc_order1</span><span class="w"> </span><span class="k">ASC</span><span class="p">,</span><span class="w"> </span><span class="n">asc_order2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">desc_order1</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">desc_order2</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p>大多数 DBMS 默认使用字典（dictionary）排序（即大小写字母被视为相同），但许多 DBMS 允许改变这种方式。</p>
<hr>
<h2 id="where-过滤数据" data-numberify>WHERE 过滤数据<a class="anchor ms-1" href="#where-过滤数据"></a></h2>
<p>使用 <code>WHERE</code> 子句能够根据指定的<strong>搜索条件</strong>（<strong>search criteria</strong>），检索用户需要的数据。搜索条件也被称为<strong>过滤条件</strong>（<strong>filter condition1</strong>）。</p>
<ul>
<li>
<p>检索单一条件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一列名
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1 的类型和 n 的类型要一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>数据也可以在应用层进行过滤，但当 DBMS 返回的数据超出实际所需的数据时，会影响应用的性能，并且降低应用的可伸缩性，这还会造成网络宽带的浪费（服务器不得不通过网络发送多余的数据）。</p>
<hr>
</li>
<li>
<p><strong>WHERE 子句操作符</strong>（条件操作符）：</p>
<p>并非所有 DBMS 都支持所有的操作符，某些 DBMS 可能不支持个别操作符。</p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>说明</strong></th>
<th><strong>操作符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>等于</td>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> or <code>!=</code></td>
<td>不等于</td>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>!&gt;</code></td>
<td>不大于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>BETWEEN</code></td>
<td>范围在指定的两个值之间</td>
</tr>
<tr>
<td><code>!&lt;</code></td>
<td>不小于</td>
<td><code>IS NULL</code></td>
<td>为 NULL 的值</td>
</tr>
</tbody>
</table>
<hr>
</li>
<li>
<p>使用 <code>BETWEEN</code> 在指定范围内检索：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一列名
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1 的类型和 n 、m 的类型要一致
</span></span></span><span class="line"><span class="cl"><span class="c1">-- n 和 m 为低端值和高端值
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 检索时匹配的值包括 n 和 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p>使用 <code>IS NULL</code> 检索空值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一列名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="no">NULL</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><code>IS NOT NULL</code> 检索不为空值的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一列名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="逻辑操作符" data-numberify>逻辑操作符<a class="anchor ms-1" href="#逻辑操作符"></a></h3>
<p>可以在一条 <code>WHERE</code> 子句中包含任意数量的<strong>逻辑操作符</strong>（<strong>logical operator</strong>），且允许两者结合以进行复杂、高级的过滤。</p>
<ol>
<li>
<p><code>AND</code> 操作符检索满足所有给定条件的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition11，condition12 …… 是包含条件操作符的子句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">condition12</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p><code>OR</code> 操作符检索满足任一条件的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition11，condition12 …… 是包含条件操作符的子句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">condition12</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">OR</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><p>许多 DBMS 在使用 <code>OR</code> 操作符时，当第 1 个条件满足的情况下，就不再计算第 2 个条件。</p>
<hr>
</li>
<li>
<p><code>NOT</code> 操作符是否定操作符，否定跟随在其后的条件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是任意条件子句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="n">condition11</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>大多数 DBMS 允许使用 NOT 否定任何条件。</p>
</li>
</ol>
<hr>
<h3 id="in-指定条件范围" data-numberify>IN 指定条件范围<a class="anchor ms-1" href="#in-指定条件范围"></a></h3>
<p><code>IN</code> 操作符用来指定条件范围，匹配范围中指定的每个条件。<code>IN</code> 操作符后的括号中的合法值用逗号分隔。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- val1, val2, ... 是与 condition1 类型相同的一组合法值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="n">val1</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p><code>IN</code> 操作符和 <code>OR</code> 操作符的功能类似，但在某些方面，<code>IN</code> 操作符有其优点。</p>
<ul>
<li>
<p>在有很多合法选项时，<code>IN</code> 操作符可读性更强。</p>
</li>
<li>
<p>与其他 <code>AND</code> 和 <code>OR</code> 操作符组合使用 <code>IN</code> 时，求值顺序更容易管理。</p>
</li>
<li>
<p><code>IN</code> 操作符一般比一组 <code>OR</code> 操作符执行得更快。</p>
</li>
<li>
<p><code>IN</code> 操作符可包含其他 SELECT 语句，能更动态地建立 WHERE 子句。</p>
</li>
</ul>
<hr>
<h3 id="通配符" data-numberify>通配符<a class="anchor ms-1" href="#通配符"></a></h3>
<p><strong>通配符</strong>（<strong>wildcard</strong>）是用于匹配值的一部分的特殊字符。</p>
<p><strong>搜索模式</strong>（<strong>search pattern</strong>）由字面值、通配符或两者组合构成的搜索条件。</p>
<p>利用通配符，可以创建比较特定数据的搜索模式。要使用通配符，必须在搜索子句中使用 <code>LIKE</code> 操作符。且通配符只能用于字符串。</p>
<ul>
<li>
<p>使用通配符搜索一般比其他简单搜索耗费更长的处理时间。</p>
</li>
<li>
<p>不要过度使用通配符。</p>
</li>
<li>
<p>尽量不要把通配符用在搜索模式的开始处（通配符置于开始处是最慢的）。</p>
</li>
<li>
<p>不同类型的通配符可以混合使用。</p>
</li>
</ul>
<hr>
<ol>
<li>
<p><code>%</code> 通配符：表示任何字符出现任意次数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一字符类型的列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 该语句表示在 condition1 列中搜索以 ABC 开头的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">WHRER</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;ABC%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>
<p>包含 <code>ABC</code> 的字符串：<code>'%ABC%'</code>；</p>
</li>
<li>
<p>以 <code>ABC</code> 结尾的字符串：<code>'ABC%'</code>；</p>
</li>
<li>
<p>以 <code>A</code> 为开头，以 <code>B</code> 为结尾的字符：<code>'A%B'</code>；</p>
</li>
<li>
<p>某些 DBMS 会用空格来填补字段内容，可能会对该搜索模式造成影响。</p>
</li>
<li>
<p>包含 <code>AB</code> 和 <code>CD</code> 的字符串：<code>'%AB%CD%'</code>；</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<hr>
</li>
<li>
<p><code>_</code> 通配符：表示匹配单个任意字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一字符类型的列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 该语句表示匹配以 ABC 结尾，开头为任意一个字符的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;_ABC&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
</li>
<li>
<p><code>[]</code> 通配符：用来指定一个字符集，它必须匹配指定位置的一个字符。</p>
<p>Example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是表中任一字符类型的列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 该语句匹配以 A 或 B 其中之一与 C 的组合的字符串（仅有两个字符）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;[AB]C&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>使用 <code>^</code> 可以来否定 <code>[]</code> 定义的字符集：<code>'[^AB]'</code> —— 该模式会匹配除了 <code>A</code> 和 <code>B</code> 之外的任何一个字符。</p>
</li>
</ol>
<h3 id="子查询" data-numberify>子查询<a class="anchor ms-1" href="#子查询"></a></h3>
<p>子查询通过嵌套的<code>SELECT</code>语句，将查询结果作为值返回。</p>
<p><code>SELECT</code>可以嵌套地使用。</p>
<hr>
<h1 id="拼接" data-numberify>拼接<a class="anchor ms-1" href="#拼接"></a></h1>
<p><strong>拼接</strong>（<strong>concatenate</strong>）是指将值联结到一起（将一个值附加到另一个值）构成单个值。</p>
<ul>
<li>
<p>SQL Server 使用 <code>+</code> 号拼接：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, filed3, ... 可以是任意同类型的字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">filed2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">filed3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>DB2、Oracle、PostgreSQL 和 SQLite 使用 <code>||</code>：<code>filed1 || filed2 || filed3 || ...</code>。</p>
</li>
<li>
<p>MySQL 和 MariaDB 使用 <code>Concat()</code> 函数：<code>Concat(filed1, filed2, filed3, ...)</code>。</p>
</li>
</ul>
<p>某些 DBMS 会用空格填充字段，可以使用 <code>RTRIM()</code> 函数来清除这些空格。</p>
<hr>
<h1 id="as-指定别名" data-numberify>AS 指定别名<a class="anchor ms-1" href="#as-指定别名"></a></h1>
<p>使用 <code>AS</code> 关键字赋予字段或值一个<strong>别名</strong>（<strong>alias</strong>）。别名既可以是一个单词，也可以是一个字符串，字符串需用引号括起。使用别名时不应使用表中实际的列名，虽然这样做也算合法，但可能会产生模糊的错误消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed 是一个字段或值
</span></span></span><span class="line"><span class="cl"><span class="c1">-- alias 是 filed 的别名
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 赋予别名后可以在接下来的子句中使用别名来替代这个字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">alias</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">alias</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="函数" data-numberify>函数<a class="anchor ms-1" href="#函数"></a></h1>
<h2 id="数值处理函数" data-numberify>数值处理函数<a class="anchor ms-1" href="#数值处理函数"></a></h2>
<p>数值处理函数仅处理数值数据，是最一致、最统一的函数。</p>
<p>常用的数值处理函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ABC()</code></td>
<td>返回一个数的绝对值。</td>
</tr>
<tr>
<td><code>COS()</code></td>
<td>返回一个角度的余弦。</td>
</tr>
<tr>
<td><code>EXP()</code></td>
<td>返回一个数的指数值。</td>
</tr>
<tr>
<td><code>PI()</code></td>
<td>返回圆周率 $\pi$ 值。</td>
</tr>
<tr>
<td><code>SIN()</code></td>
<td>返回一个角度的正弦。</td>
</tr>
<tr>
<td><code>SQRT()</code></td>
<td>返回一个数的平方根。</td>
</tr>
<tr>
<td><code>TAN()</code></td>
<td>返回一个角度的正切。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="文本处理函数" data-numberify>文本处理函数<a class="anchor ms-1" href="#文本处理函数"></a></h2>
<p>常用的文本处理函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LEFT(str, num)</code></td>
<td>返回字符串 <code>str</code> 左边前 <code>num</code> 个字符。</td>
</tr>
<tr>
<td><code>LENGTH(str)</code>、
<code>DATALENGTH(str)</code>
or
<code>LEN(str)</code></td>
<td>返回字符串的长度。</td>
</tr>
<tr>
<td><code>LOWER(str)</code></td>
<td>将字符串转换为小写。</td>
</tr>
<tr>
<td><code>LTRIM(str)</code></td>
<td>去掉字符串左边的空格。</td>
</tr>
<tr>
<td><code>RIGHT(str, num)</code></td>
<td>返回字符串 <code>str</code> 右边前 <code>num</code> 个字符。</td>
</tr>
<tr>
<td><code>RTRIM(str)</code></td>
<td>去掉字符串右边的空格。</td>
</tr>
<tr>
<td><code>SUBSTR(str, n, size)</code> or <code>SUBSTRING(str, n, size)</code></td>
<td>提取字符串的组成部分。
DB2、Oracle、PostgreSQL 和 SQLite 使用 <code>SUBSTR()</code>；
MariaDB、MySQL 和 SQL Server 使用 <code>SUBSTRING()</code>。
<code>n</code> 是指字符串中第 <code>n</code> 个字符（从 1 开始计数），
<code>size</code> 是指截取的字符串长度，截取出的字符串包括第 <code>n</code> 个字符。</td>
</tr>
<tr>
<td><code>SOUNDEX(str)</code></td>
<td>返回字符串的 SOUNDEX 值（描述 <code>str</code> 语音表示的字母数字模式）。
PostgreSQL 不支持。SQLite 要开启 SQLITE_SOUNDEX 编译选项。
使用 <code>SOUNDEX()</code> 函数对两个字符串进行比较，
使得能对字符串进行发音比较而不是字母比较。
如 <code>WHERE SOUNDEX(str1) = SOUNDEX(str2)</code>。</td>
</tr>
<tr>
<td><code>UPPER(str)</code></td>
<td>将字符串转换为大写。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="日期和时间处理函数" data-numberify>日期和时间处理函数<a class="anchor ms-1" href="#日期和时间处理函数"></a></h2>
<p>日期和时间函数在 SQL 中可移植性最差。</p>
<ul>
<li>
<p>SQL Server 使用 <code>DATEPART(part, date)</code> 返回日期中的一部分，<code>part</code>（不是字符型的参数）指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>PostgreSQL 使用 <code>DATE_PART(part_str, date)</code> 返回日期中的一部分，<code>part_str</code> 指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>Oracle 和 PostgreSQL 都支持 <code>EXTRACT(part FROM date)</code> 返回日期中的一部分。<code>part</code>（不是字符型）指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>Oracle 还支持 <code>to_date(date_str, form_str)</code> 将字符串转化成日期，<code>date_str</code> 是某个带有日期格式的字符串，<code>form_str</code> 指定日期的形式。一般这样使用：<code>WHERE date_column BETWEEN to_date('2020-01-01', 'yyyy-mm-dd') AND todate('2020-12-31', 'yyyy-mm-dd')</code>。</p>
</li>
<li>
<p>DB2、MySQL 和 MariaDB 中有 <code>YEAR(date)</code> 和 <code>MONTH(date)</code> 等函数用于提取年份和月份等信息。</p>
</li>
<li>
<p>在 SQLite 可以使用 <code>strftime('%Y', date)</code> 提取年份，也可以提取月份等。</p>
</li>
</ul>
<hr>
<p>MySQL Date 函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NOW()</code></td>
<td>返回当前的日期和时间。</td>
</tr>
<tr>
<td><code>CURDATE()</code></td>
<td>返回当前的日期。</td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前的时间。</td>
</tr>
<tr>
<td><code>DATE()</code></td>
<td>提取日期或日期/时间表达式的日期部分。</td>
</tr>
<tr>
<td><code>EXTRACT()</code></td>
<td>返回日期/时间的单独部分。</td>
</tr>
<tr>
<td><code>DATE_ADD()</code></td>
<td>向日期添加指定的时间间隔。</td>
</tr>
<tr>
<td><code>DATE_SUB()</code></td>
<td>从日期减去指定的时间间隔。</td>
</tr>
<tr>
<td><code>DATEDIFF()</code></td>
<td>返回两个日期之间的天数。</td>
</tr>
<tr>
<td><code>DATE_FORMAT()</code></td>
<td>用不同的格式显示日期/时间。</td>
</tr>
</tbody>
</table>
<hr>
<p>SQL Server Date 函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GETDATE()</code></td>
<td>返回当前的日期和时间</td>
</tr>
<tr>
<td><code>DATEPART()</code></td>
<td>返回日期/时间的单独部分</td>
</tr>
<tr>
<td><code>DATEADD()</code></td>
<td>在日期中添加或减去指定的时间间隔</td>
</tr>
<tr>
<td><code>DATEDIFF()</code></td>
<td>返回两个日期之间的时间</td>
</tr>
<tr>
<td><code>CONVERT()</code></td>
<td>用不同的格式显示日期/时间</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="汇总数据" data-numberify>汇总数据<a class="anchor ms-1" href="#汇总数据"></a></h2>
<p>使用<strong>聚集函数</strong>（<strong>aggregate function</strong>）可以对某些行进行计算并返回一个值。</p>
<p>SQL 聚集函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AVG(filed)</code></td>
<td>返回某字段的平均数，类型必须是数值类型，<code>AVG()</code> 会忽略值为 <code>NULL</code> 的行。</td>
</tr>
<tr>
<td><code>COUNT(filed)</code></td>
<td>返回某字段的行数</td>
</tr>
<tr>
<td><code>MAX(filed)</code></td>
<td>返回某字段的最大值，允许 <code>filed</code> 是日期值，许多 DBMS 还允许 <code>filed</code> 是字符串，如果 <code>filed</code> 是字符串，那么 <code>MAX()</code> 会返回按该列排序后的最后一行。<code>MAX()</code> 忽略值为 <code>NULL</code> 的行。</td>
</tr>
<tr>
<td><code>MIN(filed)</code></td>
<td>返回某字段的最小值，与 <code>MAX()</code> 类似，如果 <code>filed</code> 是字符串，那么 <code>MAX()</code> 会返回按该列排序后的最前面一行。</td>
</tr>
<tr>
<td><code>SUM(filed)</code></td>
<td>返回某列值之和，类型必须是数值类型，<code>SUM()</code> 会忽略值为 <code>NULL</code> 的行。</td>
</tr>
</tbody>
</table>
<p>Usage for Example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">filed</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">average</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SELECT 语句可以根据需要包含多个聚集函数。</p>
<hr>
<h1 id="group-by-数据分组" data-numberify>GROUP BY 数据分组<a class="anchor ms-1" href="#group-by-数据分组"></a></h1>
<p><strong>分组</strong>是使用 SELECT 语句的 <code>GROUP BY</code> 子句，将数据分为多个逻辑组，对每个组进行操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 显示 filed1, filed2, ... 并根据它们进行分组
</span></span></span><span class="line"><span class="cl"><span class="c1">-- COUNT(*) 表示计算分组中的所有行
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 该语句是先按照 filed1 进行分组，然后再按照 filed2 进行分组
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 使用分组后输出的结果可能是根据 filed1, filed2, ... 排序好的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><p><code>GROUP BY</code> 子句指示 DBMS 分组数据，然后对每个组（不是整个结果集）进行聚集。</p>
<p>使用 <code>GROUP BY</code> 的规定：</p>
<ul>
<li>
<p><code>GROUP BY</code> 子句可以包含任意数目的列。所以可以对分组进行嵌套，更细致地进行数据分组。</p>
</li>
<li>
<p>在建立分组后，操作的最小单位只能是分组，而无法再对个别列进行操作。</p>
</li>
<li>
<p><code>GROUP BY</code> 子句中列出的每一列都必须是检索列或有效表达式列（但不能是聚集函数）。在 SELECT 中使用表达式，则必须在 <code>GROUP BY</code> 子句中指定相同的表达式，而不能使用别名。</p>
</li>
<li>
<p>大多数 SQL 实现不允许 <code>GROUP BY</code> 列带有长度可变的数据类型（如文本或备注型字段）。</p>
</li>
<li>
<p>除聚集计算语句外，SELECT 语句中的每一列都必须在 <code>GROUP BY</code> 子句中给出。</p>
</li>
<li>
<p>分组列中所有包含具有 <code>NULL</code> 值的行，都将 <code>NULL</code> 作为一个分组返回。</p>
</li>
<li>
<p><code>GROUP BY</code> 子句必须出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前。</p>
</li>
</ul>
<blockquote>
<p>📌并非所有 SQL 实现都支持在使用 <code>GROUP BY</code> 子句时，使用相对位置指定列，并且使用它容易在编辑 SQL 语句时出错。</p>
</blockquote>
<hr>
<h2 id="having-过滤分组" data-numberify>HAVING 过滤分组<a class="anchor ms-1" href="#having-过滤分组"></a></h2>
<p>使用 <code>HAVING</code> 子句来过滤分组。<code>HAVING</code> 支持所有 <code>WHERE</code> 子句支持的操作符，两者的区别是 <code>WHERE</code> 仅对行进行过滤，而 <code>HAVING</code> 可以对分组进行过滤（在没有指定 <code>GROUP BY</code> 时，大多数 DBMS 会同等对待 <code>WHERE</code> 和 <code>HAVING</code>，即 <code>HAVING</code> 也可以对行进行过滤）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed_1, filed_2, ... 是聚集操作
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1 是相对于每行的条件，condition1_ 是相对于每个分组的条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">filed_1</span><span class="p">,</span><span class="w"> </span><span class="n">filed_2</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">HAVING</span><span class="w"> </span><span class="n">condition1_</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在同时使用 <code>WHERE</code> 和 <code>GROUP BY</code> 时，被 <code>WHERE</code> 过滤掉的行并不会包括在分组中。</p>
<hr>
<h2 id="分组和排序" data-numberify>分组和排序<a class="anchor ms-1" href="#分组和排序"></a></h2>
<p><code>ORDER BY</code> 与 <code>GROUP BY</code> 的区别</p>
<table>
<thead>
<tr>
<th><strong>ORDER BY</strong></th>
<th><strong>GROUP BY</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>对产生的输出排序</td>
<td>对行分组，但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意列都可以使用（甚至非选择的列也可以使用，即 SELECT 没有给出的列也能使用）</td>
<td>只可能使用选择列或表达式列（SELECT 中给出的列），而且必须使用每个选择列表达式（不能使用别名）</td>
</tr>
<tr>
<td>是可选的，任何情况下都能根据需要选择是否使用</td>
<td>在使用聚集函数的情况下，
还要显示列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
<p><code>GROUP BY</code> 分组不一定是按照分组顺序输出的，所以应该提供明确的 <code>ORDER BY</code> 子句指定排序方式，以确保在任何情况下输出都能正确地排序。</p>
<hr>
<h1 id="子查询-1" data-numberify>子查询<a class="anchor ms-1" href="#子查询-1"></a></h1>
<p><strong>子查询</strong>（<strong>subquery</strong>）是指嵌套在其他查询中的查询。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 每个子查询中的 SELECT 语句有且仅有一个字段
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 在子查询中企图检索多个列将返回错误
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 理论上可以无限嵌套，但实际使用时由于性能的限制，不能嵌套太多的子查询
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed_1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                     </span><span class="k">FROM</span><span class="w"> </span><span class="n">table2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                     </span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition12</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed_2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                          </span><span class="k">FROM</span><span class="w"> </span><span class="n">table3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                          </span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition13</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(...));</span><span class="w">
</span></span></span></code></pre></div><p>在 SELECT 语句中，子查询总是从内向外处理（类似递归的处理方式）。</p>
<hr>
<h2 id="使用计算字段进行子查询" data-numberify>使用计算字段进行子查询<a class="anchor ms-1" href="#使用计算字段进行子查询"></a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed_1, filed_2, ... 是计算字段，是由其 AS 前的圆括号中的子查询建立的
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table1._filed1 是 table1 中名为 _filed1 的列或列表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table2._filed1 是 table2 中名为 _filed2 的列或列表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table1._filed1 和 table2._filed1 是两个不同表格中同名同类型的列，并不是同一个列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table1._filed2 和 table3._filed2 的关系与 table1._filed1 和 table2._filed1 类似
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 第 1 条子查询的解释是，对所有 table2 中符合 table1._filed1 = table2._filed1 的行进行计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">FROM</span><span class="w"> </span><span class="n">table2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">_filed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table2</span><span class="p">.</span><span class="n">_filed1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">filed_1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">FROM</span><span class="w"> </span><span class="n">table3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">_filed2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table3</span><span class="p">.</span><span class="n">_filed2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">filed_2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>计算字段用一个句点分隔表名和列名，句点前是表名，句点后是列名，即 <code>tab_name.column</code>，这种写法也叫完全限定列名。在有可能混淆列名时（如使用子查询时）必须使用这种语法。</p>
<hr>
<h1 id="join-联结表" data-numberify>JOIN 联结表<a class="anchor ms-1" href="#join-联结表"></a></h1>
<p><strong>联结</strong>（<strong>join</strong>）是一种机制，用来在一条 SELECT 语句中关联表，可以联结多个表返回一组输出。</p>
<blockquote>
<p>联结不是物理实体，它在实际的数据库表总并不存在，它仅在数据查询的执行期间存在。
对于联结，需要考虑性能，如果联结过多的表，可能会非常耗费资源，使性能下降。
SQL 本身不限制每个联结约束中表的数目，但实际上许多 DBMS 都有限制。</p>
</blockquote>
<p>联结类型：</p>
<ul>
<li>
<p>内联结（inner join）</p>
</li>
<li>
<p>外联结（outer join）</p>
</li>
<li>
<p>自联结（self-join）</p>
</li>
<li>
<p>自然联结（natural join）</p>
</li>
</ul>
<p>可以在一个 SELECT 语句中使用联结多个表，而且每个表的联结类型可以不相同。</p>
<hr>
<h2 id="inner-join-内联结" data-numberify>INNER JOIN 内联结<a class="anchor ms-1" href="#inner-join-内联结"></a></h2>
<p><strong>内联结</strong>（<strong>inner join</strong>）又称为<strong>等值联结</strong>（<strong>equijoin</strong>），是基于两个表之间的项等测试。</p>
<p>许多子查询都可以使用内联结来替代，但是子查询与联结同样需要耗费一定的资源，所以在一个语句中，不应使用过多的子查询和联结。</p>
<hr>
<ol>
<li>
<p>在 <code>FROM</code> 中指定多个列（等值联结）。</p>
<p>对于联结，需要保证所有联结都有 <code>WHERE</code> 子句，并且要保证 <code>WHERE</code> 子句的正确性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 完全限定名：tab_name.column_name
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1s 中必须给出联结条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="p">,</span><span class="w"> </span><span class="n">table2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1s</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>如果上述语句没有在 <code>WHERE</code> 中指出配对方式，那么 <code>table1</code> 中的每一行会与 <code>table2</code> 中的每一行进行配对，然后 <code>table1</code> 和 <code>table2</code> 已经配对完成的行会再次与 <code>table3</code> 中的每一行配对，以此类推，直到所有的表都完成了配对。这种由没有联结条件的表联结后返回的结果为<strong>笛卡尔积</strong>（<strong>cartesian product</strong>）。</p>
</li>
<li>
<p>使用 <code>INNER JOIN</code>（内联结）指定要联结的表，联结条件用特定的 <code>ON</code> 子句给出。</p>
<p>同样地，对于这种方式的联结，需要保证所有联结都有有效的 <code>ON</code> 子句。如果没有 <code>ON</code> 子句，也会出现笛卡尔积。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1 中必须给出联结条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">condition11</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">table3</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">condition12</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 如果有其他条件的话 WHERE 子句在 INNER JOIN 之后给出
</span></span></span></code></pre></div></li>
</ol>
<p>ANSI SQL 规范首选 <code>INNER JOIN</code> 语法。</p>
<hr>
<h2 id="自联结" data-numberify>自联结<a class="anchor ms-1" href="#自联结"></a></h2>
<p><strong>自联结</strong>（<strong>self-join</strong>）是指在同一个 SELECT 语句中，多次联结同一个表。</p>
<p>对于自联结来说，由于多次引用同一个表，如果不对表起别名的话，会造成系统混乱（同一个表，表名自然相同，所以系统无法区分究竟指的是哪个表，虽然本质上都是同一个表）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>虽然自联结也可以用子查询替换，但对于大多数 DBMS 来说，处理联结远比处理子查询快。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">filed_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed_1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="k">WHERE</span><span class="w"> </span><span class="n">filed_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="自然联结" data-numberify>自然联结<a class="anchor ms-1" href="#自然联结"></a></h2>
<p><strong>自然联结</strong>（<strong>natural join</strong>）指每个含义相同的列仅出现一次的联结。自然联结一般是通过对一个表使用通配符，而对其他表的列使用明确的子集来完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="outer-join-外联结" data-numberify>OUTER JOIN 外联结<a class="anchor ms-1" href="#outer-join-外联结"></a></h2>
<p><strong>外联结</strong>（<strong>outer join</strong>）是指包含无关联行的联结。通常，内联结都是将一个表格中的行与另一个表格中的行通过联结条件进行关联，此时两个表格中没有被联结条件关联起来的行将会被忽略。而外联结则会包含这些没有被联结条件所关联起来的行，并根据需要给某些列赋予 <code>NULL</code> 值。</p>
<p>外联结有三种类型：</p>
<ul>
<li>
<p><code>LEFT OUTER JOIN</code> —— 左外联结，包含左表的所有行（即 <code>FROM</code> 后面紧跟的表，示例中为 <code>T1</code>），即使在右表（示例中为 <code>T2</code>）中没有被匹配（结果为 <code>NULL</code>）。</p>
<p>基本上所有的 DBMS 都支持。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><code>RIGHT OUTER JOIN</code> —— 右外联结，包含左表的所有行（即 <code>JOIN</code> 关键字后紧跟的表，示例中为 <code>T2</code>），即使在右表（示例中为 <code>T1</code>）中没有被匹配（结果为 <code>NULL</code>）。</p>
<p>SQLite 不支持。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed_2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">RIGHT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><code>FULL OUTER JOIN</code> —— 全外联结，只要左表和右表其中一个表中存在匹配，就返回。</p>
<p>MariaDB、MySQL 和 SQLite 都不支持。</p>
</li>
</ul>
<p>左外联结和右外联结可以相互转换。</p>
<hr>
<h2 id="联结聚合函数与分组" data-numberify>联结、聚合函数与分组<a class="anchor ms-1" href="#联结聚合函数与分组"></a></h2>
<p>联结的一种用法是使用聚合函数从另一个表格中汇总数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1 是联结条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">.</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">COUNT</span><span class="p">(</span><span class="n">T2</span><span class="p">.</span><span class="n">filed_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name_filed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">condition1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">T1</span><span class="p">.</span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span></span></span></code></pre></div><p>对于上述语句也可以指定外联结，仅需将 <code>INNER JOIN</code> 替换成外联结的关键字。</p>
<p>使用外联结从另一个表中汇总数据，那些没有被关联的行经过 <code>COUNT()</code> 函数计算后的返回值将会为 0。</p>
<hr>
<h1 id="union-组合查询" data-numberify>UNION 组合查询<a class="anchor ms-1" href="#union-组合查询"></a></h1>
<p><strong>组合查询</strong>通常称为<strong>并</strong>（<strong>union</strong>）或<strong>符合查询</strong>（<strong>compound query</strong>）。通过组合查询可以同时执行多条 SELECT 语句，并将结果作为一个查询结果集返回。</p>
<p>需要使用组合查询的情况：</p>
<ul>
<li>
<p>在一个查询中从不同的表返回结构数据；</p>
</li>
<li>
<p>对一个表执行多个查询，按一个查询返回数据。</p>
</li>
</ul>
<blockquote>
<p>📌</p>
<ul>
<li>
<p>组合相同表的查询所完成的工作一般可以用 <code>WHERE</code> 子句替代。</p>
<p>理论上使用 <code>WHERE</code> 子句和组合查询从性能上看并没有太大差别，但各实现之间任有差别。</p>
</li>
<li>
<p>第一条 SELECT 中的列名或指定的别名作为整个组合查询的结果集的列名。因此组合查询所返回的结果集的列名是第一条 SELECT 中的列名，且在组合查询中的 <code>ORDER BY</code> 子句中指出的列名应是第一条 SELECT 中第列名。</p>
</li>
<li>
<p>每一个组合查询最多仅能有一条 <code>ORDER BY</code> 子句，且必须位于整个组合查询语句的最后（即最后一条 SELECT 语句）。</p>
<p>即，无法对某条 SELECT 指定一种排序方式，而对另一条 SELECT 指定另一种排序方式，所有的 SELECT 只能用同一种方式排序。</p>
</li>
</ul>
</blockquote>
<p>使用组合查询的规则：</p>
<ul>
<li>
<p>必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 <code>UNION</code> 分隔。</p>
</li>
<li>
<p>每个查询必须包含相同的列、表达式或聚集函数（数量必须要相同，类型必须要兼容）。</p>
</li>
</ul>
<hr>
<p>使用 <code>UNION</code> 关键字，会自动去除重复的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 和 filed_1, filed_2, ... 数量必须相同，类型要兼容
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table1 和 table2 可以是同个表格，也可以是不同的表格
</span></span></span><span class="line"><span class="cl"><span class="c1">-- ORDER BY 必须位于语句的最后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition11</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">UNION</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed_1</span><span class="p">,</span><span class="w"> </span><span class="n">filed_2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition12</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">UNION</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">filed</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在上述语句中，将 <code>UNION</code> 替换成 <code>UNION ALL</code>，返回的结果集将包含重复的行。</p>
<hr>
<h1 id="insert-语句" data-numberify>INSERT 语句<a class="anchor ms-1" href="#insert-语句"></a></h1>
<p>INSERT 语句用来将行插入（或添加）到数据库表。</p>
<hr>
<h2 id="插入完整的行" data-numberify>插入完整的行<a class="anchor ms-1" href="#插入完整的行"></a></h2>
<ol>
<li>
<p>简单但不保险的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">value2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">value3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p><code>VALUES</code> 后面的括号中，按照表中列的定义次序，指出了要存储到表中的数据，且必须给每一列提供一个值（在没有指定列名的情况下）。如果某列没有值，则该列应该使用 <code>NULL</code>（在允许对该列指定空值的情况下）。各列必须以它们在表定义中出现的次序填充。</p>
<p>这种语法虽然简单但并不安全，因为这种 SQL 语句高度依赖于表中列的定义次序。如果表结构发生变动，那么这样的语句并不能按照预期的情况执行。</p>
<blockquote>
<p>📌在某些 SQL 实现中，<code>INTO</code> 关键字是可选的。但为了确保可移植，还是要提供 <code>INTO</code> 关键字。</p>
</blockquote>
</li>
<li>
<p>保险但比较繁琐的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1 与 value1 对应，filed2 与 value2 对应，以此类推
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="p">(</span><span class="n">filed1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="n">filed2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="n">filed3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">value2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">value3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p>这种方法需要在表名后面，使用括号将表中的所有列名指出（不用按照表中列的定义顺序）。在插入行时，VALUES 必须以其指定的次序匹配指定的列名，这样即使表结构改变，该 INSERT 语句仍能正确工作。不要使用没有明确给出列的 INSERT 语句。</p>
</li>
</ol>
<p>主键的值必须有唯一性，DBMS 不允许插入主键值重复的行。如果确实需要插入，应先删除原有的记录。</p>
<hr>
<h2 id="插入行的一部分" data-numberify>插入行的一部分<a class="anchor ms-1" href="#插入行的一部分"></a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1 与 value1 对应，filed2 与 value2 对应，以此类推
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="p">(</span><span class="n">filed1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="n">filed2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">value2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p>同样使用表名后面的括号指定列，只不过仅需指出需要插入的部分列，并且只需给这些列提供值。</p>
<p>无论是插入完整的行还是插入行的一部分，都必须确保 <code>VALUES</code> 的数目正确。如果不提供列名，则必须给每个表列提供一个值；如果提供列名，则必须给列出的每一个列一个值。否则，就会产生错误。</p>
<p>在 <code>VALUES</code> 中没有指出的列，DBMS 将赋予它们默认值或空值。这些列必须满足：</p>
<ul>
<li>
<p>列定义为允许 <code>NULL</code> 值。</p>
</li>
<li>
<p>在表定义中给出了默认值。</p>
</li>
</ul>
<hr>
<h2 id="insert-select" data-numberify>INSERT SELECT<a class="anchor ms-1" href="#insert-select"></a></h2>
<p>INSERT 还允许利用 SELECT 语句将检索到的结果插入表中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 将 table2 中满足条件的 filed_1, filed_2, ... 列按照对应顺序插入到 table1 中
</span></span></span><span class="line"><span class="cl"><span class="c1">-- table1 和 table2 可以是同一个表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">table1</span><span class="p">(</span><span class="n">filed1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                   </span><span class="n">filed2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                   </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed_1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">filed_2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1s</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>一般 INSERT 只插入一行。而 INSERT SELECT 可以用一条语句插入多行。</p>
<hr>
<h2 id="select-into" data-numberify>SELECT INTO<a class="anchor ms-1" href="#select-into"></a></h2>
<p><code>SELECT ... INTO</code> 用于从一个表中复制数据，然后把数据插入到另一个新表中（<code>INTO</code> 子句后指定的表，该语句执行后会自动创建）。</p>
<blockquote>
<p>📌MySQL 不支持 <code>SELECT ... INTO</code> 语句。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- INTO 后面的 IN 子句代表插入到其他数据库
</span></span></span><span class="line"><span class="cl"><span class="c1">-- IN 子句可省略，默认代表当前数据库
</span></span></span><span class="line"><span class="cl"><span class="c1">-- new_table 的表结构与 old_table 指定列 filed1, filed2, ... 的结构相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INTO</span><span class="w"> </span><span class="n">new_table</span><span class="w"> </span><span class="p">[</span><span class="k">IN</span><span class="w"> </span><span class="n">external_db</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">old_table</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p><code>SELECT INTO</code> 语句可以通过使用促使查询没有数据返回的 <code>WHERE</code> 子句创建一个新的空表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INTO</span><span class="w"> </span><span class="n">new_table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">old_table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="更新和删除数据" data-numberify>更新和删除数据<a class="anchor ms-1" href="#更新和删除数据"></a></h1>
<blockquote>
<p>在客户端或服务器的 DBMS 中，使用 UPDATE 和 DELETE 语句可能需要特殊的安全权限。</p>
</blockquote>
<hr>
<h2 id="update-语句" data-numberify>UPDATE 语句<a class="anchor ms-1" href="#update-语句"></a></h2>
<p>UPDATE 语句用于更新（修改）表中的数据。</p>
<p>有两种使用 UPDATE 语句的方式：</p>
<ol>
<li>
<p>更新表中的特定行 —— 使用 <code>WHERE</code> 子句过滤：</p>
<p>基本的 UPDATE子句由三部分组成：</p>
<ul>
<li>
<p>要更新的表 —— 使用 <code>UPDATE</code> 关键字指定；</p>
</li>
<li>
<p>列名和它们的新值 —— 使用 <code>SET</code> 关键字指定更新的内容（即使用 “列=值” 对将新值赋给被更新的列）；</p>
</li>
<li>
<p>确定要更新哪些行的过滤 —— 使用 <code>WHERE</code> 子句指定过滤条件。
在 UPDATE 中，<code>WHERE</code> 可以使用 SELECT 子查询。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 是 tab_name 中的列
</span></span></span><span class="line"><span class="cl"><span class="c1">-- value1, value2, ... 是与 filed1, filed2, ... 相对应类型的数据
</span></span></span><span class="line"><span class="cl"><span class="c1">-- filed1 = value1, filed2 = value2, ... 是 “列=值” 对
</span></span></span><span class="line"><span class="cl"><span class="c1">-- condition1s 是过滤的条件，指定了要更新的行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">filed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">filed2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1s</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>更新表中的所有行 —— 不使用 <code>WHERE</code> 子句。</p>
<p>一般的 UPDATE 字句都要使用 <code>WHERE</code> 字句指定过滤条件，否则 <code>SET</code> 子句指定的更新内容将应用到所有的列。</p>
</li>
</ol>
<blockquote>
<p>📌有的 SQL 实现支持在 UPDATE 语句中使用 FROM 子句，用一个表的数据更新另一个表的行。</p>
</blockquote>
<p>使用 UPDATE 删除某个列的值：将要删除的列置为 <code>NULL</code>（假设表定义允许 <code>NULL</code>）。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">del_filed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">NULL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1s</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="delete-语句" data-numberify>DELETE 语句<a class="anchor ms-1" href="#delete-语句"></a></h2>
<p>使用 DELETE 语句可以从一个表中删除（去掉）数据。</p>
<p>有两种使用 DELETE 语句的方式：</p>
<ul>
<li>从表中删除特定的行 —— 使用 <code>WHERE</code> 子句过滤：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- condition1s 是过滤条件，指定了要删除的行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1s</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>从表中删除所有行 —— 不使用 <code>WHERE</code> 子句：
使用 DELETE 语句时应该指定 <code>WHERE</code> 子句，否则它将会删除表中所有的行。
如果确实想删除表中所有行，应该使用速度更快的 <code>TRUNCATE TABLE</code> 语句。</li>
</ul>
<p>DELETE 语句删除的是表中的行，即它的操作对象是行而不是列，如果想要删除列，则要使用 UPDATE 语句将该列置为 <code>NULL</code>。</p>
<hr>
<h2 id="update-和-delete-的使用准则" data-numberify>UPDATE 和 DELETE 的使用准则<a class="anchor ms-1" href="#update-和-delete-的使用准则"></a></h2>
<ul>
<li>
<p><strong>绝对不要使用不带  子句的 UPDATE 或 DELETE 子句</strong>，除非确实打算更新和删除每一行。</p>
</li>
<li>
<p><strong>应保证每个表都有主键</strong>。</p>
</li>
<li>
<p>在使用 UPDATE 或 DELETE 之前，应先用 SELETE 进行测试，确保 <code>WHERE</code> 子句过滤的是正确的记录。:</p>
</li>
<li>
<p>使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关的行。</p>
</li>
<li>
<p>如果 DBMS 允许数据库管理员施加约束，防止执行不带 <code>WHERE</code> 子句的 UPDATE 或 DELETE 子句，那么应该使用它。</p>
</li>
</ul>
<blockquote>
<p>📌如果 SQL 没有撤销（undo）按钮，应该更小心地使用 UPDATE 和 DELETE 语句。</p>
</blockquote>
<hr>
<h1 id="创建和删除数据库" data-numberify>创建和删除数据库<a class="anchor ms-1" href="#创建和删除数据库"></a></h1>
<p>创建数据库使用 <code>CREATE DATABASE</code> 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="n">db_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>删除数据库使用 <code>DROP DATABASE</code> 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="n">db_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>注意：删除数据库后，数据库中的所有数据（表、视图、索引等数据都将会被删除）。</p>
<hr>
<h1 id="sql-通用数据类型" data-numberify>SQL 通用数据类型<a class="anchor ms-1" href="#sql-通用数据类型"></a></h1>
<p>数据类型定义列中存放的值的种类。数据库表中的每个列都要求有名称和数据类型。SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。</p>
<p>不同的 DBMS 数据类型有些不同。有的 DBMS 允许自定义数据类型，有的不允许。</p>
<p>以下是 SQL 通用数据类型：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CHARACTER(n)</code> 或 <code>CHAR(n)</code></td>
<td>字符/字符串。固定长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>VARCHAR(n)</code> 或  <code>CHARACTER VARYING(n)</code></td>
<td>字符/字符串。可变长度。最大长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>BINARY(n)</code></td>
<td>二进制串。固定长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>BOOLEAN</code></td>
<td>存储 <code>TRUE</code> 或 <code>FALSE</code> 值</td>
</tr>
<tr>
<td><code>VARBINARY(n) </code> 或 <code>BINARY VARYING(n)</code></td>
<td>二进制串。可变长度。最大长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>INTEGER(p)</code></td>
<td>整数值（没有小数点）。精度 <code>p</code>。</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>整数值（没有小数点）。精度 5。</td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td>整数值（没有小数点）。精度 10。</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>整数值（没有小数点）。精度 19。</td>
</tr>
<tr>
<td><code>DECIMAL(p,s)</code></td>
<td>精确数值，精度 <code>p</code>，小数点后位数 <code>s</code>。
例如：<code>DECIAML(5,2)</code> 是一个小数点前有 3 位数，小数点后有 2 位数的数字。</td>
</tr>
<tr>
<td><code>NUMERIC(p,s)</code></td>
<td>精确数值，精度 <code>p</code>，小数点后位数 <code>s</code>。（与  DECIMAL 相同）.</td>
</tr>
<tr>
<td><code>FLOAT(p)</code></td>
<td>近似数值，尾数精度 <code>p</code>。一个采用以 10 为基数的指数计数法的浮点数。该类型的 <code>size</code> 参数由一个指定最小精度的单一数字组成。</td>
</tr>
<tr>
<td><code>REAL</code></td>
<td>近似数值，尾数精度 7。</td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td><code>DOUBLE PRECISION</code></td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>存储年、月、日的值。</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>存储小时、分、秒的值。</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>存储年、月、日、小时、分、秒的值。</td>
</tr>
<tr>
<td><code>INTERVAL</code></td>
<td>由一些整数字段组成，代表一段时间，取决于区间的类型。</td>
</tr>
<tr>
<td><code>ARRAY</code></td>
<td>元素的固定长度的有序集合。</td>
</tr>
<tr>
<td><code>MULTISET</code></td>
<td>元素的可变长度的无序集合。</td>
</tr>
<tr>
<td><code>XML</code></td>
<td>存储 XML 数据。</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>SQL 数据类型快速参考手册</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>Access</strong></th>
<th><strong>SQL Server</strong></th>
<th><strong>Oracle</strong></th>
<th><strong>MySQL</strong></th>
<th><strong>PostgreSQL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>boolean</strong></td>
<td><code>Yes/No</code></td>
<td><code>Bit</code></td>
<td><code>Byte</code></td>
<td>N/A</td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><strong>integer</strong></td>
<td><code>Number (integer)</code></td>
<td><code>Int</code></td>
<td><code>Number</code></td>
<td><code>Int</code>、 <code>Integer</code></td>
<td><code>Int</code>、 <code>Integer</code></td>
</tr>
<tr>
<td><strong>float</strong></td>
<td><code>Number (single)</code></td>
<td><code>Float Real</code></td>
<td><code>Number</code></td>
<td><code>Float</code></td>
<td><code>Numeric</code></td>
</tr>
<tr>
<td><strong>currency</strong></td>
<td><code>Currency</code></td>
<td><code>Money</code></td>
<td>N/A</td>
<td>N/A</td>
<td><code>Money</code></td>
</tr>
<tr>
<td><strong>string (fixed)</strong></td>
<td>N/A</td>
<td><code>Char</code></td>
<td><code>Char</code></td>
<td><code>Char</code></td>
<td><code>Char</code></td>
</tr>
<tr>
<td><strong>string (variable)</strong></td>
<td>Text (&lt;256) Memo (65k+)</td>
<td><code>Varchar</code></td>
<td><code>Varchar</code>、<code>Varchar2</code></td>
<td><code>Varchar</code></td>
<td><code>Varchar</code></td>
</tr>
<tr>
<td><strong>binary object</strong></td>
<td>OLE Object Memo</td>
<td>Binary (fixed up to 8K) Varbinary (&lt;8K) Image (&lt;2GB)</td>
<td>Long Raw</td>
<td>Blob Text</td>
<td>Binary Varbinary</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="时间数据格式" data-numberify>时间数据格式<a class="anchor ms-1" href="#时间数据格式"></a></h2>
<p>MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>
<p>DATE - 格式：<code>YYYY-MM-DD</code></p>
</li>
<li>
<p>DATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>TIMESTAMP - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>YEAR - 格式：<code>YYYY</code> 或 <code>YY</code></p>
</li>
</ul>
<p>SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>
<p>DATE - 格式：<code>YYYY-MM-DD</code></p>
</li>
<li>
<p>DATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>SMALLDATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>TIMESTAMP - 格式：唯一的数字</p>
</li>
</ul>
<hr>
<h1 id="创建和操纵表格" data-numberify>创建和操纵表格<a class="anchor ms-1" href="#创建和操纵表格"></a></h1>
<h2 id="create-table-创建表" data-numberify>CREATE TABLE 创建表<a class="anchor ms-1" href="#create-table-创建表"></a></h2>
<p>一般有两种创建表格的方法：</p>
<ol>
<li>
<p>使用 SQL 语句 <code>CTEATE TABLE</code> 创建表格；</p>
</li>
<li>
<p>多数 DBMS 都具有交互式创建和管理数据库表的工具。</p>
<ul>
<li>其本质是交互工具根据用户操作自动生成并执行相应的 SQL 语句。</li>
</ul>
</li>
</ol>
<blockquote>
<p>不同的 SQL 实现中，CREATE TABLE 语句的语法会有所不同（主要区别是在列定义上）。</p>
</blockquote>
<p>使用 <code>CREATE TABLE</code> 创建表，必须给出以下信息：</p>
<ul>
<li>
<p>新表的名字，在关键字 <code>CREATE TABLE</code> 之后给出；</p>
</li>
<li>
<p>表列的名字和定义，在列名后的括号中指出，用逗号分隔；</p>
</li>
<li>
<p>有的 DBMS 还要求指定表的位置。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column_name1</span><span class="w">    </span><span class="n">DataType1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column_name2</span><span class="w">    </span><span class="n">DataType2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column_name3</span><span class="w">    </span><span class="n">DataType3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">cluumn_name4</span><span class="w">    </span><span class="n">DataType4</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>创建新表时只能指定不存在的表名，SQL 无法通过 <code>CREATE</code> 语句覆盖已有的表。</p>
<h2 id="alter-table-更新表定义" data-numberify>ALTER TABLE 更新表定义<a class="anchor ms-1" href="#alter-table-更新表定义"></a></h2>
<p>使用 ALTER TABLE 时需要考虑的事情：</p>
<ul>
<li>
<p>理想情况下，不要在表中包含数据时对表结构进行更新（特别是不要删除已有的列）。
应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。</p>
</li>
<li>
<p>所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。</p>
</li>
<li>
<p>许多 DBMS 不允许删除或更改表中的列。</p>
</li>
<li>
<p>多数 DBMS 允许重新命名表中的列。</p>
</li>
<li>
<p>许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。</p>
</li>
</ul>
<p>使用 ALTER TABLE 必须给出的信息：</p>
<ul>
<li>
<p>在 ALTER TABLE 之后给出表名；</p>
</li>
<li>
<p>列出要更改表的操作。</p>
</li>
</ul>
<hr>
<ol>
<li>
<p>增加表列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="n">filed</span><span class="w"> </span><span class="n">DataType</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>删除列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">filed</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>修改列定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="k">column_name</span><span class="w"> </span><span class="n">NewDataType</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在MySQL中使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">MODIFY</span><span class="w"> </span><span class="k">column_name</span><span class="w"> </span><span class="n">NewDataType</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<hr>
<p>复杂的表结构更改一般需要执行以下步骤：</p>
<ol>
<li>
<p>用新的列布局创建一个新表；</p>
</li>
<li>
<p>使用 INSERT SELECT 语句从旧表复制数据到新表；</p>
</li>
<li>
<p>检验包含所需数据的新表；</p>
</li>
<li>
<p>重命名旧表（在确定无误的情况下可删除）；</p>
</li>
<li>
<p>用旧表原来的名字重命名新表；</p>
</li>
<li>
<p>根据需要，重新创建触发器、存储过程、索引和外键。</p>
</li>
</ol>
<hr>
<p>使用 ALTER TABLE 的注意事项：</p>
<ul>
<li>
<p>SQLite 对使用 ALTER TABLE 的最重要的限制是：不支持使用 ALTER TABLE 定义主键和外键，必须在最初创建表时指定。</p>
</li>
<li>
<p>在使用 ALTER TABLE 之前应先做好完整的备份（表结构和数据的备份）。</p>
</li>
<li>
<p>表结构的更改不能撤销。</p>
<ul>
<li>
<p>如果增加了不需要的列，也许无法删除它们。</p>
</li>
<li>
<p>如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="drop-table-删除表" data-numberify>DROP TABLE 删除表<a class="anchor ms-1" href="#drop-table-删除表"></a></h2>
<p><code>DROP TABLE</code> 语句用于删除表本身（包括表数据）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>📌删除表时，没有确认步骤，且不能撤销。</p>
</blockquote>
<blockquote>
<p>📌<strong>使用关系规则防止意外删除</strong>：</p>
<p>许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条 <code>DORP TABLE</code> 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行，直到该关系被删除为止。</p>
</blockquote>
<hr>
<h2 id="truncate-table-删除表数据" data-numberify>TRUNCATE TABLE 删除表数据<a class="anchor ms-1" href="#truncate-table-删除表数据"></a></h2>
<p><code>TRUNCATE TABLE</code> 语句用于删除表内的数据（但并不包括表本身）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">TRUNCATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="重命名表" data-numberify>重命名表<a class="anchor ms-1" href="#重命名表"></a></h2>
<p>对于重命名表，每个 DBMS 的支持都有所不同：</p>
<ul>
<li>
<p>DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 使用 <code>RENAME</code> 语句。</p>
</li>
<li>
<p>SQL Server 使用 <code>sp_rename</code> 存储过程。</p>
</li>
<li>
<p>SQLite 使用 <code>ALTER TABLE</code> 语句。</p>
</li>
</ul>
<hr>
<h1 id="sql-约束" data-numberify>SQL 约束<a class="anchor ms-1" href="#sql-约束"></a></h1>
<p>SQL <strong>约束</strong>（Constraints）用于规定表中如何插入或处理数据的规则。如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 <code>CREATE TABLE</code> 语句），或者在表创建之后规定（通过 <code>ALTER TABLE</code> 语句）。</p>
<p>SQL 有如下几种约束：</p>
<table>
<thead>
<tr>
<th><strong>关键字</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NULL</code></td>
<td>允许存储 NULL 值。
如果不指定 NOT NULL 或 PRIMARY KEY，则默认为 NULL。
在插入行时允许不给出该列的值。此时，会给该项指定为值 NULL。
对于 DB2，在定义允许 NULL 的列中不能指定 NULL。</td>
</tr>
<tr>
<td><code>NOT NULL</code></td>
<td>指示某列不能存储 NULL 值。
如果不向字段添加值，就无法插入新记录或者更新记录。</td>
</tr>
<tr>
<td><code>UNIQUE </code></td>
<td>唯一约束。保证某列的每行必须有唯一的值。
唯一约束可包含 NULL 值，可重复使用，但是不能用来定义外键。</td>
</tr>
<tr>
<td><code>PRIMARY KEY</code></td>
<td>主键约束。NOT NULL 和 UNIQUE 的结合。
确保某列（或多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</td>
</tr>
<tr>
<td><code>FOREIGN KEY</code></td>
<td>外键约束。保证一个表中的数据匹配另一个表中的值的参照完整性。</td>
</tr>
<tr>
<td><code>CHECK</code></td>
<td>保证列中的值符合指定的条件。</td>
</tr>
<tr>
<td><code>DEFAULT</code></td>
<td>规定没有给列赋值时的默认值。
在插入行时如果不给出值，则用默认值赋值。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">主键约束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w">  </span><span class="n">Type1</span><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">默认为允许</span><span class="w"> </span><span class="k">NULL</span><span class="err">，可以不用指出</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w">  </span><span class="n">Type2</span><span class="w">  </span><span class="p">[</span><span class="k">NULL</span><span class="p">],</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">不允许</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="err">的列，必须用</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="err">指出</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column3</span><span class="w">  </span><span class="n">Type3</span><span class="w">  </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">用</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="err">指定默认值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="n">default_val</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="n">Type4</span><span class="w"> </span><span class="err">类型的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column4</span><span class="w">  </span><span class="n">Type4</span><span class="w">  </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w">  </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">default_val</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="not-null-非空约束" data-numberify>NOT NULL 非空约束<a class="anchor ms-1" href="#not-null-非空约束"></a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>添加 NOT NULL 约束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">MODIFY</span><span class="w"> </span><span class="k">column_name</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="unique-唯一约束" data-numberify>UNIQUE 唯一约束<a class="anchor ms-1" href="#unique-唯一约束"></a></h2>
<p>每个表可以有多个 UNIQUE 约束。</p>
<p>创建表时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">方法一：直接在列定义中用</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="err">关键字指出</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">UNIQUE</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">方法二：定义列后使用</span><span class="w"> </span><span class="k">UNIQUE</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">UNIQUE</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">可以不用定义</span><span class="w"> </span><span class="n">u_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="p">[</span><span class="n">u_name</span><span class="p">]</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>更新表定义时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="p">(</span><span class="k">column_name</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="err">可以省略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">u_name</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>撤销 UNIQUE 约束：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">u_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / Oracle / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">u_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="primary-key-主键约束" data-numberify>PRIMARY KEY 主键约束<a class="anchor ms-1" href="#primary-key-主键约束"></a></h2>
<p>只要满足以下条件，就可以被用作主键：</p>
<ul>
<li>
<p>任意两行的主键值都不相同（主键必须包含唯一值）。</p>
</li>
<li>
<p>每行都具有一个主键值（主键列不能包含 NULL 值）。</p>
</li>
<li>
<p>包含主键值的列从不修改或更新。</p>
</li>
<li>
<p>主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</p>
</li>
</ul>
<hr>
<p>创建表时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 在列定义中直接指出主键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 通过 PRIMARY KEY () 定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">可以不用定义</span><span class="w"> </span><span class="n">pk_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="p">[</span><span class="n">pk_name</span><span class="p">]</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>更新表定义时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="k">column_name</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="err">可以省略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">pk_name</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>撤销 PRIMARY KEY 约束：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / Oracle / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">pk_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="foreign-key-外键约束" data-numberify>FOREIGN KEY 外键约束<a class="anchor ms-1" href="#foreign-key-外键约束"></a></h2>
<p>创建表时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">方法一：使用</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="err">关键字</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table1</span><span class="p">(</span><span class="n">column_1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">方法二：使用</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column2</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table2</span><span class="p">(</span><span class="n">column_2</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">命名</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="err">约束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="p">[</span><span class="n">fk_name</span><span class="p">]</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table3</span><span class="p">(</span><span class="n">column_3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>更新表定义时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table1</span><span class="p">(</span><span class="n">column_1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 FOREIGN KEY 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">fk_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">table1</span><span class="p">(</span><span class="n">column_1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>撤销 FOREIGN KEY 约束：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">fk_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / Oracle / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">fk_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="check-检查约束" data-numberify>CHECK 检查约束<a class="anchor ms-1" href="#check-检查约束"></a></h2>
<p>CHECK 约束常见用途：</p>
<ul>
<li>
<p>检查最小或最大值。</p>
</li>
<li>
<p>指定范围。</p>
</li>
<li>
<p>只允许特定值。</p>
</li>
</ul>
<hr>
<p>创建表时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">限制</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="err">的值大于</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">限制</span><span class="w"> </span><span class="n">column2</span><span class="w"> </span><span class="err">只能取</span><span class="w"> </span><span class="s1">&#39;Y&#39;</span><span class="w"> </span><span class="err">或</span><span class="w"> </span><span class="s1">&#39;N&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">column2</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;[YN]&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 CHECK 约束，并定义多个列的 CHECK 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">Type1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">Type2</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">chk_name</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">column2</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;[YN]&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>修改表定义时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 命名 CHECK 约束，并定义多个列的 CHECK 约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">chk_name</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">column2</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;[YN]&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>撤销 CHECK 约束：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="n">chk_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / Oracle / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">chk_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="default-默认约束" data-numberify>DEFAULT 默认约束<a class="anchor ms-1" href="#default-默认约束"></a></h2>
<p>创建表时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="n">default_val</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="n">Type4</span><span class="w"> </span><span class="err">类型的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w">  </span><span class="n">Type1</span><span class="w">  </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w">  </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">default_val</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 可以使用类似 GETDATE() 的函数插入系统值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">默认值为当前的日期</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">birthday</span><span class="w">  </span><span class="nb">DATE</span><span class="w">  </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w">  </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">GETDATE</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>更新表结构时：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">default_val</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">default_val</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">column1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Oracle：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">MODIFY</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">default_val</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<p>撤销 DEFAULT 约束：</p>
<p>MySQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>SQL Server / Oracle / MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="auto-increment-字段" data-numberify>AUTO INCREMENT 字段<a class="anchor ms-1" href="#auto-increment-字段"></a></h1>
<p>在定义表时，在列中添加 auto-increment 字段可以在新纪录插入表时对该列生成一个唯一的数字。</p>
<p>定义为 auto-increment 字段的列必须是整数类型。</p>
<p>定义为 auto-increment 的列常常被定义为 <code>PRIMARY KEY</code>。</p>
<hr>
<p>MySQL 使用 <code>AUTO_INCREMENT</code> 关键字来执行 auto-increment 任务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">定义</span><span class="w"> </span><span class="n">column1</span><span class="w"> </span><span class="err">为</span><span class="w"> </span><span class="n">AUTO</span><span class="w"> </span><span class="k">INCREMENT</span><span class="w"> </span><span class="err">主键字段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="n">TYPE1</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column2</span><span class="w"> </span><span class="n">TYPE2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column3</span><span class="w"> </span><span class="n">TYPE3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>定义了 AUTO_INCREMENT 字段后，可以不用对该列指定值，或者对该列指定为 NULL 值（会自动添加一个唯一的值）。</p>
<p>MySQL 的 AUTO_INCREMENT 只能在 key 上被定义。PRIMARY KEY 和 UNIQUE 都是有效的定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- val2 和 val3 是分别与 column2 和 column3 同类型的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 不对 auto-increment 列指定值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="n">column3</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">val2</span><span class="p">,</span><span class="w"> </span><span class="n">val3</span><span class="w"> </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 指定为 NULL 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="n">column3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">,</span><span class="w"> </span><span class="n">val3</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>AUTO_INCREMENT 默认的开始值是 <code>1</code>，每新增一条记录都会递增 <code>1</code>。</p>
<p>让 AUTO_INCREMENT 序列以其他的值起始：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- number 是任意数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="nb">number</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>MySQL 设定起始值只能在建表后使用 <code>ALTER TABLE</code> 语句。也可以在建表后直接使用 <code>ALTER TABLE</code> 语句定义 AUTO_INCREMENT 以及它的起始值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_test</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="nb">number</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- number 是任意数字
</span></span></span></code></pre></div><hr>
<p>MS SQL Server 使用 <code>IDENTITY()</code> 来执行 auto-increment 任务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- IDENTITY(initial, incremental) 中，
</span></span></span><span class="line"><span class="cl"><span class="c1">-- initial 是初始值，incremental 是递增值
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 即，以 initial 作为初始值，每新增一条记录递增 incremental
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">column1</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">IDENTITY</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span><span class="w"> </span><span class="n">incremental</span><span class="p">)</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>插入数据的方法同 MySQL。</p>
<hr>
<p>Oracle 通过创建 <code>sequence</code> 对象（该对象生成数字序列）创建 auto-increment 字段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="n">SEQUENCE</span><span class="w"> </span><span class="n">sp_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">MINVALUE</span><span class="w"> </span><span class="mi">1</span><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">最小值为</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">START</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="o">#</span><span class="w"> </span><span class="err">起始值为</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INCREMENT</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="o">#</span><span class="w"> </span><span class="err">每次递增</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CACHE</span><span class="w"> </span><span class="mi">10</span><span class="w">    </span><span class="o">#</span><span class="w"> </span><span class="err">缓存</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="err">个值以提高性能</span><span class="w">
</span></span></span></code></pre></div><p>插入新记录时，必须使用 <code>sequence</code> 对象的 <code>nextval</code> 函数（该函数从 <code>sp_name</code> 序列中取回下一个值）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 假设 tab_name 已被创建，
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 且要对 column1 使用 nextval() 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="n">column3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">sp_name</span><span class="p">.</span><span class="n">nextval</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">,</span><span class="w"> </span><span class="n">val3</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="视图" data-numberify>视图<a class="anchor ms-1" href="#视图"></a></h1>
<p>视图是虚拟的表。视图并不包含数据，它只包含使用时动态检索数据的查询。视图的 SELECT 用法与表的用法基本相同。</p>
<p>使用视图的原因：</p>
<ul>
<li>
<p>重用 SQL 语句。</p>
</li>
<li>
<p>简化复杂的 SQL 操作（无需知道视图的基本查询细节）。</p>
</li>
<li>
<p>使用表的一部分而不是整个表。</p>
</li>
<li>
<p>保护数据。
可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</p>
</li>
<li>
<p>更改数据格式和表示。
视图可返回与底层表的表示和格式不同的数据。</p>
</li>
</ul>
<hr>
<p>视图的使用规则：</p>
<ul>
<li>
<p>视图名必须为一且不能与其他视图或表重名。</p>
</li>
<li>
<p>对于可创建的视图数目没有限制。</p>
</li>
<li>
<p>创建视图，必须具有足够的访问权限（通常由数据库管理人员授予）。</p>
</li>
<li>
<p>视图可以嵌套，但允许的嵌套层数在不同的 DBMS 中有所不同。
嵌套视图、使用多个联结和过滤创建复杂的视图都会使性能下降。在产品环境中使用之前，应该对其进行全面测试。</p>
</li>
<li>
<p>许多 DBMS 禁止在视图查询中使用 <code>ORDER BY</code> 子句。</p>
</li>
<li>
<p>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</p>
</li>
<li>
<p>视图不能索引，也不能有关联的触发器或默认值。</p>
</li>
<li>
<p>有些 DBMS 把视图作为只读的查询（不能将数据写回底层表，如 SQLite）。</p>
</li>
<li>
<p>有些 DBMS 禁止对视图中的行进行插入或更新后，该行不再属于该视图的操作。
默认情况下，如果删除视图中的某行的某列后，可能会导致该行不属于该视图。但是某些 DBMS 会防止这种情况发生。</p>
</li>
</ul>
<hr>
<h2 id="create-view-创建视图" data-numberify>CREATE VIEW 创建视图<a class="anchor ms-1" href="#create-view-创建视图"></a></h2>
<p>使用 <code>CREATE VIEW</code> 语句创建视图，通常包含两部分：</p>
<ul>
<li>
<p>视图名；</p>
</li>
<li>
<p><code>SELECT</code> 查询语句。</p>
</li>
</ul>
<p>视图的用途：</p>
<ol>
<li>
<p>利用视图简化复杂的联结：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">view_name</span><span class="w"> </span><span class="k">AS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="p">,</span><span class="w"> </span><span class="n">table2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">condition1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>用视图重新格式话检索出的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- filed1, filed2, ... 指需要重命名的字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">view_name</span><span class="w"> </span><span class="k">AS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">filed1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">alias1</span><span class="p">,</span><span class="w"> </span><span class="n">filed2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">alias2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>用视图过滤不想要的数据。</p>
</li>
</ol>
<p>一般创建的视图都不会绑定特定的数据，这会提高视图的可重用性。</p>
<p>从视图检索数据时如果使用了一条 <code>WHERE</code> 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p>
<hr>
<h2 id="drop-view-删除视图" data-numberify>DROP VIEW 删除视图<a class="anchor ms-1" href="#drop-view-删除视图"></a></h2>
<p>通过 <code>DROP VIEW</code> 删除视图（仅删除视图的定义，视图中并包含真实的数据）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">view_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="索引" data-numberify>索引<a class="anchor ms-1" href="#索引"></a></h1>
<p>索引通过排序数据以加快搜索和排序操作的速度。</p>
<ul>
<li>
<p>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。</p>
</li>
<li>
<p>索引数据可能要占用大量的存储空间。</p>
</li>
<li>
<p>用户无法看到索引。</p>
</li>
<li>
<p>并非所有数据都适合做索引。</p>
</li>
<li>
<p>索引用于数据过滤和数据排序。如果经常以某种特定的顺序排序数据，则该数据可能适合做索引。</p>
</li>
<li>
<p>可以在索引中定义多个列。这样的索引仅在以这个列组合排序时有用。</p>
</li>
</ul>
<hr>
<h2 id="create-index-创建索引" data-numberify>CREATE INDEX 创建索引<a class="anchor ms-1" href="#create-index-创建索引"></a></h2>
<p>索引使用 <code>CREATE INDEX</code> 语句创建（不同的 DBMS 创建索引的语句变化很大）。</p>
<p>创建一个允许使用重复值的索引：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p>创建唯一索引（不允许两个行拥有相同的索引值）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">tab_name</span><span class="w"> </span><span class="p">(</span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p>索引必须唯一命名。</p>
<hr>
<h2 id="drop-index-删除索引" data-numberify>DROP INDEX 删除索引<a class="anchor ms-1" href="#drop-index-删除索引"></a></h2>
<p>MySQL:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>MS Access：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">tab_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>MS SQL Server：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">tab_name</span><span class="p">.</span><span class="n">index_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>DB2 / Oracle：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

