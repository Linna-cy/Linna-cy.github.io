<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数学 on Linner&#39;s Blog</title>
    <link>/tags/%E6%95%B0%E5%AD%A6/</link>
    <description>Recent content in 数学 on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>Copyright © 2020-2023 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Fri, 02 Sep 2022 12:43:41 +0800</lastBuildDate><atom:link href="/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>集合论</title>
      <link>/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/</link>
      <pubDate>Fri, 02 Sep 2022 12:43:41 +0800</pubDate>
      
      <guid>/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/</guid>
      <description><![CDATA[集合的概念 A set is a group of objects. (simplest way) By a set we mean any collection M into a whole of definite disinct objects m (which we called elements of M) of our perception or thought. (Cantor&rsquo;s way) 集合（set）是由 &lt;u&gt;指定范围 &lt;/]]></description>
      <content:encoded><![CDATA[<h1 id="集合的概念" data-numberify>集合的概念<a class="anchor ms-1" href="#集合的概念"></a></h1>
<blockquote>
<ul>
<li>A <strong>set</strong> is a group of objects. (simplest way)</li>
<li>By a <strong>set</strong> we mean any collection M into a whole of definite disinct objects m (which we called <strong>elements</strong> of M) of our perception or thought. (Cantor&rsquo;s way)</li>
</ul>
</blockquote>
<p><strong>集合</strong>（set）是由 <code>&lt;u&gt;</code>指定范围 <code>&lt;/u&gt;</code>内的 <code>&lt;u&gt;</code>满足给定条件的所有对象 <code>&lt;/u&gt;</code>聚集在一起构成的，指定范围内的每一个对象称为这个集合的<strong>元素</strong>（element）。</p>
<ul>
<li>集合中的元素是<strong>无序</strong>的。</li>
<li>集合中的元素是<strong>不同</strong>的（即，同个集合中相同或重复的元素被认为是一个元素）。</li>
</ul>
<p>通常情况下，</p>
<ul>
<li>用带（或不带）下标的 <code>&lt;u&gt;</code>大写 <code>&lt;/u&gt;</code>英文字母表示 <code>&lt;u&gt;</code>集合 <code>&lt;/u&gt;</code>：$A,B,C,\dots,A_1,B_1,C_1,\dots$</li>
<li>用带（或不带）下标的 <code>&lt;u&gt;</code>小写 <code>&lt;/u&gt;</code>英文字母表示 <code>&lt;u&gt;</code>元素 <code>&lt;/u&gt;</code>：$a,b,c,\dots,a_1,b_1,c_1,\dots$</li>
</ul>
<p>ZFC 公理化集合论：</p>
<ul>
<li>外延公理，</li>
<li>空集存在公理，</li>
<li>无序对公理，</li>
<li>并集公理，</li>
<li>幂集公理，</li>
<li>无穷公理，</li>
<li>替换公理，</li>
<li>正则公理，</li>
<li>选择公理。</li>
</ul>
<hr>
<h2 id="常见的集合" data-numberify>常见的集合<a class="anchor ms-1" href="#常见的集合"></a></h2>
<ul>
<li>空集 $\emptyset$；</li>
<li>正整数集 $\mathbf{N^+}$ or $\mathbf{W}$：$1,2,3,\cdots$</li>
<li>自然数集 $\mathbf{N}$：$0,1,2,3,\cdots$</li>
<li>整数集 $\mathbf{Z}$：$\cdots,-2,-1,0,1,2,\cdots$</li>
<li>质数/素数集 $\mathbf{P}$：$2,3,5,7,\cdots$</li>
<li>有理数集 $\mathbf{Q}$；</li>
<li>无理数集 $\mathbf{I}$；</li>
<li>实数集 $\mathbf{R}$；</li>
<li>复数集 $\mathbf{C}$；</li>
<li>$\cdots\cdots$</li>
</ul>
<p>关系：</p>
<p>$$
\mathbf{W} \subseteq \mathbf{N} \subseteq \mathbf{Z} \subseteq \mathbf{Q} \subseteq \mathbf{R} \subseteq \mathbf{C}
$$</p>
<hr>
<h1 id="集合的表示方法" data-numberify>集合的表示方法<a class="anchor ms-1" href="#集合的表示方法"></a></h1>
<h2 id="枚举法" data-numberify>枚举法<a class="anchor ms-1" href="#枚举法"></a></h2>
<p><strong>枚举法</strong>又称<strong>列举法</strong>或<strong>显示法</strong>，是枚举出集合中的所有或部分元素（要能看出其他元素之间的规律）。</p>
<p>Example：</p>
<ul>
<li>枚举出集合中的所有元素：$A = {a,b,c,d}$；</li>
<li>枚举出集合中的部分元素：$B = {1,3,5,\cdots,2n+1,\cdots}$。</li>
</ul>
<hr>
<h2 id="叙述法" data-numberify>叙述法<a class="anchor ms-1" href="#叙述法"></a></h2>
<p><strong>叙述法</strong>又称<strong>隐式法</strong>，是通过刻画（或用自然语言描述）集合中元素所具备的某种特性来表示集合的方法，通常用符号 $P(x)$ 来表示不同对象 $x$ 所具有的性质 $P$ ，由 $P(x)$ 所定义的集合常记为</p>
<p>$$
{x|P(x)}。
$$</p>
<hr>
<h2 id="文氏图" data-numberify>文氏图<a class="anchor ms-1" href="#文氏图"></a></h2>
<p><strong>文氏图</strong>（<strong>Venn diagram</strong>）又叫<strong>维恩图</strong>，用于展示集合或类之间的大致关系。</p>
<p><picture><img class="img-fluid " alt="维恩图" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E7%BB%B4%E6%81%A9%E5%9B%BE.png" loading="lazy" width="1980" height="563" />
</picture>

</p>
<p>一般用方向表示全集，用圆形表示某一特定集合。</p>
<hr>
<h2 id="递归指定集合法" data-numberify>递归指定集合法<a class="anchor ms-1" href="#递归指定集合法"></a></h2>
<p>递归指定集合法是指通过计算规则定义集合中的元素的方法。</p>
<p>Example：</p>
<p>设 $a_0 = 1$，$a_{i+1}=2a_i(i \ge 0)$，定义 $S={a_0,a_1,\cdots,a_n,\cdots}={a_k|k\ge0}$，可以得出集合 $S$ 为</p>
<p>$$
S={1,2,2^2,\cdots,2^n,\cdots}。
$$</p>
<hr>
<h2 id="归纳法" data-numberify>归纳法<a class="anchor ms-1" href="#归纳法"></a></h2>
<ol>
<li>
<p>指出集合至少要包含的元素</p>
<ul>
<li>第一部分：基础，指出某些最 <code>&lt;u&gt;</code>基本元素 <code>&lt;/u&gt;</code>属于某集合；</li>
<li>第二部分：归纳，指出 <code>&lt;u&gt;</code>由基本元素构造新元素的方法 <code>&lt;/u&gt;</code>；</li>
</ul>
</li>
<li>
<p>指出集合至多要包含的元素</p>
<ul>
<li>第三部分：极小性，指出该 <code>&lt;u&gt;</code>集合的界限 <code>&lt;/u&gt;</code>。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="基数" data-numberify>基数<a class="anchor ms-1" href="#基数"></a></h1>
<p>Definition：</p>
<p>集合 $A$ 中的元素个数称为集合的<strong>基数</strong>（base number），记为 $|A|$。</p>
<p>对于任意集合 $A$ 来说，</p>
<ul>
<li>若 $|A|$ 是 <code>&lt;u&gt;</code>有限的 <code>&lt;/u&gt;</code>，称该集合为<strong>有限集</strong>（finite set）；</li>
<li>若 $|A|$ 是 <code>&lt;u&gt;</code>无限的 <code>&lt;/u&gt;</code>，称该集合为<strong>无限集</strong>（infinite set）。</li>
</ul>
<hr>
<h1 id="集合与元素的关系" data-numberify>集合与元素的关系<a class="anchor ms-1" href="#集合与元素的关系"></a></h1>
<p>元素与集合之间有两种关系：</p>
<ul>
<li>
<p>属于：如 “$a$ 是集合 $A$ 中的元素” 或 “$a$ 属于 $A$ ” 记为</p>
<p>$$
a \in A。
$$</p>
</li>
<li>
<p>不属于：如 “$a$ 不是是集合 $A$ 中的元素” 或 “$a$ 不属于 $A$” 记为</p>
<p>$$
a \notin A。
$$</p>
</li>
</ul>
<hr>
<h1 id="集合与集合的关系" data-numberify>集合与集合的关系<a class="anchor ms-1" href="#集合与集合的关系"></a></h1>
<h2 id="外延性原理" data-numberify>外延性原理<a class="anchor ms-1" href="#外延性原理"></a></h2>
<p>Theorem：</p>
<p>两个集合 $A$ 和 $B$ <strong>相等</strong>，当且仅当它们的<strong>元素完全相同</strong>，记为 $A\ =\ B$，否则 $A$ 和 $B$ <strong>不相等</strong>，记为 $A\ \neq\ B$。</p>
<hr>
<h2 id="包含关系" data-numberify>包含关系<a class="anchor ms-1" href="#包含关系"></a></h2>
<p>Definitions：</p>
<p>设 $A$，$B$ 是任意两个集合，</p>
<ul>
<li>
<p><strong>包含与不包含</strong>：如果 $B$ 的每个元素都是 $A$ 中的元素，则称 $B$ 是 $A$ 的<strong>子集</strong>（subset），也称 ${B}$ <strong>被</strong> ${A}$ <strong>包含</strong>或 ${A}$ <strong>包含</strong> ${B}$，记作 ${B \subseteq A}$ 或 $A \supseteq B$，称 $\subseteq$ 或 $\supseteq$ 为<strong>被包含关系</strong>（included relation）或<strong>包含关系</strong>（inclusion relation）；否则记作 ${B \nsubseteq A}$。</p>
<p>“$\subseteq$” 定义的数学语言描述为：</p>
<p>$$
B \subseteq A<br>
\Longleftrightarrow\ \forall x，
如果 x \subseteq B，
则 x \subseteq A。
$$</p>
<p>由子集的定义可推出 $A \subseteq A$。</p>
</li>
<li>
<p><strong>真包含</strong>：如果 $B \subseteq A$ 并且 $A \neq B$，则称 $B$ 是 $A$ 的<strong>真子集</strong>（proper subset），也称做 ${B}$ <strong>被</strong> ${A}$ <strong>真包含</strong>或 ${A}$ <strong>真包含</strong> ${B}$，记作 ${B \subset A}$，称 $\subset$ 为<strong>真包含关系</strong>（properly inclusion relation）。</p>
<p>“$\subset$” 定义的数学语言描述为：</p>
<p>$$
B \subset A \Longleftrightarrow 对 \forall x，若 x \in B，则 x \in A，并且 \exists y \in A，但 y \notin B。
$$</p>
</li>
</ul>
<hr>
<h2 id="相等关系" data-numberify>相等关系<a class="anchor ms-1" href="#相等关系"></a></h2>
<p>Theorem：</p>
<p>设 $A$，$B$ 为任意两个集合，则 ${A\ =\ B}\ \Longleftrightarrow\ {A \subseteq B}$ 并且 ${B \subseteq A}$。</p>
<hr>
<h1 id="常见特殊的集合" data-numberify>常见特殊的集合<a class="anchor ms-1" href="#常见特殊的集合"></a></h1>
<h2 id="空集" data-numberify>空集<a class="anchor ms-1" href="#空集"></a></h2>
<p>Definition：</p>
<p>不含任何元素的集合叫做<strong>空集</strong>（empty set），记作 $\emptyset$。</p>
<p>$$
\emptyset = {x|x \neq x}
$$</p>
<ul>
<li>空集是一切集合的子集。</li>
<li>空集是<strong>绝对唯一</strong>的。</li>
</ul>
<p>Example：</p>
<ul>
<li>$|\emptyset| = 0$，</li>
<li>$|{\emptyset}| = 1$。</li>
</ul>
<hr>
<h3 id="证明空集是绝对唯一的" data-numberify>证明空集是绝对唯一的<a class="anchor ms-1" href="#证明空集是绝对唯一的"></a></h3>
<blockquote>
<p>对 “唯一性” 的证明通常采用反证法（先假设 “不唯一”，得出矛盾，从而证明 “唯一性” 是正确的）。</p>
</blockquote>
<p>证明：</p>
<p>假设有两个不同的空集 $\emptyset_1$ 和 $\emptyset_2$ ，由空集是一切集合的子集得</p>
<p>$$
\empty_1 \subseteq \emptyset_2\ 和\ \emptyset_2 \subseteq \emptyset_1
$$</p>
<p>根据集合的相等关系，得 $\emptyset_1 = \emptyset_2$，与假设矛盾。因此空集是绝对唯一的。</p>
<hr>
<h2 id="全集" data-numberify>全集<a class="anchor ms-1" href="#全集"></a></h2>
<p>Definition：</p>
<p>在一个相对固定的范围内，包含此范围内所有元素的集合，称为<strong>全集</strong>或<strong>论集</strong>（universal set），用 $U$ 或 $E$ 表示。</p>
<p>在维恩图中一般用方形表示全集。</p>
<p><picture><img class="img-fluid " alt="全集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%85%A8%E9%9B%86.png" loading="lazy" width="1021" height="563" />
</picture>

</p>
<p>全集是<strong>相对唯一</strong>的。</p>
<hr>
<h2 id="m-元子集" data-numberify>m 元子集<a class="anchor ms-1" href="#m-元子集"></a></h2>
<p>Definition：</p>
<p>如果一个集合含有 $n$ 个元素，则称集合 $A$ 为 $n$ 元子集，称含有 $A$ 中 $m(0 \le m \le n)$个元素的子集为它的 $m$ 元子集。</p>
<p>对于任意 $n$ 元集合 $A$，它的 $m$ 元（$0 \le m \le n$）子集（包含空集）个数为 $C_n^m$ 个，所以不同的子集个数为：</p>
<p>$$
C_n^0 + C_n^1 + \cdots + C_n^n = (1 + 1)^n = 2^n。
\tag{1}
$$</p>
<hr>
<h2 id="幂集" data-numberify>幂集<a class="anchor ms-1" href="#幂集"></a></h2>
<p>Definition：</p>
<p>设 $A$ 为任意集合，把 $A$ 的所有不同子集构成的集合叫做 $A$ 的<strong>幂集</strong>（power set），记作 $P(A)$，即</p>
<p>$$
P(A)\ =\ {x|x \subseteq A}。
$$</p>
<p>由公式 $(1)$ 可得 $|A| = 2^n(n=|A|)$。</p>
<p>幂集也叫做<strong>集族</strong>（family of set）或<strong>集合的集合</strong>。</p>
<blockquote>
<p>对集族的研究在数学方面、知识库和表处理语言以及人工智能等方面都有十分重要的意义。</p>
</blockquote>
<hr>
<h1 id="集合的运算" data-numberify>集合的运算<a class="anchor ms-1" href="#集合的运算"></a></h1>
<h2 id="集合运算的定义" data-numberify>集合运算的定义<a class="anchor ms-1" href="#集合运算的定义"></a></h2>
<p>Definition：</p>
<p>设 $U$ 是全集，$A$、$B$ 是 $U$ 的两个子集，则</p>
<ol>
<li>
<p>“$\cup$” <strong>并运算</strong>（union operation）：$A \cup B = {x|x \in A\ or\ x \in B}$ 是 $A$ 与 $B$ 的<strong>并集</strong>（union）。</p>
<p><picture><img class="img-fluid " alt="并集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%B9%B6%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
<p>并集可代表两个集合 “相加”。</p>
</li>
<li>
<p>“$\cap$” <strong>交运算</strong>（intersection operation）：$A \cap B = {x|x \in A\ and\ B}$ 是 $A$ 与 $B$ 的<strong>交集</strong>（intersection）。</p>
<p><picture><img class="img-fluid " alt="交集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E4%BA%A4%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
</li>
<li>
<p>“$\overline{A}$” <strong>补运算</strong>（complement operation）：$\overline{A} = U - A$ 是集合 $A$ 的<strong>补集</strong>（complement）（也可记为 $A&rsquo;$、$~A$、$A^c$ 等）。$A$ 对于全集 $U$ 的补集是<strong>绝对补集</strong>。</p>
<p><picture><img class="img-fluid " alt="补集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E8%A1%A5%E9%9B%86.png" loading="lazy" width="1116" height="828" />
</picture>

</p>
</li>
<li>
<p>“$-$” <strong>差运算</strong>（subtraction operation）：$A-B={x|x \in A\ and\ x \notin B} = A \cap \overline{B}$ 是 $A$ 与 $B$ 的<strong>差集</strong>（subtraction)，又称 $B$ 在 $A$ 中的<strong>相对补集</strong>。</p>
<p><picture><img class="img-fluid " alt="差集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%B7%AE%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
<p>当 $A=U$ 时，$A-B=\overline{B}$。</p>
</li>
<li>
<p>“$\oplus$” <strong>对称差运算</strong>（symmetric difference operation）：$A \oplus B = {x|(x \in A\ and\ x \notin B)\ or\ (x\in B\ and\ x \notin A} = (A-B) \cup (B-A)$ 是 $A$ 与 $B$ 的<strong>对称差集</strong>（symmetric difference of set）。</p>
<p><picture><img class="img-fluid " alt="相对补集" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E7%9B%B8%E5%AF%B9%E8%A1%A5%E9%9B%86.png" loading="lazy" width="1585" height="828" />
</picture>

</p>
</li>
</ol>
<p>扩展：</p>
<p>设 $A_1,A_2,\cdots,A_n$ 是任意 $n$ 个集合，则</p>
<ul>
<li>
<p>这 $\mathbf n$ <strong>个集合的并集</strong>是包含那些<strong>至少是这组集合中一个集合成员的元素</strong>的集合，即</p>
<p>$$
\displaystyle \bigcup_{i=1}^{n}{A_i}
= A_1 \cup A_2 \cup \cdots \cup A_n
= {x|x \in A_1\ or\ x \in A_2 \cdots or\ x \in A_n}
$$</p>
</li>
<li>
<p>这 $\mathbf n$ <strong>个集合的交集</strong>是那些属于<strong>这组集合中所有集合成员的元素</strong>的集合，即</p>
<p>$$
\displaystyle \bigcap_{i=1}^{n}{A_i}
= A_1 \cap A_2 \cap \cdots \cap A_n
= {x|x \in A_1\ and\ x \in A_2 \cdots and\ x \in A_n}
$$</p>
</li>
</ul>
<p>当 $n$ 无限增大时，可记为</p>
<ul>
<li>$\displaystyle \bigcup^{\infin}_{i=1}A_i = A_1 \cup A_2 \cup \cdots$</li>
<li>$\displaystyle \bigcap^{\infin}_{i=1}A_i = A_1 \cap A_2 \cap \cdots$</li>
</ul>
<hr>
<h2 id="集合运算的基本等式" data-numberify>集合运算的基本等式<a class="anchor ms-1" href="#集合运算的基本等式"></a></h2>
<p>设 $U$ 为全集，$A$，$B$，$C$ 为任意集合，</p>
<table>
<thead>
<tr>
<th style="text-align:left">等式</th>
<th style="text-align:center">性质</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$A \cup A = A$<br>$A \cap A = A$</td>
<td style="text-align:center">幂等率</td>
</tr>
<tr>
<td style="text-align:left">$A \cup B = B \cup A$<br>$A \cap B = B \cap A$</td>
<td style="text-align:center">交换律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (B \cup C) = (A \cup B) \cup C$<br>$A \cap (B \cap C) = (A \cap B) \cap C$</td>
<td style="text-align:center">结合律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup \emptyset = A$<br>$A \cap U = A$</td>
<td style="text-align:center">同一律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup U = U$<br>$A \cap \emptyset = \emptyset$</td>
<td style="text-align:center">零律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$<br>$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$</td>
<td style="text-align:center">分配律</td>
</tr>
<tr>
<td style="text-align:left">$A \cup (A \cap B) = A$<br>$A \cap (A \cup B)$</td>
<td style="text-align:center">吸收律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A} \cap A = \emptyset$</td>
<td style="text-align:center">矛盾律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A} \cup A = U$</td>
<td style="text-align:center">排中律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{\overline{A}}=A$</td>
<td style="text-align:center">双重否定律</td>
</tr>
<tr>
<td style="text-align:left">$\overline{A \cup B} = \overline{A} \cap \overline{B}$<br>$\overline{A \cap B} = \overline{A}$</td>
<td style="text-align:center">德摩根律</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="分配律" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E5%88%86%E9%85%8D%E5%BE%8B-16308401576391.png" loading="lazy" width="3655" height="1381" />
</picture>

</p>
<p>证明德摩根律的等式之一：$\overline{A \cup B} = \overline{A} \cap \overline{B}$</p>
<p>证明：</p>
<ol>
<li>
<p>证明 $\overline{A \cup B} \subseteq \overline{A} \cap \overline{B}$</p>
<p>$\begin{aligned} \forall x \in \overline{A \cup B} \quad &amp; \Rightarrow\ x \notin A \cup B\ \Rightarrow\ x \notin A\ and\ x \notin B\ &amp; \Rightarrow x \in \overline{A}\ and\ x \in \overline{B}\ \Rightarrow\ x \in \overline{A} \cap \overline{B}， \end{aligned}$</p>
<p>即 $\overline{A \cup B} \subseteq \overline{A} \cap \overline{B}$；</p>
</li>
<li>
<p>证明 $\overline{A} \cap \overline{B} \subseteq \overline{A \cup B}$</p>
<p>$\begin{aligned} \forall x \in \overline{A} \cap \overline{B} \quad &amp; \Rightarrow\ x \in \overline{A}\ and\ x \in \overline{B}\ \Rightarrow\ x \notin A\ and\ x \notin B\ &amp; \Rightarrow\ x \notin A \cup B\ \Rightarrow\ x \in \overline{A} \cap \overline{B}， \end{aligned}$</p>
<p>即 $\overline{A} \cap \overline{B} \subseteq \overline{A \cup B}$。</p>
</li>
</ol>
<p>综上可得 $\overline{A \cup B} = \overline{A} \cap \overline{B}$。</p>
<hr>
<h1 id="无限集合" data-numberify>无限集合<a class="anchor ms-1" href="#无限集合"></a></h1>
<p>有限集合与无限集合的根本区别是：对于无限集合，表面上个数完全不相等的两个集合之间仍可能存在等势关系，如集合与真子集之间。</p>
<h2 id="等势" data-numberify>等势<a class="anchor ms-1" href="#等势"></a></h2>
<p><strong>冯·诺依曼的自然数定义</strong>：</p>
<p>基于基数，利用一个集合的序列来定义自然数。</p>
<ol>
<li>$\emptyset \in \mathbf{N}$；</li>
<li>若 $n \in \mathbf{N}$，则 $n&rsquo; \equiv n \cup {n} \in \mathbf{N}$。</li>
</ol>
<p>从而，这个 <code>&lt;u&gt;</code>集合序列的基数 <code>&lt;/u&gt;</code>可以来定义自然数：</p>
<ul>
<li>$0 \equiv \emptyset$；</li>
<li>$1 \equiv \emptyset \cup {\emptyset} = {\emptyset} = {0}$；</li>
<li>$2 \equiv {\emptyset} \cup {{\emptyset}} = {\emptyset, {\emptyset}} = {0,1}$；</li>
<li>$\cdots$</li>
<li>$n \equiv {0,1,2,3,\cdots,n-1}$；</li>
<li>$\cdots$</li>
<li>$\mathbf{N} \equiv {0,1,2,\cdots,n,\cdots}$。</li>
</ul>
<blockquote>
<p>实际上，任意含有 $n$ 个元素的集合都可以用 $n$ 表示。即，任意两个基数相同的集合之间都可以建立一一对应关系。</p>
</blockquote>
<hr>
<p>Definition：</p>
<p>设 $A$，$B$ 为两个集合，若在 $A$，$B$ 之间存在一种一一对应的关系：</p>
<p>$$
\Psi:\ A \rightarrow B
$$</p>
<p>则称 $A$ 与 $B$ 是<strong>等势的</strong>（equipotential），记作：</p>
<p>$$
A \sim B
$$</p>
<p>也称集合 $A$、$B$ <strong>等势</strong>（equipotent）。</p>
<p>由等势定义可得，如果 $A = B$，那么 $A \sim B$，反之则不一定成立。</p>
<p>Theorem：</p>
<ol>
<li>两个有限集合等式当且仅当它们有相同的元素个数。</li>
<li>有限集合不和其任何真子集等势。</li>
<li><code>&lt;u&gt;</code>可数集合可以与其可数的真子集等势 <code>&lt;/u&gt;</code>。</li>
</ol>
<hr>
<h2 id="可数集合" data-numberify>可数集合<a class="anchor ms-1" href="#可数集合"></a></h2>
<p>Definition：</p>
<p>凡与自然数集合 $\mathbf{N}$ 等势的集合，称之为<strong>可数集合</strong>（countable set），该类集合的基数记为 $\aleph_0$（aleph，阿列夫）。</p>
<p>Example：</p>
<p>证明以下集合是可数集合，</p>
<ol>
<li>
<p>$O^+ = {x|x \in \mathbf{N}，x是正奇数}$</p>
<p>在 $O^+$ 与 $\mathbf{N}$ 之间建立一个一一对应关系 $\varphi_1 : \mathbf{N} \rightarrow O^+$：</p>
<p>$$
\begin{matrix}
0&amp; 1&amp; 2&amp; \cdots&amp; n&amp; \cdots\
\downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow\
1&amp; 3&amp; 5&amp; \cdots&amp; 2n+1&amp; \cdots&amp;\
\end{matrix}
$$</p>
<p>所以 $O^+$ 是可数集合。</p>
</li>
<li>
<p>$P = {x|x \in \mathbf{N}，x是素数}$</p>
<p>在 $P$ 与 $\mathbf{N}$ 之间建立一个一一对应关系 $\varphi_2 : \mathbf{N} \rightarrow P$：</p>
<p>$$
\begin{matrix}
0&amp; 1&amp; 2&amp; 3&amp; 4&amp; \cdots\
\downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow&amp; \downarrow\
2&amp; 3&amp; 5&amp; 7&amp; 11&amp; \cdots&amp;\
\end{matrix}
$$</p>
<p>所以 $P$ 是可数集合。</p>
</li>
<li>
<p>有理数集合 $\mathbf{Q}$</p>
<p>将 $\mathbf{Q}$ 中的所有元素都写成 $p/q$（$p$、$q$ 是整数，且 $q \neq 0$）的形式，从 $0/1^{[0]}$ 开始，将所有有理数与自然数一一配对（其中 $p/q^{[n]}$ 的上标 $[n]$ 代表对应于该有理数的自然数）：</p>
<p><picture><img class="img-fluid " alt="证明Q是可数集合" src="/blog/2022/09/%E9%9B%86%E5%90%88%E8%AE%BA/%E8%AF%81%E6%98%8EQ%E6%98%AF%E5%8F%AF%E6%95%B0%E9%9B%86%E5%90%88-16308441770882.jpg" loading="lazy" width="1362" height="360" />
</picture>

</p>
<p>所以 $\mathbf{Q}$ 是可数集合。</p>
</li>
</ol>
<hr>
<h2 id="不可数集合" data-numberify>不可数集合<a class="anchor ms-1" href="#不可数集合"></a></h2>
<p>Definition：</p>
<p>开区间 $(0,1)$ 称为不可数集合，凡<strong>与开区间 $(0,1)$ 等势</strong>的集合，都称为<strong>不可数集合</strong>，该类集合的基数记为 $\aleph$（或 $\aleph_1$）。</p>
<p>Example：</p>
<ol>
<li>
<p>闭区间 $[0,1]$ 是不可数集合。</p>
<p>证明：在 $[0,1]$ 和 $(0,1)$ 之间建立如下对应关系：</p>
<p>$$
R:
\begin{cases}
\begin{matrix}
0&amp; \rightarrow&amp; 1/4 \
1&amp; \rightarrow&amp; 1/2 \
\cfrac{1}{2^n}&amp; \rightarrow&amp; \cfrac{1}{2^{n+2}},&amp; n=1,2,3,\cdots \
n&amp; \rightarrow&amp; n,&amp; 其他 n \in (0,1)\
\end{matrix}
\end{cases}
$$</p>
<p>显然 $[0,1]$ 与 $(0,1)$ 是等势的，所以 $[0,1]$ 是不可数集合。</p>
</li>
<li>
<p>实数集 $\mathbf R$ 是不可数集合。</p>
<p>证明：在实数集 $\mathbf R$ 和开区间 $(0,1)$ 之间建立如下对应关系：</p>
<p>$$
n \rightarrow \tan{\pi\bigg(\cfrac{2n-1}{2}\bigg)}
$$</p>
<p>显然 $(0,1)$ 与 $\mathbf{R}$ 之间是等势的，所以 $\mathbf{R}$ 是一个不可数集合。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>命题逻辑</title>
      <link>/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/</link>
      <pubDate>Sun, 23 Jan 2022 02:03:41 +0800</pubDate>
      
      <guid>/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/</guid>
      <description><![CDATA[命题的定义 具有确切真值的陈述句称为命题（proposition）。命题可以取一个 “值”，称为真值。真值只有 “真”（用 “T” or “1” 表示，即 T]]></description>
      <content:encoded><![CDATA[<h1 id="命题的定义" data-numberify>命题的定义<a class="anchor ms-1" href="#命题的定义"></a></h1>
<p>具有<u>确切真值的陈述句</u>称为<strong>命题</strong>（<strong>proposition</strong>）。命题可以取一个 “值”，称为<strong>真值</strong>。真值只有 “真”（用 “T” or “1” 表示，即 True）和 “假”（用 “F” or “0” 表示，即 False）。</p>
<blockquote>
<p>通常用带或不带下标的大写英文字母表示命题。</p>
</blockquote>
<hr>
<h2 id="非命题" data-numberify>非命题<a class="anchor ms-1" href="#非命题"></a></h2>
<p>一切没有判断内容的句子，如命令句（祈使句）、感叹句、疑问句、二义性的陈述句等都<u>不能作为命题</u>。</p>
<hr>
<h1 id="原子命题与复合命题" data-numberify>原子命题与复合命题<a class="anchor ms-1" href="#原子命题与复合命题"></a></h1>
<ul>
<li><strong>原子命题</strong>（<strong>简单命题</strong>）：不能再分解为更简单命题的命题。</li>
<li><strong>复合命题</strong>：可以分解为更为简单命题的命题。这些简单命题之间是通过联结词和标点符号复合而成。</li>
</ul>
<hr>
<h2 id="命题变元" data-numberify>命题变元<a class="anchor ms-1" href="#命题变元"></a></h2>
<p>一个特定的命题是一个<strong>常值命题</strong>，它不是具有值 “T”，就是具有值 “F”。</p>
<p>一个任意的没有赋予具体内容的原子命题就是一个<u>变量命题</u>，常称它为<strong>命题变量</strong>（或<strong>命题变元</strong>，<strong>propositional vatiable</strong>）。</p>
<p>命题变元<u>无具体的真值</u>，它的变域是集合 ${T,F}$（或 ${0,1}$）。</p>
<hr>
<h1 id="联结词" data-numberify>联结词<a class="anchor ms-1" href="#联结词"></a></h1>
<p>联结词是<strong>两个命题真值之间的联结</strong>，而不是命题内容之间的连接，因此复合命题的真值只取决于<u>构成它们的各简单命题的真值</u>，而与它们的内容无关，与二者之间是否有关系无关。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264217690456.jpg" loading="lazy" width="1268" height="208" />
</picture>

</p>
<hr>
<h2 id="否定联结词" data-numberify>否定联结词<a class="anchor ms-1" href="#否定联结词"></a></h2>
<p>设 $P$ 是任意一个命题，复合命题 <font color="green">“非 $P$”</font>（或 <font color="green">“$P$ 的否定”</font>）称为 $P$ 的<strong>否定式</strong>（<strong>negation</strong>），记作 <font color="red">$\neg P$</font>，“$\neg$” 为否定联结词。</p>
<p>$P$ 为真当且仅当 $\neg P$ 为假。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P$</th>
<th style="text-align:center">$\neg P$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“$\neg$” 是自然语言中的 “非”、“不”、“没有” 等的逻辑抽象。</p>
</blockquote>
<hr>
<h2 id="合取联结词" data-numberify>合取联结词<a class="anchor ms-1" href="#合取联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 并且 $Q$”</font>（或 <font color="green">“$P$ 和 $Q$”</font>）称为 $P$ 与 $Q$ 的<strong>合取式</strong>（<strong>conjunction</strong>），记作 <font color="red">$P \wedge Q$</font>，“$\wedge$” 为<strong>合取联结词</strong>。</p>
<p>$P \wedge Q$ 为真当且仅当 $P$、$Q$ 同为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \wedge Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16263438047401.jpg" loading="lazy" width="1246" height="252" />
</picture>

</p>
<hr>
<h2 id="析取联结词" data-numberify>析取联结词<a class="anchor ms-1" href="#析取联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 或 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>析取式</strong>（<strong>disjunction</strong>），记作 <font color="red">$P \vee Q$</font>，“$\vee$” 为<strong>析取联结词</strong>。</p>
<p>$P \vee Q$ 为真当且仅当 $P$、$Q$ 至少有一个为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>联结词 “$\vee$” 是自然语言中的 “或”、“或者” 等的逻辑抽象。</p>
<p>自然语言中的 “或” 有 “可兼或”（或称为同或）、“不可兼或”（即异或）两种。</p>
<p>严格来讲，析取联结词实际上代表的是可兼或。</p>
</blockquote>
<hr>
<h2 id="异或联结词" data-numberify>异或联结词<a class="anchor ms-1" href="#异或联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 或 $Q$”</font> 有时代表不可兼或，记作 <font color="red">$P \oplus Q$ 或 $P \overline{\vee} Q$</font>，“$\oplus$” 或 “$\overline{\vee}$” 为<strong>异或联结词</strong>。</p>
<p>$P \oplus Q$ 为真当且仅当 $P$、$Q$ 中有且仅有一个为真。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="蕴涵联结词" data-numberify>蕴涵联结词<a class="anchor ms-1" href="#蕴涵联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“如果 $P$，则 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>蕴涵式</strong>（<strong>implication</strong>），记作 $P \rightarrow Q$，“$\rightarrow$” 为<strong>蕴含联结词</strong>。</p>
<p>$P \rightarrow Q$ 为假当且仅当 $P$ 为真且 $Q$ 为假（$P$ 为假时，认为该蕴涵式为真）。</p>
<p>一般把蕴涵式 $P \rightarrow Q$ 中的 $P$ 称为该蕴涵式的<strong>前件</strong>，$Q$ 称为蕴涵式的<strong>后件</strong>。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264203339885.jpg" loading="lazy" width="1270" height="255" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264204420358.jpg" loading="lazy" width="1289" height="552" />
</picture>

</p>
<hr>
<h2 id="等价联结词" data-numberify>等价联结词<a class="anchor ms-1" href="#等价联结词"></a></h2>
<p>设 $P$、$Q$ 是任意两个命题，复合命题 <font color="green">“$P$ 当且仅当 $Q$”</font> 称为 $P$ 与 $Q$ 的<strong>蕴涵式</strong>（<strong>implication</strong>），记作 $P \leftrightarrow Q$，“$\leftrightarrow$” 为<strong>等价联结词</strong>。</p>
<p>$P \leftrightarrow Q$ 为真当且仅当 $P$、$Q$ 同为真假。</p>
<p>真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$P \qquad Q$</th>
<th style="text-align:center">$P \vee Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0 \qquad 0$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">$0 \qquad 1$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 0$</td>
<td style="text-align:center">$0$</td>
</tr>
<tr>
<td style="text-align:center">$1 \qquad 1$</td>
<td style="text-align:center">$1$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“$\leftrightarrow$” 是自然语言中的 “等价”、“充分必要条件”、“当且仅当” 等的逻辑抽象。</p>
</blockquote>
<hr>
<h2 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h2>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264212687867.jpg" loading="lazy" width="1139" height="479" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264213759514.jpg" loading="lazy" width="1138" height="303" />
</picture>

</p>
<p>命题联结词 “$\wedge$”、“$\vee$”、“$\leftrightarrow$” 具有对称性，而 “$\neg$”、“$\rightarrow$” 没有。</p>
<hr>
<h2 id="优先级" data-numberify>优先级<a class="anchor ms-1" href="#优先级"></a></h2>
<p>优先顺序：括号、否定、合取、析取、蕴涵、等价。同级的联结词，按出现的先后次序（从左到右）。</p>
<hr>
<h1 id="命题联结词的应用" data-numberify>命题联结词的应用<a class="anchor ms-1" href="#命题联结词的应用"></a></h1>
<h2 id="联结词与开关电路" data-numberify>联结词与开关电路<a class="anchor ms-1" href="#联结词与开关电路"></a></h2>
<p>设命题 $P$：开关 $S_1$ 闭合；命题 $Q$：开关 $S_2$ 闭合。则以下电路可用复合命题表示：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264222756445.jpg" loading="lazy" width="1072" height="270" />
</picture>

</p>
<ol>
<li>“串联”：$P \wedge Q$；</li>
<li>“并联”：$P \vee Q$；</li>
<li>“断开”：$\neg P$。</li>
</ol>
<hr>
<h2 id="联结词与逻辑电路" data-numberify>联结词与逻辑电路<a class="anchor ms-1" href="#联结词与逻辑电路"></a></h2>
<ol>
<li>
<p>与门：$\wedge$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264225030176.jpg" loading="lazy" width="338" height="138" />
</picture>

</p>
</li>
<li>
<p>或门：$\vee$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264225922743.jpg" loading="lazy" width="336" height="139" />
</picture>

</p>
</li>
<li>
<p>非门：$\neg$</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264226657751.jpg" loading="lazy" width="330" height="139" />
</picture>

</p>
</li>
</ol>
<hr>
<h2 id="联结词与网页检索" data-numberify>联结词与网页检索<a class="anchor ms-1" href="#联结词与网页检索"></a></h2>
<p>在<strong>布尔检索</strong>中，</p>
<ol>
<li>$\wedge$（一般用 AND 表示）用于匹配包含两个检索项的记录；</li>
<li>$\vee$（一般用 OR 表示）用于匹配包含两个检索项至少一个的记录；</li>
<li>$\neg$（一般用 NOT 表示）用于排除某个特定的检索项。</li>
</ol>
<hr>
<h2 id="联结词与位运算" data-numberify>联结词与位运算<a class="anchor ms-1" href="#联结词与位运算"></a></h2>
<ol>
<li>按位与：$\wedge$；</li>
<li>按位或：$\vee$；</li>
<li>按位取反：$\neg$。</li>
</ol>
<hr>
<h1 id="命题公式" data-numberify>命题公式<a class="anchor ms-1" href="#命题公式"></a></h1>
<p>复合命题是由原子命题与联结词构成的命题。所以，当其中的原子命题是<a href="#命题变元">命题变元</a>时，此复合命题也即为命题变元的函数，且该函数的值仍为 “真” 或 “假” 值，这样的函数可形象地称为 “<strong>真值函数</strong>” 或 “<strong>命题公式</strong>”，此命题公式没有确切的真值。</p>
<hr>
<h2 id="命题公式的定义" data-numberify>命题公式的定义<a class="anchor ms-1" href="#命题公式的定义"></a></h2>
<p><strong>命题演算的合式公式</strong>（<strong>Well Formed Formula</strong>，<strong>WFF</strong>），又称<strong>命题公式</strong>（简称公式），按如下规则生成：</p>
<ol>
<li>命题变元本身是一个公式；</li>
<li>如果 $G$ 是公式，则 $(\neg G)$ 也是公式；</li>
<li>如果 $G$、$H$ 是公式，则 $(G \wedge H)$、$(G \vee H)$、$(G \rightarrow H)$、$(G \leftrightarrow H)$ 也是公式；</li>
<li>仅由<u>有限步使用规则 1、2、3</u> 后所得到的包含命题变元、联结词和括号的符号串才是命题公式。</li>
</ol>
<p>如果 $G$ 是含有 $n$ 个命题变元 $P_1、P_2、P_3、\cdots、P_n$ 的公式，可记为：$G(P_1,P_2,P_3,\cdots,P_n)$ 或简写为 $G$。</p>
<hr>
<ul>
<li>原子命题变元是最简单的合式公式，称为原子合式公式，简称原子公式；</li>
<li>命题公式没有真值，只有对其命题变元进行真值指派后，方可确定命题公式的真值；</li>
<li>整个公式的最外层括号可以省略，公式中不影响运算次序的括号也可以省略；</li>
<li>在实际应用中，为了便于存储和运算，命题公式常用二元数方式来表达。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264271696146.jpg" loading="lazy" width="870" height="365" />
</picture>

</p>
<hr>
<h2 id="命题公式的解释" data-numberify>命题公式的解释<a class="anchor ms-1" href="#命题公式的解释"></a></h2>
<p>设 $P_1、P_2、P_3、\cdots、P_n$ 是出现在公式 $G$ 中的所有命题变元，给 $P_1、P_2、P_3、\cdots、P_n$ 指定一组真值，则这组真值称为 $G$ 的一个<strong>解释</strong>，常记为 <font color="red">$I$</font>。</p>
<ul>
<li>如果公式 $G$ 在解释 $I$ 下是真的，则称 <font color="green">$I$ 满足 $G$</font>，此时 $I$ 是 $G$ 的<strong>成真赋值</strong>；</li>
<li>如果 $G$ 在解释 $I$ 下是假的，则称 <font color="green">$I$ 弄假于 $G$</font>，此时 $I$ 是 $G$ 的<strong>成假赋值</strong>。</li>
</ul>
<hr>
<h2 id="命题公式的分类" data-numberify>命题公式的分类<a class="anchor ms-1" href="#命题公式的分类"></a></h2>
<ul>
<li><strong>永真公式</strong>（又叫<strong>重言式</strong>，<strong>tautology</strong>）：如果在它的所有解释之下其真值都为 “真”。</li>
<li><strong>永假公式</strong>（又叫<strong>矛盾式</strong>，<strong>contradiction</strong>）：如果在它的所有解释下其真值都为 “假”。</li>
</ul>
<hr>
<ul>
<li><strong>不可满足公式</strong>：即永假公式。</li>
<li><strong>可满足公式</strong>（<strong>satisfiable</strong>）：不为永假公式的公式。</li>
</ul>
<hr>
<ul>
<li>$G$ 是永真的当且仅当 $\neg G$ 是永假的；</li>
<li>$G$ 是可满足的当且仅当至少有一个解释 $I$，使 $G$ 在 $I$ 下为真；</li>
<li>若 $G$ 是永真式，则 $G$ 一定是可满足式，但反之可满足式不一定是永真式。</li>
</ul>
<hr>
<h2 id="等价的命题公式" data-numberify>等价的命题公式<a class="anchor ms-1" href="#等价的命题公式"></a></h2>
<p>设 $G$、$H$ 是两个命题公式，$P_1、P_2、P_3、\cdots、P_n$ 是出现在 $G$、$H$ 中所有的命题变元，如果对于 $P_1、P_2、P_3、\cdots、P_n$ 的 $2^n$ 个解释，$G$ 与 $H$ 的<strong>真值结果都相同</strong>，则称公式 $G$ 与 $H$ 是<strong>等价</strong>的，记作 <font color="red">$G = H$</font>（或 <font color="red">$G \Leftrightarrow H$</font>）。</p>
<hr>
<h3 id="公式等价的充分必要条件" data-numberify>公式等价的充分必要条件<a class="anchor ms-1" href="#公式等价的充分必要条件"></a></h3>
<p>对于任意两个公式 $G$ 和 $H$，<font color="red">$G = H$ 的充分必要条件是公式 $G \leftrightarrow H$ 是永真公式</font>。</p>
<p>Proof：</p>
<ul>
<li>必要性：假定 $G = H$，则 $G$、$H$ 在其任意解释 $I$ 下或同为真或同为假，于是由 “$\leftrightarrow$” 的意义知，公式 $G \leftrightarrow H$ 在其任何的解释 $I$ 下，其真值为 “真”，即 $G \leftrightarrow H$ 为永真公式。</li>
<li>充分性：假定公式 $G \leftrightarrow H$ 是永真公式，$I$ 是它的任意解释，在 $I$ 下，$G \leftrightarrow H$ 为真，因此，$G$，$H$ 或同为真或同为假，由于 $I$ 的任意性，故有 $G = H$。</li>
</ul>
<blockquote>
<p>可判定性：能否给出一个可行方法，完成对任意公式的判定问题（类型或等价判定）。</p>
</blockquote>
<p>命题公式是可判定的。</p>
<hr>
<h2 id="命题公式的基本等价关系" data-numberify>命题公式的基本等价关系<a class="anchor ms-1" href="#命题公式的基本等价关系"></a></h2>
<p>设 $G$、$H$、$S$ 为任意的命题公式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">性质</th>
<th style="text-align:left">等式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><b id="a2"></b>幂等律</td>
<td style="text-align:left">$G \vee G = G$<br/>$G \wedge G = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a3"></b>交换律</td>
<td style="text-align:left">$G \vee H = H \vee G$<br/>$G \wedge H = H \wedge G$</td>
</tr>
<tr>
<td style="text-align:center">结合律</td>
<td style="text-align:left">$G \vee (H \vee S) = (G \vee H) \vee S$<br/>$G \wedge (H \wedge S) = (G \wedge H) \wedge S$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a4"></b>同一律</td>
<td style="text-align:left">$G \wedge 0 = G$<br/>$G \vee 1 = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a5"></b>零律</td>
<td style="text-align:left">$G \vee 1 = 1$<br/>$G \wedge 0 = 0$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a6"></b>分配律</td>
<td style="text-align:left">$G \vee (H \wedge S) = (G \vee H) \wedge (G \vee S)$</br>$G \wedge (H \vee S) = (G \wedge H) \vee (G \wedge S)$</td>
</tr>
<tr>
<td style="text-align:center">吸收率</td>
<td style="text-align:left">$G \vee (G \wedge H) = G$<br/>$G \wedge (G \vee H) = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a7"></b>矛盾律</td>
<td style="text-align:left">$\neg G \wedge G = 0$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a8"></b>排中律</td>
<td style="text-align:left">$\neg G \vee G = 1$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a9"></b>双重否定律</td>
<td style="text-align:left">$\neg(\neg G) = G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a10"></b>德摩根律</td>
<td style="text-align:left">$\neg(G \vee H) = \neg G \wedge \neg H$</br>$\neg(G \wedge H) = \neg G \vee \neg H$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a11"></b>蕴涵式</td>
<td style="text-align:left">$G \rightarrow H = \neg G \vee H$</td>
</tr>
<tr>
<td style="text-align:center">假言易位</td>
<td style="text-align:left">$G \rightarrow H = \neg H \rightarrow \neg G$</td>
</tr>
<tr>
<td style="text-align:center"><b id="a12"></b>等价式</td>
<td style="text-align:left">$G \leftrightarrow H = (G \rightarrow H) \wedge (H \rightarrow G) = (\neg G \vee H) \wedge (\neg H \vee G)$</td>
</tr>
<tr>
<td style="text-align:center">等价否定等式</td>
<td style="text-align:left">$G \leftrightarrow H = \neg G \leftrightarrow \neg H$</td>
</tr>
<tr>
<td style="text-align:center">归谬论</td>
<td style="text-align:left">$(G \rightarrow H) \wedge (G \rightarrow \neg H) = \neg G$</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="基本等价关系的应用" data-numberify>基本等价关系的应用<a class="anchor ms-1" href="#基本等价关系的应用"></a></h3>
<p>（1）判断公式类型</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264420672234.jpg" loading="lazy" width="620" height="374" />
</picture>

</p>
<p>（2）证明公式等价</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264420999525.jpg" loading="lazy" width="883" height="430" />
</picture>

</p>
<p>（3）开关电路化简</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264421759266.jpg" loading="lazy" width="646" height="360" />
</picture>

</p>
<p>（4）逻辑电路化简</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264422111932.jpg" loading="lazy" width="622" height="380" />
</picture>

</p>
<p>（5）其他</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264422514796.jpg" loading="lazy" width="1232" height="605" />
</picture>

</p>
<hr>
<h1 id="范式" data-numberify>范式<a class="anchor ms-1" href="#范式"></a></h1>
<ul>
<li>命题变元或命题变元的否定称为<strong>文字</strong>。</li>
<li><u>有限个</u>文字（$\ge 1$）的析取称为<strong>简单析取式</strong>（或<strong>子句</strong>）。
单个文字可构成子句。</li>
<li><u>有限个</u>文字（$\ge 1$）的合取称为<strong>简单合取式</strong>（或<strong>短语</strong>）。
单个文字可构成短语。</li>
<li>$P$ 与 $\neg P$ 称为<strong>互补对</strong>。</li>
</ul>
<hr>
<ul>
<li><u>有限个</u>（$\ge 1$）简单合取式（短语）的析取式称为<strong>析取范式</strong>（<strong>disjunctive normal form</strong>）。</li>
<li><u>有限个</u>（$\ge 1$）简单析取式（子句）的合取式称为<strong>合取范式</strong>（<strong>conjunctive normal form</strong>）。</li>
</ul>
<p>文字可以是子句、短语、析取范式、合取范式。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265483645877.png" loading="lazy" width="1226" height="340" />
</picture>

</p>
<ol>
<li>命题公式的析取范式可以指出公式何时为真，而合取范式可以指出公式何时为假，从而能够替代真值表。</li>
<li>命题公式的范式表达并不唯一。</li>
</ol>
<p>Example：</p>
<ol>
<li>
<p>$P$、$\neg P$ 可以是文字、短语、子句、析取范式、合取范式。</p>
</li>
<li>
<p>$P \vee Q \vee \neg R$ 是子句、合取范式、析取范式。</p>
<ul>
<li>
<p>将该式认为是子句，那么单个子句就可构成合取范式。</p>
</li>
<li>
<p>将 $P$、$Q$、$\neg R$ 认为是短语，那么三个短语析取可构成析取范式。</p>
</li>
<li>
<p>$(P \vee Q \vee \neg R)$ 是子句、合取范式。</p>
<p>加了括号后该式就被认为是一个整体，不能作为析取范式。</p>
</li>
</ul>
</li>
<li>
<p>$\neg P \wedge Q \wedge R$ 是短语、析取范式、合取范式。</p>
<ul>
<li>将该式认为是短语，那么单个短语就可构成析取范式。</li>
<li>将 $\neg P$、$Q$、$R$ 认为是子句，那么三个子句合取可构成合取范式。</li>
<li>$(\neg P \wedge Q \wedge R)$ 是短语、析取范式。</li>
</ul>
</li>
<li>
<p>$P \vee (Q \vee \neg R)$ 即不是析取范式也不是合取范式，但转换为 $P \vee Q \vee \neg R$ 后，即是析取范式又是合取范式。</p>
</li>
</ol>
<hr>
<h2 id="范式存在定理" data-numberify>范式存在定理<a class="anchor ms-1" href="#范式存在定理"></a></h2>
<p>联结词之间可以通过命题公式的基本等价关系进行相互转换，因此可以通过逻辑等价公式求出等价的析取范式和合取范式，具体步骤如下：</p>
<ol>
<li>将公式中的 $\rightarrow$、$\leftrightarrow$ 用联结词 $\neg$、$\wedge$、$\vee$ 来取代（使用<a href="#a11">蕴涵式</a>和<a href="#a12">等价式</a>）。</li>
<li>将否定联结词移到各个命题变元的前端，并消去多余的否定号（使用<a href="#a9">双重否定律</a>和<a href="#a10">德摩根律</a>）。</li>
<li>利用<a href="#a6">分配律</a>，可将公式化成一些合取式的析取，或化成一些析取式的合取。</li>
</ol>
<p>对任意一个公式，经过以上步骤（期间可用其他<a href="#命题公式的基本等价关系">等价公式</a>来化简），必能化成与其等价的析取范式和合取范式。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16264518371675.jpg" loading="lazy" width="622" height="382" />
</picture>

</p>
<hr>
<h2 id="主范式" data-numberify>主范式<a class="anchor ms-1" href="#主范式"></a></h2>
<p>范式是不唯一的，对构成范式的子句或短语进一步进行规范化，形成唯一的主析取范式和主合取范式。</p>
<hr>
<h3 id="极大项和极小项" data-numberify>极大项和极小项<a class="anchor ms-1" href="#极大项和极小项"></a></h3>
<p>在含有 $n$ 个命题变元 $P_1、P_2、P_3、\cdots、P_n$ 的<u>短语或子句</u>中，若
<u>每个命题变元与其否定不同时存在</u>，但<u>二者之一恰好出现一次且仅一次</u>，并且<font color="green">出现的次序与 $P_1、P_2、P_3、\cdots、P_n$ 一致</font>，则</p>
<ul>
<li>称此<strong>短语</strong>为关于 $P_1、P_2、P_3、\cdots、P_n$ 的一个<strong>极小项</strong>，</li>
<li>称此<strong>子句</strong>为关于 $P_1、P_2、P_3、\cdots、P_n$ 的一个<strong>极大项</strong>。</li>
</ul>
<p>若有 $n$ 个命题，则应有 $2^n$ 个不同的极小项和 $2^n$ 个不同的极大项。</p>
<hr>
<p>对于极小项：</p>
<ul>
<li>没有两个不同的极小项是等价的。</li>
<li>每个极小项只有一组成假赋值，因此可用于给极大项编码。
编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。</li>
</ul>
<p>Example：</p>
<p>设命题变元 $P$、$Q$，</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265086173840.jpg" loading="lazy" width="1150" height="340" />
</picture>

</p>
<hr>
<p>对于极大项（与极小项相反的规定）：</p>
<ul>
<li>没有两个不同的极大项是等价的。</li>
<li>每个极大项只有一组成假赋值，因此可用于给极大项编码。
编码规则为：命题变元与 0 对应，命题变元的否定与 1 对应。</li>
</ul>
<p>Example：</p>
<p>设命题变元 $P$、$Q$，</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265087894491.jpg" loading="lazy" width="1146" height="339" />
</picture>

</p>
<hr>
<p>极小项的编码可对应为真情况时，相应的短语为真的真值序列。极大项的编码可对应为假情况时，相应的子句为假的真值序列。</p>
<p>极小项和极大项还有以下性质：</p>
<p>设有 $n$ 个命题变元，设 $i,j \in {0, 1, \cdots, 2^{n-1}}$ 且 $i \neq j$，$m_i、m_j$ 代表这 $n$ 个命题变元对应的极小项，$M_i、M_j$ 代表对应的命题变元的极大项。那么就有</p>
<ol>
<li>
<p>$m_i \wedge m_j = 0$，</p>
<p>$M_i \vee M_j = 1$；</p>
</li>
<li>
<p>$m_i = \neg M_i$，</p>
<p>$M_i = \neg m_i$；</p>
</li>
<li>
<p>$\displaystyle \bigvee_{i=0}^{2^n-1}{m_i} = 1$，</p>
<p>$\displaystyle \bigwedge_{i=0}^{2^n-1}{M_i} = 0$。</p>
</li>
</ol>
<hr>
<h3 id="主析取范式和主合取范式" data-numberify>主析取范式和主合取范式<a class="anchor ms-1" href="#主析取范式和主合取范式"></a></h3>
<ul>
<li>在给定的<u>析取范式</u>中，若<u>每一个短语都是极小项</u>，且按照编码<u>从小到大</u>的顺序排列，则称该范式为<strong>主析取范式</strong>(<strong>principal disjunctive normal form</strong>)。</li>
<li>在给定的<u>合取范式</u>中，若<u>每一个子句都是极大项</u>，且按照编码<u>从小到大</u>的顺序排列，则称该范式为<strong>主合取范式</strong>(<strong>principal conjunctive normal form</strong>)。</li>
</ul>
<p>如果一个主析取范式<u>不包含任何极小项</u>，则称该主析取范式为 “<strong>空</strong>”；如果一个<u>主合取范式不包含</u>任何极大项，则称主合取范式为 “<strong>空</strong>”。</p>
<hr>
<p>任何一个公式都有与之等价的主析取范式和主合取范式。</p>
<ul>
<li>如果某一公式的主析取范式包含所有的极小项，即主合取范式为空，则该公式为永真公式。</li>
<li>如果某一公式主合取范式包含所有的极大项，即主析取范式为空，则该公式为永假公式。</li>
<li>若有两个公式，它们具有相同的主析取范式或主合取范式，则两公式等价。</li>
</ul>
<hr>
<h2 id="主范式求解定理" data-numberify>主范式求解定理<a class="anchor ms-1" href="#主范式求解定理"></a></h2>
<ol>
<li>
<p>求出该公式所对应的析取范式和合取范式。</p>
</li>
<li>
<p>消去重复出现的命题变元，矛盾式或重言式。</p>
<ol>
<li>先利用<a href="#a2">幂等律</a>、<a href="#a7">矛盾律</a>和<a href="#a8">排中律</a>消去重复出现的命题元素；</li>
<li>再使用<a href="#a4">同一律</a>和<a href="#a5">零律</a>消去其中的常数。</li>
</ol>
</li>
<li>
<p>若析取（合取）范式的某一个短语（子句）$B_i$ 中缺少命题变元 $P$，则可用如下方式将 $P$ 补进去：</p>
<ul>
<li>求主析取范式：$B_i = B_i \wedge 1 = B_i \wedge (\neg P \vee P) = (B_i \wedge \neg P) \vee (B_i \wedge P)$；</li>
<li>求主合取范式：$B_i = B_i \vee 0 = B_i \vee (\neg P \wedge P) = (B_i \vee \neg P) \wedge (B_i \vee P)$。</li>
</ul>
</li>
<li>
<p>利用<a href="#a2">幂等律</a>将重复的极小项和极大项合并，并利用<a href="#a3">交换律</a>进行顺序调整，由此可转换成标准的主析取范式和主合取范式。</p>
</li>
</ol>
<p>主析取范式的极小项编码序列与主合取范式的极大项变编码序列是互补的。因此，只需求出主析取范式或主合取范式中其中之一，就可对应求出主合取范式或主析取范式。</p>
<hr>
<h3 id="公式转换法" data-numberify>公式转换法<a class="anchor ms-1" href="#公式转换法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265114352643.jpg" loading="lazy" width="962" height="466" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265112790430.jpg" loading="lazy" width="1014" height="389" />
</picture>

</p>
<hr>
<h3 id="真值表技术" data-numberify>真值表技术<a class="anchor ms-1" href="#真值表技术"></a></h3>
<p>从真值表按所给的算法求出主范式的方法，称为<strong>真值表技术</strong> (<strong>technique of truth table</strong>)。</p>
<p>方法：</p>
<ul>
<li>列出真值表，选出公式的真值结果为真的所有的行，在这样的每一行中，找到其每一个解释所对应的极小项，将这些极小项进行析取即可得到相应的主析取范式。</li>
<li>列出真值表，选出公式的真值结果为假的所有的行，在这样的每一行中，找到其每一个解释所对应的极大项，将这些极大项进行合取即可得到相应的主合取范式。</li>
</ul>
<hr>
<h1 id="推理" data-numberify>推理<a class="anchor ms-1" href="#推理"></a></h1>
<p><strong>推理</strong>是指从一组前提合乎逻辑的推出结论的思维过程。</p>
<hr>
<h2 id="基本推理形式" data-numberify>基本推理形式<a class="anchor ms-1" href="#基本推理形式"></a></h2>
<p>设 $G_1、G_2、\cdots、G_n、H$ 是命题公式，称 $H$ 是 $G_1、G_2、\cdots、G_n$ 的<strong>逻辑结果</strong>当且仅当<font color="green">对任意解释 $I$，如果 $I$ 使得 $G_1 \wedge G_2 \wedge \cdots \wedge G_n$ 为真，则 $I$ 也会使 $H$ 为真</font>，记为 $G_1、G_2、\cdots、G_n\ \Rightarrow\ H$，“$\Rightarrow$” 称为<strong>蕴涵关系</strong>，此时称 $G_1、G_2、\cdots、G_n\ \Rightarrow\ H$ 为有效的，否则称为无效的。</p>
<p>$G_1、G_2、\cdots、G_n$ 称为一组<strong>前提</strong>，有时用集合 $\Gamma$ 来表示，记为 $\Gamma = {G_1,G_2,\cdots,G_n}$，$H$ 称为<strong>结论</strong>。此时也称 $H$ 是前提集合 $\Gamma$ 的逻辑结果，记为 $\Gamma \Rightarrow H$。</p>
<hr>
<h2 id="推理的判定定理" data-numberify>推理的判定定理<a class="anchor ms-1" href="#推理的判定定理"></a></h2>
<p>公式 $H$ 是前提集合 $\Gamma = {G_1,G_2,\cdots,G_n}$ 的逻辑结果当且仅当 $(G_1 \wedge G_2 \wedge \cdots \wedge G_n) \rightarrow H$ 为永真公式。</p>
<p>判定方法：</p>
<ol>
<li>真值表技术，</li>
<li>公式转换法，</li>
<li>主析取范式法。</li>
</ol>
<p><picture><img class="img-fluid " alt="16265511416012" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265511416012.jpg" loading="lazy" width="620" height="370" />
</picture>

</p>
<hr>
<h2 id="基本蕴涵关系" data-numberify>基本蕴涵关系<a class="anchor ms-1" href="#基本蕴涵关系"></a></h2>
<p>设 $G$、$H$、$I$ 为任意命题公式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">简化规则</td>
<td style="text-align:left">$G \wedge H \Rightarrow G$<br/>$G \wedge H \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">添加规则</td>
<td style="text-align:left">$G \Rightarrow G \vee H$</td>
</tr>
<tr>
<td style="text-align:center">合取引入规则</td>
<td style="text-align:left">$G,H \Rightarrow G \wedge H$</td>
</tr>
<tr>
<td style="text-align:center">选言三段论</td>
<td style="text-align:left">$G \vee H, \neg G \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">假言推理规则</td>
<td style="text-align:left">$G \rightarrow H, G \Rightarrow H$</td>
</tr>
<tr>
<td style="text-align:center">否定后件式</td>
<td style="text-align:left">$G \rightarrow H, \neg H \Rightarrow \neg G$</td>
</tr>
<tr>
<td style="text-align:center">假言三段论</td>
<td style="text-align:left">$G \rightarrow H, H \rightarrow I \Rightarrow G \rightarrow I$</td>
</tr>
<tr>
<td style="text-align:center">二难推论</td>
<td style="text-align:left">$G \vee H, G \rightarrow I, H \rightarrow I \Rightarrow I$</td>
</tr>
</tbody>
</table>
<p>![])(16265520749814.jpg)</p>
<hr>
<h2 id="自然演绎法推理" data-numberify>自然演绎法推理<a class="anchor ms-1" href="#自然演绎法推理"></a></h2>
<ul>
<li>
<p>规则 $\mathbf{P}$（称为<strong>前提引用规则</strong>）：在推导过程中，可随时引入前提集合中的任意一个前提，引入附加前提时需作声明。</p>
</li>
<li>
<p>规则 $\mathbf{T}$（称为<strong>逻辑结果引用规则</strong>）：在推导过程中，可随时引入公式 $S$，该公式 $S$ 是由其前的一个或多个公式（可以是前提条件或推导出来的公式）推导出来的逻辑结果。</p>
</li>
<li>
<p>规则 $\mathbf{CP}$（称为<strong>附加前提规则</strong>）：如果能从给定的前提集合 $\Gamma$ 与公式 $P$ 推导出 $S$，则能从此前提集合 $\Gamma$ 推导出 $P \rightarrow S$。</p>
<p>原理：$P \rightarrow (Q \rightarrow R) = (P \wedge Q) \rightarrow R$。
使用场合：当结论公式是<u>蕴涵式或析取式</u>时使用。</p>
</li>
</ul>
<p>命题演算推理系统 = 三个推理规则 + 基本等价公式 + 基本蕴涵公式。</p>
<hr>
<p>从前提集合 $\Gamma$ 推出结论 $H$ 的一个<strong>演绎</strong>是构造命题公式的一个有限序列：</p>
<p>$$
H_1, H_2, H_3, \cdots, H_{n-1}, H_n
$$</p>
<p>其中，$H_i$ 或者是 $\Gamma$ 中的某个前提，或者是前面的某些 $H_j(j &lt; i)$ 的有效结论，并且 $H_n$ 就是 $H$，则称公式 $H$ 为该演绎的有效结论，或者称从前提 $\Gamma$ 能够演绎出结论 $H$ 来。</p>
<hr>
<h3 id="直接证明法" data-numberify>直接证明法<a class="anchor ms-1" href="#直接证明法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265912526773.jpg" loading="lazy" width="620" height="442" />
</picture>

</p>
<hr>
<h3 id="规则-cp-证明法" data-numberify>规则 CP 证明法<a class="anchor ms-1" href="#规则-cp-证明法"></a></h3>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265902308226.jpg" loading="lazy" width="622" height="426" />
</picture>

</p>
<hr>
<h3 id="间接证明法" data-numberify>间接证明法<a class="anchor ms-1" href="#间接证明法"></a></h3>
<p>间接证明法又叫反证法、归谬法。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265935152814.jpg" loading="lazy" width="1206" height="620" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16265936708923.jpg" loading="lazy" width="622" height="362" />
</picture>

</p>
<blockquote>
<p>反证法在逻辑推理中有时十分方便。反证法实际上是规则 CP 的一种变形，所以可以使用 CP 证明法来代替它。</p>
</blockquote>
<hr>
<h1 id="谓词逻辑" data-numberify>谓词逻辑<a class="anchor ms-1" href="#谓词逻辑"></a></h1>
<p>对简单命题进行分解，利用<u>个体词、谓词和量词</u>来描述简单命题句子，从而研究其中的逻辑关系，并研究个体与总体的内在联系和数量关系。</p>
<hr>
<h2 id="个体词" data-numberify>个体词<a class="anchor ms-1" href="#个体词"></a></h2>
<p>在原子命题中，可以<u>独立存在的客体</u>（句子中的主语、宾语等），称为<strong>个体词</strong>。</p>
<p>个体词可分为个体常量和个体变量，均在个体域内取值。</p>
<ol>
<li>表示具体或特定的个体词称为<strong>个体常量</strong>。一般用带或不带下标的小写英文字母 $a, b, c, \cdots, a_1, b_1, c_1, \cdots$ 等表示。</li>
<li>表示抽象的或泛指的个体词称为<strong>个体变量</strong>。一般用带或不带下标的小写英文字母 $x, y, z, \cdots, x_1, y_1, z_1, \cdots$ 等表示。</li>
</ol>
<hr>
<ul>
<li>个体词的取值范围称为<strong>个体域</strong>（或<strong>论域</strong>），常用 $D$ 表示。</li>
<li>宇宙间的所有个体域聚集在一起所构成的个体域称为<strong>全总个体域</strong>。无特别说明时，默认使用全总个体域。</li>
</ul>
<hr>
<h2 id="谓词" data-numberify>谓词<a class="anchor ms-1" href="#谓词"></a></h2>
<p>在原子命题中，用以刻划<u>客体的性质或客体之间的关系</u>即是<strong>谓词</strong>。</p>
<p>设 $D$ 为非空的个体域，定义在 $D^n$ 上取值为 ${0,1}$ 上的 $n$ 元函数，称为 $n$ 元命题函数或 $n$ 元谓词，记为 $P(x_1, x_2, \cdots, x_n)$。其中，个体变量 $x_1, x_2, \cdots, x_n \in D$。</p>
<ol>
<li>表示具体性质或关系的谓词称为<strong>谓词常量</strong>。</li>
<li>表示抽象的或泛指的性质或关系的谓词称为<strong>谓词变量</strong>。</li>
</ol>
<p>谓词均使用大写英文字母 $P, Q, R, \cdots, F, G, H, \cdots$ 来表示。</p>
<p>$D^n$ 表示 $n$ 个个体都在个体域 $D$ 上取值。</p>
<ul>
<li>谓词中个体词的顺序不能随意变更。</li>
<li>一元谓词用以描述某一个个体的某种<strong>特性</strong>，而 $n$ 元谓词（$n \ge 2$）则用以描述 $n$ 个个体之间的<strong>关系</strong>。</li>
<li>谓词 $P(x_1, x_2, \cdots, x_n)$ 包含了个体变量，因而本身并不是命题，只有用谓词常量取代 $P$，用个体常量取代 $x_1, x_2, \cdots, x_n$ 后才会称为命题。</li>
<li>一般将<u>没有任何个体变量</u>的谓词称为 <strong>0 元谓词</strong>（如，$F(a_1, a_2, \cdots, a_n$）。当 $F$ 为谓词常量时，0 元谓词就成为命题。命题逻辑中的所有命题都可以表示成 0 元谓词。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267215046524.jpg" loading="lazy" width="1204" height="546" />
</picture>

</p>
<hr>
<h2 id="量词" data-numberify>量词<a class="anchor ms-1" href="#量词"></a></h2>
<ul>
<li><strong>全称量词</strong>（$\forall x$）：所有的 $x$；任意的 $x$；一切的 $x$；每一个 $x$；……</li>
<li><strong>存在量词</strong>（$\exists x$）：有些 $x$；至少有一个 $x$；某一些 $x$；存在 $x$；……</li>
</ul>
<p>其中的 $x$ 称为作用变量。一般将其量词加在其谓词之前，记为 $(\forall x)F(x)$、$(\exists x)F(x)$。此时，$F(x)$ 称为全称量词和存在量词的<strong>辖域</strong>。</p>
<p>![16267650196113.jpg]</p>
<p>引入更准确的表达方式：以上符号化必须要特别注明个体域，在表达比较复杂的命题时会容易混淆。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267651119352.jpg" loading="lazy" width="622" height="392" />
</picture>

</p>
<p>其中，$T(x)$、$C(x)$、$H(x)$ 和 $N(x)$ 分别是各自个体变量的<strong>个性谓词</strong>。</p>
<hr>
<p>统一一个<strong>全总个体域</strong>，而对每一个句子中个体变量的变化范围用一元<strong>特性谓词</strong>刻划之。这种特性谓词在加入到命题函数中时必定遵循如下原则：</p>
<ul>
<li>对于<strong>全称量词</strong>（$\forall x$），刻划其对应个体域的特性谓词作为<strong>蕴涵式的前件</strong>加入。</li>
<li>对于<strong>存在量词</strong>（$\exists x$），刻划其对应个体域的特性谓词作为<strong>合取式的合取项</strong>加入。</li>
</ul>
<hr>
<h2 id="谓词逻辑的真值" data-numberify>谓词逻辑的真值<a class="anchor ms-1" href="#谓词逻辑的真值"></a></h2>
<ul>
<li>$(\forall x)G(x)$：对 $\forall x \in D$，$G(x)$ 都成立。
<ul>
<li>$(\forall x)G(x)$ 取值为 1 当且仅当对任意 $x \in D$，$G(x)$ 都取值为 1；</li>
<li>$(\forall x)G(x)$ 取值为 0 当且仅当存在 $x_0 \in D$，使得 $G(x_0)$ 取值为 0。</li>
</ul>
</li>
<li>$(\exists x)G(x)$：存在一个 $x_0 \in D$（是有一个的意思，即可以存在一个以上，且包括一个），使得 $G(x_0)$ 成立。
<ul>
<li>$(\exists x)G(x)$ 取值为 1 当且仅当存在 $x_0 \in D$，使得 $G(x_0)$ 取值为 1；</li>
<li>$(\exists x)G(x)$ 取值为 0 当且仅当对任意 $x \in D$，$G(x)$ 都取值为 0。</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267661575626.jpg" loading="lazy" width="1261" height="559" />
</picture>

</p>
<p>当个体域 $D = {x_0, x_1, \cdots, x_n}$ 是<strong>有限集合</strong>时，</p>
<ul>
<li>$(\forall x)G(x) = G(x_0) \wedge G(x_1) \wedge \cdots \wedge G(x_n)$；</li>
<li>$(\exists x)G(x) = G(x_0) \vee G(x_1) \vee \cdots \vee G(x_n)$。</li>
</ul>
<p>注意：量词对变元的约束往往与量词的次序有关。不同的量词次序，可以产生不同的真值。因此当多个量词同时出现时，不能随意颠倒它们的顺序，否则会改变原有的含义。</p>
<hr>
<h1 id="谓词合式公式" data-numberify>谓词合式公式<a class="anchor ms-1" href="#谓词合式公式"></a></h1>
<p>在基于谓词的形式化中，将使用如下四种符号：</p>
<ol>
<li><strong>常量符号</strong>：指所属个体域 $D$ 中的某个元素，用带或不带下标的小写英文字母 $a, b, c, \cdots, a_1, b_1, c_1, \cdots$ 来表示。</li>
<li><strong>变量符号</strong>：指所属个体域 $D$ 中的任意元素，用带或不带下标的小写英文字母 $x, y, z, \cdots, x_1, y_1, z_1, \cdots$ 来表示。</li>
<li><strong>函数符号</strong>：$n$ 元函数符号 $f(x_1, x_2, \cdots, x_n)$ 可以是所属个体域集合 $D^n \rightarrow D$ 的任意一个函数，用带或不带下标的小写英文字母 $f, g, h, \cdots, f_1, g_1, h_1, \cdots$ 来表示。</li>
<li><strong>谓词符号</strong>：$n$ 元谓词符号 $P(x_1, x_2, \cdots, x_n)$ 可以是所属个体域集合 $D_n \rightarrow {0, 1}$ 的任意一个谓词，用带或不带下标的大写英文字母 $P, Q, R, \cdots, P_1, Q_1, R_1, \cdots$ 来表示。</li>
</ol>
<p>函数可用于表达个体词之间的转换关系，可以更方便地表示谓词逻辑中的个体词。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267707683350.jpg" loading="lazy" width="1188" height="301" />
</picture>

</p>
<p>$n$ 元函数是个体域集合 $D^n$ 到 $D$ 的映射。</p>
<hr>
<h2 id="项的定义" data-numberify>项的定义<a class="anchor ms-1" href="#项的定义"></a></h2>
<p>谓词逻辑中的<strong>项</strong>（<strong>Term</strong>），被递归地定义为：</p>
<ul>
<li><u>任意的常量符号或任意的变量符号</u>是项。</li>
<li>若 $f(x_1, x_2, \cdots, x_n)$ 是 $n$ 元函数符号，$t_1, t_2, \cdots, t_n$ 是项，则 $f(t_1, t_2, \cdots, t_n)$ 是项。</li>
<li>仅由<u>有限次</u>使用以上两个规则产生的符号串才是项。</li>
</ul>
<hr>
<h2 id="合式公式的定义" data-numberify>合式公式的定义<a class="anchor ms-1" href="#合式公式的定义"></a></h2>
<p>若 $P(x_1, x_2, \cdots, x_n)$ 是 $n$ 元谓词， $t_1, t_2, \cdots, t_n$ 是项，则称 $P(t_1, t_2, \cdots, t_n)$ 为<strong>原子谓词公式</strong>，简称<strong>原子公式</strong>。</p>
<hr>
<p>满足下列条件的表达式，称为<strong>合式公式</strong>（<strong>well-formed formulae/wff</strong>），简称公式。</p>
<ol>
<li><u>原子公式</u>是合式公式。</li>
<li>若 $G$、$H$ 是合式公式，则 $(\neg G), (\neg H), (G \vee H), (G \wedge H), (G \rightarrow H), (G \leftrightarrow H)$ 也是合式公式。</li>
<li>若 $G$ 是合式公式，$x$ 是个体变量，则 $(\forall x)G$、$(\exists x)G$ 也是合式公式。</li>
<li>由<u>有限次</u>使用以上三个规则产生的表达式是合式公式。</li>
</ol>
<hr>
<ul>
<li>公式的最外层括号可省略。</li>
<li>量词后面的括号省略方式为：一个量词的辖域中仅出现一个原子公式，则此辖域的外层括号可省略，否则不能省略。</li>
<li>一个个体词只能接受一个量词的约束，否则就是没有意义的。</li>
</ul>
<hr>
<h2 id="自由变元与约束变元" data-numberify>自由变元与约束变元<a class="anchor ms-1" href="#自由变元与约束变元"></a></h2>
<p>给定一个合式公式 $G$，若变元 $x$ 出现<u>在使用变元的量词的辖域之内</u>，则称变元 $x$ 的出现为<strong>约束出现</strong>，此时的变元 $x$ 称为<strong>约束变元</strong>。若 $x$ 的出现<u>不是约束出现</u>，则称它为<strong>自由出现</strong>，此时的变元 $x$ 称为<strong>自由变元</strong>。</p>
<ul>
<li>若量词后有括号，则括号内的子公式就是该量词的辖域；</li>
<li>若量词后无括号，则与量词邻接的子公式为该量词的辖域。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16267722145151.jpg" loading="lazy" width="1273" height="591" />
</picture>

</p>
<hr>
<p>为了区分同一公式中，变量符号相同但不是同为自由变元或约束变元的符号（这样的变量是不同的变量，仅是符号相同），可以分别使用不同的变量符号来表示。</p>
<ol>
<li>
<p>约束变元的命名规则：</p>
<ul>
<li>将量词中的变元以及该量词辖域中此变量的所有约束出现都用新的个体变元替换；</li>
<li>新的变元一定要有别于改名辖域中的其他变量。</li>
</ul>
</li>
<li>
<p>自由变元的命名规则：</p>
<ul>
<li>
<p>将公式中出现该自由变元的每一处都用新的个体变元替换；</p>
</li>
<li>
<p>新的变元不允许在源公式中以任何约束形式出现。</p>
<p>也可用个体常量代入。但是代入个体常量后，公式的含义就发生了变化，即公式从具有普遍意义变为仅针对该个体变量有意义。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="闭式" data-numberify>闭式<a class="anchor ms-1" href="#闭式"></a></h2>
<p>设 $G$ 是任意一个公式，若 $G$ 中无自由出现的个体变元，则称 $G$ 为封闭的合式公式，简称<strong>闭式</strong>。</p>
<p>闭式是一个命题。</p>
<hr>
<h2 id="谓词逻辑公式的解释" data-numberify>谓词逻辑公式的解释<a class="anchor ms-1" href="#谓词逻辑公式的解释"></a></h2>
<p>谓词逻辑中，公式 $G$ 的每一个解释 $I$ 由如下四部分组成：</p>
<ol>
<li><strong>非空的个体域</strong>集合 $D$。</li>
<li>$G$ 中的每个<strong>常量符号</strong>，指定 $D$ 中的某个特定元素。</li>
<li>$G$ 中的每个 $n$ 元<strong>函数符号</strong>，指定 $D^n$ 到 $D$ 中的某个特定的函数。</li>
<li>$G$ 中的每个 $n$ 元<strong>谓词符号</strong>，指定 $D^n$ 到 ${0,1}$ 中的某个特定的谓词。</li>
</ol>
<p>规定：公式中无自由变元，或将自由变元看成是常量符号。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2022/01/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/16268605039802.jpg" loading="lazy" width="1141" height="592" />
</picture>

</p>
<hr>
<h2 id="谓词公式的分类" data-numberify>谓词公式的分类<a class="anchor ms-1" href="#谓词公式的分类"></a></h2>
<ol>
<li>
<p>如果公式 $G$ 在它<u>所有的解释下都取值为真</u>，则称 $G$ 为<strong>有效公式</strong>。</p>
<p>如 $(\forall x)(\forall y)(P(x, y) \wedge Q(x, y) \rightarrow P(x, y))$。</p>
</li>
<li>
<p>如果公式 $G$ 在它<u>所有的解释下都取值为假</u>，则称 $G$ 为<strong>矛盾公式</strong>。</p>
<p>如，$(\forall x)(\forall y)(\neg P(x, y) \wedge P(x, y))$。</p>
</li>
<li>
<p>如果<font color="green">至少有一种解释使得公式 $G$ 取值为真</font>，则称 $G$ 为<strong>可满足公式</strong>。</p>
</li>
</ol>
<hr>
<h2 id="谓词公式的可判定性" data-numberify>谓词公式的可判定性<a class="anchor ms-1" href="#谓词公式的可判定性"></a></h2>
<ul>
<li>
<p>一般情况下，谓词逻辑是不可判定的。</p>
</li>
<li>
<p>只含有一元谓词变项的公式是可判定的。</p>
</li>
<li>
<p>如下形式的公式：</p>
<p>$(\forall x_1) (\forall x_2) \cdots (\forall x_n) P(x_1, x_2, \cdots, x_n)$，</p>
<p>$(\exists x_1) (\exists x_2) \cdots (\exists x_n) P(x_1, x_2, \cdots, x_n)$。</p>
<p>若 $P$ 中无量词和其他自由变元时，是可判定的。</p>
</li>
<li>
<p>个体域有穷时的谓词公式是可判定的。</p>
</li>
</ul>
<hr>
<h2 id="谓词公式的等价关系" data-numberify>谓词公式的等价关系<a class="anchor ms-1" href="#谓词公式的等价关系"></a></h2>
<p>如果公式 $G \leftrightarrow H$ 是<strong>有效公式</strong>，则公式 $G$、$H$ 称为<strong>等价</strong>的，记为 $G=H$。</p>
<hr>
<p>设 $G(P_1, P_2, \cdots, P_n)$ 是命题演算<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>中的<a href="#命题公式">命题公式</a>，$P_1, P_2, \cdots, P_n$ 是出现在 $G$ 中的命题变元，当用任意的谓词公式 $G_i(1\le i \le n)$ 分别代入 $P_i$ 后，得到的新谓词公式 $G(G_1, G_2, \cdots, G_n)$​ 称为原公式的<strong>代入实例</strong>。</p>
<p>定理：永真公式的任意一个代入实例必为有效公式。</p>
<hr>
<p>##谓词演算中的基本等价公式</p>
<p><a href="#命题公式的基本等价关系">命题演算中的基本等价公式</a>在谓词演算中依然成立。</p>
<table>
<thead>
<tr>
<th style="text-align:center">性质</th>
<th style="text-align:left">等式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">改名规则</td>
<td style="text-align:left"><code>(\exists x)G(x) = (\exists y)G(y)</code><br/><code>(\forall x)G(x) = (\forall y)G(y)</code></td>
</tr>
<tr>
<td style="text-align:center">量词转换律<br/>or<br/>量词否定等价式</td>
<td style="text-align:left"><code>\neg (\exists x)G(x) = (\forall x)G(x)</code><br/><code>\neg (\forall x) \neg G(x) = (\exists x) \neg G(x)</code></td>
</tr>
</tbody>
</table>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>命题公式、范式和推理都是针对命题演算，它们的对象都是命题。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

