<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>软考 on Linner&#39;s Blog</title>
    <link>/tags/%E8%BD%AF%E8%80%83/</link>
    <description>Recent content in 软考 on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>Copyright © 2020-2023 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Thu, 25 May 2023 11:34:54 +0800</lastBuildDate><atom:link href="/tags/%E8%BD%AF%E8%80%83/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软考概念总结篇</title>
      <link>/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/</link>
      <pubDate>Thu, 25 May 2023 11:34:54 +0800</pubDate>
      
      <guid>/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/</guid>
      <description><![CDATA[计算机系统 跳转连接：软件设计师——计算机系统篇 基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节]]></description>
      <content:encoded><![CDATA[<h1 id="计算机系统" data-numberify>计算机系统<a class="anchor ms-1" href="#计算机系统"></a></h1>
<p>跳转连接：<a href="/p/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%af%87/">软件设计师——计算机系统篇</a></p>
<h2 id="基本单位" data-numberify>基本单位<a class="anchor ms-1" href="#基本单位"></a></h2>
<table>
<tr>
    <td>位（比特）<br>最小数据单位</td>
    <td><b>bit、b</b></td>
    <td></td>
</tr>
<tr>
    <td>字节<br>最小存储单位</td>
    <td>byte、B</td>
    <td>1B = 8b</td>
</tr>
<tr>
    <td>千字节</td>
    <td>KB</td>
    <td>1KB = 1024B</td>
</tr>
<tr>
    <td>兆字节</td>
    <td>MB</td>
    <td>1MB = 1024KB</td>
</tr>
<tr>
    <td>吉字节</td>
    <td>GB</td>
    <td>1GB = 1024MB</td>
</tr>
<tr>
    <td>太字节</td>
    <td>TB</td>
    <td>1TB = 1024GB</td>
</tr>
</table>
<h2 id="中央处理单元" data-numberify>中央处理单元<a class="anchor ms-1" href="#中央处理单元"></a></h2>
<p>CPU的功能：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">程序控制</td>
<td style="text-align:left">通过执行指令来控制程序的执行顺序。</td>
</tr>
<tr>
<td style="text-align:center">操作控制</td>
<td style="text-align:left">CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</td>
</tr>
<tr>
<td style="text-align:center">时间控制</td>
<td style="text-align:left">对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</td>
</tr>
<tr>
<td style="text-align:center">数据处理</td>
<td style="text-align:left">通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。</td>
</tr>
</tbody>
</table>
<p>CPU的组成：</p>
<ul>
<li>运算器：
<ul>
<li>算术逻辑单元（ALU）：处理数据，对数据进行算术运算和逻辑运算。</li>
<li>累加寄存器（AC，累加器）：通用寄存器，存放操作数或者结果。。</li>
<li>数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字。</li>
<li>状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态。</li>
</ul>
</li>
<li>控制器：
<ul>
<li>指令寄存器（IR）：暂存要执行的指令。</li>
<li>程序计数器（PC，指令计数器）：寄存信息和指令计数。</li>
<li>地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。</li>
<li>指令译码器（ID）。</li>
</ul>
</li>
<li>寄存器组</li>
<li>内部总线</li>
</ul>
<h2 id="数据编码" data-numberify>数据编码<a class="anchor ms-1" href="#数据编码"></a></h2>
<p><picture><img class="img-fluid " alt="带符号数的范围" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png" loading="lazy" width="1174" height="273" />
</picture>

</p>
<h2 id="寻址方式" data-numberify>寻址方式<a class="anchor ms-1" href="#寻址方式"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:left">操作数就包含在指令中。</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:left">操作数在内存，指令给出操作数的地址。</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:left">操作数在寄存器，指令给出操作数的寄存器名（地址）。</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:left">操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。</td>
</tr>
<tr>
<td style="text-align:center">间接寻址</td>
<td style="text-align:left">指令中给出操作数地址（操作数地址在内存中）的地址。</td>
</tr>
<tr>
<td style="text-align:center">相对寻址</td>
<td style="text-align:left">指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。</td>
</tr>
<tr>
<td style="text-align:center">变址寻址</td>
<td style="text-align:left">操作数地址等于变址寄存器的内容加偏移量。</td>
</tr>
</tbody>
</table>
<h2 id="校验码" data-numberify>校验码<a class="anchor ms-1" href="#校验码"></a></h2>
<p>编码系统的码距：</p>
<ul>
<li>$\ge 2$：该编码系统具有<u>检错能力</u>；</li>
<li>$\ge 3$：该编码系统才<u>可能有纠错能力</u>。</li>
</ul>
<p>奇偶校验码：</p>
<ul>
<li>码距为2。</li>
<li>仅能检测奇数位数出错。</li>
</ul>
<p>海明码：</p>
<p>设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：</p>
<p>$$
2^k-1 \ge n+k
$$</p>
<p>循环冗余（n,k）码：</p>
<ul>
<li>信息码（数据），占k位；</li>
<li>校验码，占n-k位；</li>
<li>码距为2，可以检错不能纠错。</li>
</ul>
<h2 id="计算机指令集" data-numberify>计算机指令集<a class="anchor ms-1" href="#计算机指令集"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">RISC<br>精简指令集（计算机）</th>
<th style="text-align:center">CISC<br>复杂指令集（计算机）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指令种类</td>
<td style="text-align:center">少、精简</td>
<td style="text-align:center">多、复杂</td>
</tr>
<tr>
<td style="text-align:center">指令复杂度</td>
<td style="text-align:center">低（简单）</td>
<td style="text-align:center">高（复杂）</td>
</tr>
<tr>
<td style="text-align:center">指令长度</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">变化</td>
</tr>
<tr>
<td style="text-align:center">寻址方式</td>
<td style="text-align:center">少</td>
<td style="text-align:center">复杂多样</td>
</tr>
<tr>
<td style="text-align:center">实现（译码方式）</td>
<td style="text-align:center">硬布线控制逻辑（组合逻辑控制器）</td>
<td style="text-align:center">微程序控制技术</td>
</tr>
<tr>
<td style="text-align:center">通用寄存器数量</td>
<td style="text-align:center">多、大量</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">流水线技术</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<h2 id="流水线技术" data-numberify>流水线技术<a class="anchor ms-1" href="#流水线技术"></a></h2>
<p>执行$n$条指令：</p>
<ul>
<li>
<p>顺序执行总时间：</p>
<p>$$
顺序执行总时间=单条指令执行的时间\times n
$$</p>
</li>
<li>
<p>流水线执行总时间：</p>
<p>$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$</p>
<p>流水线（操作）周期为执行时间最长的一段操作的时间。</p>
</li>
<li>
<p>连续输入$n$条指令的吞吐率：</p>
<p>$$
吞吐率=\cfrac {n}{总执行时间}
$$</p>
<p>如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：</p>
<p>$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$</p>
</li>
<li>
<p>加速比：</p>
<p>$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$</p>
</li>
</ul>
<h2 id="存储器" data-numberify>存储器<a class="anchor ms-1" href="#存储器"></a></h2>
<p>按存储器所处位置可分为：</p>
<ul>
<li>内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。</li>
<li>外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。</li>
</ul>
<p>按存储器工作方式：</p>
<ul>
<li>读/写存储器（RAM）。</li>
<li>只读存储器：ROM、PROM、EPROM、EEPROM等。
<ul>
<li>固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。</li>
<li>可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。</li>
</ul>
</li>
</ul>
<h2 id="缓存" data-numberify>缓存<a class="anchor ms-1" href="#缓存"></a></h2>
<p>高速缓存中的地址映像方法：</p>
<ul>
<li>
<p>直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884025087.png" loading="lazy" width="825" height="526" />
</picture>

</p>
</li>
<li>
<p>全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679884252415.png" loading="lazy" width="730" height="538" />
</picture>

</p>
</li>
<li>
<p>组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。</p>
</li>
</ul>
<blockquote>
<p>发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。</p>
<p>地址映像都是由硬件自动完成。</p>
</blockquote>
<h2 id="中断" data-numberify>中断<a class="anchor ms-1" href="#中断"></a></h2>
<p>程序查询方式（程序直接控制方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888001780.png" loading="lazy" width="754" height="1174" />
</picture>

</p>
<ul>
<li>CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数放入内存。</li>
</ul>
<p>中断驱动方式：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888578058.png" loading="lazy" width="787" height="1134" />
</picture>

</p>
<ul>
<li>I/O设备通过中断信号主动向CPU报告I/O操作已完成。</li>
<li>CPU和I/O可并行工作。</li>
<li>CPU利用率得到提升。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数据放入内存。</li>
</ul>
<p>DMA方式（直接存储器存储方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1679888972074.png" loading="lazy" width="816" height="723" />
</picture>

</p>
<ul>
<li>CPU和I/O可并行工作。</li>
<li>仅在传送数据块多开始和结束时才需要CPU的干预。</li>
<li>由外设直接将数据放入内存。</li>
<li>一次读写的单位为&quot;块&quot;而不是字。</li>
</ul>
<p>DMA传输数据比中断驱动方式传输数据要快一点。</p>
<h2 id="总线" data-numberify>总线<a class="anchor ms-1" href="#总线"></a></h2>
<p>微机中的总线分为：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<p>常见总线：</p>
<ul>
<li>ISA总线。</li>
<li>EISA总线。</li>
<li>PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。</li>
<li>PCI Express 总线。</li>
<li>前端总线。</li>
<li>RS-232C。</li>
<li>SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。</li>
<li>SATA。</li>
<li>USB。</li>
<li>IEEE-1394。</li>
<li>IEEE-488总线。</li>
</ul>
<h2 id="加密与认证技术" data-numberify>加密与认证技术<a class="anchor ms-1" href="#加密与认证技术"></a></h2>
<p>加密技术用于防止第三方窃听：</p>
<ul>
<li>
<p>对称加密：只有一把密钥。加密和解密用同一把密钥。</p>
<ul>
<li>密钥分发有缺陷。</li>
<li>加密解密速度很快。</li>
<li>适合加量大量明文数据。</li>
</ul>
</li>
<li>
<p>非对称加密：</p>
<ul>
<li>加密和解密不是同一把密钥。</li>
<li>一共有两把密钥，分别是公钥和私钥。</li>
<li>用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。</li>
<li>不能通过一把密钥推出另一把密钥。</li>
<li>用接收方的公钥加密明文可以实现防止窃听的效果。</li>
<li>密钥分发没有缺陷。</li>
<li>加密解密速度很慢。</li>
</ul>
</li>
</ul>
<p>认证技术用于防止篡改、假冒和否认：</p>
<ul>
<li>摘要（防止篡改）：Hash算法加密，放在密文后。</li>
<li>数字签名（防止假冒和否认）：<u>发送方用私钥对摘要进行签名</u>（加密）。接收方用<u>发送方的公钥对数字签名进行验证</u>（解密）。</li>
</ul>
<p>数字证书：CA机构用私钥对用户的公钥签名（加密）。接收方用CA的公钥验证（解密），从而得到用户的公钥。</p>
<p>加密算法：</p>
<ul>
<li>对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：
<ul>
<li>DES</li>
<li>3DES</li>
<li>RC-5</li>
<li>IDEA</li>
<li>AES</li>
<li>RC4</li>
</ul>
</li>
<li>非对称密钥（公钥、公开密钥加密）算法：
<ul>
<li>RSA</li>
<li>ECC</li>
<li>DSA</li>
</ul>
</li>
<li>其他加密算法：
<ul>
<li>Hash函数</li>
<li>SHA-1安全散列算法</li>
<li>MD5摘要算法</li>
</ul>
</li>
</ul>
<h2 id="系统可靠度" data-numberify>系统可靠度<a class="anchor ms-1" href="#系统可靠度"></a></h2>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1157" height="400" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1133" height="376" />
</picture>

</p>
<hr>
<h1 id="程序设计语言" data-numberify>程序设计语言<a class="anchor ms-1" href="#程序设计语言"></a></h1>
<p>跳转连接：<a href="/p/%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e7%af%87/">软件设计师——程序设计语言篇</a></p>
<h2 id="编译过程" data-numberify>编译过程<a class="anchor ms-1" href="#编译过程"></a></h2>
<p><picture><img class="img-fluid " alt="编译过程" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680232196718.png" loading="lazy" width="549" height="466" />
</picture>

</p>
<p>必须的编译过程阶段：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>目标代码生成</li>
</ol>
<p>可省略的编译过程阶段：</p>
<ul>
<li>中间代码生成</li>
<li>（中间或目标）代码优化</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">词法分析</td>
<td style="text-align:left">对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号</td>
</tr>
<tr>
<td style="text-align:center">语法分析</td>
<td style="text-align:left">根据语言的语法规则将单词符号序列分解成各类语法单位</td>
</tr>
<tr>
<td style="text-align:center">语义分析</td>
<td style="text-align:left">检查源程序是否包含静态语义错误</td>
</tr>
<tr>
<td style="text-align:center">中间代码生成</td>
<td style="text-align:left">分水岭，上面是前端，下面是后端</td>
</tr>
<tr>
<td style="text-align:center">代码优化</td>
<td style="text-align:left">所做的优化一般与具体的机器无关</td>
</tr>
<tr>
<td style="text-align:center">目标代码生成</td>
<td style="text-align:left">把中间代码变换成机器指令</td>
</tr>
</tbody>
</table>
<h2 id="正规式" data-numberify>正规式<a class="anchor ms-1" href="#正规式"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">闭包</td>
<td style="text-align:left">表示其前面链接的符号或集合可以出现$[0, +\infty]$次。</td>
</tr>
<tr>
<td style="text-align:center"><code>·</code></td>
<td style="text-align:center">连接</td>
<td style="text-align:left">可省略，将多个符号或集合连接起来。表示逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center">或</td>
<td style="text-align:left">表示逻辑或。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1680248469003.png" loading="lazy" width="990" height="277" />
</picture>

</p>
<p>设$U$、$V$和$W$均为正规式：</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680249034196.png" loading="lazy" width="974" height="185" />
</picture>

</p>
<h2 id="有限自动机" data-numberify>有限自动机<a class="anchor ms-1" href="#有限自动机"></a></h2>
<ul>
<li>
<p><strong>确定的有限自动机</strong>（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的<strong>状态是唯一的</strong>。</p>
<p>一个DFA是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$：</p>
<ul>
<li>
<p>$S$：包含<u>状态的有限集</u>（每个元素称为一个状态）。</p>
</li>
<li>
<p>$\Sigma$：有穷<u>字母表</u>，其每个元素称为一个<u>输入字符</u>。</p>
</li>
<li>
<p>$f$：$S \times \Sigma \to S$ 上的<u>单值部分映像</u>。</p>
<p>$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$</p>
<p>表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。</p>
</li>
<li>
<p>$s_0$：唯一的<u>开始状态</u>，$s_0 \in S$。</p>
</li>
<li>
<p>$Z$：非空的<u>终止状态集合</u>，$Z \subseteq S$。</p>
</li>
</ul>
<p>DFA可以用两种直观的方式表示：</p>
<ul>
<li>
<p><strong>状态转换图</strong>：简称为转换图，是一个有向图。</p>
<ul>
<li>
<p>DFA中的每个<strong>状态</strong>对应转换图中的一个<strong>结点</strong>。</p>
</li>
<li>
<p>DFA中的每个<strong>转换函数</strong>对应图中的一条<strong>有向弧</strong>。</p>
</li>
<li>
<p><strong>双圈表示的结点是终态结点。</strong></p>
<blockquote>
<p>终态也可以是初态。</p>
</blockquote>
</li>
</ul>
<p>若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。</p>
</li>
<li>
<p><strong>状态转换矩阵</strong>：用一个二位数组$M$表示。</p>
<p>矩阵元素$M[A,a]$：</p>
<ul>
<li><strong>行下标</strong>：表示状态。当前状态为$A$。</li>
<li><strong>列下标</strong>：表示输入的字符。当前输入为$a$。</li>
<li>$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251834262.png" loading="lazy" width="983" height="160" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680251962756.png" loading="lazy" width="982" height="585" />
</picture>

</p>
</li>
<li>
<p><strong>不确定的有限自动机</strong>（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的<strong>状态是不唯一的</strong>。</p>
<p>NFA也是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：</p>
<ul>
<li>
<p>$f$是$S \times \Sigma \to 2^S$ 上的映像。</p>
<p>对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。</p>
</li>
<li>
<p>有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。</p>
</li>
</ul>
<blockquote>
<p>DFA是NFA的特例。</p>
</blockquote>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680252743732.png" loading="lazy" width="918" height="407" />
</picture>

</p>
</li>
</ul>
<p><u>有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。</u></p>
<h2 id="设计语言成分" data-numberify>设计语言成分<a class="anchor ms-1" href="#设计语言成分"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">成分</th>
<th style="text-align:left">包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据成分</td>
<td style="text-align:left"><ul><li>标识符</li><li>关键字</li><li>常量</li><li>变量</li><li>全局量</li><li>局部量</li><li>数据类型</li></ul></td>
</tr>
<tr>
<td style="text-align:center">运算成分</td>
<td style="text-align:left"><ul><li>算数</li><li>关系</li><li>逻辑</li><li>位</li></ul></td>
</tr>
<tr>
<td style="text-align:center">控制结构</td>
<td style="text-align:left"><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul></td>
</tr>
<tr>
<td style="text-align:center">传输成分</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">函数</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h1 id="数据结构" data-numberify>数据结构<a class="anchor ms-1" href="#数据结构"></a></h1>
<p>跳转连接：<a href="/p/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%af%87/">软件设计师——数据结构篇</a></p>
<h2 id="线性表" data-numberify>线性表<a class="anchor ms-1" href="#线性表"></a></h2>
<p><strong>顺序表：</strong></p>
<p>在表长为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：</p>
<ul>
<li>
<p>在第$i$个插入位置插入，需要移动$n+1-i$个元素。</p>
<ul>
<li>在第1个位置插入（$a_1$）需要移动$n$个元素；</li>
<li>在第$n+1$个位置插入（$a_n$后面）不需要移动元素。</li>
</ul>
</li>
<li>
<p>设在第$i$个插入位置插入的概率为$p_i$，<u>等概率下插入</u>一个新元素需要移动的元素个数的<u>期望值$E_{insert}$</u>为：</p>
<p>$$
E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}
$$</p>
</li>
</ul>
<p>在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：</p>
<ul>
<li>
<p>删除第$i$个元素$a_i$需要移动$n-i$个元素。</p>
<ul>
<li>删除元素$a_1$需要移动$n-1$个元素；</li>
<li>删除元素$a_n$不需要移动元素。</li>
</ul>
</li>
<li>
<p>设$a_i$被删除的概率为$q_i$，<u>等概率下删除元素</u>时需要移动的元素个数的<u>期望值$E_{delete}$</u>为：</p>
<p>$$
E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}
$$</p>
</li>
</ul>
<p><strong>插入操作时间复杂度：</strong></p>
<ul>
<li>最好情况（在第$n+1$个位置插入）：$O(1)$；</li>
<li>最坏情况（在第1个位置插入）：$O(n)$；</li>
<li>平均复杂度：$O(n)$。</li>
</ul>
<p><strong>链表插入和删除操作时间复杂度</strong>（带不带头节点的复杂度都一样）：</p>
<ul>
<li>最好情况（在$i=1$位置）：$O(1)$；</li>
<li>最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$</li>
<li>平均复杂度：$O(n)$</li>
</ul>
<h2 id="串的模式匹配" data-numberify>串的模式匹配<a class="anchor ms-1" href="#串的模式匹配"></a></h2>
<p>朴素的模式匹配（布鲁特一福斯）算法：</p>
<p>设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：</p>
<ul>
<li>
<p>最好情况：$O(m)$，次数为$m$；</p>
</li>
<li>
<p>最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$</p>
</li>
<li>
<p>平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$</p>
</li>
</ul>
<h2 id="数组" data-numberify>数组<a class="anchor ms-1" href="#数组"></a></h2>
<p>设：</p>
<ul>
<li>二维数组为$A[n,m]$，$n$为行数，$m$为列数；</li>
<li>数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；</li>
<li>$LOC(a_{i,j})$为元素$a_{i,j}$的地址；</li>
<li>$L$为单个元素的存储空间大小。</li>
</ul>
<p>则有：</p>
<ul>
<li>
<p>以行为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$</p>
</li>
<li>
<p>以列为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$</p>
</li>
</ul>
<p><strong>对称矩阵：</strong></p>
<p>假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p>如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p><strong>三对角矩阵：</strong></p>
<p>设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：</p>
<p>$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$</p>
<p>如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$</p>
<h2 id="树" data-numberify>树<a class="anchor ms-1" href="#树"></a></h2>
<ul>
<li>
<p>设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：</p>
<p>$$
n = (\sum_{i=1}^{n}{d_i})+1
$$</p>
<p><strong>度</strong>：结点拥有的子树数。</p>
</li>
<li>
<p>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。</p>
</li>
<li>
<p>高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。</p>
</li>
</ul>
<p><strong>二叉树：</strong></p>
<ul>
<li>
<p>第$i$层（$i \ge 1$）上<u>最多</u>有$2^{i-1}$个结点。</p>
</li>
<li>
<p>高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。</p>
</li>
<li>
<p>若二叉树终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。</p>
</li>
<li>
<p>具有$n$个结点的完全二叉树的深度（高度）为：</p>
<p>$$
\lfloor \log_2{n} \rfloor + 1;
$$</p>
<p>或：</p>
<p>$$
\lceil \log_2{(n+1)} \rceil
$$</p>
</li>
<li>
<p>二叉树形态总数（卡特兰数）：</p>
<p>$$
\cfrac{C^{n}_{2n}}{n+1}
$$</p>
</li>
</ul>
<p><strong>链式存储二叉树：</strong></p>
<p>设有$n$个结点的二叉树，则其<strong>空指针域数量</strong>：</p>
<ul>
<li>
<p>对于二叉链表：</p>
<ul>
<li>总指针域个数：$2n$；</li>
<li>分支数（子孙结点数，非空指针域个数）：$n-1$。</li>
</ul>
<p>可得：</p>
<p>$$
空指针域数=2n-(n-1)=n+1
$$</p>
</li>
<li>
<p>对于三叉链表：</p>
<ul>
<li>总指针域个数：$3n$；</li>
<li>分支数（子孙结点数）：$n-1$；</li>
<li>指向父结点且非空的指针域个数：$n-1$。</li>
</ul>
<p>即，非空指针域个数为：$2(n-1)$。</p>
<p>可得：</p>
<p>$$
空指针域数=3n-2(n-1)=n+2
$$</p>
</li>
</ul>
<p><strong>平衡二叉树：</strong></p>
<p>设一个二叉树的左右子树高度之差的绝对值为$d$，那么</p>
<ul>
<li>不平衡的二叉树：$d &gt; 1$；</li>
<li>平衡的二叉树：$d \le 1$。</li>
</ul>
<p><strong>哈夫曼树</strong>（最优二叉树）：带权路径长度最短。</p>
<p>设：</p>
<ul>
<li>带权叶子结点数：$n$；</li>
<li>叶子结点的权值：$w_k$；</li>
<li>叶子结点到根的路径长度：$l_k$。</li>
</ul>
<p>则树的带权路径长度为：</p>
<p>$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$</p>
<p>给定$n$个权值后，哈夫曼树的结点数$m$就确定了：</p>
<p>$$
m = 2 \times n - 1
$$</p>
<p><strong>哈夫曼压缩比：</strong></p>
<p><picture><img class="img-fluid " alt="压缩比例题" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1680959771881.png" loading="lazy" width="784" height="489" />
</picture>

</p>
<ol>
<li>
<p>按照<u>出现频率</u>计算<u>加权平均长度</u>：</p>
<p>$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$</p>
<p>即：</p>
<p>$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$</p>
<p>压缩后平均长度为2.2。</p>
</li>
<li>
<p>计算压缩比：</p>
<p>$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$</p>
<p>即，</p>
<ul>
<li>
<p>编码5个字符至少需要3位：$2^2 &lt; 5 &lt; 2^3$，所以压缩前编码长度为3；</p>
</li>
<li>
<p>压缩比：</p>
<p>$$
\cfrac{3-2.2}{3} \approx 0.27
$$</p>
</li>
</ul>
</li>
</ol>
<h2 id="图" data-numberify>图<a class="anchor ms-1" href="#图"></a></h2>
<p><strong>完全图</strong>：</p>
<ul>
<li>$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边。</li>
<li>$n$个顶点的有向完全图共有$n(n-1)$条边。</li>
</ul>
<p>对于所有的图，其所有顶点的度数之和 $= 2e$（$e$为边数）。</p>
<p>$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。</p>
<p>图的邻接矩阵：横$i$竖$j$，横出竖入。</p>
<p><strong>深度优先搜索：</strong></p>
<ol>
<li>设置搜索指针$p$，使$p$指向顶点$v$；</li>
<li>访问$p$所指顶点，并使$p$指向与其<u>相邻接的且尚未被访问过</u>的顶点。</li>
<li>若$p$所指顶点存在，则重复步骤2，否则执行步骤4。</li>
<li>沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。</li>
</ol>
<p><strong>广度优先搜索：</strong></p>
<ol>
<li>从图中的某个顶点$v$出发；</li>
<li>访问$v$后，依次访问$v$的各个未被访问过的邻接点；</li>
<li>分别从$v$的邻接点出发，依次访问它们的邻接点；</li>
<li>按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；</li>
<li>若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。</li>
</ol>
<p>广度和深度优先搜索<strong>时间复杂度</strong>（一样）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<p><strong>AOV 网拓扑排序</strong>：如果所有顶点已输出，说明网中不存在回路，否则说明存在。</p>
<ol>
<li>在AOV网中选择一个入度为0的顶点且输出它。</li>
<li>从网中删除该顶点及与该顶点有关的所有弧。</li>
<li>重复上述两步，直到网中不存在入度为0的顶点为止。</li>
</ol>
<hr>
<h1 id="操作系统" data-numberify>操作系统<a class="anchor ms-1" href="#操作系统"></a></h1>
<p>跳转连接：<a href="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/">软件设计师——操作系统篇</a></p>
<h2 id="进程的三态" data-numberify>进程的三态<a class="anchor ms-1" href="#进程的三态"></a></h2>
<ul>
<li><strong>运行</strong>：当一个进程在处理机上运行时。</li>
<li><strong>就绪</strong>：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。</li>
<li><strong>阻塞</strong>（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。</li>
</ul>
<h2 id="同步互斥" data-numberify>同步互斥<a class="anchor ms-1" href="#同步互斥"></a></h2>
<ul>
<li>
<p><strong>同步</strong>：指在系统中一些需要相互合作，协同工作的进程。</p>
</li>
<li>
<p><strong>互斥</strong>：指系统中多个进程因争用临界资源而互斥执行。</p>
</li>
<li>
<p>临界资源（CR）：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。</p>
</li>
<li>
<p>临界区（CS）：是进程中对临界资源实施操作的那段程序。</p>
<p>互斥临界区管理的4条原则：有空即进、无空则等、有限等待和让权等待。</p>
</li>
</ul>
<h2 id="信号量" data-numberify>信号量<a class="anchor ms-1" href="#信号量"></a></h2>
<ul>
<li>公用信号量：实现进程间的互斥，初值为<code>1</code>或资源的数目。</li>
<li>私用信号量：实现进程间的同步，初值为<code>0</code>或某个正整数。</li>
</ul>
<p>信号量$S$的物理意义：</p>
<ul>
<li>$S \ge 0$：表示某资源的可用数，此时<strong>有可用资源</strong>；</li>
<li>$S &lt; 0$：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。</li>
</ul>
<p>PV操作：P申请V释放，P减V加，P进V出。</p>
<ul>
<li>P操作$S &lt; 0$：无可用资源，置该进程为<strong>阻塞</strong>状态。</li>
<li>V操作$S \le 0$：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列。</li>
</ul>
<p>假定信号量S表示某条消息，进程可以：</p>
<ul>
<li>调用P操作：测试消息是否到达；</li>
<li>调用V操作：通知消息已经准备好。</li>
</ul>
<h2 id="死锁" data-numberify>死锁<a class="anchor ms-1" href="#死锁"></a></h2>
<p>产生死锁的原因：</p>
<ul>
<li>进程间互相<u>竞争资源</u>。</li>
<li><u>进程推进顺序非法</u>。</li>
</ul>
<p>产生死锁的4个必要条件：</p>
<ul>
<li>互斥条件</li>
<li>请求保持条件</li>
<li>不可剥夺条件</li>
<li>环路条件</li>
</ul>
<p>发生死锁时，在进程资源有向图中必构成环路。</p>
<p>造成死锁的情况：</p>
<ul>
<li>进程推进顺序不当</li>
<li>同类资源分配不当</li>
<li>PV操作使用不当</li>
</ul>
<p>死锁的处理策略：</p>
<ul>
<li>鸵鸟策略（不理睬策略）</li>
<li>预防策略</li>
<li>避免策略</li>
<li>检测与解除死锁</li>
</ul>
<p>死锁预防：</p>
<ul>
<li>
<p>预先静态分配法：破坏了“不可剥夺条件”，<u>预先分配所需资源，保证不等待资源</u>。</p>
<p>该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源。</p>
</li>
<li>
<p>资源有序分配法：破坏了“环路条件”，<u>把资源分类按顺序排列，保证不形成环路</u>。</p>
<p>该方法存在的问题是限制进程对资源的请求：由于资源的排序占用系统开销。</p>
</li>
</ul>
<p><a href="/p/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%af%87/#%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95">银行家算法</a></p>
<h2 id="线程轻型进程" data-numberify>线程（轻型进程）<a class="anchor ms-1" href="#线程轻型进程"></a></h2>
<ul>
<li>基本上不拥有资源，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈）。</li>
<li>与其它同一进程的线程共享进程所拥有的全部资源。</li>
</ul>
<p>线程分为：</p>
<ul>
<li>用户级线程</li>
<li>内核支持线程</li>
</ul>
<h2 id="存储管理" data-numberify>存储管理<a class="anchor ms-1" href="#存储管理"></a></h2>
<p><strong>程序的局限性：</strong></p>
<ul>
<li>
<p><strong>时间局限性</strong>：</p>
<ul>
<li>如果程序中的某条<u>指令一旦执行</u>，则不久的将来该指令<u>可能再次被执行</u>；</li>
<li>如果某个<u>存储单元被访问</u>，则不久以后该存储单元<u>可能再次被访问</u>。</li>
</ul>
<p>产生时间局限性的典型原因是<u>在程序中存在着大量的循环操作</u>。</p>
</li>
<li>
<p><strong>空间局限性</strong>：指一旦<u>程序访问了某个存储单元</u>，则在不久的将来，<u>其附近的存储单元也最有可能被访问</u>。</p>
<p>即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为<u>程序是顺序执行的</u>。</p>
</li>
</ul>
<p><strong>段页式存储管理：</strong></p>
<ol>
<li>将整个主存划分成大小相等的存储块（页框）。</li>
<li>将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。</li>
<li>将每个段划分成若干页，以页框为单位离散分配。</li>
</ol>
<h2 id="缓冲" data-numberify>缓冲<a class="anchor ms-1" href="#缓冲"></a></h2>
<p><picture><img class="img-fluid " alt="单缓冲并行工作示意图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189558038.png" loading="lazy" width="1251" height="272" />
</picture>

</p>
<p>$n$个作业的单缓冲所花费的时间为：</p>
<p>$$
(Max(C, T) + M) \times n + Min(C, T)
$$</p>
<p><picture><img class="img-fluid " alt="双缓冲并行工作示意图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683189296831.png" loading="lazy" width="1147" height="257" />
</picture>

</p>
<p>$n$个作业的双缓冲所花费的时间为：</p>
<p>$$
Max(T, M, C) \times n + T + M + C - Max(T, M, C)
$$</p>
<p>即，</p>
<p>$$
Max(T, M, C) \times (n - 1) + T + M + C
$$</p>
<h2 id="磁盘调度" data-numberify>磁盘调度<a class="anchor ms-1" href="#磁盘调度"></a></h2>
<ul>
<li>
<p><strong>先来先服务</strong>（First-Come First-Served，FCFS）：根据进程请求访问磁盘的先后次序进行调度。</p>
<ul>
<li>优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。</li>
<li>缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</li>
</ul>
</li>
<li>
<p><strong>最短寻道时间优先</strong>（Shortest Seek Time First，SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。</p>
<ul>
<li>优点：可能会出现饥饿现象。</li>
<li>缺点：不能保证平均寻道时间最短。</li>
</ul>
</li>
<li>
<p><strong>扫描算法</strong>（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。</p>
<p>在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<ul>
<li>优点：避免了饥饿现象的出现。</li>
<li>缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。</li>
</ul>
</li>
<li>
<p><strong>单向扫描算法</strong>（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定磁头只做单向移动。</p>
<p>例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p>
</li>
</ul>
<h2 id="旋转调度算法" data-numberify>旋转调度算法<a class="anchor ms-1" href="#旋转调度算法"></a></h2>
<p><picture><img class="img-fluid " alt="初始逻辑记录分布情况" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683268410250.png" loading="lazy" width="322" height="311" />
</picture>

</p>
<p>设$n$个扇区的磁盘，经过一个扇区的时间为$t$，读取一个记录后处理的时间为$c$，那么：</p>
<ul>
<li>
<p>顺序处理完所有记录的总时间为：</p>
<p>$$
(t + nt) (n-1) + t + c
$$</p>
<p>即：</p>
<p>$$
t \times n^2 + c
$$</p>
</li>
<li>
<p>记录优化后的总时间：</p>
<p>$$
n(t + c)
$$</p>
</li>
</ul>
<h2 id="多级磁盘索引结构" data-numberify>多级磁盘索引结构<a class="anchor ms-1" href="#多级磁盘索引结构"></a></h2>
<ul>
<li>
<p><strong>直接索引</strong>：索引表中的地址项直接指向磁盘数据块。</p>
<p><picture><img class="img-fluid " alt="直接索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683271855209.png" loading="lazy" width="670" height="659" />
</picture>

</p>
</li>
<li>
<p><strong>一级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的记录是地址项，这些地址项直接指向磁盘数据块。</p>
<p>称这个磁盘索引块为<strong>一级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="一级间接地址索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683274982800.png" loading="lazy" width="904" height="737" />
</picture>

</p>
</li>
<li>
<p><strong>二级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的一个记录指向一个一级索引块。</p>
<p>称这个记录指向一级索引块的磁盘索引块为<strong>二级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="二级间接地址索引" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683275164015.png" loading="lazy" width="1121" height="784" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="面向对象" data-numberify>面向对象<a class="anchor ms-1" href="#面向对象"></a></h1>
<p>跳转连接：<a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/">软件设计师——面向对象篇</a></p>
<h2 id="设计原则" data-numberify>设计原则<a class="anchor ms-1" href="#设计原则"></a></h2>
<ul>
<li>
<p><strong>责任原则</strong>（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>（Open &amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即<strong>开放的</strong>；但是不可修改的，即<strong>封闭的</strong>。</p>
</li>
<li>
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。</p>
<p>即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，<u>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</u>。</p>
</li>
<li>
<p><strong>接口分离原则</strong>（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>即：<u>依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。</u></p>
<p>这样做的好处就在于可以最大限度地应对可能的变化。</p>
</li>
</ul>
<p>Robert C. Martin提出的面向对象设计原则（重点的）：</p>
<ul>
<li><strong>共同封闭原则</strong>（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</li>
<li><strong>共同重用原则</strong>（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。</li>
</ul>
<h2 id="uml" data-numberify>UML<a class="anchor ms-1" href="#uml"></a></h2>
<p><a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#uml">面向对象——UML</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
</li>
</ul>
<h2 id="设计模式" data-numberify>设计模式<a class="anchor ms-1" href="#设计模式"></a></h2>
<p><a href="/p/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%af%87/#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">面向对象——设计模式</a></p>
<p>设计模式代码仓库：<a href="https://gitee.com/linner_cheng/design-patterns" target="_blank" rel="noopener noreferrer">https://gitee.com/linner_cheng/design-patterns<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<p>设计模式分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:left">创建型</th>
<th style="text-align:left">结构型</th>
<th style="text-align:left">行为型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:left">与对象的创建有关</td>
<td style="text-align:left">处理类或对象的组合</td>
<td style="text-align:left">描述类或对象的交互和职责分配</td>
</tr>
<tr>
<td style="text-align:center">类模式</td>
<td style="text-align:left">Factory Method（工厂方法模式）</td>
<td style="text-align:left">Adapter（适配器模式）</td>
<td style="text-align:left">Interpreter（解释器模式）<br>Template Method（模板方法模式）</td>
</tr>
<tr>
<td style="text-align:center">对象模式</td>
<td style="text-align:left">Abstract Factory（抽象工厂模式）<br>Builder（生成器模式）<br>Prototype（原型模式）<br>Singleton（单例模式）</td>
<td style="text-align:left">Adapter（适配器模式）<br>Bridge（桥接模式）<br>Composite（组合模式）<br>Decorator（装饰器模式）<br>Facade（外观模式）<br>Flyweight（享元模式）<br>Proxy（代理模式）</td>
<td style="text-align:left">Chain of Responsibility（责任链模式）<br>Command（命令模式）<br>Iterator（迭代器模式）<br>Mediator（中介者模式）<br>Memento（备忘录模式）<br>Observer（观察者模式）<br>State（状态模式）<br>Strategy（策略模式）<br>Visitor（访问者模式）</td>
</tr>
</tbody>
</table>
<p>创建型设计模式（抽象了对象的实例化过程）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:center">动态生产对象</td>
<td style="text-align:left">定义创建对象的接口，由子类实例化对象。让类的实例化延迟到其子类。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:center">生成系列对象</td>
<td style="text-align:left">提供创建一系列对象的接口，无需指定具体的类。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:center">构造复杂对象</td>
<td style="text-align:left">将复杂对象的构建与表示分离。使得同样的构建可以创建不同的表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:center">克隆对象</td>
<td style="text-align:left">用原型实例指定创建对象的类型，通过复制原型来创建对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:center">一个实例</td>
<td style="text-align:left">保证一个类仅有一个实例，并提供一个全局访问点。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left"><ul><li>一个类不知道它所必须创建对象的类</li><li>由子类来指定创建的对象</li><li>将创建对象的职责委托给多个帮助子类中的某一个</li></ul></td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left"><ul><li>系统独立于它产品的创建、<u>组合</u>和表示</li><li>系统由多个产品系列中的一个来配置</li><li>强调一系列相关产品对象的设计，以便进行联合使用</li><li>提供一个产品类库，只显示它们的接口而不是实现</li></ul></td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left"><ul><li>创建复杂对象的算法，独立于该对象的组成部分以及它们的装配方式</li><li>构造过程必须允许被构造的对象有不同的表示</li></ul></td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left"><ul><li>系统独立于它产品创建、<u>构成</u>和表示</li><li>要实例化的类是在运行时刻指定，如动态装载</li><li>避免创建一个与产品类层次平行的工厂类层次</li></ul></td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left"><ul><li>类只能有一个实例，用户可从一个全局点访问</li><li>这个唯一实例是通过子类化可扩展的，客户无须更改代码就能使用扩展实例</li></ul></td>
</tr>
</tbody>
</table>
<p>结构型模式（组合类或对象获得新的结构）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器（类/对象）</td>
<td style="text-align:center">接口转换</td>
<td style="text-align:left">将类的接口转换成兼容其他类的接口。<br>使原本接口不兼容的类可以一起工作。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:center">抽象与实现分离</td>
<td style="text-align:left">将类的抽象与实现分离，使它们可以独立变化。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">组合对象</td>
<td style="text-align:left">将对象组合成树型结构以表示“部分——整体”的层次结构。<br>使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td style="text-align:center">装饰</td>
<td style="text-align:center">动态附加职责</td>
<td style="text-align:left">动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:center">对外统一接口</td>
<td style="text-align:left">为子系统定义和提供一个统一的对外高层接口（外观）。<br>简化了该子系统的使用。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:center">共享大量细粒度对象</td>
<td style="text-align:left">提供支持大量细粒度对象共享的有效方法。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:center">中介代理</td>
<td style="text-align:left">为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left"><ul><li>使用接口不符合要求的类</li><li>创建可复用、可与其它不相关类或不可预见类协同工作</li><li>（仅适用于对象适配器）想使用子类，但又不想对它们子类化来匹配接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left"><ul><li>在抽象和实现之间没有固定的绑定关系</li><li>抽象以及实现都可以通过生成子类的方法扩充</li><li>对抽象的实现部分的修改不会对用户产生影响</li><li>隐藏抽象的实现</li><li>在多个对象间共享实现，用户并不知道</li></ul></td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left"><ul><li>表示对象的部分——整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，并统一地使用它们</li></ul></td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left"><ul><li>不影响其他对象，而动态透明地添加职责</li><li>处理那些可以撤销的职责</li><li>不能采用子类进行扩充</li></ul></td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left"><ul><li>为一个复杂子系统提供一个简单接口</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性</li><li>需要构建一个层次结构的子系统时</li></ul></td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left"><ul><li>使用了大量的对象，造成很大开销</li><li>对象的大多数状态都可变为外部状态</li><li>删除对象的外部状态后，可以用相对较少的共享对象取代很多组对象</li></ul></td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left"><ul><li>在需要比较通用和复杂对象指针代替简单指针时</li></ul></td>
</tr>
</tbody>
</table>
<p>行为型模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:center">职责传递</td>
<td style="text-align:left">将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。<br>给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:center">请求封装为对象</td>
<td style="text-align:left">将一个请求封装为一个对象，可用不同请求对客户进行参数化。<br>将请求排队或记录日志，支持撤销操作。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:center">语句解释</td>
<td style="text-align:left">给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:center">顺序访问数据集</td>
<td style="text-align:left">提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:center">不直接引用</td>
<td style="text-align:left">用对象封装一系列的对象交互。<br>使各对象不需显式地相互调用，达到低耦合。<br>可以独立改变对象间的交互。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:center">保存状态</td>
<td style="text-align:left">不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。<br>可以在以后恢复保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:center">联动</td>
<td style="text-align:left">定义对象间的一种一对多依赖关系。<br>一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">状态封装成类</td>
<td style="text-align:left">把对象的行为封装在不同的状态对象中。<br>允许一个对象在其内部状态改变时改变它的行为。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:center">多方案切换</td>
<td style="text-align:left">定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:center">框架</td>
<td style="text-align:left">定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。<br>可以不改变算法结构而重新定义其某些特定步骤。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:center">数据与操作分离</td>
<td style="text-align:left">封装作用与某对象结构中元素的操作。<br>可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left"><ul><li>有多个对象处理请求，运行时刻自动确定由谁处理</li><li>不明指定接收者的情况下向多个对象中的一个提交请求</li><li>可处理请求的对象集合被动态指定</li></ul></td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left"><ul><li>抽象出待执行的动作以参数化某对象</li><li>不同的时刻指定、排列和执行请求</li><li>支持取消操作，支持修改日志</li></ul></td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left"><ul><li>文法简单</li><li>效率不是关键问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left"><ul><li>访问聚合对象的内容而不暴露其内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left"><ul><li>一组对象以复杂的方式进行通信</li><li>一个对象引用其他很多对象并且直接与这些对象通信</li><li>定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul></td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left"><ul><li>必须保存一个对象在某一个时刻的（部分）状态</li><li>如果用接口让其他对象直接得到这些状态，会暴露对象的实现细节并破坏对象的封装性</li></ul></td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left"><ul><li>当抽象模型有两个方面，其中一个方面依赖于另一个方面</li><li>当改变一个对象的同时需要改变其他对象，又不知道有多少对象待改变</li><li>当一个对象必须通知其他对象，又不能假定其他对象是谁（不能紧耦合）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left"><ul><li>对象的行为决定于它的状态，且在运行时刻根据状态改变行为</li><li>操作中含有庞大的多分支的条件语句</li></ul></td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left"><ul><li>许多相关的类仅仅是行为有异</li><li>需要使用一个算法的不同变体</li></ul></td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left"><ul><li>一次性实现算法中不变的部分，将可变的行为留给子类实现</li><li>各子类中公共行为被提取到公共父类中，避免代码重复</li></ul></td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left"><ul><li>对象结构包含很多类对象，用户想对这些对象实施操作</li><li>对对象结构中的对象进行很多不同且不相关的操作</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新操作</li></ul></td>
</tr>
</tbody>
</table>
<p>个人理解的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left">具体工厂（工厂接口的实现）创建具体对象。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left">一个具体工厂（抽象工厂的子类）创建多个产品，不同工厂用不同方式创建这一系列产品。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left">复杂对象通过切换构建<code>construct(Builder)</code>来创建不同表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left">多个原型之间通过克隆<code>Prototype.clone()</code>来复制对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left">通过私有化无参构造方法、静态<code>Singleton instance</code>属性和静态<code>getInstance()</code>方法使对象保持单例。</td>
</tr>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left">适配器继承目标类，重写目标类的方法，方法将不兼容的接口包装成与目标类一致的接口。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left">将产品（抽象）与其某属性（实现）分开，通过桥接（组合）产品与其属性独立出来的类来制造不同产品。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left">用树形结构和一致的抽象类让部分和整体的操作一致。如文件树。</td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left">装饰器继承被装饰类，通过构造器传入被装饰对象，然后在与被装饰类一致的方法中添加新操作。多个装饰器嵌套可组成一条装饰链。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left">复杂子系统有很多操作，外观将其简化。跟适配器很像。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left">让一个对象假装成许多个对象。就是很多个对象之间可能有一部分属性的值是一样的，定义一个对象然后共享这部分属性。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left">代理就是给被代理对象加一些操作，跟适配器和外观不同的是代理的接口是与被代理对象一致的。</td>
</tr>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left">有多个接口一致的对象，将请求在这些对象间层层转发，请求可以被其中一个对象处理（JavaWeb里的过滤器）。和嵌套的装饰器很像。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left">就是一个命令一个对象，调用这些对象的方式一致（对象接口一致）。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left">解释语言的上下文。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left">在集合对象的外部，通过迭代器访问集合中的元素，对应的迭代器可由集合对象给出<code>iterator()</code>。跟Java里的迭代器一个样。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left">有多个类似对象，这些对象通过中介互相发送消息（就好像微信聊天一样，微信就是中介）。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left">捕获并保存对象的内部状态，并且可以恢复到原型保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left">在目标对象状态更新时，观察者们可以收到通知<code>update()</code>，然后更新自身状态，与目标对象的状态保持一致。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left">一个状态一个类，在状态中通过判断变换到其它状态。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left">就是动态切换算法。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left">模板实现算法操作中不变的部分，其余的交给子类去实现。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left">就是在<code>Visitor.visit(访问对象)</code>中定义对象的操作，然后在结构类中提供<code>accept(Visitor)</code>来访问这些对象。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="数据库" data-numberify>数据库<a class="anchor ms-1" href="#数据库"></a></h1>
<p>跳转连接：<a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/">软件设计师——数据库篇</a></p>
<h2 id="三级模式两级映像" data-numberify>三级模式两级映像<a class="anchor ms-1" href="#三级模式两级映像"></a></h2>
<p><picture><img class="img-fluid " alt="三级模式两级映像" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681373319410.png" loading="lazy" width="486" height="377" />
</picture>

</p>
<p>三级结构有3类数据模型：</p>
<ul>
<li><strong>外模型</strong>：用户使用的<strong>数据视图</strong>，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。</li>
<li><strong>概念模型</strong>：全局的<strong>逻辑数据视图</strong>，是数据库管理员所看到的实体、实体属性和实体之间的联系。</li>
<li><strong>内模型</strong>：数据的物理<strong>存储模型</strong>。</li>
</ul>
<p>三个物理模型分别对应数据库系统的3层结构：</p>
<ul>
<li>
<p><strong>外模式（子模式、用户模式）</strong>：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。</p>
</li>
<li>
<p><strong>概念模式（模式）</strong>：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。</p>
</li>
<li>
<p><strong>内模式（物理模式、存储模式）</strong>：是数据在数据库内部的表示方式。</p>
<p>定义<u>所有的<strong>内部记录类型</strong>、<strong>索引</strong>和<strong>文件</strong>的组织方式</u>。</p>
</li>
</ul>
<p>数据库系统在三级模式之间提供了两级映像：</p>
<ul>
<li>模式——内模式映像存在于<u>概念级和内部级</u>之间，实现<u>概念模式和内模式</u>间的相互转换。</li>
<li>外模式——模式映像：存在于<u>外部级和概念级</u>之间，实现了<u>外模式和概念模式</u>之间的相互转换。</li>
</ul>
<p>二级映像功能保证数据的独立性：</p>
<ul>
<li><strong>物理独立性</strong>：指当数据库的<u>内模式发生改变时，数据的逻辑结构不变</u>。</li>
<li><strong>逻辑独立性</strong>：指用户的<u>应用程序与数据库的逻辑结构是相互独立的</u>。</li>
</ul>
<h2 id="完整性约束" data-numberify>完整性约束<a class="anchor ms-1" href="#完整性约束"></a></h2>
<ul>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ul>
<h2 id="关系代数运算符" data-numberify>关系代数运算符<a class="anchor ms-1" href="#关系代数运算符"></a></h2>
<p><picture><img class="img-fluid " alt="关系代数运算符" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681431891302.png" loading="lazy" width="735" height="301" />
</picture>

</p>
<ul>
<li>
<p><strong>广义笛卡儿积</strong>（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。</p>
<p>元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \times S$，其形式定义如下：</p>
<p>$$
R \times S = \{ t| (t \ = \ &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \}
$$</p>
<p>如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \times K2$个元组。</p>
<blockquote>
<p>$&lt;t^n, t^m&gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。</p>
</blockquote>
</li>
<li>
<p><strong>投影</strong>（Projection）：投影运算是从关系的<u>垂直方向</u>进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\pi_A (R)$，其形式定义如下：</p>
<p>$$
\pi_A (R) = \{ t[A]|t \in R \}
$$</p>
</li>
<li>
<p><strong>选择</strong>（Selection）：选择运算是从关系的<u>水平方向</u>进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\sigma_F (R)$其形式定义如下：</p>
<p>$$
\sigma_A (R) = \{ t| (t \in R) \wedge F(t) = True \}
$$</p>
<p>其中，$F(t)$中的运算对象可以是：</p>
<ul>
<li>属性名（或列的序号）；</li>
<li>常数；</li>
<li>运算符；</li>
<li>算术比较符（$&lt;, \le, &gt;, \ge, \neq$）；</li>
<li>逻辑运算符（$\wedge, \vee, \neg$）。</li>
</ul>
</li>
<li>
<p><strong>连接</strong>（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。</p>
<blockquote>
<p>可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。</p>
</blockquote>
<ul>
<li>
<p><strong>$\theta$连接</strong>：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[X] \ \theta \ t^m[Y]) \}
$$</p>
<p>其中：</p>
<ul>
<li>$X \theta Y$：连接的条件；</li>
<li>$\theta$：比较运算符；</li>
<li>$X$和$Y$分别为$R$和$S$上度数相等且可比的属性组；</li>
<li>$t^n\left[ X \right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量；</li>
<li>$t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。</li>
</ul>
<p>$\theta$连接也可以表示为：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] \ \theta \ t^m[j]) \}
$$</p>
<p>其中，</p>
<ul>
<li>
<p>$i=1,2,3,\cdots,n$；</p>
</li>
<li>
<p>$j=1,2,3,\cdots,m$；</p>
</li>
<li>
<p>$i \theta j$：</p>
<p>从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\theta$运算的元组进行连接。</p>
</li>
</ul>
<p>$\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\theta$连接可表示为：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \sigma_{X \theta Y}(R \times S)
$$</p>
<p>或：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \sigma_{i \theta j}(R \times S)
$$</p>
</li>
<li>
<p><strong>等值连接</strong>：当$\theta$为“=”时，称之为等值连接，记为$R \mathop{\Join}\limits_{i = j} S$，其形式定义如下：</p>
<p>$$
R \mathop{\Join}\limits_{i = j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] = t^m[j]) \}
$$</p>
</li>
<li>
<p>$F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\mathop{\Join}\limits_{F}$。</p>
<p>$F$是形为$F_1 \wedge F_2 \wedge \cdots \wedge F_n$的公式，每个$F_p$是形为$i \theta j$的式子。</p>
</li>
<li>
<p><strong>自然连接</strong>：自然连接是一种特殊的等值连接，它要求两个关系中<u>进行比较的分量必须是相同的属性组</u>，并且在结果集中<u>将重复属性列去掉</u>。</p>
<p>若：</p>
<ul>
<li>
<p>$t^n \in R$，$t^m \in S$；</p>
</li>
<li>
<p>$R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；</p>
</li>
<li>
<p>假定$R$关系的属性：</p>
<p>$$
A_1,A_2,\cdots,A_{n-k},B_1,B_2,\cdots,B_k
$$</p>
</li>
<li>
<p>$S$关系的属性：</p>
<p>$$
B_1,B2,\cdots,B_k,B_{k+1},B_{k+2},\cdots,B_m
$$</p>
</li>
</ul>
<p>自然连接可以记为$R \Join S$,其形式定义如下：</p>
<p>$$
R \Join S = \{ t| (t = &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (R.B_1 = S.B_1) \wedge (R.B_2 = S.B_2) \wedge \cdots \wedge (R.B_k = S.B_k) \}
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>外连接</strong>（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。</p>
<p>外连接运算有3种：</p>
<ul>
<li>
<p><strong>左外连接</strong>（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>右外连接</strong>（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>全外连接</strong>（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681454087063.png" loading="lazy" width="762" height="575" />
</picture>

</p>
</li>
</ul>
<h2 id="sql" data-numberify>SQL<a class="anchor ms-1" href="#sql"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#sql">数据库篇——SQL</a></p>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。</p>
<p>关键字：<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。</p>
<p>关键字：<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。</p>
<p>关键字：<code>SELECT</code>等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。</p>
</li>
</ol>
<p>授权语句格式（<code>GRANT</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">GRANT</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">TO</span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">WITH</span><span class="w"> </span><span class="k">GRANT</span><span class="w"> </span><span class="k">OPTION</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><p>常见的操作权限如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">对象类型</th>
<th style="text-align:left">操作权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">属性列</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">视图</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">基本表</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALTER</code>、<br><code>INDEX</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:center"><code>DATABASE</code></td>
<td style="text-align:left"><code>CREATETAB</code></td>
</tr>
</tbody>
</table>
<ul>
<li>建立表的权限，可由DBA授予普通用户；</li>
<li><code>WITH GRANT OPTION</code>：表示获得了这些权限的用户还可以将权限赋给其他用户。</li>
</ul>
<p>收回权限语句格式（<code>REVOKE</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">REVOKE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><h2 id="函数依赖" data-numberify>函数依赖<a class="anchor ms-1" href="#函数依赖"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">结论</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">函数依赖</td>
<td style="text-align:left">元组在$X$上的属性值相等，那么在$Y$上的属性值也相等</td>
<td style="text-align:left">$X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">非平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是非平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">完全函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$X&rsquo; \subset X$，$X&rsquo; \not\rightarrow Y$</td>
<td style="text-align:left">$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">部分函数依赖（局部函数依赖）</td>
<td style="text-align:left">$X \rightarrow Y$，$X \stackrel{f}{\not\longrightarrow} Y$</td>
<td style="text-align:left">$Y$对$X$部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">传递依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$，$Y \rightarrow Z$</td>
<td style="text-align:left">$Z$对$X$传递依赖</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">码（候选码，候选关键字）</td>
<td style="text-align:left">若$K \stackrel{f}{\rightarrow} U$，则$K$为$R$的候选码</td>
</tr>
<tr>
<td style="text-align:center">主属性</td>
<td style="text-align:left">包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">非主属性</td>
<td style="text-align:left">不包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">外码</td>
<td style="text-align:left">$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码</td>
</tr>
</tbody>
</table>
<p>Armstrong公理系统：</p>
<table>
<thead>
<tr>
<th style="text-align:center">定律</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自反律</td>
<td style="text-align:left">$Y \subseteq X \subseteq U$</td>
<td style="text-align:left">$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">增广律</td>
<td style="text-align:left">$X \rightarrow Y$，$Z \subseteq U$</td>
<td style="text-align:left">$XZ \rightarrow XZ$</td>
</tr>
<tr>
<td style="text-align:center">传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ Y \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">合并规则</td>
<td style="text-align:left">$X \rightarrow Y,\ X \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow YZ$</td>
</tr>
<tr>
<td style="text-align:center">伪传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ WY \rightarrow Z$</td>
<td style="text-align:left">$XW \rightarrow Z$</td>
</tr>
<tr>
<td style="text-align:center">分解规则</td>
<td style="text-align:left">$X \rightarrow Y,\ Z \subseteq Y$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<h2 id="关系模式的分解" data-numberify>关系模式的分解<a class="anchor ms-1" href="#关系模式的分解"></a></h2>
<ul>
<li><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%97%a0%e6%8d%9f%e8%bf%9e%e6%8e%a5">无损连接</a></li>
<li><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e4%bf%9d%e6%8c%81%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96">保持函数依赖</a></li>
</ul>
<h2 id="范式" data-numberify>范式<a class="anchor ms-1" href="#范式"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e8%8c%83%e5%bc%8f">数据库篇——范式</a></p>
<ol>
<li>
<p>第一范式（1NF）：若关系模式R的<u>每一个分量是不可再分的数据项</u>，则关系模式R属于第一范式。</p>
<p>如，关系模式$R&lt;U,F&gt;$：</p>
<p>$$
U = \{ 学号,姓名,学院,院长,课程号,课程名,成绩 \} \\
F = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长,课程号 \rightarrow 课程名,(学号,课程号) \rightarrow 成绩 \}
$$</p>
</li>
<li>
<p>第二范式（2NF）：若关系模式$R \in 1NF$，且<u>每一个非主属性完全依赖于码</u>，则关系模式$R \in 2NF$。</p>
<p>即当<u>1NF消除了对主键的部分函数依赖后就能满足2NF</u>。</p>
<p>例如，$学号 \rightarrow 学院$，即$(学号,课程号) \stackrel{P}{\rightarrow} 学院$（部分依赖于码），所以$R \not\in 2NF$。</p>
<p><u>模式的分解需要保持函数依赖。</u>根据$F$，将$R$分解为：</p>
<ul>
<li>
<p>$R_1&lt;U_1,F_1&gt;$：</p>
<p>$$
U_1 = \{ 学号,姓名,学院,院长 \} \\
F_1 = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长 \}
$$</p>
</li>
<li>
<p>$R_2&lt;U_2,F_2&gt;$：</p>
<p>$$
U_2 = \{ 课程号,课程名 \} \\
F_2 = \{ 课程号 \rightarrow 课程名 \}
$$</p>
</li>
<li>
<p>$R_3&lt;U_3,F_3&gt;$：</p>
<p>$$
U_3 = \{ 学号,课程号,成绩 \} \\
F_3 = \{ (学号,课程号) \rightarrow 成绩 \}</p>
</li>
</ul>
<p>则，$R1 \in 2NF$，$R2 \in 2NF$，$R3 \in 2NF$。</p>
</li>
<li>
<p>第三范式（3NF）：若关系模式$R(R \in 2NF)$中<u>任何一个非主属性都不传递函数依赖于码</u>。</p>
<p>若关系模式$R&lt;U,F&gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：</p>
<ul>
<li>$X \rightarrow Y(Y \not\rightarrow X)$，</li>
<li>$Y \rightarrow Z$，</li>
</ul>
<p>则关系模式$R \in 3NF$，其中：</p>
<ul>
<li>$Y$为属性组，</li>
<li>$Z(Z \not\subseteq Y)$为非主属性。</li>
</ul>
<p>即当<u>2NF消除了非主属性对主键的传递函数依赖</u>，则称为3NF。</p>
<p>如，$R_1$中有$学号 \rightarrow 学院$，$学院 \rightarrow 院长$（非主属性&quot;院长&quot;传递依赖于主键&quot;学号&quot;）。可将$R_1$分解为：</p>
<ul>
<li>
<p>$R_{11}&lt;U_{11},F_{11}&gt;$：</p>
<p>$$
U_{11} = \{ 学号,姓名,学院 \} \\
F_{11} = \{ 学号 \rightarrow 姓名, 学号 \rightarrow 学院 \}
$$</p>
</li>
<li>
<p>$R_{12}&lt;U_{12},F_{12}&gt;$：</p>
<p>$$
U_{12} = \{ 学院,院长 \} \\
F_{12} = \{ 学院 \rightarrow 院长 \}
$$</p>
</li>
</ul>
</li>
</ol>
<p>范式之间的关系：</p>
<p>$$
5NF \sub 4NF \sub BCNF \sub 3NF \sub 2NF \sub 1NF
$$</p>
<p><picture><img class="img-fluid " alt="规范化范式的包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681894653450.png" loading="lazy" width="564" height="309" />
</picture>

</p>
<p>3NF和BCNE它们是进行规范化的主要目标。</p>
<p>1NF到4NF之间的转换关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">范式</th>
<th style="text-align:left">转换关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1NF</td>
<td style="text-align:left">每一个分量是不可再分的数据项</td>
</tr>
<tr>
<td style="text-align:center">2NF</td>
<td style="text-align:left">1NF消除了部分函数依赖后满足2NF</td>
</tr>
<tr>
<td style="text-align:center">3NF</td>
<td style="text-align:left">2NF消除了非主属性对码的传递函数依赖后满足3NF</td>
</tr>
<tr>
<td style="text-align:center">BCNF</td>
<td style="text-align:left">3NF消除了主属性对码的部分和传递函数依赖后满足BCNF</td>
</tr>
<tr>
<td style="text-align:center">4NF</td>
<td style="text-align:left">BCNF消除非平凡且非函数依赖的多值依赖后满足4NF</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="规范化步骤" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1681988070233.png" loading="lazy" width="288" height="303" />
</picture>

</p>
<p>几种范式及其分解的性质：</p>
<table>
<thead>
<tr>
<th style="text-align:left">性质</th>
<th style="text-align:center">3NF</th>
<th style="text-align:center">BCNF</th>
<th style="text-align:center">4NF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">消除函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">消除多值函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">保持函数依赖</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">保持多值函数依赖</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<h2 id="数据库设计" data-numberify>数据库设计<a class="anchor ms-1" href="#数据库设计"></a></h2>
<p><a href="/p/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%af%87/#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1">数据库篇——数据库设计</a></p>
<h2 id="分布式数据库" data-numberify>分布式数据库<a class="anchor ms-1" href="#分布式数据库"></a></h2>
<p>基本概念：</p>
<ul>
<li><strong>分片透明</strong></li>
<li><strong>复制透明</strong></li>
<li><strong>位置透明</strong></li>
<li><strong>逻辑透明</strong></li>
</ul>
<p>性质：</p>
<ul>
<li><strong>共享性</strong>：数据存储在不同的结点数据共享。</li>
<li><strong>自治性</strong>：指每结点对本地数据都能独立管理。</li>
<li><strong>可用性</strong>：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。</li>
<li><strong>分布性</strong></li>
</ul>
<hr>
<h1 id="结构化设计" data-numberify>结构化设计<a class="anchor ms-1" href="#结构化设计"></a></h1>
<p>跳转连接：<a href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/">软件设计师——结构化设计篇</a></p>
<h2 id="模块化" data-numberify>模块化<a class="anchor ms-1" href="#模块化"></a></h2>
<ul>
<li>
<p><strong>模块</strong>：是在程序中是数据说明、可执行语句等<u>程序对象的集合</u>，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。</p>
<p>在软件的体系结构中，模块是可组合、分解和更换的单元。</p>
</li>
<li>
<p><strong>模块化</strong>：是指<u>将一个待开发的软件分解成若干个小的简单部分一模块</u>，<u>每个模块可独立地开发、测试，最后组装成完整的程序</u>。</p>
<p>这是一种<u>复杂问题“分而治之”的原则</u>。</p>
<p>模块化的<u>目的是使程序的结构清晰，容易阅读、理解、测试和修改。</u></p>
</li>
<li>
<p><strong>模块独立</strong>：是指<u>每个模块完成一个相对独立的特定子功能</u>，并且<u>与其他模块之间的联系简单</u>。</p>
<p>衡量模块独立程度的标准有（模块独立性的两个定性标准）：</p>
<ul>
<li><strong>耦合性</strong>；</li>
<li><strong>内聚性</strong>。</li>
</ul>
<p>在将软件系统划分模块时，应尽量做到<strong>高内聚</strong>、<strong>低耦合</strong>，提高模块的独立性。</p>
</li>
</ul>
<p>通常，可以按照在软件系统中的功能将模块分为四种类型：</p>
<ul>
<li>传入模块：取得数据或输入数据，经过某些处理，再将其传送给其他模块。</li>
<li>传出模块：输出数据，在输出前可能进行某些处理。数据可能被输出到系统的外部，或者会输出到其他模块进行进一步处理。</li>
<li>变换模块：从上级调用模块得到数据，进行特定的处理，转换成其他形式，再将加工结果返回给调用模块。</li>
<li>协调模块：一般不对数据进行加工，主要是通过调用、协调和管理其他模块来完成特定的功能。</li>
</ul>
<h2 id="耦合和内聚" data-numberify>耦合和内聚<a class="anchor ms-1" href="#耦合和内聚"></a></h2>
<p><picture><img class="img-fluid " alt="耦合的种类" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683443957893.png" loading="lazy" width="874" height="133" />
</picture>

</p>
<table>
<thead>
<tr>
<th style="text-align:center">耦合类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无直接耦合</td>
<td style="text-align:left">没有直接关系，不传递任何信息</td>
</tr>
<tr>
<td style="text-align:center">数据耦合</td>
<td style="text-align:left">调用关系，传递简单数据值</td>
</tr>
<tr>
<td style="text-align:center">标记耦合</td>
<td style="text-align:left">传递数据结构</td>
</tr>
<tr>
<td style="text-align:center">控制耦合</td>
<td style="text-align:left">调用关系，被调模块传递给主调模块控制变量</td>
</tr>
<tr>
<td style="text-align:center">外部耦合</td>
<td style="text-align:left">通过软件之外的环境联结</td>
</tr>
<tr>
<td style="text-align:center">公共耦合</td>
<td style="text-align:left">通过公共数据环境相互作用</td>
</tr>
<tr>
<td style="text-align:center">内容耦合</td>
<td style="text-align:left">直接使用另一个模块的内部数据<br>或通过非正常入口转入另一个模块内部</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="内聚的种类" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683460613634.png" loading="lazy" width="852" height="150" />
</picture>

</p>
<table>
<thead>
<tr>
<th style="text-align:center">内聚类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偶然内聚<br>（巧合内聚）</td>
<td style="text-align:left">各处理之间没有任何联系</td>
</tr>
<tr>
<td style="text-align:center">逻辑内聚</td>
<td style="text-align:left">执行若干个逻辑上相似的功能，<br>通过参数确定该模块完成哪一个功能</td>
</tr>
<tr>
<td style="text-align:center">时间内聚</td>
<td style="text-align:left">把需要同时执行的动作组合在一起</td>
</tr>
<tr>
<td style="text-align:center">过程内聚</td>
<td style="text-align:left">完成多个任务，这些任务必须按指定的过程执行</td>
</tr>
<tr>
<td style="text-align:center">通信内聚</td>
<td style="text-align:left">所有处理都在同一个数据结构上操作，<br>或者各处理使用相同的输入数据或者产生相同的输出数据</td>
</tr>
<tr>
<td style="text-align:center">顺序内聚</td>
<td style="text-align:left">各处理都与同一功能密切相关且必须顺序执行，<br>前一功能元素的输出就是下一功能元素的输入</td>
</tr>
<tr>
<td style="text-align:center">功能内聚</td>
<td style="text-align:left">所有元素共同作用完成一个功能，缺一不可</td>
</tr>
</tbody>
</table>
<h2 id="系统结构设计原则" data-numberify>系统结构设计原则<a class="anchor ms-1" href="#系统结构设计原则"></a></h2>
<p>为保证总体结构设计顺利完成，应遵循以下几条原则：</p>
<ul>
<li>
<p><strong>分解——协调原则</strong>：</p>
<p>系统整体，具有其整体的目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</p>
</li>
<li>
<p><strong>自顶向下的原则</strong>：从上往下，逐层分解；先确定上层模块的功能，再确定下层模块的功能。</p>
</li>
<li>
<p><strong>信息隐蔽、抽象的原则</strong>：<u>上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做</u>。</p>
</li>
<li>
<p><strong>一致性原则</strong>：统一的规范、标准、文件模式……</p>
</li>
<li>
<p><strong>明确性原则</strong>：每个模块必须：</p>
<ul>
<li>功能明确、接口明确；</li>
<li>消除多重功能和无用接口。</li>
</ul>
</li>
<li>
<p><strong>高内聚、低耦合</strong></p>
</li>
<li>
<p><strong>模块的扇入系数和扇出系数要合理</strong>：</p>
<ul>
<li><strong>扇出系数</strong>：模块直接调用其他模块的个数。</li>
<li><strong>扇入系数</strong>：模块被其他模块调用时，直接调用它的模块个数。</li>
</ul>
<p><u>一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7</u>。</p>
</li>
<li>
<p><strong>模块的规模适当</strong>：</p>
<ul>
<li><u>过大的模块常常使系统分解得不充分；</u></li>
<li><u>过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</u></li>
</ul>
</li>
<li>
<p><u>模块的作用范围应该在其控制范围之内。</u></p>
</li>
<li>
<p>避免或减少使用病态连接：病态连接是指从中部进入或访问一个模块。</p>
</li>
</ul>
<h2 id="系统文档" data-numberify>系统文档<a class="anchor ms-1" href="#系统文档"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">人员</th>
<th style="text-align:center">阶段</th>
<th style="text-align:left">文档</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用户<br>系统分析人员</td>
<td style="text-align:center">系统规划<br>系统分析</td>
<td style="text-align:left">沟通文档，主要是<strong>规划报告</strong>、<strong>合同</strong>、<strong>方案</strong>：<br><ul><li>可行性研究报告</li><li>总体规划报告</li><li>系统开发合同</li><li>系统方案说明书</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>项目管理人员</td>
<td style="text-align:center">项目期内</td>
<td style="text-align:left">沟通文档（项目管理文件），主要是<strong>计划</strong>、<strong>报告</strong>类文档：<br><ul><li>系统开发计划<ul><li>工作任务分解表</li><li>PERT图</li><li>甘特图</li><li>预算分配表</li></ul></li><li>系统开发月报</li><li>系统开发总结报告</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统测试人员<br>系统开发人员</td>
<td style="text-align:center">测试</td>
<td style="text-align:left">系统测试人员根据以下文档对系统进行测试：<br><ul><li>系统方案说明书</li><li>系统开发合同</li><li>系统设计说明书</li><li>测试计划</li></ul>系统测试人员再将评估结果撰写成系统测试报告</td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>用户</td>
<td style="text-align:center">系统运行期间</td>
<td style="text-align:left">用户通过系统开发人员撰写的文档运行系统：<br><ul><li>用户手册</li><li>操作指南</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>系统维护人员</td>
<td style="text-align:center">维护</td>
<td style="text-align:left">沟通文档：<ul><li>系统设计说明书</li><li>系统开发总结报告<ul><li>研制报告</li><li>研制报告</li><li>技术手册</li></ul></li></ul></td>
</tr>
<tr>
<td style="text-align:center">用户<br>维修人员</td>
<td style="text-align:center">运维</td>
<td style="text-align:left">用户将运行过程中的问题进行记载：<ul><li>系统运行报告</li><li>维护修改建议</li></ul>系统维护人员根据以下文档对系统进行维护和升级：<ul><li>维护修改建议</li><li>系统开发人员留下的技术手册等文档</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="数据流图和数据字典" data-numberify>数据流图和数据字典<a class="anchor ms-1" href="#数据流图和数据字典"></a></h2>
<p><a href="/p/%e7%bb%93%e6%9e%84%e5%8c%96%e8%ae%be%e8%ae%a1%e7%af%87/#%e7%bb%93%e6%9e%84%e5%8c%96%e5%88%86%e6%9e%90%e6%96%b9%e6%b3%95">结构化设计篇——结构化分析方法</a></p>
<hr>
<h1 id="软件工程" data-numberify>软件工程<a class="anchor ms-1" href="#软件工程"></a></h1>
<p>跳转连接：<a href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/">软件设计师——软件工程篇</a></p>
<h2 id="软件过程模型" data-numberify>软件过程模型<a class="anchor ms-1" href="#软件过程模型"></a></h2>
<p>能力成熟度模型（从1开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始级</td>
<td style="text-align:left">杂乱无章，几乎没有明确定义的步骤。</td>
</tr>
<tr>
<td style="text-align:center">可重复级</td>
<td style="text-align:left">建立基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。</td>
</tr>
<tr>
<td style="text-align:center">已定义级</td>
<td style="text-align:left">将管理和工程文档化、标准化并综合成标准软件过程；<br>使用标准开发过程（或方法论）构建（或集成）系统。</td>
</tr>
<tr>
<td style="text-align:center">己管理级</td>
<td style="text-align:left">对软件过程和产品质量制定了的详细度量标准，且有定量的理解和控制。</td>
</tr>
<tr>
<td style="text-align:center">优化级</td>
<td style="text-align:left">加强了定量分析，通过过程质量和新观念、新技术使过程不断地改进。</td>
</tr>
</tbody>
</table>
<p>能力成熟度集成连续式模型（从0开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">能力等级</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未完成的</td>
<td style="text-align:left">未执行或未得到等级1中的所有目标。</td>
</tr>
<tr>
<td style="text-align:center">已执行的</td>
<td style="text-align:left">可标识的输入工作产品到输出工作产品的转换，实现特定目标。<p>关注：特定目标的完成。</p></td>
</tr>
<tr>
<td style="text-align:center">已管理的</td>
<td style="text-align:left">已管理的过程的制度化。<p>关注：针对单个过程实例的能力。</p></td>
</tr>
<tr>
<td style="text-align:center">已定义级的</td>
<td style="text-align:left">已定义的过程的制度化。<p>关注：过程的组织级标准化和部署。</p></td>
</tr>
<tr>
<td style="text-align:center">定量管理的</td>
<td style="text-align:left">可定量管理的过程的制度化。<p>说明：使用测量和质量保证来控制和改进。</p></td>
</tr>
<tr>
<td style="text-align:center">优化的</td>
<td style="text-align:left">优化的过程的制度化。<p>说明：使用量化手段改变和优化。</p></td>
</tr>
</tbody>
</table>
<p>各开发模型的适用范围：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瀑布模型</td>
<td style="text-align:left">将软件生存周期中的活动定为线性顺序链接的阶段模型</td>
<td style="text-align:left">需求明确、大致固定且变更少</td>
</tr>
<tr>
<td style="text-align:center">V模型</td>
<td style="text-align:left">瀑布模型的变体，强调测试贯穿项目的始终，是一种测试的开发模型</td>
<td style="text-align:left">需求明确、低风险</td>
</tr>
<tr>
<td style="text-align:center">增量模型</td>
<td style="text-align:left">融合瀑布模型和原型迭代，核心功能先完成，每轮迭代都会有新的增量，核心功能得到充分测试，强调每个增量均发布一个可操作的产品</td>
<td style="text-align:left">快速构造可运行的产品，产品升级，领域熟悉或已有原型</td>
</tr>
<tr>
<td style="text-align:center">演化模型</td>
<td style="text-align:left">迭代的过程模型，需求无法被完整定义，功能在使用过程中不断完善</td>
<td style="text-align:left">对软件需求缺乏准确认识的情况</td>
</tr>
<tr>
<td style="text-align:center">原型模型</td>
<td style="text-align:left">原型开发方法模型，目的是快速、低成本地构建原型系统</td>
<td style="text-align:left">需求不清或多变、领域陌生；不适合大规模系统</td>
</tr>
<tr>
<td style="text-align:center">螺旋模型</td>
<td style="text-align:left">结合瀑布和演化模型，强调引入风险分析，属于面向对象开发模型</td>
<td style="text-align:left">庞大、复杂、高风险的系统，开发人员有丰富的风险评估经验和知识</td>
</tr>
<tr>
<td style="text-align:center">喷泉模型</td>
<td style="text-align:left">面向对象模型，特点是迭代、无间隙和支持重用，各阶段无明显界限，可迭代交叉</td>
<td style="text-align:left">面向对象的开发过程</td>
</tr>
<tr>
<td style="text-align:center">统一过程</td>
<td style="text-align:left">用例驱动、以架构为中心、迭代和增量</td>
<td></td>
</tr>
</tbody>
</table>
<p>统一过程模型阶段里程碑和关注点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">里程碑</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始阶段</td>
<td style="text-align:left">生命周期目标</td>
<td style="text-align:left">项目的初创活动</td>
</tr>
<tr>
<td style="text-align:center">精化阶段</td>
<td style="text-align:left">生命周期架构</td>
<td style="text-align:left">需求分析和架构演进</td>
</tr>
<tr>
<td style="text-align:center">构建阶段</td>
<td style="text-align:left">初始运作功能</td>
<td style="text-align:left">系统的构建</td>
</tr>
<tr>
<td style="text-align:center">移交阶段</td>
<td style="text-align:left">产品发布</td>
<td style="text-align:left">软件提交方面的工作</td>
</tr>
</tbody>
</table>
<h2 id="软件需求" data-numberify>软件需求<a class="anchor ms-1" href="#软件需求"></a></h2>
<ul>
<li>
<p><strong>功能需求</strong>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p>
</li>
<li>
<p><strong>性能需求</strong>：考虑软件开发的技术性指标。</p>
<p>例如：</p>
<ul>
<li>存储容量限制；</li>
<li>执行速度；</li>
<li>响应时间；</li>
<li>吞吐量。</li>
</ul>
</li>
<li>
<p><strong>用户或人的因素</strong>：考虑用户的类型。</p>
<p>例如：</p>
<ul>
<li>各种用户对使用计算机的熟练程度，需要接受的训练；</li>
<li>用户理解、使用系统的难度；</li>
<li>用户错误操作系统的可能性。</li>
</ul>
</li>
<li>
<p><strong>环境需求</strong>：考虑未来软件应用的环境，包括硬件和软件。</p>
<ul>
<li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li>
<li>对软件的需求包括：操作系统、网络、数据库等。</li>
</ul>
</li>
<li>
<p><strong>界面需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>来自其他系统的输入；</li>
<li>到其他系统的输出；</li>
<li>对数据格式的特殊规定；</li>
<li>对数据存储介质的规定。</li>
</ul>
</li>
<li>
<p><strong>文档需求</strong>：考虑需要哪些文档，文档针对哪些读者。</p>
</li>
<li>
<p><strong>数据需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>输入、输出数据的格式；</li>
<li>接收、发送数据的频率；</li>
<li>数据的准确性和精度；</li>
<li>数据流量；</li>
<li>数据需保持的时间。</li>
</ul>
</li>
<li>
<p><strong>资源使用需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>软件运行时所需要的数据、其他软件、内存空间等资源；</li>
<li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li>
</ul>
</li>
<li>
<p><strong>安全保密要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>是否需要对访问系统或系统信息加以控制；</li>
<li>隔离用户数据的方法；</li>
<li>用户程序如何与其他程序和操作系统隔离</li>
<li>系统备份要求。</li>
</ul>
</li>
<li>
<p><strong>可靠性要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>系统的可靠性要求；</li>
<li>系统是否必须检测和隔离错误；</li>
<li>出错后，重启系统允许的时间。</li>
</ul>
</li>
<li>
<p><strong>软件成本消耗与开发进度需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>开发是否有规定的时间表；</li>
<li>软/硬件投资有无限制。</li>
</ul>
</li>
<li>
<p><strong>其他非功能性要求</strong>：</p>
<p>如采用某种开发模式，需要确定：</p>
<ul>
<li>质量控制标准；</li>
<li>里程碑和评审；</li>
<li>验收标准；</li>
<li>各种质量要求的优先级；</li>
<li>可维护性方面的要求。</li>
</ul>
</li>
</ul>
<h2 id="单元测试" data-numberify>单元测试<a class="anchor ms-1" href="#单元测试"></a></h2>
<p>在测试中应检查以下要点：</p>
<ul>
<li>
<p>模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。</p>
<p>在测试中应检查以下要点：</p>
<ul>
<li>测试模块的<u>输入参数</u>和<u>形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用其他模块时，所给出的<u>实际参数</u>和<u>被调用模块的形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用标准函数时，所用的<u>参数在属性、数目和顺序上是否正确</u>。</li>
<li><u>全局变量在各模块中的定义和用法是否一致。</u></li>
<li><u>输入是否仅改变了形式参数。</u></li>
<li><u>开/关的语句</u>是否正确。</li>
<li>规定的<u>I/O格式</u>是否与输入/输出语句一致。</li>
<li>在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。</li>
</ul>
</li>
<li>
<p>局部数据结构</p>
</li>
<li>
<p>重要的执行路径</p>
</li>
<li>
<p>出错处理</p>
</li>
<li>
<p>边界条件</p>
</li>
</ul>
<h2 id="集成测试" data-numberify>集成测试<a class="anchor ms-1" href="#集成测试"></a></h2>
<ul>
<li>
<p><strong>非增量集成</strong>：分别测试各个模块，再把这些模块组合起来进行整体测试。</p>
<ul>
<li>优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。</li>
<li>缺点：容易混乱，出现错误不容易查找和定位。</li>
</ul>
</li>
<li>
<p><strong>增量集成</strong>：以小增量的方式逐步进行构造和测试。</p>
<p>增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。</p>
</li>
</ul>
<p>增量集成策略：</p>
<ul>
<li>自项向下集成测试：从主控模块（主程序）开始，以深度优先或广度优先的方式。不需要驱动模块。</li>
<li>自底向上集成测试：从原子模块开始进行构造和测试。不需要桩模块。</li>
<li>回归测试</li>
<li>冒烟测试</li>
</ul>
<h2 id="测试方法" data-numberify>测试方法<a class="anchor ms-1" href="#测试方法"></a></h2>
<p>黑白盒测试法属于动态测试。设计测试用例时应包括合理的输入条件和不合理的输入条件。</p>
<h2 id="黑盒测试" data-numberify>黑盒测试<a class="anchor ms-1" href="#黑盒测试"></a></h2>
<p>等价类划分：从每个等价类中选取一个代表性数据作为测试用例。用少量代表性的测试用例取得较好的测试效果。</p>
<p>分为有效等价类和无效等价类。</p>
<p>定义等价类的原则如下。</p>
<ol>
<li>在<u>输入条件规定了取值范围或值的个数</u>的情况下，<u>可以定义1个有效等价类和2个无效等价类</u>。</li>
<li>在<u>输入条件规定了输入值的集合或规定了“必须如何”</u>的条件的情况下，<u>可以定义1个有效等价类和一个无效等价类</u>。</li>
<li>在输入条件是一个<u>布尔量</u>的情况下，<u>可以定义一个有效等价类和一个无效等价类</u>。</li>
<li>在<u>规定了输入数据的一组值（假定$n$个）</u>，并且程序要<u>对每一个输入值分别处理</u>的情况下，<u>可以定义$n$个有效等价类和1个无效等价类</u>。</li>
<li>在<u>规定了输入数据必须遵守的规则</u>的情况下，<u>可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</u>。</li>
<li>在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。</li>
</ol>
<p>无效等价类的划分：每个无效等价类的测试用例，<u>只违反一个输入的取值范围</u>。如果违反了多个输入的取值范围，那便是不好的测试用例。</p>
<p>例如，输入$x$的取值范围是$0 \sim 10$，输入$y$的取值范围是$-10 \sim -1$，那么可以定义三个等价类：</p>
<ul>
<li>有效等价类1：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类2：$x$的取值范围是$x &lt; 0 \ \ OR \ \ x &gt; 10$，输入$y$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类3：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$x &lt; -10 \ \ OR \ \ x &gt; -1$。</li>
</ul>
<p>除了等价类划分还有：</p>
<ul>
<li>边界值分析</li>
<li>错误推测</li>
<li>因果图</li>
</ul>
<h2 id="白盒测试" data-numberify>白盒测试<a class="anchor ms-1" href="#白盒测试"></a></h2>
<p>逻辑覆盖：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。</p>
<p>主要的逻辑覆盖标准有6种，它们的覆盖程度从低到高为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑覆盖</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语句覆盖</td>
<td style="text-align:left">每条语句执行一次</td>
</tr>
<tr>
<td style="text-align:center">分支（判定）覆盖</td>
<td style="text-align:left">每个分支获得一次True/False</td>
</tr>
<tr>
<td style="text-align:center">条件覆盖</td>
<td style="text-align:left">每个分支中的每个逻辑条件的所有可能取值满足一次</td>
</tr>
<tr>
<td style="text-align:center">判定/条件覆盖</td>
<td style="text-align:left">分支覆盖 + 条件覆盖</td>
</tr>
<tr>
<td style="text-align:center">条件组合覆盖</td>
<td style="text-align:left">每个判定中条件的各种可能值的组合都出现一次</td>
</tr>
<tr>
<td style="text-align:center">路径覆盖</td>
<td style="text-align:left">覆盖被测试程序中所有可能的路径</td>
</tr>
</tbody>
</table>
<p>除了逻辑覆盖还有：</p>
<ul>
<li>循环覆盖</li>
<li>基本路径测试</li>
</ul>
<h2 id="软件维护" data-numberify>软件维护<a class="anchor ms-1" href="#软件维护"></a></h2>
<p>正确性和完善性维护是针对来自系统内部的维护，适应性和预防性是针对来自系统外部的维护。</p>
<ul>
<li>
<p>正确性维护针对的是系统内部的错误。</p>
<p>来自系统内部的，与错误有关的都是属于正确性维护。</p>
</li>
<li>
<p>完善性维护针对的是系统内部与功能、性能等方面有关的维护。</p>
<p>来自系统内部的，与系统功能、性能等方面有关的改善都是完善性维护。完善性维护的需求可以来自外部，例如功能的扩展。</p>
</li>
<li>
<p>适应性维护是针对来自系统外部的技术、管理需求等方面的变化。</p>
<p>针对来自系统外部的变化，系统功能等方面没有缺失，仅仅只是适应当前环境变化所做的更改，都是属于适应性维护。</p>
</li>
<li>
<p>预防性维护针对的是未来的环境变化。</p>
</li>
</ul>
<h2 id="沟通路径" data-numberify>沟通路径<a class="anchor ms-1" href="#沟通路径"></a></h2>
<p>软件项目中沟通路径$m$的计算公式（人数$n$）：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="估算模型" data-numberify>估算模型<a class="anchor ms-1" href="#估算模型"></a></h2>
<p>COCOMO模型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型分类</th>
<th style="text-align:left">类型或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本COCOMO模型</td>
<td style="text-align:left">静态单变量模型，对整个软件系统进行估算</td>
</tr>
<tr>
<td style="text-align:center">中级COCOMO模型</td>
<td style="text-align:left">静态多变量模型，将系统模型分为系统和部件2个层次</td>
</tr>
<tr>
<td style="text-align:center">详细COCOMO模型</td>
<td style="text-align:left">将系统模型分为系统、子系统和模块3个层次</td>
</tr>
<tr>
<td style="text-align:center">COCOMOII</td>
<td style="text-align:left">层次结构，分为应用组装模型、早期设计阶段模型和体系结构阶段模型</td>
</tr>
</tbody>
</table>
<p>COCOMOII的使用时期及规模估算选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段性模型</th>
<th style="text-align:center">规模估算选择</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用组装模型</td>
<td style="text-align:center">对象点</td>
</tr>
<tr>
<td style="text-align:center">早期设计阶段模型</td>
<td style="text-align:center">功能点</td>
</tr>
<tr>
<td style="text-align:center">体系结构阶段模型</td>
<td style="text-align:center">代码行</td>
</tr>
</tbody>
</table>
<h2 id="甘特图和pert图" data-numberify>甘特图和PERT图<a class="anchor ms-1" href="#甘特图和pert图"></a></h2>
<p><a href="/p/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%af%87/#%e8%bf%9b%e5%ba%a6%e7%ae%a1%e7%90%86">软件工程篇——项目进度管理</a></p>
<h2 id="风险分类" data-numberify>风险分类<a class="anchor ms-1" href="#风险分类"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目风险</td>
<td style="text-align:left">威胁到项目计划。<p>风险因素：<br>预算、进度、人员、资源和利益相关者，项目复杂度、规模和结构的不确定性</p></td>
</tr>
<tr>
<td style="text-align:center">技术风险</td>
<td style="text-align:left">威胁到软件的质量及交付时间。<p>风险因素：<br>设计、实现、接口、验证和维护，规格说明的歧义性、技术的不确定性、技术陈旧和使用“前沿”技术</p></td>
</tr>
<tr>
<td style="text-align:center">市场风险</td>
<td style="text-align:left">开发了一个没有人真正需要的产品或系统。</td>
</tr>
<tr>
<td style="text-align:center">策略风险</td>
<td style="text-align:left">开发的产品不再符合公司的整体商业策略。</td>
</tr>
<tr>
<td style="text-align:center">销售风险</td>
<td style="text-align:left">开发了一个销售部门不知道如何去销售的产品。</td>
</tr>
<tr>
<td style="text-align:center">管理风险</td>
<td style="text-align:left">由于重点的转移或人员的变动而失去了高级管理层的支持。</td>
</tr>
<tr>
<td style="text-align:center">预算风险</td>
<td style="text-align:left">没有得到预算或人员的保证。</td>
</tr>
</tbody>
</table>
<p>风险管理总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">风险管理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">风险识别</td>
<td style="text-align:left">指出对项目计划的威胁。可通过建立风险条目检查表识别。</td>
</tr>
<tr>
<td style="text-align:center">风险预测</td>
<td style="text-align:left">从风险发生的可能性或概率、风险产生的后果评估可能发生的风险。</td>
</tr>
<tr>
<td style="text-align:center">风险评估</td>
<td style="text-align:left">从风险发生的概率和产生的影响评估风险。可用定义风险参照水准技术评估。</td>
</tr>
<tr>
<td style="text-align:center">风险控制</td>
<td style="text-align:left">目的是辅助项目建立处理风险的策略。策略是风险避免、风险监控和RMMM计划。</td>
</tr>
<tr>
<td style="text-align:center">风险避免</td>
<td style="text-align:left">应对风险的最好办法是主动地避免风险。</td>
</tr>
<tr>
<td style="text-align:center">风险监控</td>
<td style="text-align:left">项目管理者应监控某些可以提供风险高低变化指示的因素。</td>
</tr>
</tbody>
</table>
<h2 id="isoiec-9126-软件质量模型" data-numberify>ISO/IEC 9126 软件质量模型<a class="anchor ms-1" href="#isoiec-9126-软件质量模型"></a></h2>
<p>由3个层次组成：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>质量子特性</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p>该模型的质量特性和质量子特性：</p>
<table>
<tr>
    <th style="text-align: center;">
        质量特性
    </th>
    <th style="text-align: center;">
        质量子特性
    </th>
</tr>
<tr>
    <td style="text-align: center;" rowspan="6">
        <b>功能性</b>（Functionality）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适合性（Suitability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        准确性（Accurateness）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        互用性（Interoperability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        依从性（Compliance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        安全性（Security）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>可靠性</b>（Reliability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        成熟性（Maturity）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        容错性（Fault tolerance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易恢复性（Recoverability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>易使用性</b>（Usability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易理解性（Understandability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易学性（Learnability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易操作性（Operability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="3">
        <b>效率</b>（Efficiency）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        时间特性（Time behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        资源特性（Resource behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可维护性</b>（Maintainability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易分析性（Analyzability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易改变性（Changeability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        稳定性（Stability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易测试性（Testability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可移植性</b>（Portability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适应性（Adaptability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易安装性（Installability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        一致性（Conformance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易替换性（Replaceability）
    </td>
</tr>
</table>
<p>质量子特性的含义：</p>
<ul>
<li>功能性：
<ul>
<li><strong>适合性</strong>：与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。</li>
<li><strong>准确性</strong>：与能够得到正确或相符的结果或效果有关的软件属性。</li>
<li><strong>互用性</strong>：<u>与其他指定系统进行交互操作</u>的能力相关的软件属性。</li>
<li><strong>依从性</strong>：<u>使软件服从有关的标准、约定、法规及类似规定</u>的软件属性。</li>
<li><strong>安全性</strong>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li>
</ul>
</li>
<li>可靠性：
<ul>
<li><strong>成熟性</strong>：与由软件故障引起失效的频度有关的软件属性。</li>
<li><strong>容错性</strong>：与<u>在软件错误或违反指定接口的情况下维持指定的性能水平</u>的能力有关的软件属性。</li>
<li><strong>易恢复性</strong>：与<u>在故障发生后，重新建立其性能水平并恢复直接受影响数据</u>的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li>
</ul>
</li>
<li>易使用性：
<ul>
<li><strong>易理解性</strong>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li>
<li><strong>易学性</strong>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li>
<li><strong>易操作性</strong>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li>
</ul>
</li>
<li>效率：
<ul>
<li><strong>时间特性</strong>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li>
<li><strong>资源特性</strong>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li>
</ul>
</li>
<li>可维护性：
<ul>
<li><strong>易分析性</strong>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li>
<li><strong>易改变性</strong>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li>
<li><strong>稳定性</strong>：与修改造成未预料效果的风险有关的软件属性。</li>
<li><strong>易测试性</strong>：为确认经修改软件所需努力有关的软件属性。</li>
</ul>
</li>
<li>可移植性：
<ul>
<li><strong>适应性</strong>：与软件转移到不同环境时的处理或手段有关的软件属性。</li>
<li><strong>易安装性</strong>：与在指定环境下安装软件所需努力有关的软件属性。</li>
<li><strong>一致性</strong>：使软件服从与可移植性有关的标准或约定的软件属性。</li>
<li><strong>易替换性</strong>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="计算机网络" data-numberify>计算机网络<a class="anchor ms-1" href="#计算机网络"></a></h1>
<p>跳转连接：<a href="/p/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%af%87/">软件设计师——计算机网络篇</a></p>
<h2 id="网络分类" data-numberify>网络分类<a class="anchor ms-1" href="#网络分类"></a></h2>
<p>按通信距离分类：</p>
<table>
    <tr>
        <th style="text-align:center">
            网络分类
            </th>
        <th style="text-align:center">
            分布距离
        </th>
        <th style="text-align:center">
            计算机分布范围
        </th>
        <th style="text-align:center">
            传输速率
        </th>
    </tr>
    <tr>
        <td style="text-align:center" rowspan="4">
            <b>
                局域网
                <br>
                MAN
            </b>
        </td>
        <tr>
            <td>10m左右</td>
            <td>房间</td>
            <td rowspan="3">
                4Mbps ~ 1Gbps
            </td>
        </tr>
        <tr>
            <td>100m左右</td>
            <td>楼寓</td>
        </tr>
        <tr>
            <td>1000m左右</td>
            <td>校园</td>
        </tr>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                城域网
                <br>
                WAN
            </b>
        </td>
        <td>10km</td>
        <td>城市</td>
        <td>50Kbps ~ 100 Mbps</td>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                广域网
                <br>
                LAN
            </b>
        </td>
        <td>100km以上</td>
        <td>国家或全球</td>
        <td>9.6Kbps ~ 45Mbps</td>
    </tr>
</table>
<h2 id="isoosi-网络体系结构" data-numberify>ISO/OSI 网络体系结构<a class="anchor ms-1" href="#isoosi-网络体系结构"></a></h2>
<p><picture><img class="img-fluid " alt="OSI 参考模型" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875696461.png" loading="lazy" width="390" height="339" />
</picture>

</p>
<ul>
<li>通信子网对应于OSI中的低三层：
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ul>
</li>
<li>资源子网对应于OSI中的高三层：
<ul>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="ISO/OSI RM 内信息流动" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683877150679.png" loading="lazy" width="724" height="404" />
</picture>

</p>
<h2 id="网络的拓扑结构" data-numberify>网络的拓扑结构<a class="anchor ms-1" href="#网络的拓扑结构"></a></h2>
<ul>
<li>
<p>总线型结构：</p>
<p><picture><img class="img-fluid " alt="总线型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875429976.png" loading="lazy" width="223" height="139" />
</picture>

</p>
</li>
<li>
<p>星型结构：</p>
<p><picture><img class="img-fluid " alt="星型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875460651.png" loading="lazy" width="198" height="164" />
</picture>

</p>
</li>
<li>
<p>环型结构：</p>
<p><picture><img class="img-fluid " alt="环型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875485913.png" loading="lazy" width="166" height="157" />
</picture>

</p>
</li>
<li>
<p>树型结构：</p>
<p><picture><img class="img-fluid " alt="树型结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875508387.png" loading="lazy" width="184" height="141" />
</picture>

</p>
</li>
<li>
<p>分布式结构：</p>
<p><picture><img class="img-fluid " alt="分布式结构" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683875530047.png" loading="lazy" width="164" height="138" />
</picture>

</p>
</li>
</ul>
<h2 id="网络设备" data-numberify>网络设备<a class="anchor ms-1" href="#网络设备"></a></h2>
<p>按照ISO/OSI的分层将互连设备分类：</p>
<ul>
<li>
<p>物理层设备：</p>
<ul>
<li>中继器（Repeater）</li>
<li>集线器（Hub）：一种多端口的中继器。集线器不能自动寻址，但可以检测发送冲突。</li>
</ul>
</li>
<li>
<p>数据链路层设备：</p>
<ul>
<li>
<p>网桥（Bridge）</p>
</li>
<li>
<p>交换机（Switch）：一种多端口的网桥。</p>
<p>交换技术：</p>
<ul>
<li>端口交换</li>
<li>帧交换</li>
<li>信元交换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络层设备：路由器（Router）</p>
<p><picture><img class="img-fluid " alt="路由器类型" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683956321797.png" loading="lazy" width="554" height="235" />
</picture>

</p>
</li>
<li>
<p>应用层设备：网关（Gateway）</p>
</li>
</ul>
<h2 id="网络传输介质" data-numberify>网络传输介质<a class="anchor ms-1" href="#网络传输介质"></a></h2>
<ul>
<li>有线介质：
<ul>
<li>双绞线（Twisted-Pair）</li>
<li>同轴电缆（Coaxial）</li>
<li>光纤（Fiber Optic）</li>
</ul>
</li>
<li>无线介质：
<ul>
<li>微波</li>
<li>红外线和激光</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="lan-模型" data-numberify>LAN 模型<a class="anchor ms-1" href="#lan-模型"></a></h2>
<p><picture><img class="img-fluid " alt="LAN 层次与 ISO/OSI RM 的对应关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683879193227.png" loading="lazy" width="397" height="252" />
</picture>

</p>
<h2 id="以太网" data-numberify>以太网<a class="anchor ms-1" href="#以太网"></a></h2>
<ul>
<li>IEEE 802.3中定义的标准局域网，速度为10Mbps，传输介质为细同轴电缆；</li>
<li>IEEE 802.3u中定义的快速以太网，速度为100Mbps，传输介质为双绞线；</li>
<li>IEEE 802.3z中定义的千兆以太网，速度为1000Mbps，传输介质为光纤或双绞线。</li>
</ul>
<h2 id="tcpip-协议族" data-numberify>TCP/IP 协议族<a class="anchor ms-1" href="#tcpip-协议族"></a></h2>
<p>基本特性：</p>
<ul>
<li>逻辑编制：IP地址包括：
<ul>
<li>网络ID号：用来标识网络；</li>
<li>子网ID号：用来标识网络上的一个子网；</li>
<li>主机ID号：用来标识子网上的一台计算机。</li>
</ul>
</li>
<li>路由选择</li>
<li>域名（DNS）解析</li>
<li>错误检测</li>
<li>流量控制</li>
</ul>
<p>TCP/IP分层模型由4个层次构成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p><picture><img class="img-fluid " alt="TCP/IP 模型于 OSI 模型的对比" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683880948768.png" loading="lazy" width="697" height="339" />
</picture>

</p>
<ul>
<li>
<p>TCP（传输控制协议）：在IP提供的不可靠数据服务的基础上为应用程序提供了<u>可靠的、面向连接的、全双工的</u>数据传输服务。</p>
<p>采用三次握手来确认建立和关闭连接是否成功。</p>
</li>
<li>
<p>UDP（用户数据报协议）：一种<u>不可靠的、无连接的</u>协议，可以保证应用程序进程间的通信。</p>
</li>
</ul>
<h2 id="地址解析协议" data-numberify>地址解析协议<a class="anchor ms-1" href="#地址解析协议"></a></h2>
<ul>
<li>ARP（地址解析协议）：将IP地址转换为MAC地址（物理地址）。</li>
<li>RARP（反地址解析协议）：将MAC地址转换为IP地址。</li>
</ul>
<h2 id="动态主机配置协议-dhcp" data-numberify>动态主机配置协议 DHCP<a class="anchor ms-1" href="#动态主机配置协议-dhcp"></a></h2>
<p>DHCP客户端可以从DHCP服务器获得以下内容：</p>
<ul>
<li>本机IP地址</li>
<li>DNS服务器地址</li>
<li>DHCP服务器地址</li>
<li>默认网关的地址</li>
</ul>
<h2 id="无效地址" data-numberify>无效地址<a class="anchor ms-1" href="#无效地址"></a></h2>
<ul>
<li>
<p>Windows无效地址：169.254.X.X</p>
<p>169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。</p>
</li>
<li>
<p>Linux无效地址：0.0.0.0</p>
</li>
</ul>
<h2 id="域名和url" data-numberify>域名和URL<a class="anchor ms-1" href="#域名和url"></a></h2>
<pre tabindex="0"><code>主机名.本地名.组名.最高层域名
</code></pre><p>主机所在的网络级别较高：</p>
<pre tabindex="0"><code>本地名.组名.最高层域名
</code></pre><p>URL即统一资源定位器（统一资源定位符）：</p>
<pre tabindex="0"><code>协议名://主机名.域名.域名后缀.域名分类/目录/网页文件
</code></pre><h2 id="ip" data-numberify>IP<a class="anchor ms-1" href="#ip"></a></h2>
<p><strong>IPv4：</strong></p>
<p><picture><img class="img-fluid " alt="IPv4各类地址分配方案" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683896541328.png" loading="lazy" width="484" height="412" />
</picture>

</p>
<p>全<code>0</code>代表的是网络，全<code>1</code>代表的是广播。</p>
<p>IPv4能表示的地址个数为：</p>
<p>$$
2^{32} \approx 40亿
$$</p>
<p><picture><img class="img-fluid " alt="IP地址类默认的子网掩码" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%E7%AF%87/uTools_1683897195900.png" loading="lazy" width="912" height="144" />
</picture>

</p>
<p>**IPv6：**长达128位的地址空间，彻底解决IPv4地址不足的问题。</p>
<p>IPv6理论上能表示的地址个数：</p>
<p>$$
2^{128} = 3.4 \times 10^{38}
$$</p>
<h2 id="防火墙技术" data-numberify>防火墙技术<a class="anchor ms-1" href="#防火墙技术"></a></h2>
<p>防火墙技术是<u>建立在内外网络边界上的过滤封锁机制</u>，它认为：</p>
<ul>
<li><u>内部网络是安全和可信赖的</u>；</li>
<li><u>外部网络是不安全和不可信赖的</u>。</li>
</ul>
<p>防火墙的作用：<u>防止不希望的、未经授权地进出被保护的内部网络。</u></p>
<p>防火墙技术经历了三个发展阶段：</p>
<ol>
<li>包过滤防火墙</li>
<li>应用代理网关防火墙</li>
<li>状态检测技术防火墙</li>
</ol>
<h2 id="入侵检测" data-numberify>入侵检测<a class="anchor ms-1" href="#入侵检测"></a></h2>
<p>入侵检测系统（DS）作为防火墙之后的第二道安全屏障。</p>
<p>入侵检测系统有效的弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足。</p>
<p>入侵防御系统（IPS）是在入侵检测系统的基础上发展起来的，不仅能检测到网络中的攻击行为，同时主动对攻击行为发出响应，对攻击进行防御。</p>
<h2 id="网络攻击" data-numberify>网络攻击<a class="anchor ms-1" href="#网络攻击"></a></h2>
<p>攻击目标对于攻击者是个黑盒子。</p>
<p>网络攻击手段有：</p>
<ul>
<li>拒绝服务攻击（Dos攻击）：使计算机或网络无法提供正常的服务通过不断向计算机发起请求来实现的。</li>
<li>重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的。</li>
<li>口令入侵攻击。</li>
<li>特洛伊木马。</li>
<li>端口欺骗攻击。</li>
<li>网络监听。</li>
<li>IP欺骗攻击。</li>
<li>SQL注入攻击。</li>
</ul>
<h2 id="病毒" data-numberify>病毒<a class="anchor ms-1" href="#病毒"></a></h2>
<p>病毒类型：</p>
<ul>
<li>
<p>Worm（蠕虫病毒）：</p>
<ul>
<li>欢乐时光，</li>
<li>熊猫烧香，</li>
<li>红色代码，</li>
<li>爱虫病毒，</li>
<li>震网。</li>
</ul>
</li>
<li>
<p>Trojan（特洛伊木马）：通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息。</p>
<p>计算机感染特洛伊木马后的典型线型是<u>有未知程序试图建立网络连接</u>。</p>
<p>常见的木马如冰河。</p>
</li>
<li>
<p>Backdoor（后门病毒）。</p>
</li>
<li>
<p>Macro（宏病毒）：</p>
<p>宏病毒感染的对象主要是<u>文本文档</u>、<u>电子表格</u>等。</p>
</li>
</ul>
<hr>
<h1 id="算法设计与分析" data-numberify>算法设计与分析<a class="anchor ms-1" href="#算法设计与分析"></a></h1>
<p>跳转连接：<a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/">软件设计师——算法设计与分析篇</a></p>
<h2 id="算法设计方法" data-numberify>算法设计方法<a class="anchor ms-1" href="#算法设计方法"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法设计方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治法</td>
<td style="text-align:left"><ol><li>将原问题<strong>分解</strong>成多个<u>与原问题相同的子问题</u></li><li><strong>递归地求解</strong>各子问题</li><li>将子问题的解<strong>合并</strong>成原问题的解</li></ol></td>
<td style="text-align:left">原问题规模大且能分解为多个与原问题相同的子问题</td>
<td style="text-align:left"><ul><li>归并排序</li><li>快速排序</li><li>最大字段和问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">动态规划法</td>
<td style="text-align:left"><ol><li>找出并刻画最优解的结构特征</li><li>递归地定义最优解的值</li><li>自底向上方式计算最优值或构造最优解</li></ol></td>
<td style="text-align:left">求解具有某种最优性质的问题</td>
<td style="text-align:left"><ul><li>0-1 背包问题</li><li>矩阵连乘</li><li>最长公共序列（LCS）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">贪心法</td>
<td style="text-align:left">与动态规划类似，但贪心法考虑的是局部最优解</td>
<td style="text-align:left">并不保证得到全局最优解，但通常能得到近似最优解</td>
<td style="text-align:left"><ul><li>活动选择问题</li><li>背包问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">回溯法</td>
<td style="text-align:left">在解空间树中，按<u>深度优先策略</u>，从根结点出发搜索解空间树</td>
<td style="text-align:left"><ul><li>可以搜索问题的所有解或任一解</li><li>适用于求解组合数较大的问题</li><li>通过限界函数减少问题的搜索空间</li></ul></td>
<td style="text-align:left"><ul><li>0-1背包问题</li><li>n皇后问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">分支限界法</td>
<td style="text-align:left">与回溯法类似，在解空间树种按<u>广度优先</u>或<u>最小耗费</u>优先方式，搜索满足约束条件的一个解</td>
<td style="text-align:left"><ul><li>可以给出<u>在某种意义下的最优解</u></li><li>分为队列式和优先队列式，优先队列式通过最大堆或最小堆实现</li></u></ul></td>
<td style="text-align:left"><ul><li>0-1 背包问题</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="算法实例" data-numberify>算法实例<a class="anchor ms-1" href="#算法实例"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e7%ae%97%e6%b3%95%e5%ae%9e%e4%be%8b">算法设计与分析篇——算法实例</a></p>
<h2 id="查找算法" data-numberify>查找算法<a class="anchor ms-1" href="#查找算法"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">算法设计与分析篇——查找算法</a></p>
<p>查找算法在查找成功时的<u>平均查找长度</u>关键字和给定值比较次数的期望值：</p>
<p>$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$</p>
<ul>
<li>
<p>$P_i$为对表中第$i$个记录进行查找的概率，</p>
<p>一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；</p>
</li>
<li>
<p>$C_i$为查找成功时，已经进行过比较的关键字个数。</p>
</li>
</ul>
<p>静态查找表有以下查找方法：</p>
<ul>
<li>顺序查找；</li>
<li>折半查找；</li>
<li>分块查找。</li>
</ul>
<p>动态查找表有以下查找方法：</p>
<ul>
<li>二叉排序树；</li>
<li>平衡排序树；</li>
<li>B-树；</li>
<li>哈希表。</li>
</ul>
<p><strong>顺序查找</strong>中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：</p>
<p>$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<p><strong>折半查找</strong>的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：</p>
<p>$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$</p>
<p>当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。</p>
<h2 id="哈希函数" data-numberify>哈希函数<a class="anchor ms-1" href="#哈希函数"></a></h2>
<p><strong>哈希函数构造方法</strong>：</p>
<ul>
<li>直接定址法；</li>
<li>数字分析法；</li>
<li>平方取中法；</li>
<li>折叠法；</li>
<li>随机数法；</li>
<li>除留余数法</li>
</ul>
<p>哈希函数的构造要考虑到：</p>
<ul>
<li>压缩性：节省存储空间；</li>
<li>散列性：尽量减少冲突。</li>
</ul>
<p><strong>除留取余数法：</strong></p>
<p>$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$</p>
<p><strong>冲突处理方法：</strong></p>
<ul>
<li>开放地址法；</li>
<li>多重散列法（再哈希法）；</li>
<li>链地址法；</li>
<li>公共溢出区法……</li>
</ul>
<p><strong>开放地址法</strong>（三种寻找空散列地址的方法）：</p>
<ul>
<li>
<p>线性探测法（线性探测再散列）：</p>
<p>$$
H_i=(H(key)+d) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$d$取$0,1,2,&hellip;,m-1$；</li>
<li>$m$为散列表的长度。</li>
</ul>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
</li>
<li>
<p>二次探测法（二次探测再散列）：</p>
<p>$$
H_i=(H(key)+q^2) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$q$取$0,1,-1,2,-2,&hellip;,\pm k$，$k \le \cfrac{m}{2}$</li>
<li>$m$为散列表的长度</li>
</ul>
</li>
</ul>
<h2 id="排序算法" data-numberify>排序算法<a class="anchor ms-1" href="#排序算法"></a></h2>
<p><a href="/p/%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90%e7%af%87/#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">算法设计与分析篇——排序算法</a></p>
<p>排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$值相同，且$R_i$领先于$R_j$，排序后：</p>
<ul>
<li><strong>稳定排序</strong>：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；</li>
<li><strong>不稳定排序</strong>：排序后可能出现$R_j$领先于$R_i$的情况。</li>
</ul>
<p>根据记录存储的位置可分为：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存储在内存中进行排序的过程。</li>
<li><strong>外部排序</strong>：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">是否归位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(log_2{n})$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>是否归位：在排序过程中，能否确定某些元素的最终排序位置。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>软考图类汇总篇</title>
      <link>/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/</link>
      <pubDate>Sat, 20 May 2023 13:29:14 +0800</pubDate>
      
      <guid>/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/</guid>
      <description><![CDATA[数据流图（DFD） 数据流图是在逻辑上描述系统的功能、输入、输出和数据存储等。 数据流图中的基本图形元素包括： 基本元素 图形表示 数据流 加工 数据存储]]></description>
      <content:encoded><![CDATA[<h1 id="数据流图dfd" data-numberify>数据流图（DFD）<a class="anchor ms-1" href="#数据流图dfd"></a></h1>
<p>数据流图是在逻辑上描述系统的功能、输入、输出和数据存储等。</p>
<p>数据流图中的基本图形元素包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本元素</th>
<th style="text-align:center">图形表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据流</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据流" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">加工</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="加工" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">数据存储</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据存储" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">外部实体</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="外部实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>软件系统内部的<strong>数据处理模型</strong>，使用<u>数据流</u>、<u>加工</u>和<u>数据存储</u>构建。</p>
<ul>
<li>
<p><strong>数据流</strong>（Data Flow）：由一组固定成分的数据组成，表示数据的流向。</p>
<p><picture><img class="img-fluid " alt="数据流" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</p>
<p>在DFD种，数据流的流向由以下几种：</p>
<ul>
<li>从<u>加工</u>流向另一个<u>加工</u>；</li>
<li>从<u>加工</u>流向<u>数据存储</u>（写）；</li>
<li>从<u>数据存储</u>流向<u>加工</u>（读）；</li>
<li>从<u>外部实体</u>流向<u>加工</u>（输入）；</li>
<li>从<u>加工</u>流向<u>外部实体</u>（输出）。</li>
</ul>
<p>即数据流的<u>起点或终点必须至少有一个是加工</u>。</p>
<p>除了与数据存储有关的数据流（流向数据存储或从数据存储流出），DFD中的每个数据流都必须用一个定义明确的名字表示。</p>
</li>
<li>
<p><strong>加工</strong>（Process）：加工描述了输入数据流到输出数据流之间的变换，也就是<u>输入数据流经过什么处理后变成了输出数据流</u>。</p>
<p><picture><img class="img-fluid " alt="加工" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</p>
<p>每个加工都有一个名字和编号。</p>
<p>一个加工可以有多个输入数据流和多个输出数据流，但<u>至少有一个输入数据流和一个输出数据流</u>。</p>
<p>数据流图中常见的3种错误如下所示：</p>
<ul>
<li>
<p><strong>黑洞</strong>：加工只有输入，没有输出。</p>
<p>如下图加工1。</p>
</li>
<li>
<p><strong>白洞</strong>：加工只有输出但没有输入。</p>
<p>如下图加工2。</p>
</li>
<li>
<p><strong>灰洞</strong>：加工中输入数据不足以产生输出数据。</p>
<p>有几种可能的原因：</p>
<ul>
<li>一个错误的命名过程；</li>
<li>错误命名的输入或输出；</li>
<li>不完全的事实。</li>
</ul>
<p>如下图加工3。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="数据流图中常见错误" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1683528176745.png" loading="lazy" width="793" height="542" />
</picture>

</p>
</li>
<li>
<p><strong>数据存储</strong>（Data Store）：存储和提供数据。</p>
<p><picture><img class="img-fluid " alt="数据存储" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</p>
<p>每个数据存储都有一个定义明确的名字标识。</p>
<p>数据存储可以：</p>
<ul>
<li>存储加工的输出数据：数据流流入数据存储，表示数据的写入操作；</li>
<li>提供加工的输入数据：数据流从数据存储流出，表示数据的读操作。</li>
<li>双向箭头的数据流指向数据存储，表示对数据的修改。</li>
</ul>
<p>DFD中的数据存储在具体实现时可以用以下方式实现：</p>
<ul>
<li>文件系统实现；</li>
<li>数据库系统实现。</li>
</ul>
<p>数据存储的存储介质可以是：</p>
<ul>
<li>磁盘、</li>
<li>磁带、</li>
<li>其他存储介质。</li>
</ul>
</li>
<li>
<p><strong>外部实体</strong>（External Agent，外部主体）：指<u>存在于软件系统之外的人员、组织、物体或外部系统</u>，它指出系统所需数据的<u>发源地（源）</u>和<u>系统所产生的数据的归宿地（宿）</u>。</p>
<p><picture><img class="img-fluid " alt="外部实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</p>
<p>例如：</p>
<ul>
<li>人员：学生、老师、员工、主观、医生、客户……</li>
<li>组织：供应商、采购部门……</li>
<li>物体：传感器、控制器、单车、车辆……</li>
<li>外部系统：支付系统、车辆交易系统、库存管理系统、道闸控制系统……</li>
</ul>
<p>在许多系统中，某个源和某个宿可以是同一个人员、组织、物体或外部系统，此时，在DFD中可以用同一个符号表示：</p>
<ul>
<li>当数据流从该符号流出时，表示它是源；</li>
<li>当数据流流向该符号时，表示它是宿；</li>
<li>当两者皆有时，表示它既是源又是宿。</li>
</ul>
<p>外部实体表示存在于系统之外的对象，用来帮助用户理解系统数据的来源和去向。</p>
</li>
</ul>
<p>数据流图必须确保：</p>
<ul>
<li>数据流的起点或终点必须至少有一个是加工。</li>
<li>加工至少有一个输入数据流和一个输出数据流。</li>
</ul>
<p>分层数据流图：</p>
<ol>
<li>
<p>顶层图：描述系统的输入和输出。</p>
<p>即描述系统从哪些外部实体接受数据流，以及系统发送数据流到哪些外部实体。</p>
<ul>
<li>顶层图只有一个加工，即待开发的软件系统。</li>
<li>顶层图中的数据流就是系统的输入/输出信息。</li>
<li>顶层图中通常没有数据存储。</li>
</ul>
</li>
<li>
<p>0层图：分解顶层图的加工。</p>
</li>
<li>
<p>再分解：将DFD中某些比较复杂的加工再次分解成一张DFD子图。</p>
</li>
</ol>
<hr>
<h1 id="实体联系图e-r-图erd" data-numberify>实体联系图（E-R 图，ERD）<a class="anchor ms-1" href="#实体联系图e-r-图erd"></a></h1>
<p>E-R图有以下几个成分（包含扩充的E-R模型成分）：</p>
<p><picture><img class="img-fluid " alt="E-R图中的主要构件" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682508598814.png" loading="lazy" width="1035" height="391" />
</picture>

</p>
<ul>
<li>
<p><strong>实体</strong>：用<strong>矩形</strong>表示。</p>
<ul>
<li>
<p><strong>弱实体</strong>：使用<strong>双线矩形框</strong>表示。将需要依赖其他实体存在的实体。</p>
<p>实体间的所有（Ownership，拥有）关系代表一个实体对另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提。</p>
<p>例如职工与家属的联系，家属总是属于某职工的（在关系模式中需要依赖职工而存在），所以家属是弱实体。</p>
</li>
<li>
<p><strong>特殊化</strong>：将一个实体集<u>按照某些特性区分为几个<strong>子实体</strong></u>。这种从普遍到特殊的过程即为特殊化。</p>
<p>子实体的图形表示如下：</p>
<p><picture><img class="img-fluid " alt="子实体" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684564987147.png" loading="lazy" width="256" height="145" />
</picture>

</p>
<p>子实体由称为子类，它会有一个超类，并且能继承超类的属性，超类的属性是实体集中所有子实体的相同属性。</p>
</li>
</ul>
</li>
<li>
<p><strong>联系</strong>：用<strong>棱形</strong>表示，并用无向边分别与有关实体连接起来，同时在无向边标注联系的类型。</p>
<p>联系的类型有两种：</p>
<ul>
<li>
<p>两个实体间的联系：</p>
<ul>
<li>$1:1$：一对一联系；</li>
<li>$1:n$：一对多联系；</li>
<li>$m:n$：多对多联系。</li>
</ul>
</li>
<li>
<p>两个以上实体间的联系：</p>
<p>例如3个实体间的联系有：</p>
<ul>
<li>$1:1:1$</li>
<li>$1:1:n$</li>
<li>$1ⓜ️n$</li>
<li>$rⓜ️n$</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>属性</strong>：用<strong>椭圆形</strong>表示，并用无向边将其与相应的实体连接起来</p>
<p>E-R模型中的属性有以下分类：</p>
<ul>
<li>简单属性：是原子的、不可再分的。</li>
<li>复合属性：可以细分为更小的部分。</li>
<li>单值属性：一个属性对应一个值。</li>
<li>多值属性：一个属性对应一组值。</li>
<li>NULL属性：实体在某个属性上没有值或属性值未知时，使用NULL值表示。</li>
<li>派生属性：派生属性可以从其他属性得来（通过运算等方式求出）。</li>
</ul>
</li>
</ul>
<h2 id="概念结构模型合并分-e-r-图" data-numberify>概念结构模型（合并分 E-R 图）<a class="anchor ms-1" href="#概念结构模型合并分-e-r-图"></a></h2>
<p>建立概念结构模型的步骤如下：</p>
<ol>
<li>
<p>选择局部应用：选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能。</p>
</li>
<li>
<p>逐一设计分E-R图。</p>
</li>
<li>
<p>E-R图合并：</p>
<p>合并时需要考虑各分E-R图之间的冲突：</p>
<ul>
<li><strong>属性冲突</strong>：同一属性在不同的分E-R图上的属性类型、取值范围和数据单位等可能会不一致。</li>
<li><strong>命名冲突</strong>：相同意义的属性在不同的分E-R图上可能会有不同的命名。</li>
<li><strong>结构冲突</strong>：同一实体在不同的分E-R图中可能会有不同的属性；同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又可能被抽象为属性，反之亦然。</li>
</ul>
</li>
</ol>
<h2 id="转换关系模式" data-numberify>转换关系模式<a class="anchor ms-1" href="#转换关系模式"></a></h2>
<ol>
<li>
<p>实体向关系模式的转换：</p>
<p>将E-R图中的实体逐一转换成为一个关系模式：</p>
<ul>
<li>实体名：对应关系模式的名称；</li>
<li>实体的属性：转换成关系模式的属性；</li>
<li>实体标识符：关系的码（键）。</li>
</ul>
<p>超类和子类的转换：超类和子类定义为两个关系模式，将超类的主键加到子类中。</p>
</li>
<li>
<p>联系向关系模式的转换：</p>
<ul>
<li>
<p>一对一联系的转换：</p>
<p>有两种方式：</p>
<ul>
<li>
<p>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码。</p>
<p>那么一个一对一联系需要转换成三个关系模式。</p>
</li>
<li>
<p>方式2（一般使用该方式）：将联系归并到关联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体码保持不变。</p>
<p>一个一对一联系仅需转换成两个关系模式。</p>
</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="联系向关系模式的转换示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682562445900.png" loading="lazy" width="304" height="358" />
</picture>

</p>
<ul>
<li>
<p>方式1：</p>
<p>厂长（<strong>姓名</strong>，性别，年龄）</p>
<p>工厂（<strong>厂号</strong>，厂名，地点）</p>
<p>管理（（厂长）<strong>姓名</strong>，厂号，任期）</p>
<blockquote>
<p>粗体代表该关系模式的码。管理的码可以为姓名或厂号。</p>
</blockquote>
</li>
<li>
<p>方式2：</p>
<p>厂长（姓名，性别，年龄）</p>
<p>工厂（厂号，厂名，地点，（厂长）姓名，任期）</p>
</li>
</ul>
</li>
<li>
<p>一对多联系的转换：</p>
<p>两种方式：</p>
<ul>
<li>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，<u>关系的码是多方实体的码</u>；</li>
<li>方式2（一般使用该方式）：将联系<u>归并到关联的两个实体的多方</u>，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变。</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="一对多联系转换的例子" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682563544291.png" loading="lazy" width="315" height="361" />
</picture>

</p>
<ul>
<li>
<p>方式1:</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格）</p>
<p>仓储（<strong>货号</strong>，仓库号，数量）</p>
</li>
<li>
<p>方式2：</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格，仓库号，数量）</p>
</li>
</ul>
</li>
<li>
<p>多对多联系的转换：</p>
<p>多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。</p>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="多对多联系转换的示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682564018777.png" loading="lazy" width="327" height="373" />
</picture>

</p>
<p>转换成：</p>
<p>学生（<strong>学号</strong>，姓名，性别，年龄）</p>
<p>课程（<strong>课程号</strong>，课程名，学时）</p>
<p>选修（<strong>（学号，课程号）</strong>，成绩）</p>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="uml" data-numberify>UML<a class="anchor ms-1" href="#uml"></a></h1>
<p>UML（Unified Modeling Language，统一建模语言）是面向对象软件的标准化建模语言。</p>
<p>UML中包含3种基本构造块：</p>
<ul>
<li>事物；</li>
<li>关系；</li>
<li>图。</li>
</ul>
<h2 id="事物" data-numberify>事物<a class="anchor ms-1" href="#事物"></a></h2>
<p>UML中有4种事物：</p>
<ul>
<li>
<p><strong>结构事物</strong>（Structural Thing）：模型的<u>静态部分</u>。</p>
<p><picture><img class="img-fluid " alt="结构事物的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682055522161.png" loading="lazy" width="708" height="294" />
</picture>

</p>
</li>
<li>
<p><strong>行为事物</strong>（Behavior Thing）：模型的<u>动态部分</u>。</p>
<p><picture><img class="img-fluid " alt="行为事物的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682055712246.png" loading="lazy" width="621" height="133" />
</picture>

</p>
</li>
<li>
<p>分组事物（Grouping Thing）：模型的<u>组织部分</u>。</p>
</li>
<li>
<p>注释事物（Annotational Thing）：模型的<u>解释部分</u>。</p>
</li>
</ul>
<h2 id="关系" data-numberify>关系<a class="anchor ms-1" href="#关系"></a></h2>
<p>UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：</p>
<ul>
<li>
<p><strong>依赖</strong>（Dependency）：是<u>两个事物间的语义关系，其中一个事物（<strong>独立事物</strong>）发生变化会影响另一个事物（<strong>依赖事物</strong>）的语义</u>。</p>
<p>在图形上，把一个依赖画成一条<u>可能有方向的虚线</u>，如图：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p>依赖有偶然性和临时性，即需要的时候依赖，不需要的时候不依赖。</p>
</li>
<li>
<p><strong>关联</strong>（Association）：是一种<u>结构关系</u>，它描述了一组链，<u>链是对象之间的连接</u>。</p>
<p>关联使用<u>实线</u>表示，在关联上可以标注重复度（Multiplicity）和角色（Role）。</p>
<p>描述了<u>整体和部分</u>间的结构关系的特殊类型的关联：</p>
<ul>
<li>
<p><strong>聚集</strong>（Aggregation，聚合）：<u>部分和整体的生命周期不一致</u>，整体消失了，部分仍然存在，<u>部分可以脱离整体存在</u>。</p>
<p>使用一端带<u>空心菱形</u>的实线表示。</p>
</li>
<li>
<p><strong>组合</strong>：<u>部分和整体的生命周期一致</u>，整体消失了，部分也消失了，<u>部分不可以脱离整体而存在</u>。</p>
<p>使用一端带<u>实心菱形</u>的实线表示。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="关联和聚集的图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<blockquote>
<p>聚合和组合中，带菱形的一端指向整体，另一端指向部分。</p>
<p>关联的关系强度比依赖的关系强度要强一点。</p>
</blockquote>
<ul>
<li>
<p>单向关联：用<u>带箭头实线</u>表示。</p>
</li>
<li>
<p>多重度：</p>
<p>进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示<u>关联中的数量关系</u>，即多重度。表示数量关系时，<u>用多重度说明数量或数量范围</u>，<u>表示有多少个实例（对象）能被连接起来</u>，即<u>一个类的实例能够与另一个类的多少个实例相关联</u>。</p>
</li>
<li>
<p>关联类：</p>
<p>当两个类之间的关联的重复度是多对多时，需要借助额外的属性来帮助表达它们之间的关系，而这个属性就需要定义在一个新的关联类中。关联类记录了这两个类之间的关联信息。关联中这些额外的属性用一条<u>垂直于关联的实线</u>表示，实线的一段连接接到关联的实线上，另一端指向这些属性。</p>
</li>
</ul>
</li>
<li>
<p><strong>泛化</strong>（Generalization）：是一种特殊/一般关系，<u>特殊元素（子元素）的对象可替代一般元素（父元素）的对象</u>。用这种方法，<u>子元素共享了父元素的结构和行为</u>。</p>
<p>在图形上，把一个泛化关系画成一条<u>带有空心箭头的实线</u>，它指向父元素：</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
<li>
<p><strong>实现</strong>（Realization）：是<u>类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约</u>。</p>
<p>在图形上，把一个实现关系画成一条<u>带有空心箭头的虚线</u>，箭头指向模板类，另一端于实现类连接。</p>
<p><picture><img class="img-fluid " alt="实现的图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682058026631.png" loading="lazy" width="167" height="61" />
</picture>

</p>
</li>
</ul>
<h2 id="uml图" data-numberify>UML图<a class="anchor ms-1" href="#uml图"></a></h2>
<h3 id="类图" data-numberify>类图<a class="anchor ms-1" href="#类图"></a></h3>
<p>类图（Class Diagram）<u>展现了一组对象、接口、协作和它们之间的关系</u>。在面向对象系统的建模中<u>最常见的图就是类图</u>。类图给出<u>系统的静态设计视图</u>。</p>
<p>类图中通常包括下述内容：</p>
<ul>
<li>
<p>类：</p>
<p><picture><img class="img-fluid " alt="类的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684650129674.png" loading="lazy" width="142" height="139" />
</picture>

</p>
<p>类中的方法和属性前面有以下三种修饰符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>public</code> 公有的</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>private</code> 私有的</td>
</tr>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:center"><code>protected</code> 受保护的</td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>package</code> 包的</td>
</tr>
</tbody>
</table>
<p>例如：</p>
  <table style="width: 200px; margin: auto;">
      <tr><th>Student</th></tr>
      <tr>
      <td>
      <p>
          <code>- id&nbsp;&nbsp;&nbsp;:&nbsp;int</code>
          <br>
          <code>+ name&nbsp;:&nbsp;String</code>
          <br>
          <code>+ age&nbsp;&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
      <tr>
      <td>
      <p>
          <code>+ getId()&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
  </table>
</li>
<li>
<p>接口：</p>
<p><picture><img class="img-fluid " alt="接口的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</p>
</li>
<li>
<p>协作：</p>
<p><picture><img class="img-fluid " alt="协作的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</p>
</li>
<li>
<p>关系：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="关联图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
<h3 id="对象图" data-numberify>对象图<a class="anchor ms-1" href="#对象图"></a></h3>
<p>对象图（Object Diagram）展现了<u>某一时刻一组对象以及它们之间的关系</u>，<u>描述了在类图中所建立的事物的实例的静态快照</u>。</p>
<p>对象图一般包括对象和链，如图：</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
<p>对象：对象图中的对象包含了类名、对象名和属性。</p>
<p>其图形化如下：</p>
<table style="width: 150px; text-align: center;">
    <tr>
    <th style="text-align: center;">
        对象名 : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>匿名对象（没有对象名）：</p>
<table style="width: 150px;">
    <tr>
    <th style="text-align: center;">
        : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>和类图一样，对象图给出<u>系统的静态设计视图</u>或<u>静态进程视图</u>，但它们是<u>从真实的或原型实例的角度建立的</u>。</p>
<h3 id="用例图" data-numberify>用例图<a class="anchor ms-1" href="#用例图"></a></h3>
<p>用例图（Use Case Diagram）通常包括以下内容：</p>
<ul>
<li>
<p>用例：是从<strong>用户角度</strong>描述<strong>系统的行为</strong>，它将<strong>系统的一个功能</strong>描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。</p>
<p>用例是一个类，它代表<strong>一类功能</strong>而不是使用该功能的某一具体实例。</p>
<p><picture><img class="img-fluid " alt="用例的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</p>
</li>
<li>
<p>参与者：是与系统交互的<strong>外部实体</strong>。</p>
<p>参与者用一个<u>人形图标</u>表示。</p>
</li>
<li>
<p>关系：</p>
<ul>
<li>
<p>用例之间的关系：</p>
<ul>
<li>
<p>包含关系：用带<code>&lt;&lt;include&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</p>
</li>
<li>
<p>扩展关系：用带<code>&lt;&lt;extend&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="扩展关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</p>
<p>扩展用例是指，一个用例中，符合某些特定情况才会触发的另一个用例。</p>
<p>即一个用例执行的时候，可能会发生一些特殊情况或可选情况，这种情况就是这个用例的扩展用例。</p>
</li>
</ul>
</li>
<li>
<p>参与者和用例之间的关联关系。</p>
</li>
<li>
<p>用例与用例以及参与者与参与者之间的泛化关系。</p>
</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
<h3 id="序列图" data-numberify>序列图<a class="anchor ms-1" href="#序列图"></a></h3>
<p>序列图（Sequence Diagram，<strong>顺序图</strong>）<u>描述了以时间顺序组织的对象之间的交互活动</u>，<u>强调消息时间顺序</u>。</p>
<p>序列图的组成：</p>
<ol>
<li>
<p>把参加交互的对象放在图的上方，沿水平方向排列。</p>
<p>通常把发起交互的对象放在左边，下级对象依次放在右边。</p>
</li>
<li>
<p>把这些对象发送和接收的消息，沿垂直方向，按时间顺序从上到下放置。</p>
</li>
</ol>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
<p>序列图的组成部分：</p>
<ul>
<li>
<p>对象：用方框框起来的<code>对象名:类名</code>，没有属性和方法等成分。</p>
</li>
<li>
<p><strong>对象生命线</strong>：表示<u>一个对象存在的时间段</u>。</p>
<p>如上图中对象下方垂直的虚线。</p>
<ul>
<li>对象可以在交互过程中创建：生命线从接收到构造型<code>create</code>消息开始；</li>
<li>也可以在交互过程中撤销：生命线从接收到构造型<code>destroy</code>消息结束，并且给出一个大$\times$的标记表明生命线的结束。</li>
</ul>
</li>
<li>
<p><strong>控制焦点</strong>：控制焦点表示<u>一个对象执行一个动作所经历的时间段</u>。</p>
<p>如上图中对象下方的空表矩形条框。</p>
</li>
<li>
<p><strong>消息</strong>：</p>
<p>普通的消息用<u>带箭头的实线</u>表示。所有消息的箭头都是指向接收对象。</p>
<ul>
<li>返回消息：用<u>带箭头的虚线</u>表示。</li>
<li>同步消息（调用消息）：指消息发送给接收对象后，需要等待接收对象返回后才可进行下一步操作。</li>
<li>异步消息：指消息发送给接收对象后，无需等待接收对象返回即可进行下一步操作。</li>
</ul>
</li>
</ul>
<p>序列图有两个不同于通信图的特性：</p>
<ul>
<li>序列图有对象生命线；</li>
<li>序列图有控制焦点。</li>
</ul>
<h3 id="通信图" data-numberify>通信图<a class="anchor ms-1" href="#通信图"></a></h3>
<p><u>通信图</u>（Communication Diagram，<strong>协作图</strong>）<u>强调收发消息的对象的结构组织</u>。通信图<u>强调参加交互的对象的组织</u>。</p>
<p>通信图的组成：</p>
<ol>
<li>将参加交互的<u>对象</u>作为图的<u>顶点</u>；</li>
<li>把连接这些对象的<u>链</u>表示为图的<u>弧</u>；</li>
<li>用对象发送和接收的<u>消息</u>来<u>修饰这些链</u>。</li>
</ol>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
<p>通信图有以下成分：</p>
<ul>
<li>
<p>对象：与序列图一样，是用一个方框框起来的<code>对象名:类名</code>。</p>
</li>
<li>
<p>路径（链接）：用实线表示，可以在链的末端附上一个路径构造型。</p>
<p>通常仅需显式地表示以下几种链的路径：</p>
<table>
<thead>
<tr>
<th style="text-align:center">构造型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;local&gt;&gt;</code></td>
<td style="text-align:center">局部</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;parameter&gt;&gt;</code></td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;global&gt;&gt;</code></td>
<td style="text-align:center">全局</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;self&gt;&gt;</code></td>
<td style="text-align:center">自身</td>
</tr>
</tbody>
</table>
<p>不必表示<code>association</code>（关联）。</p>
</li>
<li>
<p>序号：用来表示消息的时间顺序。是消息前的一个数字前缀，可使用带小数点的号码表示嵌套消息，嵌套可为任意深度。</p>
<p>如2表示第2个消息，2.1表示嵌套在消息2中的第1个消息。</p>
</li>
<li>
<p>消息：沿同一个链可以显示许多消息（可能发自不同方向），并且每个消息都有唯一的序号。</p>
</li>
</ul>
<p>通信图有两个不同于序列图的特性：</p>
<ul>
<li>通信图有路径；</li>
<li>通信图有序号。</li>
</ul>
<h3 id="状态图" data-numberify>状态图<a class="anchor ms-1" href="#状态图"></a></h3>
<p>状态图（State Diagram，状态转换图）关注<u>系统的动态视图</u>，<u>强调对象行为的事件顺序</u>。</p>
<p>状态图由以下组成：</p>
<ul>
<li>
<p><strong>状态</strong>：指对象的生命周期中某个条件或者状态，是<u>任何可以被观察到的系统行为模式</u>，<u>一个状态代表系统的一种行为模式</u>。</p>
<p>状态规定了系统内对事件的响应方式。</p>
<p>系统对事件的响应：</p>
<ul>
<li>可以是<u>做一个（或一系列）动作</u>；</li>
<li>可以是仅仅<u>改变系统本身的状态</u>；</li>
<li>可以是<u>即改变状态，又做动作</u>。</li>
</ul>
<p>状态转换图中定义的状态主要有：</p>
<ul>
<li><strong>初态</strong>（初始状态）：用一个<u>实心圆点</u>表示。一张状态图<u>只能有一个初态</u>。</li>
<li><strong>终态</strong>（最终状态）：用一个<u>实心圆点外加一个圆圈</u>表示。一张状态图<u>可以没有终态，也可以有多个</u>。</li>
<li><strong>中间状态</strong>。</li>
</ul>
<p>状态图中的状态用一个<u>圆角矩形</u>表示，可以用两条水平横线将其分为上中下3个部分：</p>
<ol>
<li>上面部分（必须）：状态的名称；</li>
<li>中间部分（可选）：状态变量的名称和值；</li>
<li>下面部分（可选）：活动表。</li>
</ol>
<p>状态还可分为：</p>
<ul>
<li>
<p>简单状态。</p>
</li>
<li>
<p>组合状态：含有子状态的状态，这个状态也称为其子状态的超状态。</p>
<p>子状态：嵌套在另外一个状态中的状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>转换</strong>（迁移）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生，而且某个特定的警界（监护）条件满足时进入目标状态。</p>
<p>状态转换用一条<u>带箭头的实线</u>表示。</p>
</li>
<li>
<p><strong>事件</strong>：是在某个特定时刻发生的事情，<u>它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象</u>。</p>
<ul>
<li>
<p><u>事件触发</u>状态转换：<u>状态变迁通常是由事件触发的。</u>状态之间带箭头实线上的事件发生时，状态转换开始（还可称之为状态“点火”或状态被“触发”）。</p>
<p>这种情况下应在表达状态转换的箭头线上标出触发转换的<u>事件表达式</u>：</p>
<pre tabindex="0"><code>事件说明 [守卫条件] / 动作表达式
</code></pre><p>事件说明的语法为：</p>
<pre tabindex="0"><code>事件名 (参数表)
</code></pre><p>守卫条件（监护条件）：一个布尔表达式。</p>
<ul>
<li>当且仅当事件发生且守卫条件为真时，状态转换才发生；</li>
<li>只有守卫条件没有事件说明时，只要守卫条件为真，状态转换就发生。</li>
</ul>
<p>动作表达式是一个过程表达式，当状态转换（事件）开始时执行。</p>
</li>
<li>
<p><u>自动触发</u>状态转换：如果箭头线上未标明事件，则表示<u>在源状态的内部活动执行完之后自动触发转换</u>。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图中的事件和转换" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684587930655.png" loading="lazy" width="717" height="135" />
</picture>

</p>
</li>
<li>
<p><strong>活动</strong>：指状态中的活动表中的活动。</p>
<p>语法如下：</p>
<pre tabindex="0"><code>事件名 (参数表) /动作表达式
</code></pre><p>事件名：可以是任何事件的名称。</p>
<p>在活动表中经常使用以下3中标准事件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>entry</code></td>
<td style="text-align:left"><u>入口动作</u>，指定<u>进入该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>exit</code></td>
<td style="text-align:left"><u>出口动作</u>，指定<u>退出该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>do</code></td>
<td style="text-align:left"><u>内部活动</u>，指定<u>在该状态下</u>的动作，占有有限时间，并可中断地工作</td>
</tr>
</tbody>
</table>
<p>活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
<p>当状态图对系统、类或用例的动态方面建模时，通常是对反应型对象建模。</p>
<h3 id="活动图" data-numberify>活动图<a class="anchor ms-1" href="#活动图"></a></h3>
<p>活动图（Activity Diagram）是一种特殊的状态图，它<u>展现了在系统内从一个活动到另一个活动的流程</u>。活动图<u>专注于系统的动态视图</u>，<u>强调对象间的控制流程</u>。</p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
<p>活动图一般包括：</p>
<ul>
<li>
<p>状态：</p>
<p>活动图的状态也包含初态和终态。其余的状态还可分为：</p>
<ul>
<li>动作状态：不能被分解，动作不能被中断。</li>
<li>活动状态：能够被进一步分解，可以被中断，其活动由其它的活动图来表示。</li>
</ul>
</li>
<li>
<p>流（转换）。</p>
</li>
<li>
<p>对象。</p>
</li>
</ul>
<p>活动图可以表示：</p>
<ul>
<li>分支（判断）：分支的流上用<code>[]</code>标记的是监护表达式；</li>
<li>（并发）分岔：将一个流分为多个可并发执行的流；</li>
<li>（并发）汇合：将分岔出去的多个流合并为同一个流。</li>
</ul>
<p>当对一个系统的动态方面建模时，有以下几种使用活动图的方式：</p>
<ul>
<li>对工作流建模；</li>
<li>对操作建模；</li>
<li>对业务的复杂流程建模。</li>
</ul>
<h3 id="构件图" data-numberify>构件图<a class="anchor ms-1" href="#构件图"></a></h3>
<p>构件图（Component Diagram，<strong>组件图</strong>）展现了<u>一组构件之间的组织和依赖</u>。构件图<u>专注于系统的静态实现视图</u>，它<u>与类图相关，通常把构件映射为一个或多个类、接口或协作</u>。</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
<p>构件图的成分有：</p>
<ul>
<li>构件：用<u>矩形</u>表示，在矩形<u>右上方有一个小标记</u>。</li>
<li>供接口：用一个<u><strong>圆圈</strong>和连接到构件上的实线</u>表示。构件提供接口给其它构件使用。</li>
<li>需接口：用一个<u><strong>半圆</strong>和连接到构件上的实线</u>表示。构件使用需接口表示需要调用其它构件提供接口。</li>
<li>依赖：将供接口（圆圈）和虚接口（半圆）连接到一起，表示两个构件通过这个接口相依赖。</li>
</ul>
<h3 id="部署图" data-numberify>部署图<a class="anchor ms-1" href="#部署图"></a></h3>
<p>部署图（Deployment Diagram）是用来<u>对面向对象系统的<strong>物理方面</strong>建模</u>的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图<u>对系统的静态部署视图进行建模</u>，它与构件图相关。</p>
<p>部署图<u>展现了系统的软件和硬件之间的关系，在实施阶段使用</u>。</p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
<blockquote>
<p><code>&lt;&lt;artifact&gt;&gt;</code>表示制品。</p>
</blockquote>
<h3 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h3>
<p>UML图分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table>
<p>类图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="类图中的类的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684650129674.png" loading="lazy" width="142" height="139" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="类图接口的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">协作</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="协作的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">依赖</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="依赖的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="泛化的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">关联</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="关联图形化表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>用例图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用例</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例的图形表示" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">包含关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的包含关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">扩展关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的扩展关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例与用例以及参与者与参与者之间的泛化关系" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>交互图中，顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><picture><img class="img-fluid " alt="类图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><picture><img class="img-fluid " alt="用例图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><picture><img class="img-fluid " alt="序列图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><picture><img class="img-fluid " alt="通信图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><picture><img class="img-fluid " alt="状态图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="软件工程" data-numberify>软件工程<a class="anchor ms-1" href="#软件工程"></a></h1>
<h2 id="沟通路径" data-numberify>沟通路径<a class="anchor ms-1" href="#沟通路径"></a></h2>
<p>沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。</p>
<p>软件项目中沟通路径$m$的计算公式：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="gantt图" data-numberify>Gantt图<a class="anchor ms-1" href="#gantt图"></a></h2>
<p>Gantt图：一种<u>简单的水平条形图</u>，它<u>以日历为基准</u>描述项目任务。</p>
<ul>
<li>
<p>垂直轴：表示<u>多个不同的任务</u>，每个任务按照左侧任务名称垂直排列。</p>
</li>
<li>
<p>水平轴：表示<u>日历时间线</u>（如时、天、周、月和年等）。</p>
<p>每个水平条表示一个任务：</p>
<ul>
<li>每一水平条的<u>起点</u>：表示该任务的<u>开始时间</u>；</li>
<li>每一水平条的<u>终点</u>：表示该任务的<u>结束时间</u>；</li>
<li>每一水平条的<u>长度</u>：表示<u>完成该任务的持续时间</u>。</li>
</ul>
<p>当日历中同一时段存在多个水平条时，表示任务之间的并发。</p>
</li>
</ul>
<p>如图：</p>
<p><picture><img class="img-fluid " alt="Gantt图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683683731050.png" loading="lazy" width="795" height="282" />
</picture>

</p>
<ul>
<li>
<p>Gantt图优点：</p>
<p>能清晰地描述：</p>
<ul>
<li>每个任务的开始时间；</li>
<li>每个任务的结束时间；</li>
<li>任务的进展情况；</li>
<li>各个任务之间的并行性。</li>
</ul>
</li>
<li>
<p>Gantt图缺点：</p>
<ul>
<li>不能清晰地反映各任务之间的<u>依赖关系</u>；</li>
<li>难以确定<u>整个项目的关键所在</u>，即不能清晰地确定影响进度的<u>关键任务</u>；</li>
<li>不能反映<u>计划中有潜力的部分</u>。</li>
</ul>
</li>
</ul>
<h2 id="pert图" data-numberify>PERT图<a class="anchor ms-1" href="#pert图"></a></h2>
<p>PERT图是一个<u>有向图</u>：</p>
<ul>
<li>
<p><strong>弧</strong>：表示<strong>任务</strong>。</p>
<p>任务包含以下成分：</p>
<ul>
<li>
<p><u>完成该任务所需的时间</u>（任务持续时间）。</p>
</li>
<li>
<p><u>松弛时间</u>（Slack Time）：表示在<u>不影响整个工期的前提下完成该任务有多少机动余地</u>。</p>
<p>即松弛时间指当前任务的工期可以推迟的时间。</p>
</li>
</ul>
<p>空任务：用虚线箭头表示，表示任务间的关系所添加。完成空任务的所需时间为0。</p>
</li>
<li>
<p><strong>结点</strong>：表示<strong>事件</strong>。</p>
<p>事件是流入结点的任务的结束，或流出结点的任务的开始。事件<u>表示某个时间点</u>，本身不消耗时间和资源。</p>
<p>事件包含以下成分：</p>
<ul>
<li>事件号。</li>
<li>出现该事件的<strong>最早时刻</strong>：表示在此时刻之前从该事件出发的任务不可能开始。</li>
<li>出现该事件的<strong>最迟时刻</strong>：表示从该事件出发的任务最迟在此时刻开始，否则整个工程就不能如期完成。</li>
</ul>
<p><u>只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。</u></p>
<p>特殊的事件：</p>
<ul>
<li>开始事件：没有任何任务流向该事件；</li>
<li>结束事件：没有任务任务从该事件流出。</li>
</ul>
<p>一个项目是从开始事件开始到结束事件结束。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683684995281.png" loading="lazy" width="850" height="490" />
</picture>

</p>
<p>设：</p>
<ul>
<li>$T(e)$：完成任务$e$的所需时间；</li>
<li>$T_s(e)$：完成任务$e$的松弛时间；</li>
<li>$T_e(v)$：事件$v$的最早时刻；</li>
<li>$T_l(v)$：事件$v$的最迟时刻。</li>
</ul>
<p>PERT图各成分取值（不一定需要满足下面的关系，但是可以用下面的式子推出）：</p>
<ul>
<li>
<p>事件$V_{in}$的<u>最早时刻</u>$T_e(V_{in})$：</p>
<ul>
<li>
<p>只有一个任务流入时，设该任务的流出事件为$V_{out}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = T_e(V_{out}) + T
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}, V_{in}&gt;)$简写为了$T$。</p>
</blockquote>
<p>即：<u>该流入任务的流出事件的最早时刻</u> + <u>完成该流入任务的所需时间</u>。</p>
</li>
<li>
<p>多个任务流入时，设与每个任务相对应的流出事件为$V_{out}[ \ i \ ]$，则这些任务为$&lt;V_{out}[ \ i \ ], V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = Max(T_e(V_{out}[ \ i \ ]) + T_i)
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}[ \ i \ ], V_{in}&gt;)$简写为了$T_i$。</p>
</blockquote>
<p>即<u>流入该事件的每个任务计算出的最早时刻的最大值</u>。</p>
</li>
<li>
<p>开始事件$V_{start}$：</p>
<p>$$
T_e(V_{start}) = 0
$$</p>
</li>
</ul>
</li>
<li>
<p>事件$V_{out}$的<u>最迟时刻</u>$T_l(V_{out})$：</p>
<ul>
<li>
<p>只有一个任务流出时，设该任务的流入事件为$V_{in}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - (T + T_s)
$$</p>
<blockquote>
<p>这里将$T_s(&lt;V_{out}, V_{in}&gt;)$简写为$T_s$。</p>
</blockquote>
<p>即：<u>该流出任务的流入事件的最迟时刻</u> -（<u>该流出任务的所需时间</u> + <u>松弛时间</u>）。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - T
$$</p>
</li>
<li>
<p>多个任务流出时，设与每个任务相对应的流入事件为$V_{in}[ \ i \ ]$，则这些任务为$&lt;V_{out}, V_{in}[ \ i \ ]&gt;$：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - (T_i + S_i))
$$</p>
<blockquote>
<p>这里把$T(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$T_i$，把$T_s(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$S_i$。</p>
</blockquote>
<p>即<u>流出该事件的每个任务计算出的最晚时刻的最大值</u>。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - T_i)
$$</p>
</li>
<li>
<p>结束事件$V_{end}$：</p>
<p>$$
T_l(V_{end}) = T_e(V_{end})
$$</p>
<p>即<u>结束事件的最早时刻与最迟时刻相等</u>。</p>
</li>
</ul>
</li>
<li>
<p>设某任务的流入事件为$V_{in}$，流出事件为$V_{out}$，则该任务$&lt;V_{out}, V_{in}&gt;$的<u>松弛时间</u>$T_s(&lt;V_{out}, V_{in}&gt;)$。</p>
<p>$$
T_s = T_l(V_{in}) - T - T_e(V_{out})
$$</p>
<p>即，该任务的流入事件的最迟时刻 - 该任务的所需时间 - 该任务的流出事件的最早时刻</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图公式参照图" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683719224977.png" loading="lazy" width="931" height="341" />
</picture>

</p>
<p>PERT图的路径：从开始事件到结束事件的一条通路。</p>
<p>PERT图的<strong>关键路径</strong>：指<u>所有的任务的松弛时间都为0的路径</u>。</p>
<p>关键路径的长度：指结束事件的最早（或最晚）时刻。</p>
<p><picture><img class="img-fluid " alt="PERT图的关键路径示例" src="/blog/2023/05/%E8%BD%AF%E8%80%83%E5%9B%BE%E7%B1%BB%E6%B1%87%E6%80%BB%E7%AF%87/uTools_1683706944555.png" loading="lazy" width="785" height="457" />
</picture>

</p>
<p>关键路径的特点：</p>
<ul>
<li>
<p>所有任务的松弛时间都为0。</p>
</li>
<li>
<p>每个事件的最早时刻和最迟时刻都是相等的。</p>
</li>
<li>
<p>所有任务持续时间的和，是PERT图所有路径中最大的，并且与结束事件的最早时刻（或最晚时刻）相等。</p>
<p>设关键路径中所有事件为$V_i$（$i = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_j, V_{j+1}&gt;$（$1 \le j \le n-1$）（表示$V_1$是开始事件，$V_2$是$V_1$往下的一个事件，以此类推，$V_n$是结束事件），那么该关键路径结束事件的最早时刻（或最晚时刻）为：</p>
<p>$$
T_e(V_n) = \sum_{i = 1}^{n-1} T_i
$$</p>
<blockquote>
<p>这里$T_i$代表$T(&lt;V_i, V_{i+1}&gt;)$。</p>
</blockquote>
</li>
</ul>
<p>最迟时刻的另一种求法（PERT图存在关键路径的情况下）：</p>
<p>已知某PERT图结束事件的最晚时刻（最早时刻），该PERT图中某一条路径（假设该路径没有分支）中所有事件为$V_j$（$j = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_k, V_{k+1}&gt;$（$1 \le k \le n-1$），该路径下任务的持续时间$T(&lt;V_{k-1}, V_k&gt;)$已知，（即$V_1$是开始事件，按照次序往下，$V_n$是结束事件），计算某一事件的最迟时刻$T_l(V_i)$（$1 \le i &lt; n$）：</p>
<p>$$
T_l(V_i) = T_l(V_n) - \sum_{j = i}^{n - 1} T_j
$$</p>
<blockquote>
<p>这里$T_j$代表$T(&lt;V_j, V_{j + 1}&gt;)$。</p>
</blockquote>
<p>即：<u>结束事件的最晚时刻</u> - <u>该事件到结束事件之间所有的任务的持续时间总和</u>。</p>
<blockquote>
<p>注意：如果事件$V_i$到结束事件之间存在多条路径，应该选择那条任务持续时间总和最大的路径。</p>
</blockquote>
<p>PERT图的优点：</p>
<ul>
<li>给出了每个任务的开始时间、结束时间和完成该任务所需的时间；</li>
<li>给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。</li>
</ul>
<p>PERT图不能清晰地描述任务之间的并行情况。</p>
<h2 id="项目活动图" data-numberify>项目活动图<a class="anchor ms-1" href="#项目活动图"></a></h2>
<p>项目活动图是一种有向图（与PERT图十分类似）：</p>
<ul>
<li>
<p>弧：表示活动。弧的权值表示活动的持续时间。</p>
</li>
<li>
<p>顶点：表示项目里程碑。</p>
<p>特殊的里程碑：</p>
<ul>
<li>开始里程碑：没有任何活动指向该里程碑；</li>
<li>结束里程碑：没有任何活动从该里程碑指出。</li>
</ul>
</li>
</ul>
<p>项目活动图的关键路径：按照PERT图的方法求出松弛时间为0的、从开始里程碑到结束里程碑的路径。</p>
<p>关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>算法设计与分析篇</title>
      <link>/docs/ruan-she/algorithm-design-analysis/</link>
      <pubDate>Wed, 17 May 2023 12:52:42 +0800</pubDate>
      
      <guid>/docs/ruan-she/algorithm-design-analysis/</guid>
      <description><![CDATA[算法概述 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。算法具有下列5个重要]]></description>
      <content:encoded><![CDATA[<h1 id="算法概述" data-numberify>算法概述<a class="anchor ms-1" href="#算法概述"></a></h1>
<p>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。算法具有下列5个重要特性：</p>
<ul>
<li><strong>有穷性</strong>：一个算法必须总是（对任何合法的输入值）在<u>执行有穷步之后结束</u>，且<u>每一步都可在有穷时间内完成</u>。</li>
<li><strong>确定性</strong>：算法中的<u>每一条指令必须有确切的含义</u>，理解时<u>不会产生二义性</u>。并且在任何条件下，算法只有唯一的一条执行路径，即对于<u>相同的输入只能得出相同的输出</u>。</li>
<li><strong>可行性</strong>：一个算法是可行的，即算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
<li><strong>输入</strong>：一个算法有<u>零个或多个输入</u>，这些输入取自于某个特定的对象的集合。</li>
<li><strong>输出</strong>：一个算法有<u>一个或多个输出</u>，这些输出是同输入有着某些特定关系的量。</li>
</ul>
<p>常用的表示算法的方法有：</p>
<ul>
<li>
<p><strong>自然语言</strong>：优点是易理解；缺点是易出现二义性，算法通常很冗长。</p>
</li>
<li>
<p><strong>流程图</strong>：优点是直观易懂；缺点是严密性不如程序设计语言，灵活性不如自然语言。</p>
</li>
<li>
<p><strong>程序设计语言</strong>：优点是能用计算机直接执行；缺点是抽象性差，使算法设计者拘泥于描述算法的具体细节，忽略了“好”算法和正确逻辑的重要性，要求算法设计者掌握程序设计语言及编程技巧。</p>
</li>
<li>
<p><strong>伪代码</strong>：伪代码是介于自然语言和程序设计语言之间的方法，它采用某一程序设计语言的基本语法，同时结合自然语言来表达。</p>
<p>计算机科学家从来没有对伪代码的书写形式达成过共识。</p>
<p>在伪代码中，可以采用最具表达力的、最简明扼要的方法来表达一个给定的算法。</p>
</li>
</ul>
<hr>
<h1 id="算法分析" data-numberify>算法分析<a class="anchor ms-1" href="#算法分析"></a></h1>
<h2 id="复杂度" data-numberify>复杂度<a class="anchor ms-1" href="#复杂度"></a></h2>
<p>由于时间复杂度与空间复杂度分别对算法占用的时间和空间资源进行分析，计算方法相似。</p>
<p>算法的时间复杂度分析主要时分析算法的运行时间，即算法执行所需要的基本操作数。算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可。</p>
<p>算法的复杂度通常是用大O表示法。</p>
<ul>
<li>加法规则：多项相加，保留最高阶项，并将系数化为1；</li>
<li>乘法规则：多项相乘都保留，并将系数化为1。</li>
</ul>
<p><picture><img class="img-fluid " alt="算法复杂度大小比较" src="/docs/ruan-she/algorithm-design-analysis/1681099842666.png" loading="lazy" width="1014" height="100" />
</picture>

</p>
<p>递归式的时间（空间）复杂度：</p>
<p>$$
递归的次数 \times 每次递归的时间（空间）复杂度
$$</p>
<h2 id="渐进符号" data-numberify>渐进符号<a class="anchor ms-1" href="#渐进符号"></a></h2>
<p>可以用渐进符号来表示渐进复杂度。</p>
<p>渐进符号包括：</p>
<ul>
<li>
<p>$O$：算法运行时间的渐进上界。</p>
<p>给定一个函数$g(n)$，$O\big( g(n)  \big) = \{ f(n):\exists 正常数c和n_0, 使得\forall n \ge n_0, 有 0 \le f(n) \le cg(n) \}$。</p>
<p>即，当$n \ge n_0$时，$f(n) \le c \cdot g(n) $。</p>
</li>
<li>
<p>$\Omega$：算法运行时间的渐进下界。</p>
<p>给定一个函数$g(n) $，$O\big( g(n) \big) = \{ f(n):\exists 正常数c和n_0,使得\forall n \ge n_0, 有 0 \le cg(n) \le f(n) \}$。</p>
<p>即，当$n \ge n_0$时，$c \cdot g(n) \le f(n)$。</p>
</li>
<li>
<p>$\Theta$：算法运行时间的渐进上界和渐进下界，即渐进紧致界（又叫紧缺界）。</p>
<p>给定一个函数$g(n)$，$O\big( g(n) \big) = \{ f(n):\exists 正常数c_1、c_2和n_0,使得\forall n \ge n_0, 有 0 \le c_1g(n) \le f(n) \le c_2g(n) \}$。</p>
<p>即，当$n \ge n_0$时，$c_1g(n) \le f(n) \le c_2g(n)$。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="递归式主方法" src="/docs/ruan-she/algorithm-design-analysis/uTools_1681110832416.png" loading="lazy" width="966" height="1204" />
</picture>

</p>
<hr>
<h1 id="算法设计方法" data-numberify>算法设计方法<a class="anchor ms-1" href="#算法设计方法"></a></h1>
<h2 id="分治法" data-numberify>分治法<a class="anchor ms-1" href="#分治法"></a></h2>
<p>任何一个可以用计算机求解的问题所需要的计算时间都与其规模有关。要想直接解决一个较大的问题，有时是相当困难的。问题的规模越小，解题所需要的计算时间往往越少，从而较容易处理。分治法的设计思想是<u>将一个难以直接解决的大问题分解成一些规模较小的相同问题，以便各个击破，分而治之</u>。</p>
<p>如果规模为$n$的问题可分解成$k$个子问题（$1 &lt; k \le n $），这些子问题互相独立且与原问题相同。分治法产生的子问题往往是原问题的较小模式。</p>
<p>一般来说，分治算法在每一层递归上都有3个步骤：</p>
<ol>
<li>
<p><strong>分解</strong>：将原问题分解成一系列子问题。</p>
</li>
<li>
<p><strong>求解</strong>：递归地求解各子问题。</p>
<p>若子问题足够小，则直接求解。</p>
</li>
<li>
<p><strong>合并</strong>：将子问题的解合并成原问题的解。</p>
</li>
</ol>
<p>分治的典型实例有：</p>
<ul>
<li>归并排序；</li>
<li>快速排序；</li>
<li>最大子段和问题。</li>
</ul>
<h3 id="递归" data-numberify>递归<a class="anchor ms-1" href="#递归"></a></h3>
<p>递归是指子程序（或函数）直接调用自己或通过一系列调用语句间接调用自己，是一种描述问题和解决问题的常用方法。还有一些问题，虽然其本身并没有明显的递归结构，但用递归技术来求解使设计出的算法简洁易懂且易于分析。</p>
<p>递归有两个基本要素：</p>
<ul>
<li>边界条件（递归出口）：确定递归到何时终止。</li>
<li>递归模式（递归体）：大问题是如何分解为小问题的。</li>
</ul>
<p>递归可以将大规模的问题分解为若干个小规模的问题，然后先解决小规模问题，再将解决完的小规模问题合并再一起，再次进行处理，最后解决完所有问题。这与分治的思想不谋而合。</p>
<p>递归是分治的一个解决方案，而分治并不一定需要通过递归实现。分治还可以通过循环结构实现。</p>
<h2 id="动态规划法" data-numberify>动态规划法<a class="anchor ms-1" href="#动态规划法"></a></h2>
<p>动态规划算法与分治法类似，其基本思想也是<u>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</u>。</p>
<p>与分治法不同的是，适合用动态规划法求解的问题，<u>经分解得到的子问题往往不是独立的</u>。不同子问题的数目常常只有多项式量级，可以<u>用一个表来记录所有己解决的子问题的答案，在需要时再找出己求得的答案</u>，这样就可以避免大量的重复计算，从而得到多项式时间的算法。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
<p>动态规划算法通常<u>用于求解具有某种最优性质的问题</u>。在这类问题中，可能会有许多可行解，每个解都对应于一个值。而最优解可能会有多个，动态规划算法能找出其中的一个最优解。设计一个动态规划算法，通常按照以下几个步骤进行：</p>
<ol>
<li>
<p>找出最优解的性质，并刻画其结构特征。</p>
</li>
<li>
<p>递归地定义最优解的值。</p>
</li>
<li>
<p>以自底向上的方式计算出最优值。</p>
<p>到此步骤为止的以上步骤（包括此步骤），是动态规划算法的基本步骤。</p>
<p>如果需要给出最优解，通常需要在此步骤中记录更多的信息，以便在步骤4中根据所记录的信息快速构造出一个最优解。</p>
</li>
<li>
<p>根据计算最优值时得到的信息，构造一个最优解。</p>
<p>在只需要求出最优值的情形下，该步骤可省略；若需要求出问题的一个最优解，该步骤必须执行。</p>
</li>
</ol>
<p>对于一个给定的问题，若其具有以下两个性质，可以考虑用动态规划法来求解：</p>
<ul>
<li>
<p><strong>最优子结构</strong>：如果一个问题的最优解中包含了其子问题的最优解，就说该问题具有最优子结构。</p>
<blockquote>
<p>当一个问题具有最优子结构时，提示我们动态规划法可能会适用，但是此时贪心策略可能也是适用的。</p>
</blockquote>
</li>
<li>
<p><strong>重叠子问题</strong>：指用来解原问题的递归算法可反复地解同样的子问题，而不是总在产生新的子问题。</p>
<p>即当一个递归算法不断地调用同一个问题时，就说该问题包含重叠子问题。</p>
<p>此时若用分治法递归求解，则每次遇到子问题都会视为新问题，会极大地降低算法的效率，而动态规划法总是充分利用重叠子问题，对每个子问题仅计算一次，把解保存在一个在需要时就可以查看的表中，而每次查表的时间为常数。</p>
</li>
</ul>
<p>动态规划的经典问题：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0-1 背包问题</td>
<td style="text-align:center">$O(nW)$，$W$为背包容量</td>
<td style="text-align:center">$O(nW)$</td>
</tr>
<tr>
<td style="text-align:center">矩阵连乘</td>
<td style="text-align:center">$O(n^3)$</td>
<td style="text-align:center">$O(n^2)$</td>
</tr>
<tr>
<td style="text-align:center">最长公共序列（LCS）</td>
<td style="text-align:center">$O(n^2)$</td>
<td></td>
</tr>
</tbody>
</table>
<p>矩阵连乘：</p>
<p>两个矩阵$A_{(m \cdot n)}$和$B_{(n \cdot p)}$相乘的次数为：$m \cdot n \cdot p$，相乘后得到的新矩阵为：$(A \cdot B)_{(m \cdot p)}$。</p>
<h2 id="贪心法" data-numberify>贪心法<a class="anchor ms-1" href="#贪心法"></a></h2>
<p>和动态规划一样，贪心法也经常<u>用于解决最优化问题</u>。</p>
<p>与动态规划法不同的是，贪心法在解决问题的策略上是仅根据当前己有的信息做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换而言之，贪心法并<u>不是从整体最优考虑</u>，它所<u>做出的选择只是在某种意义上的局部最优</u>。<u>这种局部最优选择并不能保证总能获得全局最优解，但通常能得到较好的近似最优解。</u></p>
<p>例如，平时购物找钱时，为使找回的零钱的硬币数最少，从最大面值的币种开始，按递减的顺序考虑各币种，先尽量用大面值的币种，当不足大面值币种的金额时才去考虑下一种较小面值的币种，这就是在采用贪心法。这种方法在这里总是最优，是因为银行对其发行的硬币种类和硬币面值的巧妙安排。如果只有面值分别为1、5和11单位的硬币，而希望找回总额为15单位的硬币，按贪心算法，应找1个11单位面值的硬币和4个1单位面值的硬币，共找回5个硬币。但最优的解答应是3个5单位面值的硬币。</p>
<p>贪心法的典型实例：</p>
<ul>
<li>活动选择问题</li>
<li>背包问题</li>
</ul>
<h2 id="回溯法" data-numberify>回溯法<a class="anchor ms-1" href="#回溯法"></a></h2>
<p>回溯法有“通用的解题法”之称，用它<u>可以系统地搜索一个问题的所有解或任一解</u>。</p>
<p>回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解：</p>
<ul>
<li>如果肯定不包含：跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯；</li>
<li>否则：进入该子树，继续按深度优先的策略进行搜索。</li>
</ul>
<p>使用回溯法求解问题：</p>
<ul>
<li>用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束；</li>
<li>用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<p>回溯法适用于解一些组合数较大的问题。</p>
<p>回溯法经典实例：</p>
<ul>
<li>0-1 背包问题</li>
<li>n 皇后问题</li>
</ul>
<h3 id="解空间" data-numberify>解空间<a class="anchor ms-1" href="#解空间"></a></h3>
<p>应用回溯法解问题时，首先应明确定义问题的解空间。问题的解空间应至少包含问题的一个（最优）解。</p>
<p>通常将解空间表示为树或图的形式。</p>
<h3 id="基本思想" data-numberify>基本思想<a class="anchor ms-1" href="#基本思想"></a></h3>
<p>确定解空间的组织结构后，回溯法从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。</p>
<ol>
<li>开始时根结点成为一个活结点（有多个活结点），同时也成为当前的扩展结点（只能有一个扩展结点）。</li>
<li>在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。</li>
<li>如果在当前扩展结点处不能再向纵深方向移动，则当前的扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。</li>
<li>回溯法即以这种工作方式递归地在解空间中搜索，直到找到所要求的解或解空间中己无活结点时为止。</li>
</ol>
<p>运用回溯法解题通常包含以下3个步骤：</p>
<ol>
<li>针对所给问题，定义问题的解空间。</li>
<li>确定易于搜索的解空间结构。</li>
<li>以深度优先的方式搜索解空间。</li>
</ol>
<h3 id="限界函数" data-numberify>限界函数<a class="anchor ms-1" href="#限界函数"></a></h3>
<p>限界函数的设计是回溯法的核心问题，也是难题。问题的解空间往往很大，为了有效地进行搜索，需要在搜索的过程中对某些结点进行剪枝，而对哪些结点进行剪枝，需要设计限界函数来判断。</p>
<p>设计限界函数的通用的指导原则是尽可能多和尽可能早地“杀掉”不可能产生最优解的活结点。好的限界函数可以大大减少问题的搜索空间，从而大大提高算法的效率。</p>
<h2 id="分支限界法" data-numberify>分支限界法<a class="anchor ms-1" href="#分支限界法"></a></h2>
<p>分支限界法类似于回溯法，也是一种<u>在问题的解空间树$T$上搜索问题解</u>的算法。在一般情况下，分支限界法的求解目标是<u>找出满足约束条件的一个解</u>，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即<u>在某种意义下的最优解</u>。</p>
<p>分支限界法以<u>广度优先</u>或以<u>最小耗费优先</u>的方式<u>搜索解空间树$T$</u>。</p>
<p>分支限界法的搜索策略是：每一个活结点只有一次机会成为扩展结点。</p>
<p>活结点一旦成为扩展结点，就一次性产生其所有子结点。在这些子结点中，那些导致不可行解或非最优解的子结点被舍弃，其余子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<blockquote>
<p>目前己有许多利用分支限界法解决大量离散最优化的实际问题的实例。</p>
</blockquote>
<p>与回溯法相似，限界函数的设计是分支限界法的一个核心问题和难题。如何设计限界函数来有效地减小搜索空间是应用分支限界法要考虑的问题。</p>
<p>根据从活结点表中选择下一扩展结点的不同方式，可将分支限界法分为几种不同的类型。最常用的有以下两种：</p>
<ul>
<li>
<p>队列式（FIFO，先进先出）分支限界法：将活结点表组织成一个队列，并按队列的先进先出原则选择下一个结点作为扩展结点。</p>
</li>
<li>
<p>优先队列式分支限界法：将活结点表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点作为扩展结点。</p>
<p>结点优先级：通常用一个与该结点相关的数值$p$来表示，规定$p$值较大的结点优先级较高。</p>
<p>在算法实现时，有两种实现方式：</p>
<ul>
<li>通常用一个最大堆（根结点比左右子结点大）来实现最大优先队列，用最大堆的Deletemax操作（删除最大堆顶）抽取堆中下一个结点成为当前扩展结点。</li>
<li>最小优先队列规定$p$值较小的结点优先级较高。通常用一个最小堆根结点比左右子结点小）来实现最小优先队列，用最小堆的Deletemin操作（删除最小堆顶）抽取堆中下一个结点成为当前扩展结点。</li>
</ul>
</li>
</ul>
<p>分支限界法经典实例：0-1 背包问题。</p>
<h2 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h2>
<table>
<thead>
<tr>
<th style="text-align:center">算法设计方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分治法</td>
<td style="text-align:left"><ol><li>将原问题<strong>分解</strong>成多个<u>与原问题相同的子问题</u></li><li><strong>递归地求解</strong>各子问题</li><li>将子问题的解<strong>合并</strong>成原问题的解</li></ol></td>
<td style="text-align:left">原问题规模大且能分解为多个与原问题相同的子问题</td>
<td style="text-align:left"><ul><li>归并排序</li><li>快速排序</li><li>最大字段和问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">动态规划法</td>
<td style="text-align:left"><ol><li>找出并刻画最优解的结构特征</li><li>递归地定义最优解的值</li><li>自底向上方式计算最优值或构造最优解</li></ol></td>
<td style="text-align:left">求解具有某种最优性质的问题</td>
<td style="text-align:left"><ul><li>0-1 背包问题</li><li>矩阵连乘</li><li>最长公共序列（LCS）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">贪心法</td>
<td style="text-align:left">与动态规划类似，但贪心法考虑的是局部最优解</td>
<td style="text-align:left">并不保证得到全局最优解，但通常能得到近似最优解</td>
<td style="text-align:left"><ul><li>活动选择问题</li><li>背包问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">回溯法</td>
<td style="text-align:left">在解空间树中，按<u>深度优先策略</u>，从根结点出发搜索解空间树</td>
<td style="text-align:left"><ul><li>可以搜索问题的所有解或任一解</li><li>适用于求解组合数较大的问题</li><li>通过限界函数减少问题的搜索空间</li></ul></td>
<td style="text-align:left"><ul><li>0-1背包问题</li><li>n皇后问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">分支限界法</td>
<td style="text-align:left">与回溯法类似，在解空间树种按<u>广度优先</u>或<u>最小耗费</u>优先方式，搜索满足约束条件的一个解</td>
<td style="text-align:left"><ul><li>可以给出<u>在某种意义下的最优解</u></li><li>分为队列式和优先队列式，优先队列式通过最大堆或最小堆实现</li></u></ul></td>
<td style="text-align:left"><ul><li>0-1 背包问题</li></ul></td>
</tr>
</tbody>
</table>
<hr>
<h1 id="算法实例" data-numberify>算法实例<a class="anchor ms-1" href="#算法实例"></a></h1>
<h2 id="最大子段和问题" data-numberify>最大子段和问题<a class="anchor ms-1" href="#最大子段和问题"></a></h2>
<p>给定$n$个整数$a_1, a_2, \cdots, a_n$（可能有负数），求该序列形如$\sum\limits_{k=i}^{j} a_k$的子段和的最大值。当序列中所有整数均为负数时，其最大子段和为$0$。即所求最大值为：</p>
<p>$$
max \left\{
0,
\mathop{max}\limits_{1 \le i \le j \le n}
\sum_{k=i}^{j} a_k
\right\}
$$</p>
<p>给定序列$A[1 \dots n]$，采用分治策略解决问题：</p>
<ol>
<li>
<p>分解：将$A[1 \dots n]$分解为长度大致相等的两段$A\left[1 \dots {n}/{2}\right]$和$A\left[ {n}/{2}+1 \dots n \right]$，分别求出这两段的最大子段和。</p>
<p>最大字段和有3中情形：</p>
<ol>
<li>$A[1 \dots n]$与$A\left[1 \dots {n}/{2}\right]$（左边那段）的最大子段和相同。</li>
<li>$A[1 \dots n]$与$A\left[ {n}/{2}+1 \dots n \right]$（右边那段）的最大子段和相同。</li>
<li>$A[1 \dots n]$的最大子段和为$\sum\limits_{k=i}^{j} a_k$，且$1 \le i \le n/2$，$n/2+1 \le j \le n$（横跨两个子段）。</li>
</ol>
</li>
<li>
<p>解决：</p>
<ul>
<li>
<p>情形1和2：再将子段进行分解，按照以上3种情形递归地计算子段的最大子段和。</p>
</li>
<li>
<p>情形3：$A\left[1 \dots {n}/{2} \right]$和$A\left[ {n}/{2}+1 \dots n \right]$都包含了最优子段的一部分。</p>
</li>
<li>
<p>在$A\left[1 \dots {n}/{2}\right]$中计算出：</p>
<p>$$
s_1 =
\mathop{max}\limits_{1 \le i \le \frac{n}{2}}
\left(\sum_{k=i}^{\frac{n}{2}} A[ \ k \ ]\right)
$$</p>
</li>
<li>
<p>在$A\left[ {n}/{2}+1 \dots n \right]$中计算出：</p>
<p>$$
s_2 =
\mathop{max}\limits_{ \frac{n}{2}+1 \le j \le n }
\left(\sum\limits_{k=\frac{n}{2}+1}^{j} A[ \ k \ ]\right)
$$</p>
</li>
</ul>
<p>$s_1 + s_2$即为情形3的最优值。</p>
</li>
<li>
<p>合并：取分解阶段3种情况下最大子段和中最大值为原问题的解。</p>
</li>
</ol>
<blockquote>
<p>以上3个步骤需要递归地进行，实际情况是：</p>
<ol>
<li>
<p>将$A[1 \dots n]$分解为由单个元素组成的$n$个子序列$\{ [a_1], [a_2], \cdots, [a_n] \}$，这$n$个子序列的最大子段和即为其唯一一个元素的值。</p>
</li>
<li>
<p>自底向上，先分别将相邻的两个子段组合起来，并根据上述分解中描述的3种情形计算其组合后的最大子段和。</p>
<p>例如$[a_1, a_2]$最大子段和有3种可能：</p>
<ol>
<li>情形1：$[a_1]$；</li>
<li>情形2：$[a_2]$；</li>
<li>情形3：$[a_1, a_2]$（即将$a_1$作为$s_1$，$a_2$作为$s_2$）。</li>
</ol>
<p>将取$\{[a_2], [a_1, a_2]\}$中值最大的序列作为$s_1$返回给上层调用。</p>
<p>$[a_3, a_4]$最大子段和也是类似以上情况，最后取$\{[a_3], [a_3, a_4]\}$中值最大的序列作为$s_2$返回给上层调用。</p>
<p>$A[1 \dots n]$中其他序列也是类似的操作。</p>
</li>
<li>
<p>接着来到上一步骤的上层调用中。</p>
<p>例如$[a_1, a_2, a_3, a_4]$的最大子段和也是有3种可能：</p>
<ol>
<li>情形1：$[a_1, a_2]$；</li>
<li>情形2：$[a_3, a_4]$；</li>
<li>情形3：$[a_1, a_2]$的$s_1$加上$[a_3, a_4]$的$s_2$。</li>
</ol>
<p>最后计算$[a_1, a_2, a_3, a_4]$的$s_1$值，可能为$[a_1, a_2, a_3, a_4]$、$[a_2, a_3, a_4]$、$[a_3, a_4]$或$[a_4]$，取其中值最大者。</p>
</li>
<li>
<p>其他层次的调用也是类似上述步骤，最后得到$[a_1, a_2, \cdots, a_{\frac{n}{2}}]$和$[a_{\frac{n}{2}+1}, \cdots, a_n]$的$s_1$和$s_2$还有它们的两个最大子段和。
根据3种情况，取3种情况中最大值者作为$A[1 \dots n]$的最大子段和。</p>
</li>
</ol>
</blockquote>
<h2 id="0-1-背包问题" data-numberify>0-1 背包问题<a class="anchor ms-1" href="#0-1-背包问题"></a></h2>
<p>有$n$个物品，第$i$个物品价值为$v_i$，重量为$w_i$，背包可容纳最大重量为$W$，$v_i$、$w_i$和$W$均为非负数。考虑如何选择装入背包的物品，使装入背包的物品总价值最大。该问题可以形式化描述如下：</p>
<ul>
<li>
<p>目标函数：$max\sum\limit_{i=1}^{n}v_ix_i$；</p>
</li>
<li>
<p>约束条件：$\sum\limit_{i=1}^{n}w_ix_i \le W$，$x_i \in {0, 1}$。</p>
<p>当物品$i$放入背包时，$x_i$为$1$，否则为$0$。</p>
</li>
</ul>
<p>满足约束条件的任一集合（$x_1, x_2, \cdots, x_n$）是问题的一个可行解，问题的目标是求问题的一个最优解。</p>
<h3 id="使用动态规划求解" data-numberify>使用动态规划求解<a class="anchor ms-1" href="#使用动态规划求解"></a></h3>
<p>根据动态规划的4个步骤求解该问题：</p>
<ol>
<li>
<p>刻画 0-1 背包问题的最优解的结构：</p>
<p>有两种情况：</p>
<ul>
<li><u>$x_n = 1$</u>：即问题的最优解包含了物品$n$，那么其余$x_1, x_2, \cdots, x_{n-1}$一定构成子问题：物品$1, 2, \cdots, n-1$在容量为<u>$W-w_n$</u>时的最优解。</li>
<li><u>$x_n = 0$</u>：即最优解不包含物品$n$，那么其余$x_1, x_2, \cdots, x_{n-1}$一定构成子问题：物品$1, 2, \cdots, n-1$在容量为<u>$W$</u>时的最优解。</li>
</ul>
</li>
<li>
<p>递归定义最优解的值：</p>
<p>设$c[i, w]$，表示背包可容纳重量为$w$时，第$i$个物品导致的最优解的总价值：</p>
<p>$$
c[i, w] =
\begin{aligned}
0,                                      &amp; i = 0 或 w = 0 \\
c[i-1, w],                              &amp; w_i &gt; w \\
max\{ c[i-1, w-w_i] + c[i-1, w] \},   &amp; i &gt; 0 且 w_i \le w
\end{aligned}
$$</p>
</li>
<li>
<p>计算背包问题最优解的值。</p>
</li>
<li>
<p>根据计算的结果构造问题最优解。</p>
</li>
</ol>
<h3 id="使用回溯法求解" data-numberify>使用回溯法求解<a class="anchor ms-1" href="#使用回溯法求解"></a></h3>
<p>以$n=3, W=30$的0-1背包问题为例，物品的价值和重量如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">物品$i$</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">价值$v_i$</td>
<td style="text-align:center">16</td>
<td style="text-align:center">15</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">重量$w_i$</td>
<td style="text-align:center">45</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>定义问题的解空间：</p>
<p><picture><img class="img-fluid " alt="0-1背包问题解空间树示例" src="/docs/ruan-she/algorithm-design-analysis/uTools_1684485061214.png" loading="lazy" width="1112" height="493" />
</picture>

</p>
<p>其中$X(i)$即为$x_i$。</p>
</li>
<li>
<p>定义限界函数：</p>
<p>考虑贪心策略，先对所有物品按其单位重量价值从大到小排序。对搜索空间树中的某个结点，有确定的$X(i)$（$1 \le i \le k$），而其他的$X(i)$（$k + 1 \le i \le n$）待定。</p>
<p>此时可以将0-1背包问题松弛为背包问题，求从当前结点扩展下去，计算能获得的最大价值。若该价值比当前已经得到的某个可行解的值要小，则该结点不必再扩展。</p>
</li>
<li>
<p>以深度优先的方式搜索解空间：</p>
<ol>
<li>
<p>开始时根结点是唯一的活结点，也是当前的扩展结点。在扩展结点处，按照深度优先策略移至结点$B$或$C$。</p>
<p>假设先移至$B$，此时$A$和$B$均是活结点，结点$B$成为当前扩展结点。</p>
<p>当前$X(1) = 1$表示选择了物品$1$，当前背包剩余容量$w = 14$，获取的价值是$v=45$。</p>
</li>
<li>
<p>从当前扩展结点$B$可以移至$D$或$E$。</p>
<p>由于$w_2=15$，移至$D$不是一个可行解，所以选择移至$E$。</p>
<p>此时$E$成为新扩展结点，$A$、$B$和$E$是当前的活结点，当前的$w$和$v$不变。</p>
</li>
<li>
<p>从$E$可以移至$J$或$K$。</p>
<p>移至$J$导致一个不可行解，所以移至$K$，$K$成为新扩展结点。</p>
<p>$K$是叶结点，故得到一个可行解。解$x$的取值是由根到叶结点$K$的路径唯一确定的，即$x = (1, 0, 0)$，对应$v = 45$。</p>
<p>由于$K$已不能在向纵深扩展，所以$K$成为死结点。返回到上一个活结点$E$，此时$E$也没有可扩展的结点，它也成为一个死结点。$B$此时也是死结点，最后回到$A$。</p>
</li>
<li>
<p>$A$还可扩展，按照类似上述步骤继续搜索。搜索结束后找到的最好解就是0-1背包问题的最优解。</p>
</li>
</ol>
</li>
</ol>
<h2 id="背包问题" data-numberify>背包问题<a class="anchor ms-1" href="#背包问题"></a></h2>
<p>有$n$个物品，第$i$个物品价值为$v_i$，重量为$w_i$，背包容量为$W$，$v_i$、$w_i$和$W$均为非负数。背包问题与0-1背包问题类似，但是每个物品可以部分装入背包，即$0 \le x_i \le 1$。</p>
<p>假设$n = 5, W = 100$，各物品的重量、价值和单位重量的价值如图：</p>
<p><picture><img class="img-fluid " alt="物品基本信息" src="/docs/ruan-she/algorithm-design-analysis/uTools_1684482734674.png" loading="lazy" width="1278" height="225" />
</picture>

</p>
<p>为了得到最优解，必须把背包放满。用贪心法求解，有3种方式：</p>
<ul>
<li>
<p>按最大价值优先放入背包的原则：</p>
<ol>
<li>先放物品$1$和$4$，获得价值$65+60=125$，背包容量剩$100-30-50=20$。</li>
<li>此时物品$5$价值最大，但不能全部放入背包。而将物品$2$和$3$放入背包比把物品$5$的一半放入背包的价值大。</li>
<li>把物品$2$放入背包，目前获得价值共$125+20=145$，剩余容量$20-10=10$。</li>
<li>此时可再放入物品$3$的$\cfrac{1}{3}$，得到总价值$145 + 1.5 \times 10 = 160$。</li>
</ol>
<p>对应的解为$\left\{1,\ 1,\ \cfrac{1}{3},\ 1,\ 0 \right\}$。</p>
</li>
<li>
<p>按最小重量优先放入背包的原则：将物品$2$、$3$、$1$和$5$放入背包，刚好装满，得到价值$20+30+60+40=155$，对应的解为$\{ 1, 1, 1, 0, 1 \}$。</p>
</li>
<li>
<p>按最大单位重量价值优先放入背包的原则：</p>
<ol>
<li>将物品$1$、$2$和$3$放入背包，得到价值$65+20+30=115$，剩余容量$100-30-10-20=40$。</li>
<li>还可将物品$4$的$\cfrac{4}{5}$放入背包，得到总价值$115 + \cfrac{4}{5} \times 60 = 163$。</li>
</ol>
<p>对应的解为$\left\{ 1,\ 1,\ 1,\ \cfrac{4}{5},\ 0 \right\}$</p>
</li>
</ul>
<h2 id="最长公共子序列lcs" data-numberify>最长公共子序列（LCS）<a class="anchor ms-1" href="#最长公共子序列lcs"></a></h2>
<p>非形式化地讲，子序列可以是从给定序列中随意地（不一定是连续的）去掉若干元素（可能一个也不去掉）后所形成的序列。令序列$X = x_1x_2\cdots x_m$，序列$Y=y_1y_2\cdots y_k$是$X$的子序列，存在$X$的一个严格递增下标序列$&lt;i_1, i_2, \cdots, i_k&gt;，使得对于所有的$j=1, 2, \cdots, k$有$x_{i_j}=y_j$。</p>
<p>公共子序列：给定两个序列$X$和$Y$，序列$Z$同时是$X$和$Y$的子序列，这个序列$Z$即为$X$和$Y$的公共子序列。</p>
<p>最长公共子序列问题定义为：给定序列$X=x_1x2 \cdots x_m$和序列$Y=y_1y2 \cdots y_n$，求这两个序列的最长公共子序列。</p>
<p>动态规划法求解最长公共子序列问题：</p>
<ol>
<li>
<p>刻画最长公共子序列问题的最优子结构：</p>
<p>LCS最优子结构定理：</p>
<ul>
<li>$x_m = y_n$：$z_k = x_m = y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个最长公共子序列。</li>
<li>$x_m \neq y_n$：
<ul>
<li>$z_k \neq x_m$：蕴含$Z$是$X_{m-1}$和$Y$的一个最长公共子序列；</li>
<li>$z_k \neq y_n$：蕴含$Z$是$X$和$Y_{n-1}$的一个最长公共子序列。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>递归定义最优解的值：</p>
<p>设$l[i, j]$表示序列$X_i$和$Y_j$的最长公共子序列的长度：</p>
<p>$$
l[i, j] =
\begin{aligned}
0,                          &amp; i=0 或 j=0 \\
l[i-1, j-1],                &amp; i,j &gt; 0 且 x_i = y_j \\
max(l[i-1, j], l[i, j-1]),  &amp; i,j &gt; 0 且 x_i \neq y_j
\end{aligned}
$$</p>
</li>
<li>
<p>计算最优解的值：</p>
<p>根据上述递归式自底向上地求出最优解的值。将$l[i, j]$的值存储在表$l[1 \dots m, 1 \dots n]$中，以行为主序从左到右计算表$l$中的元素，同时维持表$b[1 \dots m, 1 \dots n]$，用其中的元素$b[i, j]$记录使得$l[i, j]$取最优值的最优子结构。</p>
<p>例如$X=ABCBDAD$和$Y=BDCABA$，对应的表$l$和$b$如图：</p>
<p><picture><img class="img-fluid " alt="动态规划求解LCS示例" src="/docs/ruan-she/algorithm-design-analysis/uTools_1684475662212.png" loading="lazy" width="599" height="480" />
</picture>

</p>
</li>
<li>
<p>构造最优解：</p>
<p>用表$b$中的信息构造$X$和$Y$的一个LCS。从$b[m, n]$开始，在表中沿着箭头方向跟踪，$b[i, j]$的值和含义如下：</p>
<ul>
<li>$“\nwarrow”$：表示$x_i = y_j$为LCS中的元素，接下来要判断（跟踪）$b[i-1, j-1]$。</li>
<li>$“\uparrow”$：表示$x_i \neq y_j$，此时需要判断（跟踪）$b[i-1, j]$。</li>
<li>$“\leftarrow”$：表示$x_i \neq y_j$，此时需要判断（跟踪）$b[i, j-1]$。</li>
</ul>
</li>
</ol>
<h2 id="活动选择问题" data-numberify>活动选择问题<a class="anchor ms-1" href="#活动选择问题"></a></h2>
<p>活动选择问题是指若干个具有竞争性的活动，要求互斥使用某一公共资源时，如何选择最大的相容活动集合。</p>
<p>假设有一个需要使用某一资源的$n$个活动组成的集合$S=\{a_1, a_2, \cdots, a_n\}$，该资源一次只能被一个资源占用。</p>
<ul>
<li>活动$a_i$有一个开始时间$s_i$和结束时间$f_i$，且$0 \le s_i \le f_i &lt; \infin$。</li>
<li>一旦被选择后，活动$a_i$就占据半开时间区间$[s_i, f_i)$。</li>
<li>如果两个活动$a_i$和$a_j$的时间区间互不重叠，则称活动$a_i$和$a_j$是兼容的。</li>
</ul>
<p>活动选择问题就是要选择出一个由互相兼容的活动组成的最大子集合。</p>
<p>该问题可用动态规划法和贪心法求解。</p>
<p><strong>使用贪心法求解</strong>：</p>
<p>定义集合$S_{ij} = \{a_k \in S: f_i \le s_k &lt; f_k \le s_j \}$。为了完整表示，加入两个虚拟活动$a_0$和$a_{n+1}$，其中$f_0=0,s_{n+1} = \infin$，则$S = S_{0, n+1}$。</p>
<p>定理：</p>
<p>对于任意非空子问题$S_{ij}$，设$a_m$是$S_{ij}$中具有最早结束时间的活动，那么有两种情况：</p>
<ul>
<li>$a_m$在$S_{ij}$的某个最大兼容活动子集中。</li>
<li>子问题$S_{im}$为空，选择$a_m$将使$S_{mj}$为唯一可能非空的子问题。</li>
</ul>
<h2 id="n-皇后问题" data-numberify>n 皇后问题<a class="anchor ms-1" href="#n-皇后问题"></a></h2>
<p>$n$皇后问题要求在$n \times n$格的棋盘上放置$n$个皇后，使得它们彼此不受攻击。按照规则，皇后可以攻击与之处在同一行、同一列或同一斜线上的其他任何棋子。$n$皇后问题等价于要求在一个$n \times n$棋盘上放置$n$个皇后，使得任何两个皇后不能被放在同一行、同一列或同一斜线上。</p>
<p>求解过程从空棋盘开始，设在第$1$行至第$m$行都己经正确地放置了$m$个皇后：</p>
<ol>
<li>
<p>在第$m+1$行上，从第1$列开始找适合放置皇后的位置，共有$n$个可选位置。当一个位置不合适时就顺序选择下一列的位置进行判断。</p>
<p>一个位置上共有以下几种情形：</p>
<ul>
<li>当前位置的所在列上，已经有一个皇后存在，该位置不合适。</li>
<li>当前位置所在的斜线上，已经有一个皇后存在，该位置不合适。</li>
<li>当前位置所在的列和斜线上，均无皇后存在，该位置合适。</li>
</ul>
</li>
<li>
<p>接着往下一行，寻找下一行中适合放皇后的位置，然后再继续往下找。</p>
<p>此时有以下几种情形：</p>
<ul>
<li>
<p>一直寻找到第$n$行，每一行上都有适合放皇后的位置。此时为一个可行解。</p>
<p>如果第$n$行还有剩余的位置，那么便继续判断这些位置，以希望再获得一个可行解；否则进行回溯，按步骤1的方式改变上一行的位置。</p>
</li>
<li>
<p>往下搜寻，在中途发现某一行上的所有位置都不能放置皇后，此时也要进行回溯，回到上一行按步骤1的方式改变位置。</p>
</li>
</ul>
</li>
</ol>
<p>用回溯法求解4-皇后问题：</p>
<p><picture><img class="img-fluid " alt="用回溯法求解4-皇后问题的搜索过程" src="/docs/ruan-she/algorithm-design-analysis/uTools_1684495382071.png" loading="lazy" width="1275" height="506" />
</picture>

</p>
<hr>
<h1 id="查找算法" data-numberify>查找算法<a class="anchor ms-1" href="#查找算法"></a></h1>
<p>查找是一种常用的基本运算。查找表是指由同一类型的数据元素（或记录）构成的集合。</p>
<p>查找表经常要进行的操作：</p>
<ul>
<li>查询某个特定的数据元素是否在查找表中。</li>
<li>检索某个特定的数据元素的各种属性。</li>
</ul>
<p>通常将只进行这两种操作的查找表称为<strong>静态查找表</strong>。</p>
<p>查找表经常要进行的另外两种操作：</p>
<ul>
<li>在查找表中插入一个数据元素。</li>
<li>从查找表中删除一个数据元素。</li>
</ul>
<p>需要在查找表中插入或删除元素，称此类查找表为<strong>动态查找表</strong>。</p>
<p><strong>关键字</strong>是数据元素（或记录）的某个数据项的值，用它来识别（标识）这个数据元素。</p>
<ul>
<li><strong>主关键字</strong>：能唯一标识一个数据元素的关键字。</li>
<li><strong>次关键字</strong>：能标识多个数据元素的关键字。</li>
</ul>
<h2 id="平均查找长度" data-numberify>平均查找长度<a class="anchor ms-1" href="#平均查找长度"></a></h2>
<p>查找算法基本操作是<u>“将记录的关键字与给定值进行比较”</u>。因此，通常<u>以“其关键字和给定值进行过比较的记录个数的期望值”作为衡量查找算法好坏的依据</u>。</p>
<p>查找算法在查找成功时的<u>平均查找长度</u>关键字和给定值比较次数的期望值：</p>
<p>$$
ASL = \sum_{i=1}^{n}{P_iC_i}
$$</p>
<ul>
<li>
<p>$P_i$为对表中第$i$个记录进行查找的概率，</p>
<p>一般认为$P_i=\cfrac{1}{n}, 1 \le i \le n$，即$\sum_{i=1}^{n}{P_i}$；</p>
</li>
<li>
<p>$C_i$为查找成功时，已经进行过比较的关键字个数。</p>
</li>
</ul>
<h2 id="查找算法-1" data-numberify>查找算法<a class="anchor ms-1" href="#查找算法-1"></a></h2>
<p>静态查找表有以下查找方法：</p>
<ul>
<li>顺序查找；</li>
<li>折半查找；</li>
<li>分块查找。</li>
</ul>
<p>动态查找表有以下查找方法：</p>
<ul>
<li>二叉排序树；</li>
<li>平衡排序树；</li>
<li>B-树；</li>
<li>哈希表。</li>
</ul>
<h3 id="顺序查找" data-numberify>顺序查找<a class="anchor ms-1" href="#顺序查找"></a></h3>
<p>顺序查找是从表的一端开始，按照顺序（从左往右或从右往左）逐一进行查找。顺序查找的方法<u>对于<strong>顺序存储方式</strong>和<strong>链式存储方式</strong>的查找表都适用</u>。</p>
<p>顺序查找中，$C_i$取决于所查记录在表中的位置。一般情况下，$C_i = n - i + 1$，在等概率下，顺序查找的平均查找长度为：</p>
<p>$$
ASL_{ss} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<h3 id="二分查找" data-numberify>二分查找<a class="anchor ms-1" href="#二分查找"></a></h3>
<p>二分查找又叫折半查找，是在有序列表的基础上进行查找，每次查找可以筛掉一半的元素。步骤如下：</p>
<p>以升序数列$L[0&hellip;n-1]$为例，假设要查找的数为$x$：</p>
<p>让$x$与数列中间位置的元素$L\left[ \left\lfloor \cfrac{n}{2} \right\rfloor \right]$进行比较，如果相等则返回该元素下标，否则：</p>
<ul>
<li>如果$x$比中间元素小，递归地对中间元素左边的数列（比$x$小的元素）进行二分查找；</li>
<li>如果$x$比中间元素大，递归地对中间元素右边的数列（比$x$大的元素）进行二分查找。</li>
</ul>
<p>折半查找的过程可用二叉树描述。$n$个结点的二叉树深度为$\lfloor log_2{n} \rfloor + 1$，折半查找进行比较的关键字个数最多不超过树的深度。所以，折半查找在查找成功时和给定值<u>进行比较的关键字个数最多为$\lfloor log_2{n} \rfloor + 1$</u>。</p>
<p>折半查找的平均查找长度（假设结点总数为$n=2^h-1$，即折半查找树为深度$h=log_2(n+1)$的满二叉树）：</p>
<p>$$
ASL_{bs} = \cfrac{1}{n} \sum_{i=1}^{n}{i \times 2^{i-1}} = \cfrac{n+1}{n} log_2{(n+1)} - 1
$$</p>
<p>当$n$值较大时，$ASL_{bs} \approx log_2{(n+1)} - 1$。</p>
<hr>
<h1 id="哈希表" data-numberify>哈希表<a class="anchor ms-1" href="#哈希表"></a></h1>
<p>哈希表查找（又叫散列表查找）是通过散列技术，将存储位置和关键字构建一个确定的关系$H$，使得每个关键字$key$对应一个存储位置$H(key)$。其中，$H$称为哈希函数或者散列函数。</p>
<p>根据设定的<strong>哈希函数</strong>$H(key)$和<strong>处理冲突的方法</strong>，将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这块连续的空间称为哈希表或散列表，这一映射过程称为<strong>哈希造表</strong>或<strong>散列表</strong>，所得的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>。</p>
<p>对于哈希表，主要考虑两个问题：</p>
<ul>
<li>如何构造哈希函数；</li>
<li>如何解决冲突。</li>
</ul>
<h2 id="冲突" data-numberify>冲突<a class="anchor ms-1" href="#冲突"></a></h2>
<p>对于某个哈希函数$H$和两个关键字$key_1$和$key_2$,如果$key_1 \neq key_2$，而$H(key_1)=H(key_2)$，则称为冲突。</p>
<p>具有相同哈希函数值的关键字对该哈希函数来说称为同义词。</p>
<p>一般情况下，冲突只能尽可能减少而不能完全避免。</p>
<h2 id="哈希函数的构造方法" data-numberify>哈希函数的构造方法<a class="anchor ms-1" href="#哈希函数的构造方法"></a></h2>
<p>常用的哈希函数构造方法有：</p>
<ul>
<li>
<p>直接定址法；</p>
</li>
<li>
<p>数字分析法；</p>
</li>
<li>
<p>平方取中法；</p>
</li>
<li>
<p>折叠法；</p>
</li>
<li>
<p>随机数法；</p>
</li>
<li>
<p>除留余数法</p>
<p>……</p>
</li>
</ul>
<p>哈希函数的构造要考虑到：</p>
<ul>
<li>
<p>压缩性：节省存储空间；</p>
</li>
<li>
<p>散列性：尽量减少冲突。</p>
<p>要减少冲突，就要设法使哈希函数尽可能均匀地把关键字映射到存储区的各个存储单元。在构造哈希函数时，一般都要对关键字进行计算，且尽可能使关键字的所有组成部分都能起作用。</p>
</li>
</ul>
<h3 id="除留取余数法" data-numberify>除留取余数法<a class="anchor ms-1" href="#除留取余数法"></a></h3>
<p>除留取余数法是最常用的构造散列函数方法。</p>
<p>除留取余数法：</p>
<p>$$
f(key)=key \enspace mod \enspace p\quad (p\le m),\ m为散列表长
$$</p>
<blockquote>
<p>$mod$ 是取模运算。</p>
<p>根据经验，若散列表表长为$m$，通常$p$为小于或等于表长（最好接近$m$）的最小质数，可以更好的减小冲突。</p>
</blockquote>
<h2 id="冲突处理方法" data-numberify>冲突处理方法<a class="anchor ms-1" href="#冲突处理方法"></a></h2>
<p>解决冲突就是为出现冲突的关键字找到另一个“空”的哈希地址。在处理冲突的过程中可能得到一个地址序列$H_i,(i=1,2,\dots,k)$。常见的处理冲突的方法有以下几种：</p>
<ul>
<li>开放地址法；</li>
<li>多重散列法（再哈希法）；</li>
<li>链地址法；</li>
<li>公共溢出区法……</li>
</ul>
<h3 id="开放地址法" data-numberify>开放地址法<a class="anchor ms-1" href="#开放地址法"></a></h3>
<p>开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。</p>
<p>有三种寻找空散列地址的方法：</p>
<ul>
<li>
<p>线性探测法（线性探测再散列）：</p>
<p>$$
H_i=(H(key)+d) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$d$取$0,1,2,&hellip;,m-1$；</li>
<li>$m$为散列表的长度。</li>
</ul>
<p>$d$初始为0，如果有冲突，那么$d$就通过递增来寻找空的散列地址。</p>
</li>
<li>
<p>二次探测法（二次探测再散列）：</p>
<p>$$
H_i=(H(key)+q^2) mod m
$$</p>
<p>其中：</p>
<ul>
<li>$q$取$0,1,-1,2,-2,&hellip;,\pm k$，$k \le \cfrac{m}{2}$</li>
<li>$m$为散列表的长度</li>
</ul>
<p>二次探测法其实是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。</p>
</li>
</ul>
<p>线性探测法市能使第$i$个哈希地址的同义词存入第$i+1$个哈希地址，这样本应存入第$i+1$个哈希地址的元素变成了第$i+2$个哈希地址元素的同义词，……，因此，可能出现很多元素在相邻的哈希地址上“聚集”起来的现象，大大降低了查找效率。</p>
<hr>
<h1 id="排序算法" data-numberify>排序算法<a class="anchor ms-1" href="#排序算法"></a></h1>
<p>排序算法有稳定排序和不稳定排序两种。假设待排序序列中，$R_i$和$R_j$值相同，且$R_i$领先于$R_j$，排序后：</p>
<ul>
<li><strong>稳定排序</strong>：排序后$R_i$和$R_j$相对次序不变，$R_i$任领先于$R_j$；</li>
<li><strong>不稳定排序</strong>：排序后可能出现$R_j$领先于$R_i$的情况。</li>
</ul>
<p>根据记录存储的位置可分为：</p>
<ul>
<li><strong>内部排序</strong>：待排序记录存储在内存中进行排序的过程。</li>
<li><strong>外部排序</strong>：排序记录的数量很大，内存无法容纳全部记录，在排序过程需要对外存进行访问的排序过程。</li>
</ul>
<p>排序过程需要进行的两种基本操作：</p>
<ol>
<li>
<p>比较两个关键字的大小。</p>
<p>这种操作对于大多数排序方法来说是必需的。</p>
</li>
<li>
<p>将记录从一个位置移动到另一个位置。</p>
<p>这种操作可以通过改变记录的存储方式来避免。</p>
</li>
</ol>
<p>排序算法及其时间、空间复杂度：</p>
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">最好时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">是否归位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(log_2{n})$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(nlog_2{n})$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>是否归位：在排序过程中，能否确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="选择排序" data-numberify>选择排序<a class="anchor ms-1" href="#选择排序"></a></h2>
<p>选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。</p>
<p>算法步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复步骤2，直到所有元素均排序完毕。</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>     <span class="c1">// 走访未排序的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 找到最小值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// i 不是最小数时，将 i 和最小数进行交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="冒泡排序" data-numberify>冒泡排序<a class="anchor ms-1" href="#冒泡排序"></a></h2>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>算法步骤：</p>
<p>假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。</p>
<ol>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。</p>
</li>
<li>
<p>对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。</p>
<p>第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。</p>
</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="直接插入排序" data-numberify>直接插入排序<a class="anchor ms-1" href="#直接插入排序"></a></h2>
<p>直接插入排序的做法是：在插入第$i$个记录（$R_i$）时，序列中的前$i-1$个记录$R_1,R_2,\cdots,R_{i-1}$已排好序。将$R_i$与前面的有序序列做比较，找到应该插入的位置将$R_i$插入，并将插入位置后的记录依序向后移动。</p>
<blockquote>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p>
<p>对于基本有序的序列用直接插入排序效率是最高的。</p>
<p>不归位：在排序过程中，不能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="希尔排序" data-numberify>希尔排序<a class="anchor ms-1" href="#希尔排序"></a></h2>
<p>希尔排序又称为“缩小增量排序”，它是对直接插入排序方法的改进。</p>
<p>希尔排序的基本思想是：先将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。</p>
<p>步骤如下：</p>
<ol>
<li>
<p>选择一个增量序列$t_1,t_2,&hellip;,t_k$，其中$t_i &lt; t_{i-1}(1 \le i \le k),t_k = 1$；</p>
<p>一般来说，$t_1 \le \cfrac{n}{2}$。</p>
</li>
<li>
<p>按增量序列个数$k$，对序列进行$k$趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为$t_i$的子序列，分别对各子表进行直接插入排序。仅增量因子为$1$时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<p><picture><img class="img-fluid " alt="希尔排序示例" src="/docs/ruan-she/algorithm-design-analysis/uTools_1681209778321.png" loading="lazy" width="649" height="460" />
</picture>

</p>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="计数排序" data-numberify>计数排序<a class="anchor ms-1" href="#计数排序"></a></h2>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是$Θ(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<blockquote>
<p>计数排序是用来排序0到100之间的数字的最好的算法。</p>
</blockquote>
<p>算法步骤：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素。</li>
<li>统计数组中每个值为 <code>i</code>的元素出现的次数，存入数组 <code>C</code>的第 <code>i</code>项。</li>
<li>对所有的计数累加（从 <code>C</code>中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素 <code>i</code>放在新数组的第 <code>C(i)</code> 项，每放一个元素就将 <code>C(i)</code> 减去 <code>1</code>。</li>
</ol>
<h2 id="堆排序" data-numberify>堆排序<a class="anchor ms-1" href="#堆排序"></a></h2>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p>
<p>堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>算法步骤</p>
<ol>
<li>
<p>将待排序的数组构造出一个堆 <code>H[0……n-1]</code>；</p>
</li>
<li>
<p>把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换；</p>
<p>此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。</p>
</li>
<li>
<p>把新的数组顶端数据调整到相应位置；</p>
</li>
<li>
<p>重复步骤 2 到 3，直到堆的尺寸为 1。</p>
</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="快速排序" data-numberify>快速排序<a class="anchor ms-1" href="#快速排序"></a></h2>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>算法步骤</p>
<ol>
<li>从序列中选择一个元素作为“基准”（pivot）。</li>
<li>将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。</li>
<li>分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。</li>
<li>分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）重复执行1到3操作。</li>
</ol>
<blockquote>
<p>归位：在排序过程中，能确定某些元素的最终排序位置。</p>
</blockquote>
<h2 id="归并排序" data-numberify>归并排序<a class="anchor ms-1" href="#归并排序"></a></h2>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归；</li>
<li>自下而上的迭代。</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<blockquote>
<p>不归位：在排序过程中，不能确定某些元素的最终排序位置。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>计算机网络篇</title>
      <link>/docs/ruan-she/computer-nework/</link>
      <pubDate>Fri, 12 May 2023 06:01:08 +0000</pubDate>
      
      <guid>/docs/ruan-she/computer-nework/</guid>
      <description><![CDATA[网络概述 计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。现代计算机网络已具有统一的网络体系结构。 计算]]></description>
      <content:encoded><![CDATA[<h1 id="网络概述" data-numberify>网络概述<a class="anchor ms-1" href="#网络概述"></a></h1>
<p>计算机网络是计算机技术与通信技术相结合的产物，它实现了远程通信、远程信息处理和资源共享。现代计算机网络已具有统一的网络体系结构。</p>
<p>计算机网络提供的主要功能有：</p>
<ul>
<li>数据通信</li>
<li>资源共享</li>
<li>负载均衡</li>
<li>高可共享性</li>
</ul>
<h2 id="计算机网络分类" data-numberify>计算机网络分类<a class="anchor ms-1" href="#计算机网络分类"></a></h2>
<p>按通信距离分类：</p>
<table>
    <tr>
        <th style="text-align:center">
            网络分类
            </th>
        <th style="text-align:center">
            分布距离
        </th>
        <th style="text-align:center">
            计算机分布范围
        </th>
        <th style="text-align:center">
            传输速率
        </th>
    </tr>
    <tr>
        <td style="text-align:center" rowspan="4">
            <b>
                局域网
                <br>
                MAN
            </b>
        </td>
        <tr>
            <td>10m左右</td>
            <td>房间</td>
            <td rowspan="3">
                4Mbps ~ 1Gbps
            </td>
        </tr>
        <tr>
            <td>100m左右</td>
            <td>楼寓</td>
        </tr>
        <tr>
            <td>1000m左右</td>
            <td>校园</td>
        </tr>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                城域网
                <br>
                WAN
            </b>
        </td>
        <td>10km</td>
        <td>城市</td>
        <td>50Kbps ~ 100 Mbps</td>
    </tr>
    <tr>
        <td style="text-align:center">
            <b>
                广域网
                <br>
                LAN
            </b>
        </td>
        <td>100km以上</td>
        <td>国家或全球</td>
        <td>9.6Kbps ~ 45Mbps</td>
    </tr>
</table>
<p>其它分类方式与其分类如：</p>
<table>
    <tr>
        <th style="text-align: center;">
            分类方式
        </th>
        <th>
            分类内容
        </th>
    </tr>
    <tr>
        <td style="text-align: center;" rowspan="4">
            信息交换方式
        </td>
    </tr>
    <tr><td>电路交换网</td></tr>
    <tr><td>分组交换网</td></tr>
    <tr><td>综合交换网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="5">
            网络拓扑结构
        </td>
    </tr>
    <tr><td>星型网</td></tr>
    <tr><td>树型网</td></tr>
    <tr><td>环型网</td></tr>
    <tr><td>总线网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="5">
            通信介质
        </td>
    </tr>
    <tr><td>双绞线网</td></tr>
    <tr><td>同轴电缆网</td></tr>
    <tr><td>光纤网</td></tr>
    <tr><td>卫星网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="3">
            传输带宽
        </td>
    </tr>
    <tr><td>基带网</td></tr>
    <tr><td>宽带网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="3">
            使用范围
        </td>
    </tr>
    <tr><td>公用网</td></tr>
    <tr><td>专用网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="4">
            速率
        </td>
    </tr>
    <tr><td>高速网</td></tr>
    <tr><td>中速网</td></tr>
    <tr><td>低速网</td></tr>
    <tr>
        <td style="text-align: center;" rowspan="3">
            通信传播方式
        </td>
    </tr>
    <tr><td>广播式</td></tr>
    <tr><td>点到点式</td></tr>
</table>
<h2 id="isoosi-网络体系结构" data-numberify>ISO/OSI 网络体系结构<a class="anchor ms-1" href="#isoosi-网络体系结构"></a></h2>
<p>ISO/OSI的参考模型共有7层：</p>
<p><picture><img class="img-fluid " alt="OSI 参考模型" src="/docs/ruan-she/computer-nework/uTools_1683875696461.png" loading="lazy" width="390" height="339" />
</picture>

</p>
<p>计算机网络按照数据通信和数据处理的功能可分为两层：</p>
<ol>
<li>
<p>内层通信子网（通信子网）：由计算机和高速通信线路组成独立的数据系统，承担全网的通信工作（解决数据传输和通信控制问题）。</p>
</li>
<li>
<p>外层资源子网（资源子网）：包括计算机、终端、通信子网接口设备、外部设备、软件资源等，它负责全网的数据处理和提供网络资源及网络服务。</p>
</li>
</ol>
<p>这两个网络层符合国际标准化组织所制定的开放式系统互连参考模型（OSI）的思想：</p>
<ul>
<li>通信子网对应于OSI中的低三层：
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ul>
</li>
<li>资源子网对应于OSI中的高三层：
<ul>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<p>服务端要向用户端传送数据（信息流向）：</p>
<ol>
<li>
<p>服务端将数据送入应用层，然后数据逐层向物理层传递。</p>
<p>在传递过程中，每一层对数据做相应处理（附加控制信息、数据变换、报文分段、报文分组、变换为帧等）。</p>
<p>最后，经由物理层将数据发送至用户端。</p>
</li>
<li>
<p>用户端接受信息，按照与服务端相反顺序的动作，从物理层开始层层剥去控制信息。</p>
<p>最后把原数据展示给用户。</p>
</li>
</ol>
<p><picture><img class="img-fluid " alt="ISO/OSI RM 内信息流动" src="/docs/ruan-she/computer-nework/uTools_1683877150679.png" loading="lazy" width="724" height="404" />
</picture>

</p>
<blockquote>
<p>只有物理层是实通信（有物理连接），其余各层均为虚通信（无连线）。</p>
</blockquote>
<h2 id="网络的拓扑结构" data-numberify>网络的拓扑结构<a class="anchor ms-1" href="#网络的拓扑结构"></a></h2>
<p>网络拓扑结构是指网络中通信线路和结点的几何排序，用于表示整个网络的结构外貌，反映各结点之间的结构关系。</p>
<p>常用的网络拓扑结构有：</p>
<ul>
<li>
<p>总线型结构：</p>
<p><picture><img class="img-fluid " alt="总线型结构" src="/docs/ruan-she/computer-nework/uTools_1683875429976.png" loading="lazy" width="223" height="139" />
</picture>

</p>
</li>
<li>
<p>星型结构：</p>
<p><picture><img class="img-fluid " alt="星型结构" src="/docs/ruan-she/computer-nework/uTools_1683875460651.png" loading="lazy" width="198" height="164" />
</picture>

</p>
</li>
<li>
<p>环型结构：</p>
<p><picture><img class="img-fluid " alt="环型结构" src="/docs/ruan-she/computer-nework/uTools_1683875485913.png" loading="lazy" width="166" height="157" />
</picture>

</p>
</li>
<li>
<p>树型结构：</p>
<p><picture><img class="img-fluid " alt="树型结构" src="/docs/ruan-she/computer-nework/uTools_1683875508387.png" loading="lazy" width="184" height="141" />
</picture>

</p>
</li>
<li>
<p>分布式结构：</p>
<p><picture><img class="img-fluid " alt="分布式结构" src="/docs/ruan-she/computer-nework/uTools_1683875530047.png" loading="lazy" width="164" height="138" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="网络互连设备" data-numberify>网络互连设备<a class="anchor ms-1" href="#网络互连设备"></a></h1>
<p>构建一个实际的网络需要网络的传输介质、网络互连设备作为支持。</p>
<h2 id="网络设备" data-numberify>网络设备<a class="anchor ms-1" href="#网络设备"></a></h2>
<p>按照ISO/OSI的分层将互连设备分类：</p>
<ul>
<li>
<p>物理层设备：</p>
<ul>
<li>中继器（Repeater）</li>
<li>集线器（Hub）：一种多端口的中继器。集线器不能自动寻址，但可以检测发送冲突。</li>
</ul>
</li>
<li>
<p>数据链路层设备：</p>
<ul>
<li>
<p>网桥（Bridge）</p>
</li>
<li>
<p>交换机（Switch）：一种多端口的网桥。</p>
<p>交换技术：</p>
<ul>
<li>端口交换</li>
<li>帧交换</li>
<li>信元交换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络层设备：路由器（Router）</p>
<p><picture><img class="img-fluid " alt="路由器类型" src="/docs/ruan-she/computer-nework/uTools_1683956321797.png" loading="lazy" width="554" height="235" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="各种路由来源的管理距离" src="/docs/ruan-she/computer-nework/uTools_1683956407885.png" loading="lazy" width="554" height="163" />
</picture>

</p>
</li>
<li>
<p>应用层设备：网关（Gateway）</p>
</li>
</ul>
<h2 id="网络传输介质" data-numberify>网络传输介质<a class="anchor ms-1" href="#网络传输介质"></a></h2>
<p>传输介质是信号传输的媒体，常用的介质分为：</p>
<ul>
<li>有线介质：
<ul>
<li>双绞线（Twisted-Pair）</li>
<li>同轴电缆（Coaxial）</li>
<li>光纤（Fiber Optic）</li>
</ul>
</li>
<li>无线介质：
<ul>
<li>微波</li>
<li>红外线和激光</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="网络组件" data-numberify>网络组件<a class="anchor ms-1" href="#网络组件"></a></h2>
<p>在一个局域网中，其基本组成部件为：</p>
<ul>
<li>服务器（Server）</li>
<li>客户端（Client）</li>
<li>网络设备</li>
<li>通信介质</li>
<li>网络软件</li>
</ul>
<hr>
<h1 id="网络协议与标准" data-numberify>网络协议与标准<a class="anchor ms-1" href="#网络协议与标准"></a></h1>
<p>计算机网络中的两个实体，想要成功通信，必须具有相同的语言，在计算机网络中称为协议（规程）。</p>
<p>网络协议指的是网络中的计算机与计算机进行通信时，为了能够实现数据的正常发送与接收必须要遵循的一些事先约定好的规则（标准或约定），在这些规程中明确规定了通信时的数据格式、数据传送时序以及相应的控制信息和应答信号等内容。</p>
<h2 id="网络标准" data-numberify>网络标准<a class="anchor ms-1" href="#网络标准"></a></h2>
<ul>
<li>
<p>电信标准：由国际电信联盟（International Telecommunication Union，ITU）发布的标准，有ITU-T的V系列、X系列等。</p>
</li>
<li>
<p>国际标准：由国际标准化组织（ISO）负责制定。</p>
<p>其他标准化组织：</p>
<ul>
<li>ANSI：美国国家标准研究所，ISO的美国代表。</li>
<li>NIST：美国国家标准和技术研究所，美国商业部的标准化机构。</li>
<li>IEEE：电气和电子工程师协会（Institute of Electrical and Electronics Engineers）。</li>
<li>ElA：电子工业协会（Electronic Industries Association）。</li>
</ul>
</li>
<li>
<p>Internet标准：特点是自发而非政府干预的，管理松散。</p>
<ul>
<li>有民间性质的协会ISOC（Internet Society）进行必要的协调与管理。</li>
<li>有网络信息中心（NIC）来管理IP地址，保证注册地址的唯一性。</li>
<li>ISOC设有nternet总体管理机构结构（IAB）。</li>
</ul>
</li>
</ul>
<h2 id="局域网协议" data-numberify>局域网协议<a class="anchor ms-1" href="#局域网协议"></a></h2>
<p>IEEE 802系列标准己被ISO采纳为国际标准。</p>
<p>局域网的基本组成主要有：</p>
<ul>
<li>网络服务器</li>
<li>网络工作站</li>
<li>网络适配器</li>
<li>传输介质</li>
</ul>
<p>决定局域网特性的主要技术有3个方面：</p>
<ul>
<li>用于传输数据的传输介质；</li>
<li>用于连接各种设备的拓扑结构；</li>
<li>用于共享资源的介质访问控制方法。</li>
</ul>
<h3 id="lan-模型" data-numberify>LAN 模型<a class="anchor ms-1" href="#lan-模型"></a></h3>
<p>在IEEE 802局域网（LAN）标准中只定义了两层：</p>
<ul>
<li>
<p>物理层</p>
</li>
<li>
<p>数据链路层：</p>
<p>根据LAN的特点把数据链路层分成：</p>
<ul>
<li>
<p>逻辑链路控制（Logical Link Control，LLC）子层：</p>
<p>实现网络层中的寻址、排序、流控和差错控制等功能</p>
</li>
<li>
<p>介质访问控制（Medium Access Control，MAC）子层</p>
</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="LAN 层次与 ISO/OSI RM 的对应关系" src="/docs/ruan-she/computer-nework/uTools_1683879193227.png" loading="lazy" width="397" height="252" />
</picture>

</p>
<h3 id="以太网" data-numberify>以太网<a class="anchor ms-1" href="#以太网"></a></h3>
<p>以太网技术采用的“存取方法”是带冲突检测的载波监听多路访问协议（Carrier-Sense Multiple Access with Collision Detection，CSMA/CD）技术。</p>
<p>以太网主要包括3中类型：</p>
<ul>
<li>IEEE 802.3中定义的标准局域网，速度为10Mbps，传输介质为细同轴电缆；</li>
<li>IEEE 802.3u中定义的快速以太网，速度为100Mbps，传输介质为双绞线；</li>
<li>IEEE 802.3z中定义的千兆以太网，速度为1000Mbps，传输介质为光纤或双绞线。</li>
</ul>
<h3 id="令牌环网" data-numberify>令牌环网<a class="anchor ms-1" href="#令牌环网"></a></h3>
<p>IEEE 802.5的介质访问使用的是令牌环控制技术。</p>
<h3 id="fddi" data-numberify>FDDI<a class="anchor ms-1" href="#fddi"></a></h3>
<p>FDDI（Fiber Distributed Data Interface,光纤分布式数据接口）类似令牌环网的协议：</p>
<ul>
<li>用光纤作为传输介质；</li>
<li>采用一种新的编码技术，称为4B/5B编码。</li>
</ul>
<h3 id="无线局域网" data-numberify>无线局域网<a class="anchor ms-1" href="#无线局域网"></a></h3>
<p>无线局域网（WLAN）使用的是带冲突避免的载波侦听多路访问方法（CSMA/CA）。</p>
<h2 id="广域网协议" data-numberify>广域网协议<a class="anchor ms-1" href="#广域网协议"></a></h2>
<p>用于广域网的主要协议有：</p>
<ul>
<li>点对点协议（PPP）</li>
<li>数字用户线（xDSL）</li>
<li>数字专线</li>
<li>帧中继</li>
<li>异步传输模式</li>
<li>X.25 协议</li>
</ul>
<h2 id="tcpip-协议族" data-numberify>TCP/IP 协议族<a class="anchor ms-1" href="#tcpip-协议族"></a></h2>
<p>TCP/IP作为Internet的核心协议，被广泛应用于局域网和广域网中，成为事实上的国际标准。</p>
<p>TCP/IP基本特性的5个表现方面：</p>
<ul>
<li>
<p>逻辑编制：</p>
<p>每台连入Internet的计算机都会被分配一个逻辑地址，即IP地址。</p>
<p>IP地址包括：</p>
<ul>
<li>网络ID号：用来标识网络；</li>
<li>子网ID号：用来标识网络上的一个子网；</li>
<li>主机ID号：用来标识子网上的一台计算机。</li>
</ul>
</li>
<li>
<p>路由选择：定义路由器如何选择网络路径的协议，即IP数据包的路由选择。</p>
</li>
<li>
<p>域名解析：</p>
<p>域名：一种易记的字母式地址结构，也称为DNS（域名服务）名。</p>
<p>将域名映射为IP地址的操作即为域名解析。</p>
<blockquote>
<p>域名较稳定，而IP地址较易发生变化。</p>
</blockquote>
</li>
<li>
<p>错误检测：TPC/IP具有分组交换确保数据信息在网络上可靠传递的特性。</p>
</li>
<li>
<p>流量控制：检测网络系统信息中的信息流量，防止出现网络拥塞，也属于分组交换确保数据信息在网络上可靠传递。</p>
</li>
</ul>
<h3 id="tcpip-分层模型" data-numberify>TCP/IP 分层模型<a class="anchor ms-1" href="#tcpip-分层模型"></a></h3>
<p>TCP/IP分层模型由4个层次构成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p><picture><img class="img-fluid " alt="TCP/IP 模型于 OSI 模型的对比" src="/docs/ruan-she/computer-nework/uTools_1683880948768.png" loading="lazy" width="697" height="339" />
</picture>

</p>
<h3 id="传输层协议-tcp-和-udp" data-numberify>传输层协议 TCP 和 UDP<a class="anchor ms-1" href="#传输层协议-tcp-和-udp"></a></h3>
<p>TCP和UDP都是应用于传输层的网络协议：</p>
<ul>
<li>
<p>TCP（Transmission Control Protocol，传输控制协议）：</p>
<p>在IP提供的不可靠数据服务的基础上为应用程序提供了可靠的、面向连接的、全双工的数据传输服务。</p>
<p>采用三次握手来确认建立和关闭连接是否成功。</p>
<p>TCP的功能或服务有：</p>
<ul>
<li>可靠传输</li>
<li>连接管理</li>
<li>差错校验和重传</li>
<li>流量控制：采用可变大小的滑动窗口协议</li>
<li>拥塞控制</li>
<li>端口寻址</li>
</ul>
</li>
<li>
<p>UDP（User Datagram Protocol，用户数据报协议）：</p>
<p>是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信。</p>
<p>UDP上的应用有VoIP等。</p>
</li>
</ul>
<p>UDP的首部8B，TCP的首部20B，UDP相比TCP来说，开销较小。</p>
<p>TCP和UDP均提供了端口寻址功能。</p>
<h3 id="电子邮件协议-smtp-和-pop3" data-numberify>电子邮件协议 SMTP 和 POP3<a class="anchor ms-1" href="#电子邮件协议-smtp-和-pop3"></a></h3>
<p>SMTP和POP3都使用TCP端口传输和接收邮件。</p>
<p>SMTP：邮件发送协议；常用端口号：25。</p>
<p>SMTP只能传输SACII码文本和文字附件，可以使用MIME邮件扩充协议，添加其他类型的附件。</p>
<p>POP3：邮件接收协议；常用端口号：110。</p>
<p>POP3基于C/S模式（Client/Server模式，客户端/服务器模式）。</p>
<h3 id="arp-和-rarp-协议" data-numberify>ARP 和 RARP 协议<a class="anchor ms-1" href="#arp-和-rarp-协议"></a></h3>
<ul>
<li>
<p>ARP（Address Resolution Protocol，地址解析协议）：将IP地址转换为MAC地址（物理地址）。</p>
<p>IP到MAC地址的转换过程：</p>
<ol>
<li>查询ARP高速缓存中是否有该IP地址</li>
<li>如果该IP地址在ARP高速缓存中，便使用与它对应的MAC地址，将数据报发送给所需的物理网卡</li>
<li>如果ARP高速缓存中没有该IP地址，ARP便在局域网上<u>以广播方式发送一个ARP请求包</u></li>
<li>如果局域网上IP地址与某台计算机中的IP地址相一致，那么该计算机便生成一个ARP应答信息，信息中包含对应的MAC地址</li>
</ol>
</li>
<li>
<p>RARP（反地址解析协议）：将MAC地址转换为IP地址，主要用于无盘工作站。</p>
</li>
</ul>
<h3 id="动态主机配置协议-dhcp" data-numberify>动态主机配置协议 DHCP<a class="anchor ms-1" href="#动态主机配置协议-dhcp"></a></h3>
<p>DHCP协议的功能和作用是：</p>
<ul>
<li>集中的管理、分配IP地址；</li>
<li>使网络环境中的主机动态地获得IP地址、Gateway地址、DNS服务器地址等信息；</li>
<li>提升地址的使用率。</li>
</ul>
<p>DHCP客户端可以从DHCP服务器获得以下内容：</p>
<ul>
<li>本机IP地址</li>
<li>DNS服务器地址</li>
<li>DHCP服务器地址</li>
<li>默认网关的地址</li>
</ul>
<h3 id="无效地址" data-numberify>无效地址<a class="anchor ms-1" href="#无效地址"></a></h3>
<ul>
<li>
<p>Windows无效地址：169.254.X.X</p>
<p>169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。</p>
</li>
<li>
<p>Linux无效地址：0.0.0.0</p>
</li>
</ul>
<h3 id="icmp" data-numberify>ICMP<a class="anchor ms-1" href="#icmp"></a></h3>
<p>ICMP（Internet Control Message Protocol，Internet控制信息协议）是一种用于发送差错报文的协议。IP传送的数据报可能丢失、重复、延迟或乱序，而ICMP就是这样一种避免差错并在发生差错时报告的机制。</p>
<p>ICMP定义了5种差错报文：</p>
<ul>
<li>源抑制</li>
<li>超时</li>
<li>目的不可达</li>
<li>重定向</li>
<li>要求分段</li>
</ul>
<p>还定义了4种信息报文：</p>
<ul>
<li>回应请求</li>
<li>回应应答</li>
<li>地址屏蔽码请求</li>
<li>地址屏蔽码应答</li>
</ul>
<p>IP在需要一个差错报文时要使用ICMP，而ICMP也是利用IP来传送报文。</p>
<p>ICMP可以用于测试因特网，如ping工具就是利用ICMP报文进行目标是否可达测试。</p>
<hr>
<h1 id="internet-地址" data-numberify>Internet 地址<a class="anchor ms-1" href="#internet-地址"></a></h1>
<p>Internet地址格式主要有两种书写形式：</p>
<ul>
<li>域名</li>
<li>IP地址</li>
</ul>
<h2 id="域名" data-numberify>域名<a class="anchor ms-1" href="#域名"></a></h2>
<p>域名（Domain Name）：通常是用户所用主机的名字或地址。</p>
<p>域名格式由若干部分组成，每个部分又称子域名（用<code>.</code>分开，最少由两个字母或数字组成）。</p>
<p>通常，一个完整、通用的层次型主机域名由以下4个部分组成：</p>
<pre tabindex="0"><code>主机名.本地名.组名.最高层域名
</code></pre><p>也可以理解为：</p>
<pre tabindex="0"><code>主机名.域名.域名后缀.域名分类
</code></pre><p><picture><img class="img-fluid " alt="域名分类及其含义" src="/docs/ruan-she/computer-nework/uTools_1683894526429.png" loading="lazy" width="554" height="180" />
</picture>

</p>
<p>如果一个主机所在的网络级别较高，它可能拥有的域名仅包含3部分：</p>
<pre tabindex="0"><code>本地名.组名.最高层域名
</code></pre><h2 id="url" data-numberify>URL<a class="anchor ms-1" href="#url"></a></h2>
<p>URL即统一资源定位器（统一资源定位符），它的形式如下：</p>
<pre tabindex="0"><code>协议名://主机名.域名.域名后缀.域名分类/目录/网页文件
</code></pre><h2 id="ip-地址" data-numberify>IP 地址<a class="anchor ms-1" href="#ip-地址"></a></h2>
<p>IP地址：Internet中的主机地址实际上是用IP地址来唯一标识的。</p>
<p>IP地址有两种：</p>
<ul>
<li>IPv4</li>
<li>IPv6</li>
</ul>
<blockquote>
<p>通常IP地址是指IPv4。</p>
</blockquote>
<h3 id="ipv4" data-numberify>IPv4<a class="anchor ms-1" href="#ipv4"></a></h3>
<p>每个IPv4地址都由4个小于256的数字组成（每个数字8位，共32位），数字之间用<code>.</code>分开，可分为5类：</p>
<p><picture><img class="img-fluid " alt="IPv4各类地址分配方案" src="/docs/ruan-she/computer-nework/uTools_1683896541328.png" loading="lazy" width="484" height="412" />
</picture>

</p>
<p>在IPv4中，全<code>0</code>代表的是网络，全<code>1</code>代表的是广播。</p>
<p>IPv4能表示的地址个数为：</p>
<p>$$
2^{32} \approx 40亿
$$</p>
<h3 id="子网掩码" data-numberify>子网掩码<a class="anchor ms-1" href="#子网掩码"></a></h3>
<p>网络软件和路由器使用<strong>子网掩码</strong>（Subnet Mask）来识别报文是仅存放在网络内部还是被路由转发到其他地方。</p>
<p>子网掩码是用来指明特定的IP地址中的网络号和主机号部分。子网掩码的格式与IP地址相同：</p>
<ul>
<li>所有对应网络号的部分用<code>1</code>填上；</li>
<li>所有对应主机号的部分用<code>0</code>填上。</li>
</ul>
<p><picture><img class="img-fluid " alt="IP地址类默认的子网掩码" src="/docs/ruan-she/computer-nework/uTools_1683897195900.png" loading="lazy" width="912" height="144" />
</picture>

</p>
<h3 id="ipv6" data-numberify>IPv6<a class="anchor ms-1" href="#ipv6"></a></h3>
<p>IPv6具有长达128位的地址空间，可以彻底解决IPv4地址不足的问题。</p>
<p>IPv6理论上能表示的地址个数：</p>
<p>$$
2^{128} = 3.4 \times 10^{38}
$$</p>
<blockquote>
<p>在想象得到的将来，IPv6的地址空间是不可能用完的。</p>
</blockquote>
<h2 id="dns-域名解析" data-numberify>DNS 域名解析<a class="anchor ms-1" href="#dns-域名解析"></a></h2>
<p>Internet中的域名地址和IP地址是等价的，它们之间是通过域名服务（DNS域名解析）来完成映射变换的。</p>
<p>DNS是一种分布式地址信息数据库系统，服务器中包含整个数据库的某部分信息，并供客户查询。DNS允许局部控制整个数据库的某些部分，但数据库的每一部分都可通过全网查询得到。</p>
<p>域名系统采用的是客户端/服务器模式，整个系统由以下两部分组成：</p>
<p>解析器和域名服务器组成。</p>
<ul>
<li>
<p>解析器（客户端）：</p>
<p>负责：</p>
<ul>
<li>查询域名服务器</li>
<li>解释从服务器返回来的应答</li>
<li>将信息返回给请求方</li>
</ul>
</li>
<li>
<p>域名服务器（服务器）：通常保存着一部分域名空间的全部信息，这部分域名空间称为区（Zone）。</p>
<p>一个域名服务器可以管理一个或多个区。</p>
<p>域名服务器可以分为：</p>
<ul>
<li>主服务器</li>
<li>Caching Only服务器</li>
<li>转发服务器（Forwarding Server）</li>
</ul>
<p>主域名服务器在接收到域名请求后，查询顺序如下：</p>
<ol>
<li>本地缓存：缓存在该服务器中的域名信息。如果先前有多个用户对该域名进行访问，域名服务器会根据需要对该域名的信息进行缓存，以便加快后续用户访问的速度。</li>
<li>本地<code>hosts</code>文件：存储在服务器中的一种记录域名与其对应IP的文件。在PC中也有这样的文件存在。</li>
<li>本地数据库：存储域名信息的数据库。</li>
<li>转发域名服务器：如果用户访问的域名在以上内容中都不存在时，域名服务器会根据访问的域名，到对应的其他域名服务器中查询。</li>
</ol>
</li>
</ul>
<p>用户A查找用户B时，域名系统工作过程如：</p>
<ol>
<li>解析器向本地域名服务器发出请求查阅用户B的域名。</li>
<li>本地域名服务器向最高层域名服务器发出查询地址的请求。</li>
<li>最高层域名服务器返回给本地域名服务器一个IP地址。</li>
<li>本地域名服务器向组域名服务器发出查询地址的请求。</li>
<li>组域名服务器返回给本地域名服务器一个IP地址。</li>
<li>本地服务器向刚返回的域名服务器发出查询域名地址请求。</li>
<li>P地址返回给本地域名服务器。</li>
<li>本地域名服务器将该地址返回给解析器。</li>
</ol>
<p>因此，在访问主机的时候只需要知道域名，通过DNS服务器将域名变换为IP地址。</p>
<p>DNS所用的是UDP端口，端口号为53。</p>
<p>在浏览器中访问网站时，通常是使用服务方的域名进行访问。在计算机上使用域名访问内容，本地计算机并不会直接去DNS服务器查询，而是会先在本地查询该域名。计算机使用域名访问时，域名查询的顺序是：</p>
<ol>
<li>本地<code>hosts</code>文件：存储在计算机电脑中的一个文件，例如<code>localhost</code>就是在本地<code>hosts</code>文件中与本地IP<code>127.0.0.1</code>对应。</li>
<li>本地DNS缓存：先前访问的域名与其对应的IP等信息会被计算机缓存在本地中，如果本地中有该域名的缓存，那便无须访问DNS服务器。</li>
<li>本地DNS服务器。</li>
<li>根域名服务器。</li>
</ol>
<p>当在Wb浏览器的地址栏中输入某URL并按下回车，则处理过程如下：</p>
<ol>
<li>对URL进行DNS域名解析，得到对应的IP地址；</li>
<li>根据这个IP，找到对应的服务器，发起TCP连接，进行三次握手：</li>
<li>建立TCP连接后发起HTTP请求；</li>
<li>服务器响应HTTP请求，浏览器得到HTML代码；</li>
<li>通信完成，断开TCP连接；</li>
<li>浏览器解析HTML代码，并请求HTML代码中的资源（如s、css图片等）；</li>
<li>浏览器将页面呈现给用户。</li>
</ol>
<hr>
<h1 id="无线通信技术" data-numberify>无线通信技术<a class="anchor ms-1" href="#无线通信技术"></a></h1>
<p>流行的无线通信技术有WiFi、蓝牙等。</p>
<p>其中，蓝牙覆盖范围最小、通信距离最短。</p>
<hr>
<h1 id="ipconfig-命令" data-numberify>ipconfig 命令<a class="anchor ms-1" href="#ipconfig-命令"></a></h1>
<p>ipconfig是Windows中，调试计算机网络常用的命令（软件），类似于Linux中的ifconfig。</p>
<p>ipconfig命令的用法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无参数</td>
<td style="text-align:left">显示所有网络适配器的IP地址、子网掩码和缺省网关值</td>
<td style="text-align:left"><code>ipconfig</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/all</code></td>
<td style="text-align:left">显示所有网络适配器的完整TCP/IP配置信息，包括DHCP服务是否已启动</td>
<td style="text-align:left"><code>ipconfig /all</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/displaydns</code></td>
<td style="text-align:left">显示本地DNS内容</td>
<td style="text-align:left"><code>ipconfig /displaydns</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/flushdns</code></td>
<td style="text-align:left">清除本地DNS缓存内容</td>
<td style="text-align:left"><code>ipconfig /flushdns</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/registerdns</code></td>
<td style="text-align:left">DNS客户端手工向服务器进行注册</td>
<td style="text-align:left"><code>ipconfig /registerdns</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/release</code></td>
<td style="text-align:left">DHCP客户端手工释放IP地址</td>
<td style="text-align:left"><code>ipconfig /release</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/renew</code></td>
<td style="text-align:left">DHCP客户端手工向服务器刷新请求（重新申请IP地址）</td>
<td style="text-align:left"><code>ipconfig /renew</code></td>
</tr>
</tbody>
</table>
<hr>
<h1 id="网络信息安全" data-numberify>网络信息安全<a class="anchor ms-1" href="#网络信息安全"></a></h1>
<p>网络存在的威胁主要表现在以下5方面：</p>
<ul>
<li>非授权访问</li>
<li>信息泄露或丢失</li>
<li>破坏数据完整性</li>
<li>拒绝服务攻击</li>
<li>利用网络传播病毒</li>
</ul>
<p>网络安全控制技术主要有：</p>
<ul>
<li>防火墙技术</li>
<li>加密技术</li>
<li>用户识别技术</li>
<li>访问控制技术</li>
<li>网络反病毒技术</li>
<li>网络安全漏洞扫描技术</li>
<li>入侵检测技术</li>
</ul>
<blockquote>
<p>要保护网络安全除了网络安全措施（使用网络安全控制技术）之外，还有：</p>
<ul>
<li>物理线路安全措施：例如设备防雷。</li>
<li>系统安全措施：例如漏洞发现与补丁管理。</li>
</ul>
</blockquote>
<h2 id="防火墙技术" data-numberify>防火墙技术<a class="anchor ms-1" href="#防火墙技术"></a></h2>
<p>防火墙（Firewall）是<u>建立在内外网络边界上的过滤封锁机制</u>，它认为：</p>
<ul>
<li><u>内部网络是安全和可信赖的</u>；</li>
<li><u>外部网络是不安全和不可信赖的</u>。</li>
</ul>
<p>防火墙是网络安全体系的基础和核心控制设施，同时也承担着繁重的通信任务。</p>
<p>防火墙的作用：<u>防止不希望的、未经授权地进出被保护的内部网络。</u></p>
<p>防火墙对通过受控干线的任何通信行为进行安全处理，如：</p>
<ul>
<li><strong>控制</strong></li>
<li><strong>审计</strong></li>
<li><strong>报警</strong></li>
<li><strong>反应</strong></li>
</ul>
<p>防火墙技术经历了三个发展阶段：</p>
<ol>
<li>包过滤防火墙</li>
<li>应用代理网关防火墙</li>
<li>状态检测技术防火墙</li>
</ol>
<h3 id="包过滤防火墙" data-numberify>包过滤防火墙<a class="anchor ms-1" href="#包过滤防火墙"></a></h3>
<p>包过滤防火墙一般有一个包检查块（通常称为包过滤器），数据包过滤可以根据数据包头中的各项信息来控制以下内容之间的相互访问：</p>
<ul>
<li>站点与站点</li>
<li>站点与网络</li>
<li>网络与网络</li>
</ul>
<p>包过滤防火墙无法控制传输数据的内容，因为内容是应用层数据，而<u>包过滤器处在网络层和数据链路层（即TCP和P层）之间</u>。</p>
<p>通过检查模块，防火墙能够拦截和检查所有出站和进站的数据，其过程如下：</p>
<ol>
<li>打开包</li>
<li>取出包头</li>
<li>根据包头的信息确定该包是否符合包过滤规则</li>
<li>对过滤进行记录</li>
<li>对于不符合规则的包，进行报警并丢弃该包</li>
</ol>
<p>过滤型防火墙的<strong>优点</strong>：</p>
<ul>
<li><u>对用户完全透明，速度较快</u>（通常直接转发报文）；</li>
<li>对每条传入和传出网络的包<u>实行低水平控制</u>；</li>
<li><u>每个IP包的字段都被检查</u>，例如：
<ul>
<li><strong>源地址，</strong></li>
<li><strong>目的IP地址，</strong></li>
<li><strong>协议，</strong></li>
<li><strong>端口；</strong></li>
</ul>
</li>
<li>可以识别和丢弃带欺骗性源IP地址的包；</li>
<li>包过滤防火墙是两个网络之间访问的唯一来源；</li>
<li>包过滤通常被包含在路由器数据包中，所以不需要额外的系统来处理这个特征。</li>
</ul>
<p>过滤型防火墙的<strong>缺点</strong>：</p>
<ul>
<li><u>不能防范黑客攻击</u>，因为网管不可能区分出可信网络与不可信网络的界限；</li>
<li><u>不支持应用层协议</u>，因为它不识别数据包中的应用层协议，访问控制粒度太粗糙；</li>
<li><u>不能处理新的安全威胁。</u></li>
</ul>
<h3 id="应用代理网关防火墙" data-numberify>应用代理网关防火墙<a class="anchor ms-1" href="#应用代理网关防火墙"></a></h3>
<p>应用代理网关防火墙<u>彻底隔断内网与外网的直接通信</u>：<u>内网用户对外网的访问变成防火墙对外网的访问</u>，然后再由防火墙转发给内网用户。<u>所有通信都必须经应用层代理软件转发，访问者任何时候都不能与服务器建立直接的TCP连接</u>，应用层的协议会话过程必须符合代理的安全策略要求。</p>
<p>应用代理网关的优点：</p>
<ul>
<li>可以检查应用层、传输层和网络层的协议特征；</li>
<li>对数据包的检测能力比较强。</li>
</ul>
<p>应用代理网关的缺点：</p>
<ul>
<li>难以配置；</li>
<li>处理速度非常慢。</li>
</ul>
<h3 id="状态检测技术防火墙" data-numberify>状态检测技术防火墙<a class="anchor ms-1" href="#状态检测技术防火墙"></a></h3>
<p>状态检测技术防火墙<u>结合了代理防火墙的安全性和包过滤防火墙的高速度等优点</u>，在不损失安全性的基础上，提高了代理防火墙的性能。</p>
<h2 id="入侵检测与防御" data-numberify>入侵检测与防御<a class="anchor ms-1" href="#入侵检测与防御"></a></h2>
<p>入侵检测系统（Intrusion Detection System，DS）作为防火墙之后的第二道安全屏障，通过从计算机系统或网络中的若干关键点收集网络的安全日志、用户的行为、网络数据包和审计记录等信息并对其进行分析，从中检查是否有违反安全策略的行为和遭到入侵攻击的迹象。入侵检测系统根据检测结果，自动做出响应。</p>
<p>入侵检测系统有效的弥补了防火墙系统对网络上的入侵行为无法识别和检测的不足。</p>
<p>入侵防御系统（IPS）是在入侵检测系统的基础上发展起来的，入侵防御系统不仅能够检测到网络中的攻击行为，同时主动的对攻击行为能够发出响应，对攻击进行防御。两者相较，主要存在以下区别：</p>
<ul>
<li>在网络中的部署位置的不同；</li>
<li>入侵响应能力的不同。</li>
</ul>
<h2 id="网络攻击" data-numberify>网络攻击<a class="anchor ms-1" href="#网络攻击"></a></h2>
<p>网络攻击是攻击者针对特定目标实施的有特定目的的活动，攻击目标对于攻击者是个黑盒子。</p>
<p>常见的网络攻击手段有：</p>
<ul>
<li>
<p>拒绝服务攻击（Dos攻击）：目的是使计算机或网络无法提供正常的服务。</p>
<p>拒绝服务攻击是不断向计算机发起请求来实现的。</p>
</li>
<li>
<p>重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的。</p>
<p>攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新发送给认证服务器。</p>
<p>重放攻击主要用于身份认证过程，目的是破坏认证的正确性。</p>
</li>
<li>
<p>口令入侵攻击：使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。</p>
</li>
<li>
<p>特洛伊木马：被伪装成程序或游戏，当用户下载了带有木马的软件或附件时，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动。</p>
</li>
<li>
<p>端口欺骗攻击：采用端口扫描找到系统漏洞从而实施攻击。</p>
</li>
<li>
<p>网络监听：攻击者可以接收某一网段在同一条物理通道上传输的所有信息，使用网络监听可以轻松截取包括账号和口令在内的信息资料。</p>
</li>
<li>
<p>IP欺骗攻击：产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。</p>
</li>
<li>
<p>SQL注入攻击：是黑客对数据库进行攻击的常用手段之一。</p>
<p>SQL注入产生的原因：</p>
<ul>
<li>没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</li>
<li>攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，</li>
<li>获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等。</li>
</ul>
</li>
</ul>
<p>入侵检测技术：</p>
<ul>
<li>专家系统</li>
<li>模型检测</li>
<li>简单匹配</li>
</ul>
<h2 id="病毒" data-numberify>病毒<a class="anchor ms-1" href="#病毒"></a></h2>
<p>计算机病毒（Computer Virus）是指编制者在计算机程序中插入的<u>破坏计算机功能或者数据的代码</u>，能影响计算机使用，<u>能自我复制</u>的一组计算机<u>指令或者程序代码</u>。</p>
<p>计算机病毒的特征包括：</p>
<ul>
<li>传播性</li>
<li>隐蔽性</li>
<li>感染性</li>
<li>潜伏性</li>
<li>触发性</li>
<li>破坏性</li>
</ul>
<p>常见的病毒类型有：</p>
<ul>
<li>
<p>Worm（蠕虫病毒）：</p>
<ul>
<li>欢乐时光，</li>
<li>熊猫烧香，</li>
<li>红色代码，</li>
<li>爱虫病毒，</li>
<li>震网。</li>
</ul>
</li>
<li>
<p>Trojan（特洛伊木马）：通过内部发起连接与外部主机建立联系，由外部主机控制并盗取用户信息。</p>
<p>计算机感染特洛伊木马后的典型线型是<u>有未知程序试图建立网络连接</u>。</p>
<p>常见的木马如冰河。</p>
</li>
<li>
<p>Backdoor（后门病毒）。</p>
</li>
<li>
<p>Macro（宏病毒）：</p>
<p>宏病毒感染的对象主要是<u>文本文档</u>、<u>电子表格</u>等。</p>
</li>
</ul>
<h2 id="网络安全" data-numberify>网络安全<a class="anchor ms-1" href="#网络安全"></a></h2>
<ul>
<li>
<p>SSL（Secure Socket Layer，安全套接层）：传输层安全协议，用于实现Web安全通信。</p>
<p>SSL常用端口号为443。</p>
</li>
<li>
<p>TLS（Transport Layer Security，传输层安全协议：建立在SSL3.0协议规范之上，是SSL3.0的后续版本。</p>
</li>
<li>
<p>SSH（Secure Shell）：终端设备与远程站点之间建立安全连接的协议，是建立在应用层和传输层基础上的安全协议。</p>
<p>SSH是专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。</p>
<p>SSH最初是UNIX上的程序，后来又迅速扩展到其他操作平台（如Linux、Windows）。</p>
</li>
<li>
<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）：是以安全为目标的HTTP通道，即使用SSL加密算法的HTTP。</p>
</li>
<li>
<p>MME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）：是一个互联网标准，扩展了电子邮件标准。</p>
</li>
<li>
<p>PGP（Pretty Good Privacy，优良保密协议）：是一个基于RSA公匙加密体系的邮件加密软件。</p>
<p>可以用它对邮件保密以防止非授权者阅读，还能对邮件加上数字签名从而使收信人可以确认邮件的发送方。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>软件工程篇</title>
      <link>/docs/ruan-she/software-engineering/</link>
      <pubDate>Mon, 08 May 2023 10:02:34 +0000</pubDate>
      
      <guid>/docs/ruan-she/software-engineering/</guid>
      <description><![CDATA[概述 软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软]]></description>
      <content:encoded><![CDATA[<h1 id="概述" data-numberify>概述<a class="anchor ms-1" href="#概述"></a></h1>
<p>软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。</p>
<p>软件工程学：</p>
<ul>
<li>软件开发技术
<ul>
<li>软件开发方法学</li>
<li>软件工具</li>
<li>软件工程环境</li>
</ul>
</li>
<li>软件工程管理
<ul>
<li>软件工程管理学</li>
<li>软件经济学</li>
</ul>
</li>
</ul>
<p>软件工程涉及软件开发、维护、管理等多方面的原理、方法、工具与环境。</p>
<h2 id="计算机软件" data-numberify>计算机软件<a class="anchor ms-1" href="#计算机软件"></a></h2>
<p>计算机软件是指：</p>
<ul>
<li>
<p>计算机系统中的程序：计算任务的处理对象和处理规则的描述。</p>
<ul>
<li>
<p>计算任务：任何以计算机为处理工具的任务。</p>
</li>
<li>
<p>处理对象：</p>
<ul>
<li>数据：如数字、文字、图形、图像、声音等，它们只是表示，而无含义。</li>
<li>信息：数据及有关的含义。</li>
</ul>
</li>
<li>
<p>处理规则：一般指处理的动作和步骤。</p>
</li>
</ul>
</li>
<li>
<p>程序文档：文档是为了便于了解程序所需的阐述性资料。</p>
</li>
</ul>
<p>按照软件的应用领域，可以将计算机软件分为十大类：</p>
<ul>
<li>系统软件</li>
<li>应用软件</li>
<li>工程/科学软件</li>
<li>嵌入式软件</li>
<li>产品线软件</li>
<li>Web应用</li>
<li>人工智能软件</li>
<li>开放计算</li>
<li>网络资源</li>
<li>开源软件</li>
</ul>
<h2 id="软件生存周期" data-numberify>软件生存周期<a class="anchor ms-1" href="#软件生存周期"></a></h2>
<ol>
<li>可行性分析与项目开发计划</li>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计</li>
<li>编码</li>
<li>测试</li>
<li>维护</li>
</ol>
<hr>
<h1 id="软件过程模型" data-numberify>软件过程模型<a class="anchor ms-1" href="#软件过程模型"></a></h1>
<p>软件开发中所遵循的路线图（一系列可预测的步骤）称为“软件过程”。过程是活动的集合，活动是任务的集合。</p>
<p>软件过程有3层含义：</p>
<ul>
<li>个体含义</li>
<li>整体含义</li>
<li>工程含义</li>
</ul>
<h2 id="能力成熟度模型" data-numberify>能力成熟度模型<a class="anchor ms-1" href="#能力成熟度模型"></a></h2>
<p>软件过程能力成熟度模型（Capability Maturity Model of Software，CMM）是对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步提高。</p>
<p>能力成熟度模型使软件组织能够较容易地确定其当前过程的成熟度并识别其软件过程执行中的薄弱环节，确定对软件质量和过程改进最为关键的几个问题，从而形成对其过程的改进策略。</p>
<p>CMM将软件过程改进分为以下5个成熟度级别：</p>
<ol>
<li>
<p><strong>初始级</strong>（Initial）：</p>
<p>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤。</p>
</li>
<li>
<p><strong>可重复级</strong>（Repeatable）：</p>
<p>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性；建立了有必要的过程准则来重复以前在同类项目中的成功。</p>
</li>
<li>
<p><strong>已定义级</strong>（Defined）：</p>
<p>管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</p>
</li>
<li>
<p><strong>己管理级</strong>（Managed）：</p>
<p>制定了软件过程和产品质量的详细度量标准。软件过程和产品质量都被开发组织的成员所理解和控制。</p>
</li>
<li>
<p><strong>优化级</strong>（Optimized）：</p>
<p>加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</p>
</li>
</ol>
<h2 id="能力成熟度模型集成" data-numberify>能力成熟度模型集成<a class="anchor ms-1" href="#能力成熟度模型集成"></a></h2>
<p>能力成熟度模型集成（CMMI）是若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率</p>
<p>CMMI提供了两种表示方法：</p>
<ul>
<li>
<p><strong>阶段式模型</strong>：</p>
<p>结构类以于CMM，它<u>关注组织的成熟度</u>。</p>
<p>CMMI-SE/SW/IPPD 1.1版中有5个成熟度等级：</p>
<ol>
<li><strong>初始的</strong>：过程不可预测且缺乏控制。</li>
<li><strong>己管理的</strong>：过程为项目服务。</li>
<li><strong>已定义的</strong>：过程为组织服务。</li>
<li><strong>定量管理的</strong>：过程已度量和控制。</li>
<li><strong>优化的</strong>：集中于过程改进。</li>
</ol>
</li>
<li>
<p><strong>连续式模型</strong>：</p>
<p>关注每个<u>过程域的能力</u>，一个组织对不同的过程域可以达到不同的过程域<strong>能力等级</strong>（Capability Level，<strong>CL</strong>）。</p>
<p>能力等级包括：</p>
<ul>
<li>共性目标</li>
<li>共性实践</li>
</ul>
<p>能力等级可以独立地应用于任何单独的过程域，任何一个能力等级都必须满足比它等级低的能力等级的所有准则。</p>
<p>CMMI中包括6个过程域能力等级（0~5）：</p>
  <ol start="0">
  <li>
      $CL_0$（未完成的）：
      <br>
      过程域<u>未执行</u>或<u>未得到$CL_1$中定义的所有目标</u>。
  </li>
  <li>
      $CL_1$（已执行的）：
      <br>
      其共性目标是<u>过程将可标识的输入工作产品转换成可标识的输出工作产品</u>，以<u>实现支持过程域的特定目标</u>。
      <br>
      关注于<u>过程域的特定目标的完成</u>。
  </li>
  <li>
      $CL_2$（已管理的）：
      <br>
      其共性目标集中于<u>已管理的过程的制度化</u>。
      <br>
      关注于<u>针对单个过程实例的能力</u>。
  </li>
  <li>
      $CL_3$（已定义级的）：
      <br>
      其共性目标集中于<u>已定义的过程的制度化</u>。
      <br>
      关注于<u>过程的组织级标准化和部署</u>。
  </li>
  <li>
      $CL_4$（定量管理的）：
      <br>
      其共性目标集中于<u>可定量管理的过程的制度化</u>。
      <br>
      使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。
  </li>
  <li>
      $CL_5$（优化的）：
      <br>
      使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。
      <br>
      其共性目标集中于<u>优化的过程的制度化</u>，表明<u>过程得到很好地执行</u>且<u>持续得到改进</u>。
  </li>
  </ol>
</li>
</ul>
<h2 id="瀑布模型" data-numberify>瀑布模型<a class="anchor ms-1" href="#瀑布模型"></a></h2>
<p>瀑布模型（Waterfall Model）是<u>将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型</u>（它规定了<u>由前至后、相互衔接的固定次序，如同瀑布流水逐级下落</u>），包括：</p>
<ul>
<li><strong>需求分析</strong>：</li>
<li><strong>设计</strong></li>
<li><strong>编码</strong></li>
<li><strong>测试</strong></li>
<li><strong>运行与维护</strong>（运维）</li>
</ul>
<p><picture><img class="img-fluid " alt="瀑布模型" src="/docs/ruan-she/software-engineering/uTools_1683592633324.png" loading="lazy" width="380" height="289" />
</picture>

</p>
<p>瀑布模型假设：<u>一个待开发的系统需求是完整的、简明的、一致的</u>，而且<u>可以先于设计和实现完成之前产生</u>。</p>
<p>瀑布模型：</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>容易理解；</li>
<li>管理成本低；</li>
<li>每个阶段都有对应的成果产物；</li>
<li>各个阶段有明显的界限划分和顺序需求；</li>
<li>强调开发的阶段性早期计划及需求调查和产品测试。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>需要客户能够完整、正确和清晰地表达自己的需要；</p>
</li>
<li>
<p>在开始的两个或3个阶段中，很难评估真正的进度状态；</p>
</li>
<li>
<p>当接近项目结束时，出现了大量的集成和测试工作；</p>
</li>
<li>
<p>直到项目结束之前，都不能演示系统的能力；</p>
</li>
<li>
<p>一旦发生错误，整个项目要推到重新开始。</p>
<p>需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。</p>
</li>
</ul>
</li>
</ul>
<p>瀑布模式适合用于：</p>
<ul>
<li><u>开发需求明确</u>的，<u>需求大致固定且不会随意变更</u>的系统；</li>
<li>开发人员对软件的应用领域很熟悉；</li>
<li>开发工作对用户参与的要求很低。</li>
</ul>
<h2 id="v模型" data-numberify>V模型<a class="anchor ms-1" href="#v模型"></a></h2>
<p>V模型式是瀑布模型的一个变体，<u>描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系</u>。</p>
<p><picture><img class="img-fluid " alt="V模型" src="/docs/ruan-she/software-engineering/uTools_1683593148604.png" loading="lazy" width="492" height="423" />
</picture>

</p>
<ul>
<li>
<p>设计、开发：随着软件团队工作沿着<u>V模型左侧步骤向下推进</u>，<u>基本问题需求逐步细化</u>，形成问题及解决方案的技术描述。</p>
</li>
<li>
<p>测试：一旦编码结束，团队沿着<u>V模型右侧的步骤向上推进</u>。</p>
<p>其实际上是<u>执行了一系列测试</u>（质量保证活动），这些测试<u>验证了团队沿着V模型左侧步骤向下推进过程中所生成的每个模型</u>。</p>
</li>
</ul>
<p>V模型是一种测试的开发模型，强调测试贯穿项目的始终，而不是集中在测试阶段。V模型提供了一种将验证确认活动（测试）应用于早期软件工程工作中的方法。</p>
<h2 id="增量模型" data-numberify>增量模型<a class="anchor ms-1" href="#增量模型"></a></h2>
<p>增量模型（Incremental Model）融合了<u>瀑布模型的基本成分</u>和<u>原型实现的迭代特征</u>。</p>
<p>增量模型<u>假设可以将需求分段为一系列增量产品，每一增量可以分别开发</u>。该模型采用<u>随着日程时间的进展而交错的线性序列</u>，每一个线性序列产生软件的一个可发布的“增量”：</p>
<p><picture><img class="img-fluid " alt="增量模型" src="/docs/ruan-she/software-engineering/uTools_1683593818710.png" loading="lazy" width="747" height="325" />
</picture>

</p>
<ul>
<li>从分析到测试为一个增量的过程（线性序列）。</li>
<li><u>核心功能先完成</u>：第1个增量往往是核心的产品。</li>
<li>客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。</li>
<li>增量模型强调<u>每一个增量均发布一个可操作的产品</u>。</li>
</ul>
<p>增量模型作为<u>瀑布模型的一个变体</u>，具有瀑布模型的所有优点。此外，它还有以下优点：</p>
<ul>
<li><u>第一个可交付版本所需要的成本和时间很少</u>；</li>
<li><u>开发由增量表示的小系统所承担的风险不大</u>；</li>
<li>由于很快发布了第一个版本，因此<u>可以减少用户需求的变更</u>；</li>
<li>优先级高的功能先交付，使得重要的功能经历更多的测试。</li>
<li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果没有对用户的变更要求进行规划，那么<u>产生的初始增量可能会造成后来增量的不稳定</u>；</li>
<li>如果需求不像早期思考的那样稳定和完整，那么<u>一些增量就可能需要重新开发、重新发布</u>；</li>
<li><u>管理发生的成本、进度和配置的复杂性可能会超出组织的能力</u>。</li>
</ul>
<p>量模型适合用于：</p>
<ul>
<li>需要快速构造可运行的产品的项目（对完成期限严格要求的产品）；</li>
<li>进行已有产品升级或新版本开发；</li>
<li>对所开发的领域比较熟悉而且已有原型系统。</li>
</ul>
<h2 id="演化模型" data-numberify>演化模型<a class="anchor ms-1" href="#演化模型"></a></h2>
<p>演化模型（Evolutionary Model）演化模型是<u>迭代的过程模型</u>，使得软件开发人员能够<u>逐步开发出更完整的软件版本</u>。演化模型特别<u>适用于对软件需求缺乏准确认识的情况</u>。</p>
<p>典型的演化模型有原型模型和螺旋模型等。</p>
<h3 id="原型模型" data-numberify>原型模型<a class="anchor ms-1" href="#原型模型"></a></h3>
<p><u>并非所有的需求都能够预先定义</u>。大量的实践表明，在<u>开发初期很难得到一个完整的、准确的需求规格说明</u>。原因有：</p>
<ul>
<li><u>客户往往不能准确地表达对未来系统的全面要求</u>，导致形成的需求规格说明不完整、不准确，甚至是有歧义。</li>
<li>在整个开发过程中，<u>用户可能会产生新的要求，导致需求的变更</u>。</li>
</ul>
<p>瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）这种新的开发方法。</p>
<p>原型模型（Prototype Model）：</p>
<ul>
<li>适合于<u>用户需求不清</u>、<u>需求经常变化</u>的情况；</li>
<li><u>不适合大规模系统的开发</u>。</li>
</ul>
<p>原型的目的是能<u>快速、低成本地构建原型系统</u>。</p>
<p>能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。</p>
<p>开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型:</p>
<p><picture><img class="img-fluid " alt="原型模型" src="/docs/ruan-she/software-engineering/uTools_1683596611929.png" loading="lazy" width="398" height="318" />
</picture>

</p>
<ol>
<li>交流：目的是定义软件的总体目标，标识需求，然后</li>
<li>快速计划：快速制订原型开发的计划，确定原型的目标和范围。</li>
<li>采用快速设计方式进行建模。</li>
<li>构建原型。</li>
<li>部署交付和反馈：被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进。</li>
<li>下一轮迭代：在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发。</li>
</ol>
<p>根据使用原型的目的不同，原型可以分为：</p>
<ul>
<li>探索型原型：目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。</li>
<li>实验型原型：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。</li>
<li>演化型原型：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。</li>
</ul>
<h3 id="螺旋模型" data-numberify>螺旋模型<a class="anchor ms-1" href="#螺旋模型"></a></h3>
<p>对于复杂的大型软件，开发一个原型往往达不到要求。</p>
<p>螺旋模型<u>将瀑布模型和演化模型结合起来</u>，<u>加入了两种模型均忽略的风险分析</u>（以风险为驱动），弥补了这两种模型的不足。</p>
<p>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：</p>
<p><picture><img class="img-fluid " alt="螺旋模型" src="/docs/ruan-she/software-engineering/uTools_1683597373666.png" loading="lazy" width="559" height="482" />
</picture>

</p>
<p>每个螺旋周期分为如下4个工作步骤：</p>
<ol>
<li><strong>制订计划</strong>：
<ol>
<li>确定软件的目标</li>
<li>选定实施方案</li>
<li>明确项目开发的限制条件</li>
</ol>
</li>
<li><strong>风险分析</strong>：
<ol>
<li>分析所选的方案</li>
<li>识别风险</li>
<li>消除风险</li>
</ol>
</li>
<li><strong>实施工程</strong>：
<ol>
<li>实施软件开发</li>
<li>验证阶段性产品</li>
</ol>
</li>
<li><strong>用户评估</strong>：
<ol>
<li>评价开发工作，提出修正建议</li>
<li>建立下一个周期的开发计划</li>
</ol>
</li>
</ol>
<p><u>螺旋模型属于面向对象开发模型。</u></p>
<p>螺旋模型适用于：</p>
<ul>
<li><u>庞大、复杂并且具有高风险的系统</u>；</li>
<li>新近开发，需求不明的情况。</li>
</ul>
<p>优点：</p>
<ul>
<li>螺旋模型<u>强调风险分析</u>，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。</li>
<li>螺旋模型<u>支持用户需求的动态变化</u>，有助于提高软件的适应能力，降低了软件开发的风险。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
<h2 id="喷泉模型" data-numberify>喷泉模型<a class="anchor ms-1" href="#喷泉模型"></a></h2>
<p>喷泉模型（Water Fountain Model）：</p>
<ul>
<li>以用户需求为动力；</li>
<li>以对象作为驱动；</li>
<li><u>适合于面向对象。</u></li>
</ul>
<p>喷泉模型<u>克服了瀑布模型不支持软件重用和多项开发活动集成的局限性</u>。其开发过程如下：</p>
<p><picture><img class="img-fluid " alt="喷泉模型" src="/docs/ruan-she/software-engineering/uTools_1683598210327.png" loading="lazy" width="247" height="361" />
</picture>

</p>
<p>喷泉模型使开发过程具有以下性质或特点：</p>
<ul>
<li>
<p><strong>迭代性</strong>：意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。</p>
</li>
<li>
<p><strong>无间隙性</strong>：指在开发活动（如分析、设计、编码）之间不存在明显的边界。</p>
<p>喷泉不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是<u>允许各开发活动交叉、迭代地进行</u>。</p>
<p>喷泉模型的<u>各个阶段没有明显的界线</u>，开发人员<u>可以同步进行</u>。</p>
</li>
<li>
<p>支持软件重用。</p>
</li>
</ul>
<p>优点：可以提高软件项目的开发效率，节省开发时间。</p>
<p>缺点：</p>
<ul>
<li>由于喷泉模型在各个开发阶段是重叠的，在开发过程中<u>需要大量的开发人员，不利于项目的管理</u>。</li>
<li>喷泉模型<u>要求严格管理文档，使得审核的难度加大</u>。</li>
</ul>
<h2 id="统一过程模型" data-numberify>统一过程模型<a class="anchor ms-1" href="#统一过程模型"></a></h2>
<p>统一过程（UP）模型开发过程的特征：</p>
<ul>
<li>
<p>用例和风险驱动。</p>
</li>
<li>
<p>以架构为中心。</p>
</li>
<li>
<p>迭代并且增量：</p>
<p>迭代：将整个软件开发项目划分为许多个小的“袖珍项目”。</p>
<p>每个“袖珍项目”都包含正常软件项目的所有元素：</p>
<ul>
<li>计划</li>
<li>分析和设计</li>
<li>构造</li>
<li>集成和测试</li>
<li>内部和外部发布</li>
</ul>
</li>
</ul>
<p>统一过程模型由UML（统一建模语言，Unified Modeling Language）方法和工具支持。</p>
<p>统一过程定义了4个技术阶段及其制品，这4个技术阶段由主要里程碑所终止：</p>
<ol>
<li>
<p><strong>起始阶段</strong>（Inception Phase）：</p>
<p>确定项目的风险及其优先次序，并对精化阶段进行详细规划和对整个项目进行粗略计算。</p>
<p>专注于：项目的初创活动。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>构想文档（Vision Document）</li>
<li>初始用例模型</li>
<li>初始项目术语表</li>
<li>初始业务用例</li>
<li>初始风险评估</li>
<li>项目计划（阶段及迭代）业务模型</li>
<li>一个或多个原型（需要时）</li>
</ul>
<p>里程碑：生命周期目标。</p>
</li>
<li>
<p><strong>精化阶段</strong>（Elaboration Phase）：</p>
<p>根据主要的用例描述设计出详细的系统构架。主要是解决用例、构架和计划是否足够稳定可靠，风险释放得到充分控制，以便能够按照合同的规定完成整个开发任务。</p>
<p>精华阶段在理解了最初的领域范围之后进行：</p>
<ul>
<li>需求分析</li>
<li>架构演进</li>
</ul>
<p>关注于：需求分析和架构演进。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>
<p>用例模型</p>
</li>
<li>
<p>补充需求：包括非功能需求</p>
</li>
<li>
<p>分析模型</p>
</li>
<li>
<p>软件体系结构描述</p>
</li>
<li>
<p>可执行的软件体系结构原型</p>
</li>
<li>
<p>初步的设计模型</p>
</li>
<li>
<p>修订的风险列表</p>
</li>
<li>
<p>项目计划：</p>
<p>包括：</p>
<ul>
<li>迭代计划</li>
<li>调整的工作流</li>
<li>里程碑</li>
<li>技术工作产品</li>
</ul>
</li>
<li>
<p>初始用户手册</p>
</li>
</ul>
<p>里程碑：生命周期目标。</p>
</li>
<li>
<p><strong>构建阶段</strong>（Construction Phase）：</p>
<p>将设计实现，并进行测试。</p>
<p>关注系统的构建，产生实现模型。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>设计模型</li>
<li>软件构件</li>
<li>集成的软件增量</li>
<li>测试计划及步骤</li>
<li>测试用例</li>
<li>支持文档：
<ul>
<li>用户手册</li>
<li>安装手册</li>
<li>对于并发增量的描述</li>
</ul>
</li>
</ul>
<p>里程碑：初始运作功能。即一个准备交到最终用户手中的产品。</p>
</li>
<li>
<p><strong>移交阶段</strong>（Transition Phase）：</p>
<p>交由用户测试并迭代完善。</p>
<p>关注于软件提交方面的工作，产生软件增量。</p>
<p>产生的主要工作产品有：</p>
<ul>
<li>提交的软件增量</li>
<li>$\beta$测试报告</li>
<li>综合用户反馈</li>
</ul>
<p>里程碑：产品发布。</p>
<blockquote>
<p>其实还有一个产生阶段，这里包含在了移交阶段中。</p>
</blockquote>
</li>
</ol>
<p>在每次迭代中有5个核心工作流：</p>
<ul>
<li>需求工作流：捕获系统应该做什么；</li>
<li>分析工作流：精华和结构化需求；</li>
<li>设计工作流：在系统架构内实现需求；</li>
<li>实现工作流：构造软件；</li>
<li>测试工作流：验证实现是否如期望那样工作。</li>
</ul>
<blockquote>
<p>统一过程的典型代表是RUP（Rational Unified Process）。</p>
<p>RUP是UP的商业扩展，完全兼容UP，但比UP更完整、更详细。</p>
</blockquote>
<h2 id="敏捷开发" data-numberify>敏捷开发<a class="anchor ms-1" href="#敏捷开发"></a></h2>
<p>敏捷开发（Agile Development）的总体目标是通过<u>“尽可能早地、持续地对有价值的软件的交付”</u>使客户满意。通过在软件开发过程中加入灵活性，敏捷方法<u>使用户能够在开发周期的后期增加或改变需求</u>。</p>
<p>敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了<u>敏捷方法所宣称的理念（敏捷宣言）</u>。</p>
<p>敏捷开发有以下几种方法：</p>
<ul>
<li>极限编程（XP）</li>
<li>水晶法（Crystal）</li>
<li>并列争求法（Scrum）</li>
<li>自适应软件开发（ASD）</li>
<li>敏捷统一过程（AUP）</li>
</ul>
<h3 id="极限编程" data-numberify>极限编程<a class="anchor ms-1" href="#极限编程"></a></h3>
<p>极限编程是为了<u>降低需求变更所带来的成本</u>，旨在<u>提高软件质量和对客户需求变化的适应性</u>，期望能够让软件开发达到低成本、低缺陷、高产出、高回报（最小投入得到最大结果）的效果。</p>
<p>极限编程（XP）软件开发方式有以下性质：</p>
<ul>
<li>轻量级（敏捷）</li>
<li>高效</li>
<li>低风险</li>
<li>柔性</li>
<li>可预测的</li>
<li>科学的</li>
</ul>
<p>XP由价值观、原则、实践和行为4个部分组成，他们之间彼此相互依赖、关联，并通过行为贯穿于整个生存周期：</p>
<ul>
<li>4大价值观：
<ul>
<li>沟通</li>
<li>简单性</li>
<li>反馈</li>
<li>勇气</li>
</ul>
</li>
<li>5个原则：
<ul>
<li>快速反馈</li>
<li>简单性假设</li>
<li>逐步修改</li>
<li>提倡更改</li>
<li>优质工作</li>
</ul>
</li>
<li>12个最佳实践：
<ul>
<li>计划游戏：快速制定计划、随着细节的不断变化而完善</li>
<li>小型发布：系统的设计要能够尽可能早地交付</li>
<li>隐喻：找到合适的比喻传达信息</li>
<li>简单设计：只处理当前的需求，使设计保持简单</li>
<li>测试先行：先写测试代码，然后再编写程序</li>
<li>重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求</li>
<li>结对编程</li>
<li>集体代码所有制</li>
<li>持续集成：可以按日甚至按小时为客户提供可运行的版本</li>
<li>每周工作40个小时</li>
<li>现场客户</li>
<li>编码标准</li>
</ul>
</li>
</ul>
<h3 id="敏捷统一过程" data-numberify>敏捷统一过程<a class="anchor ms-1" href="#敏捷统一过程"></a></h3>
<p>敏捷统一过程（Agile Unified Process，AUP）采用以下原理来构建软件系统：</p>
<ul>
<li>“在大型上连续”</li>
<li>“在小型上迭代”。</li>
</ul>
<p>采用经典的UP阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。</p>
<p>在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个AUP迭代执行以下活动：</p>
<ul>
<li><strong>建模</strong>：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。</li>
<li><strong>实现</strong>：将模型翻译成源代码。</li>
<li><strong>测试</strong>：像XP一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。</li>
<li><strong>部署</strong>：对软件增量的交付以及获取最终用户的反馈。</li>
<li><strong>配置及项目管理</strong>：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。</li>
<li><strong>环境管理</strong>：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。</li>
</ul>
<h3 id="其他敏捷开发方法" data-numberify>其他敏捷开发方法<a class="anchor ms-1" href="#其他敏捷开发方法"></a></h3>
<p><strong>水晶法</strong>：</p>
<ul>
<li>
<p>认为每一个不同的项目都需要一套不同的策略、约定和方法论。</p>
</li>
<li>
<p>认为人对软件质量有重要的影响。</p>
<p>随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。</p>
</li>
<li>
<p>通过更好地交流和经常性的交付，软件生产力得到提高。</p>
</li>
</ul>
<p><strong>并列争求法</strong>：</p>
<p>使用迭代的方法。</p>
<ul>
<li>把每30天一次的迭代称为一个“冲刺”。</li>
<li>按需求的优先级别来实现产品。</li>
<li>多个自组织和自治的小组并行地递增实现产品。</li>
<li>协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。</li>
</ul>
<p><strong>自适应软件开发</strong>：</p>
<p>有6个基本原则：</p>
<ul>
<li>有一个使命作为指导；</li>
<li>特征被视为客户价值的关键点；</li>
<li>过程中的等待是很重要的，因此“重做”与“做”同样关键；</li>
<li>变化不被视为改正，而是被视为对软件开发实际情况的调整；</li>
<li>确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求；</li>
<li>风险也包含其中。</li>
</ul>
<h2 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h2>
<p>能力成熟度模型（从1开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始级</td>
<td style="text-align:left">杂乱无章，几乎没有明确定义的步骤。</td>
</tr>
<tr>
<td style="text-align:center">可重复级</td>
<td style="text-align:left">建立基本的项目管理过程和实践来跟踪项目费用、进度和功能特性。</td>
</tr>
<tr>
<td style="text-align:center">已定义级</td>
<td style="text-align:left">将管理和工程文档化、标准化并综合成标准软件过程；<br>使用标准开发过程（或方法论）构建（或集成）系统。</td>
</tr>
<tr>
<td style="text-align:center">己管理级</td>
<td style="text-align:left">对软件过程和产品质量制定了的详细度量标准，且有定量的理解和控制。</td>
</tr>
<tr>
<td style="text-align:center">优化级</td>
<td style="text-align:left">加强了定量分析，通过过程质量和新观念、新技术使过程不断地改进。</td>
</tr>
</tbody>
</table>
<p>能力成熟度集成连续式模型（从0开始）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">能力等级</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未完成的</td>
<td style="text-align:left">未执行或未得到等级1中的所有目标。</td>
</tr>
<tr>
<td style="text-align:center">已执行的</td>
<td style="text-align:left">可标识的输入工作产品到输出工作产品的转换，实现特定目标。<p>关注：特定目标的完成。</p></td>
</tr>
<tr>
<td style="text-align:center">已管理的</td>
<td style="text-align:left">已管理的过程的制度化。<p>关注：针对单个过程实例的能力。</p></td>
</tr>
<tr>
<td style="text-align:center">已定义级的</td>
<td style="text-align:left">已定义的过程的制度化。<p>关注：过程的组织级标准化和部署。</p></td>
</tr>
<tr>
<td style="text-align:center">定量管理的</td>
<td style="text-align:left">可定量管理的过程的制度化。<p>说明：使用测量和质量保证来控制和改进。</p></td>
</tr>
<tr>
<td style="text-align:center">优化的</td>
<td style="text-align:left">优化的过程的制度化。<p>说明：使用量化手段改变和优化。</p></td>
</tr>
</tbody>
</table>
<p>各开发模型的适用范围：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瀑布模型</td>
<td style="text-align:left">将软件生存周期中的活动定为线性顺序链接的阶段模型</td>
<td style="text-align:left">需求明确、大致固定且变更少</td>
</tr>
<tr>
<td style="text-align:center">V模型</td>
<td style="text-align:left">瀑布模型的变体，强调测试贯穿项目的始终，是一种测试的开发模型</td>
<td style="text-align:left">需求明确、低风险</td>
</tr>
<tr>
<td style="text-align:center">增量模型</td>
<td style="text-align:left">融合瀑布模型和原型迭代，核心功能先完成，每轮迭代都会有新的增量，核心功能得到充分测试，强调每个增量均发布一个可操作的产品</td>
<td style="text-align:left">快速构造可运行的产品，产品升级，领域熟悉或已有原型</td>
</tr>
<tr>
<td style="text-align:center">演化模型</td>
<td style="text-align:left">迭代的过程模型，需求无法被完整定义，功能在使用过程中不断完善</td>
<td style="text-align:left">对软件需求缺乏准确认识的情况</td>
</tr>
<tr>
<td style="text-align:center">原型模型</td>
<td style="text-align:left">原型开发方法模型，目的是快速、低成本地构建原型系统</td>
<td style="text-align:left">需求不清或多变、领域陌生；不适合大规模系统</td>
</tr>
<tr>
<td style="text-align:center">螺旋模型</td>
<td style="text-align:left">结合瀑布和演化模型，强调引入风险分析，属于面向对象开发模型</td>
<td style="text-align:left">庞大、复杂、高风险的系统，开发人员有丰富的风险评估经验和知识</td>
</tr>
<tr>
<td style="text-align:center">喷泉模型</td>
<td style="text-align:left">面向对象模型，特点是迭代、无间隙和支持重用，各阶段无明显界限，可迭代交叉</td>
<td style="text-align:left">面向对象的开发过程</td>
</tr>
<tr>
<td style="text-align:center">统一过程</td>
<td style="text-align:left">用例驱动、以架构为中心、迭代和增量</td>
<td></td>
</tr>
</tbody>
</table>
<p>统一过程模型阶段里程碑和关注点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:left">里程碑</th>
<th style="text-align:left">关注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始阶段</td>
<td style="text-align:left">生命周期目标</td>
<td style="text-align:left">项目的初创活动</td>
</tr>
<tr>
<td style="text-align:center">精化阶段</td>
<td style="text-align:left">生命周期架构</td>
<td style="text-align:left">需求分析和架构演进</td>
</tr>
<tr>
<td style="text-align:center">构建阶段</td>
<td style="text-align:left">初始运作功能</td>
<td style="text-align:left">系统的构建</td>
</tr>
<tr>
<td style="text-align:center">移交阶段</td>
<td style="text-align:left">产品发布</td>
<td style="text-align:left">软件提交方面的工作</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="需求分析" data-numberify>需求分析<a class="anchor ms-1" href="#需求分析"></a></h1>
<h2 id="软件需求" data-numberify>软件需求<a class="anchor ms-1" href="#软件需求"></a></h2>
<p>需求分析主要的目的是弄清楚系统需要“做什么”，并将其阐述出来。</p>
<p>软件需求是指<u>用户对目标软件系统在功能、行为、性能、设计约束等方面的期望</u>。通常，这些需求包括：</p>
<ul>
<li>
<p><strong>功能需求</strong>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p>
</li>
<li>
<p><strong>性能需求</strong>：考虑软件开发的技术性指标。</p>
<p>例如：</p>
<ul>
<li>存储容量限制；</li>
<li>执行速度；</li>
<li>响应时间；</li>
<li>吞吐量。</li>
</ul>
</li>
<li>
<p><strong>用户或人的因素</strong>：考虑用户的类型。</p>
<p>例如：</p>
<ul>
<li>各种用户对使用计算机的熟练程度，需要接受的训练；</li>
<li>用户理解、使用系统的难度；</li>
<li>用户错误操作系统的可能性。</li>
</ul>
</li>
<li>
<p><strong>环境需求</strong>：考虑未来软件应用的环境，包括硬件和软件。</p>
<ul>
<li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li>
<li>对软件的需求包括：操作系统、网络、数据库等。</li>
</ul>
</li>
<li>
<p><strong>界面需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>来自其他系统的输入；</li>
<li>到其他系统的输出；</li>
<li>对数据格式的特殊规定；</li>
<li>对数据存储介质的规定。</li>
</ul>
</li>
<li>
<p><strong>文档需求</strong>：考虑需要哪些文档，文档针对哪些读者。</p>
</li>
<li>
<p><strong>数据需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>输入、输出数据的格式；</li>
<li>接收、发送数据的频率；</li>
<li>数据的准确性和精度；</li>
<li>数据流量；</li>
<li>数据需保持的时间。</li>
</ul>
</li>
<li>
<p><strong>资源使用需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>软件运行时所需要的数据、其他软件、内存空间等资源；</li>
<li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li>
</ul>
</li>
<li>
<p><strong>安全保密要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>是否需要对访问系统或系统信息加以控制；</li>
<li>隔离用户数据的方法；</li>
<li>用户程序如何与其他程序和操作系统隔离</li>
<li>系统备份要求。</li>
</ul>
</li>
<li>
<p><strong>可靠性要求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>系统的可靠性要求；</li>
<li>系统是否必须检测和隔离错误；</li>
<li>出错后，重启系统允许的时间。</li>
</ul>
</li>
<li>
<p><strong>软件成本消耗与开发进度需求</strong>：</p>
<p>考虑以下方面：</p>
<ul>
<li>开发是否有规定的时间表；</li>
<li>软/硬件投资有无限制。</li>
</ul>
</li>
<li>
<p><strong>其他非功能性要求</strong>：</p>
<p>如采用某种开发模式，需要确定：</p>
<ul>
<li>质量控制标准；</li>
<li>里程碑和评审；</li>
<li>验收标准；</li>
<li>各种质量要求的优先级；</li>
<li>可维护性方面的要求。</li>
</ul>
</li>
</ul>
<p>软件需求的出处：</p>
<ul>
<li>可以来自于用户（实际的和潜在的）、用户的规约、应用领域的专家、相关的技术标准和法规；</li>
<li>可以来自于原有的系统、原有系统的用户、新系统的潜在用户；</li>
<li>可以来自于竞争对手的产品。</li>
</ul>
<h2 id="需求工程" data-numberify>需求工程<a class="anchor ms-1" href="#需求工程"></a></h2>
<p>需求工程可以细分为6个阶段：</p>
<ol>
<li>需求获取</li>
<li>需求分析与协商</li>
<li>系统建模</li>
<li>需求规约</li>
<li>需求验证</li>
<li>需求管理</li>
</ol>
<hr>
<h1 id="系统设计" data-numberify>系统设计<a class="anchor ms-1" href="#系统设计"></a></h1>
<p>进入设计阶段，需要把软件系统“做什么”的逻辑模型转换成“怎么做”的物理模型。即着手实现软件系统需求。</p>
<p>系统设计的主要目的就是为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方案。</p>
<p>系统设计的主要内容包括：</p>
<ul>
<li>新系统总体结构设计</li>
<li>代码设计</li>
<li>输出、输入设计</li>
<li>处理过程设计</li>
<li>数据存储设计</li>
<li>用户界面设计</li>
<li>安全控制设计</li>
</ul>
<p>常用的设计方法有以下两种：</p>
<ul>
<li>面向数据流的结构化设计方法（SD）。</li>
<li>面向对象的分析方法（OOD）。</li>
</ul>
<p>系统设计的基本任务大体上可以分为两个步骤：</p>
<ol>
<li>概要设计</li>
<li>详细设计</li>
</ol>
<h2 id="概要设计" data-numberify>概要设计<a class="anchor ms-1" href="#概要设计"></a></h2>
<ol>
<li>
<p><strong>设计软件系统总体结构</strong>（<strong>总体结构设计</strong>）：</p>
<p>其基本任务是：</p>
<ul>
<li>采用某种设计方法，将一个复杂的系统按功能划分成模块；</li>
<li>确定每个模块的功能；</li>
<li>确定模块之间的调用关系；</li>
<li>确定模块之间的接口，即模块之间传递的信息；</li>
<li>评价模块结构的质量。</li>
</ul>
<p>软件系统总体结构的设计是概要设计关键的一步，直接影响到下一个阶段详细设计与编码的工作。</p>
<p>软件系统的质量及一些整体特性都在软件系统总体结构的设计中决定。</p>
</li>
<li>
<p><strong>数据结构及数据库设计</strong>：</p>
<ol>
<li>
<p><strong>数据结构设计</strong>：逐步细化的方法也适用于数据结构的设计。</p>
<p>在需求分析阶段，己经通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性。在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段，宜使用抽象的数据类型。</p>
</li>
<li>
<p><strong>数据库设计</strong>：</p>
<p>数据库的设计是指数据存储文件的设计，主要进行以下几方面设计：</p>
<ol>
<li>
<p>概念设计：在数据分析的基础上，采用自底向上的方法从用户角度进行视图设计，一般用E-R模型来表述数据模型。</p>
<p>E-R模型既是设计数据库的基础，也是设计数据结构的基础。</p>
</li>
<li>
<p>逻辑设计：E-R模型是独立于数据库管理系统（DBMS）的，要结合具体的DBMS特征来建立数据库的逻辑结构。</p>
</li>
<li>
<p>物理设计：对于不同的DBMS，物理环境不同，提供的存储结构与存取方法各不相同。</p>
<p>物理设计就是设计数据模式的一些物理细节，如数据项存储要求、存取方法和索引的建立等。</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>编写概要设计文档</strong>：</p>
<p>文档主要有：</p>
<ul>
<li>概要设计说明书</li>
<li>数据库设计说明书</li>
<li>用户手册</li>
<li>修订测试计划</li>
</ul>
</li>
<li>
<p><strong>评审</strong>：</p>
<p>对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。</p>
</li>
</ol>
<h2 id="详细设计" data-numberify>详细设计<a class="anchor ms-1" href="#详细设计"></a></h2>
<ol>
<li>
<p><strong>算法设计</strong>：<u>对每个模块进行详细的算法设计</u>，用某种图形、表格和语言等工具<u>将每个模块处理过程的详细算法描述出来</u>。</p>
</li>
<li>
<p><strong>数据结构设计</strong>：对模块内的数据结构进行设计。</p>
</li>
<li>
<p><strong>数据库设计</strong>：对数据库进行物理设计，即确定数据库的物理结构。</p>
</li>
<li>
<p>其他设计：</p>
<p>根据软件系统的类型，还可能要进行以下设计：</p>
<ul>
<li><strong>代码设计</strong>：为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计。</li>
<li><strong>输入/输出格式设计</strong>。</li>
<li><strong>用户界面设计</strong>。</li>
</ul>
</li>
<li>
<p>编写<u>详细设计说明书</u>。</p>
</li>
<li>
<p><strong>评审</strong>：<u>对处理过程的算法和数据库的物理结构都要评审。</u></p>
</li>
</ol>
<p>系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统（包括硬件设备和编制软件程序）的重要基础。</p>
<hr>
<h1 id="系统测试" data-numberify>系统测试<a class="anchor ms-1" href="#系统测试"></a></h1>
<p>系统测试是<u>为了发现错误而执行程序的过程</u>。</p>
<ul>
<li>成功的测试：发现了至今尚未发现的错误的测试。</li>
<li>测试的目的：希望能以最少的人力和时间发现潜在的各种错误和缺陷。</li>
</ul>
<p>信息系统测试应包括：</p>
<ul>
<li>软件测试</li>
<li>硬件测试</li>
<li>网络测试</li>
</ul>
<p>系统测试是保证系统质量和可靠性的关键步骤，是对系统开发过程的最后复查。</p>
<p>根据测试的概念和目的，在进行信息系统测试时应遵循以下基本原则：</p>
<ol>
<li>
<p>应尽早并不断地进行测试。测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患。</p>
</li>
<li>
<p>测试工作应该避免由原开发软件的人或小组承担。</p>
<ul>
<li>开发人员往往不愿否认自己的工作，总认为自己开发的软件没有错误；</li>
<li>开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性。</li>
</ul>
</li>
<li>
<p>在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确。</p>
</li>
<li>
<p>在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。</p>
</li>
<li>
<p>在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。</p>
</li>
<li>
<p>严格按照测试计划来进行，避免测试的随意性。</p>
<p>测试计划应包括：</p>
<ul>
<li>测试内容</li>
<li>进度安排</li>
<li>人员安排</li>
<li>测试环境</li>
<li>测试工具</li>
<li>测试资料</li>
</ul>
</li>
<li>
<p>妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。</p>
</li>
<li>
<p>测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。</p>
</li>
</ol>
<p>系统测试阶段的<u>测试目标来自于需求分析阶段</u>。</p>
<p>测试过程：</p>
<ol>
<li>制定测试计划</li>
<li>编制测试大纲</li>
<li>根据测试大纲设计和生成测试用例</li>
<li>实施测试</li>
<li>生成测试报告</li>
</ol>
<h2 id="单元测试" data-numberify>单元测试<a class="anchor ms-1" href="#单元测试"></a></h2>
<p><strong>单元测试</strong>也称为<strong>模块测试</strong>，<u>在模块编写完成且无编译错误后就可以进行</u>。单元测试<u>侧重于模块中的内部处理逻辑和数据结构</u>。如果选用<u>机器测试</u>，一般用<u>白盒测试法</u>。这类测试<u>可以对多个模块同时进行</u>。</p>
<p>单元测试主要检查模块的以下5个特征：</p>
<ul>
<li>
<p>模块接口：模块的接口保证了测试模块的数据流可以正确地流入、流出。</p>
<p>在测试中应检查以下要点：</p>
<ul>
<li>测试模块的<u>输入参数</u>和<u>形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用其他模块时，所给出的<u>实际参数</u>和<u>被调用模块的形式参数</u>在<u>个数、属性、单位</u>上<u>是否一致</u>。</li>
<li>调用标准函数时，所用的<u>参数在属性、数目和顺序上是否正确</u>。</li>
<li><u>全局变量在各模块中的定义和用法是否一致。</u></li>
<li><u>输入是否仅改变了形式参数。</u></li>
<li><u>开/关的语句</u>是否正确。</li>
<li>规定的<u>I/O格式</u>是否与输入/输出语句一致。</li>
<li>在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。</li>
</ul>
</li>
<li>
<p>局部数据结构</p>
</li>
<li>
<p>重要的执行路径</p>
</li>
<li>
<p>出错处理</p>
</li>
<li>
<p>边界条件</p>
</li>
</ul>
<p>模块间存在调用与被调关系，对每个模块进行测试时，需要开发两种模块：</p>
<ul>
<li>
<p>驱动模块：接收测试例子的数据，将这些数据送到测试模块，输出结果。</p>
<p>即模拟被测试模块的上一级模块，相当于被测模块的主程序。</p>
</li>
<li>
<p>桩模块（存根模块）：代替测试模块中所调用的子模块，其内部可进行少量的数据处理。目的是为了检验入口、输出调用和返回的信息。</p>
<p>即模拟被测模块的子模块（所调用的模块），但不是软件产品的组成部分。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="单元测试环境" src="/docs/ruan-she/software-engineering/uTools_1683613415307.png" loading="lazy" width="360" height="344" />
</picture>

</p>
<p>提高模块的内聚度可以简化单元测试。</p>
<h2 id="集成测试" data-numberify>集成测试<a class="anchor ms-1" href="#集成测试"></a></h2>
<p>集成测试就是<u>把模块按系统设计说明书的要求组合起来进行测试</u>。即使所有的模块都通过了测试，在集成之后，仍然可能出现问题：</p>
<ul>
<li>穿过模块的数据丢失；</li>
<li>一个模块的功能对其他模块造成有害的影响；</li>
<li>各个模块集成起来没有达到预期的功能；</li>
<li>全局数据结构出现问题；</li>
<li>单个模块的误差可以接受，但模块组合后，可能会出现误差累积，最后累积到不能接受的程度。</li>
</ul>
<p>集成测试是进行一些旨在<u>发现与接口相关的错误</u>的测试，其目标是<u>利用已通过单元测试的构件建立设计中描述的程序结构</u>。</p>
<p>通常，集成测试有两种方法：</p>
<ul>
<li>
<p><strong>非增量集成</strong>：分别测试各个模块，再把这些模块组合起来进行整体测试。</p>
<ul>
<li>优点：可以对模块进行并行测试，能充分利用人力，并加快工程进度。</li>
<li>缺点：容易混乱，出现错误不容易查找和定位。</li>
</ul>
</li>
<li>
<p><strong>增量集成</strong>：以小增量的方式逐步进行构造和测试。</p>
<p>增量式测试的范围一步步扩大，错误容易定位，更易于对接口进行彻底测试，并且可以运用系统化的测试方法。</p>
</li>
</ul>
<p>增量集成策略有：</p>
<ul>
<li>
<p><strong>自项向下集成测试</strong>：一种构造软件体系结构的增量方法。</p>
<p>模块的集成顺序为从主控模块（主程序）开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于（或间接从属于）主控模块的模块集成到结构中。</p>
<p><picture><img class="img-fluid " alt="自顶向下集成" src="/docs/ruan-she/software-engineering/uTools_1683617607121.png" loading="lazy" width="500" height="393" />
</picture>

</p>
<p><strong>深度优先集成</strong>是<u>首先集成位于程序结构中主控路径上的所有构件</u>，也可以根据特定应用系统的特征进行选择。</p>
<p>例如上图中，选择最左边的路径：</p>
<ol>
<li>首先，集成构建$M_1$、$M_2$和$M_5$；</li>
<li>其次，集成$M_8$或$M_6$（若$M_2$的正常运行是必须的）；</li>
<li>然后，集成中间和右边控制路径上的构建。</li>
</ol>
<p>广度优先集成<u>首先沿着水平方向，将属于同一层的构建集成起来</u>。</p>
<p>例如上图中：</p>
<ol>
<li>首先，将构建$M_2$、$M_3$和$M_4$集成起来；</li>
<li>其次是$M_5$、$M_6$、$M_7$，依次类推。</li>
</ol>
<p>集成过程可以通过下列5个步骤完成：</p>
<ol>
<li><u>主控模块用作测试驱动模块</u>，用这些从属于主控模块的所有模块代替桩模块。</li>
<li>依靠所选择的集成方法（即深度优先或广度优先），每次用实际模块替换一个从属桩模块。</li>
<li>在集成每个模块后都进行测试。</li>
<li>在完成每个测试集之后，用实际模块替换另一个桩模块。</li>
<li>可以执行回归测试，以确保没有引入新的错误。</li>
</ol>
<p>回到第2步继续执行此过程，直到完成了整个程序结构的构造。</p>
<blockquote>
<p><u>自顶向下集成不需要驱动模块。</u></p>
</blockquote>
</li>
<li>
<p><strong>自底向上集成测试</strong>：自底向上集成测试就是从原子模块（程序结构的最底层构件）开始进行构造和测试。</p>
<p>由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总是存在的，因此，没有必要使用桩模块。自底向上集成策略可以利用以下步骤来实现：</p>
<ol>
<li>连接低层构件以构成完成特定子功能的簇。</li>
<li>编写驱动模块（测试的控制程序）以协调测试用例的输入和输出。</li>
<li>测试簇。</li>
<li>去掉驱动程序，沿着程序结构向上逐步连接簇。</li>
</ol>
<blockquote>
<p>簇：一系列相关低层构建的集合。</p>
<p><u>自底向上集成不需要桩模块。</u></p>
</blockquote>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="自底向上" src="/docs/ruan-she/software-engineering/uTools_1683619189037.png" loading="lazy" width="762" height="534" />
</picture>

</p>
<ol>
<li>连接相应的构建形成簇1、簇2和簇3；</li>
<li>编写驱动模块（图中虚线上方连接的框，即$D_1$、$D_2$和$D_3$）</li>
<li>利用驱动模块对每个簇进行测试。</li>
<li>簇1和簇2中的构建从属于模块$M_a$，去掉驱动模块$D_1$和$D_2$，将这两个簇直接与$M_a$相连；簇3去掉驱动模块$D_3$，然后与$M_b$相连。</li>
<li>最后将$M_a$和$M_b$与构建$M_c$连接在一起。</li>
</ol>
</li>
<li>
<p><strong>回归测试</strong>：重新执行己测试过的某些子集，以确保变更没有传播不期望的副作用。</p>
<p>每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的/O,以及调用新的控制逻辑。这些变更可能会使原来可以正常工作的功能产生问题。</p>
<p>回归测试有助于保证变更不引入无意识行为或额外的错误。回归测试的方法有：</p>
<ul>
<li>手工执行，重新执行所有测试用例的子集</li>
<li>利用捕捉/回放工具自动执行</li>
</ul>
<p>回归测试要执行的测试子集包含以下3种测试用例：</p>
<ul>
<li><u>能够测试软件所有功能</u>的具有代表性的<u>测试样本</u>。</li>
<li>额外测试，侧重于<u>可能会受变更影响的软件功能</u>。</li>
<li>侧重于<u>已发生变更的软件构件测试</u>。</li>
</ul>
<p>随着集成测试的进行，<u>回归测试的数量可能变得相当庞大</u>，因此，应将回归测试用例设计成<u>只包括每个主要程序功能的一个或多个错误类的测试</u>。</p>
</li>
<li>
<p><strong>冒烟测试</strong>：一种常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。</p>
<p>冒烟测试方法包括下列活动：</p>
<ol>
<li>
<p>将已经转换为代码的软件构件集成到构建中。</p>
<p>一个构建包括所有的：</p>
<ul>
<li>数据文件</li>
<li>库</li>
<li>可复用的模块</li>
<li>实现一个或多个产品功能所需的工程化构件</li>
</ul>
</li>
<li>
<p>设计一系列测试以<u>暴露影响构建正确地完成它的功能的错误</u>，其<u>目的是为了发现极有可能造成项目延迟的业务阻塞错误</u>。</p>
</li>
<li>
<p>每天将该构建与其他构建及整个软件产品（以其当前形势）集成起来进行冒烟测试。</p>
<p>这种集成方法可以自顶向下，也可以自底向上。</p>
</li>
</ol>
</li>
</ul>
<h2 id="测试方法" data-numberify>测试方法<a class="anchor ms-1" href="#测试方法"></a></h2>
<p>测试方法分为：</p>
<ul>
<li>
<p><strong>静态测试</strong>：</p>
<p>指被测试程序不在机器上运行，而是采用以下手段对程序进行检测：</p>
<ul>
<li>
<p><strong>人工检测</strong>：不依靠计算机而是依靠人工审查程序或评审软件。</p>
<p>人工检测包括：</p>
<ul>
<li>代码检查</li>
<li>静态结构分析</li>
<li>代码质量度量</li>
</ul>
</li>
<li>
<p><strong>计算机辅助静态分析</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>动态测试</strong>：指通过运行程序发现错误。</p>
<p>在对软件产品进行动态测试时可以采用以下两种测试方法：</p>
<ul>
<li><strong>黑盒测试法</strong></li>
<li><strong>白盒测试法</strong></li>
</ul>
<p>测试用例由以下组成：</p>
<ul>
<li>测试输入数据</li>
<li>预期输出结果：与测试输入数据对应的预期输出结果</li>
</ul>
<p>在设计测试用例时，应当包括：</p>
<ul>
<li>合理的输入条件</li>
<li>不合理的输入条件</li>
</ul>
</li>
</ul>
<h3 id="黑盒测试" data-numberify>黑盒测试<a class="anchor ms-1" href="#黑盒测试"></a></h3>
<p><strong>黑盒测试</strong>也称为<strong>功能测试</strong>，在<u>完全不考虑软件的内部结构和特性</u>的情况下，测试软件的外部特性。</p>
<p>进行黑盒测试主要是为了发现以下几类错误：</p>
<ol>
<li>是否有错误的功能或遗漏的功能？</li>
<li>界面是否有误？输入是否正确接收？输出是否正确？</li>
<li>是否有数据结构或外部数据库访问错误？</li>
<li>性能是否能多接受？</li>
<li>是否有初始化或终止性错误？</li>
</ol>
<p>常用的黑盒测试技术有：</p>
<ul>
<li>
<p><strong>等价类划分</strong>：将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。</p>
<p>每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以<u>用少量代表性的测试用例取得较好的测试效果</u>。</p>
<p>等价类划分有两种不同的情况：</p>
<ul>
<li>有效等价类</li>
<li>无效等价类</li>
</ul>
<p>在设计测试用例时，要同时考虑这两种等价类。</p>
<p>定义等价类的原则如下。</p>
<ol>
<li>在<u>输入条件规定了取值范围或值的个数</u>的情况下，<u>可以定义1个有效等价类和2个无效等价类</u>。</li>
<li>在<u>输入条件规定了输入值的集合或规定了“必须如何”</u>的条件的情况下，<u>可以定义1个有效等价类和一个无效等价类</u>。</li>
<li>在输入条件是一个<u>布尔量</u>的情况下，<u>可以定义一个有效等价类和一个无效等价类</u>。</li>
<li>在<u>规定了输入数据的一组值（假定$n$个）</u>，并且程序要<u>对每一个输入值分别处理</u>的情况下，<u>可以定义$n$个有效等价类和1个无效等价类</u>。</li>
<li>在<u>规定了输入数据必须遵守的规则</u>的情况下，<u>可以定义一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</u>。</li>
<li>在确知己划分的等价类中，各元素在程序处理中的方式不同的情况下，则应将该等价类进一步划分为更小的等价类。</li>
</ol>
<p>例如，输入$x$的取值范围是$0 \sim 10$，输入$y$的取值范围是$-10 \sim -1$，那么可以定义三个等价类：</p>
<ul>
<li>有效等价类1：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类2：$x$的取值范围是$x &lt; 0 \ \ OR \ \ x &gt; 10$，输入$y$的取值范围是$-10 \sim -1$；</li>
<li>无效等价类3：$x$的取值范围是$0 \sim 10$，输入$x$的取值范围是$x &lt; -10 \ \ OR \ \ x &gt; -1$。</li>
</ul>
<p>无效等价类的划分：每个无效等价类的测试用例，只违反一个输入的取值范围。如果违反了多个输入的取值范围，那便是不好的测试用例。</p>
</li>
<li>
<p><strong>边界值分析</strong>：输入的<u>边界比中间更加容易发生错误</u>，因此用边界值分析来<u>补充等价类划分的测试用例设计技术</u>。</p>
<p>边界值划分<u>选择等价类边界的测试用例</u>，既<u>注重于输入条件边界</u>，又<u>适用于输出域测试用例</u>。</p>
<p>对边界值设计测试用例应遵循的原则如下：</p>
<ol>
<li>如果<u>输入条件规定了值的范围</u>，则应取<u>刚达到这个范围的边界的值</u>，以及<u>刚刚超越这个范围边界的值</u>作为测试输入数据。</li>
<li>如果<u>输入条件规定了值的个数</u>，则用<u>最大个数、最小个数、比最小个数少1、比最大个数多1的数据</u>作为测试数据。</li>
<li>根据规格说明的每个输出条件使用上述两条原则。</li>
<li>如果程序的规格说明给出的<u>输入域或输出域是有序集合</u>，则应选取<u>集合的第一个元素和最后一个元素</u>作为测试用例。</li>
<li>如果程序中使用了一个<u>内部数据结构</u>，则应当选择这个<u>内部数据结构边界上的值</u>作为测试用例。</li>
<li>分析规格说明，找出其他可能的边界条件。</li>
</ol>
</li>
<li>
<p><strong>错误推测</strong></p>
</li>
<li>
<p><strong>因果图</strong></p>
</li>
</ul>
<h3 id="白盒测试" data-numberify>白盒测试<a class="anchor ms-1" href="#白盒测试"></a></h3>
<p><strong>白盒测试</strong>也称为<strong>结构测试</strong>，<u>根据程序的内部结构和逻辑来设计测试用例</u>，对程序的路径和过程进行测试，检查是否满足设计的需要。</p>
<p>白盒测试常用的技术有：</p>
<ul>
<li>
<p><strong>逻辑覆盖</strong>：考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。</p>
<p>主要的逻辑覆盖标准有6种，它们的覆盖程度从低到高为：</p>
<ol>
<li>
<p><strong>语句覆盖</strong>：指选择足够的测试数据，使<u>被测试程序中的每条语句至少执行一次</u>。</p>
<p>语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。</p>
</li>
<li>
<p><strong>判定覆盖</strong>（分支覆盖）：指设计足够的测试用例，使得<u>被测程序中的每个判定表达式至少获得一次“真”/“假”值</u>。</p>
<p>判定覆盖的判定表达式是指判定表达式整体。</p>
<p>判定覆盖要比语句覆盖更强一些。</p>
</li>
<li>
<p><strong>条件覆盖</strong>：指构造一组测试用例，使得<u>每一判定语句中每个逻辑条件的各种可能的值至少满足一次</u>。</p>
<p>条件覆盖的判定语句是指判定表达式下的判定语句（如果有），即用<code>AND</code>、<code>OR</code>等逻辑运算符连接起来的语句（不包含逻辑运算符的语句）。</p>
</li>
<li>
<p><strong>判定/条件覆盖</strong>：指设计足够的测试用例，<u>使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次</u>。</p>
<p>判定/条件覆盖同时满足：</p>
<ul>
<li>判定覆盖</li>
<li>条件覆盖</li>
</ul>
</li>
<li>
<p><strong>条件组合覆盖</strong>：指设计足够的测试用例，使得<u>每个判定中条件的各种可能值的组合都至少出现一次</u>。</p>
<p>满足条件组合覆盖的测试用例一定满足：</p>
<ul>
<li>判定覆盖</li>
<li>条件覆盖</li>
<li>判定/条件覆盖</li>
</ul>
</li>
<li>
<p><strong>路径覆盖</strong>：指<u>覆盖被测试程序中所有可能的路径</u>。</p>
</li>
</ol>
</li>
<li>
<p><strong>循环覆盖</strong></p>
</li>
<li>
<p><strong>基本路径测试</strong></p>
</li>
</ul>
<h3 id="总结-1" data-numberify>总结<a class="anchor ms-1" href="#总结-1"></a></h3>
<p>白盒测试逻辑覆盖技术总结（覆盖程度从低到高）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑覆盖</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语句覆盖</td>
<td style="text-align:left">每条语句执行一次</td>
</tr>
<tr>
<td style="text-align:center">分支（判定）覆盖</td>
<td style="text-align:left">每个分支获得一次True/False</td>
</tr>
<tr>
<td style="text-align:center">条件覆盖</td>
<td style="text-align:left">每个分支中的每个逻辑条件的所有可能取值满足一次</td>
</tr>
<tr>
<td style="text-align:center">判定/条件覆盖</td>
<td style="text-align:left">分支覆盖 + 条件覆盖</td>
</tr>
<tr>
<td style="text-align:center">条件组合覆盖</td>
<td style="text-align:left">每个判定中条件的各种可能值的组合都出现一次</td>
</tr>
<tr>
<td style="text-align:center">路径覆盖</td>
<td style="text-align:left">覆盖被测试程序中所有可能的路径</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="运行和维护" data-numberify>运行和维护<a class="anchor ms-1" href="#运行和维护"></a></h1>
<p>软件维护是软件生命周期中的最后一个阶段，处于系统投入生产性运行以后的时期中，因此<u>不属于系统开发过程</u>。<u>软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程</u>，即软件在交付使用后对软件所做的一切改动。</p>
<h2 id="系统可维护性" data-numberify>系统可维护性<a class="anchor ms-1" href="#系统可维护性"></a></h2>
<p>系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的。<u>系统的可维护性可以衡量系统是否能被很好地维护。</u></p>
<p>系统可维护性的评价指标：</p>
<ol>
<li>
<p><strong>可理解性</strong>：指别人能理解系统的结构、界面、功能和内部过程的难易程度。</p>
<p>模块化、详细设计文档、结构化设计和良好的高级程序设计语言等都有助于提高可理解性。</p>
</li>
<li>
<p><strong>可测试性</strong>：<u>诊断和测试的容易程度取决于易理解的程度。</u></p>
<p>好的文档资料有利于诊断和测试；程序的结构、高性能的测试工具以及周密计划的测试工序也是至关重要的。</p>
<p>在进行系统维护时，应该充分利用在系统测试阶段保存下来的测试用例。</p>
</li>
<li>
<p><strong>可修改性</strong>：诊断和测试的容易程度与系统设计所制定的设计原则有直接关系。</p>
<p>模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响。</p>
</li>
</ol>
<p><strong>软件文档与软件维护</strong>：</p>
<p><u>软件文档是软件可维护性的决定因素。</u>文档是软件产品的一部分，并且编写高质量的文档可以提高软件开发的质量。</p>
<p>软件系统的文档分为：</p>
<ul>
<li><strong>用户文档</strong>：主要描述<u>系统功能</u>和<u>使用方法</u>，并<u>不关心</u>这些<u>功能是怎样实现的</u>；</li>
<li><strong>系统文档</strong>：描述<u>系统设计、实现和测试</u>等各方面的内容。</li>
</ul>
<p>可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审（如将来要改进的部分和可能会修改的部分）。</p>
<p>维护应该针对整个软件配置，不应该只修改源程序代码。</p>
<h2 id="软件维护" data-numberify>软件维护<a class="anchor ms-1" href="#软件维护"></a></h2>
<p>软件维护主要是指<u>根据需求变化或硬件环境的变化对应用程序进行部分或全部修改</u>。修改时应充分利用源程序，<u>修改后要填写程序修改登记表</u>，并<u>在程序变更通知书上写明新旧程序的不同之处</u>。</p>
<p>软件维护的内容一般有以下几个方面：</p>
<ol>
<li>
<p><strong>正确性维护</strong>：指<u>改正在系统开发阶段已发生而系统测试阶段尚未发现的错误</u>。</p>
<p>所发现的错误有：</p>
<ul>
<li>不太重要、不影响系统正常运行的错误，其维护工作可随时进行；</li>
<li>非常重要的错误，甚至会影响整个系统的正常运行，其维护工作必须制定计划，进行修改，并且要进行复查和控制。</li>
</ul>
</li>
<li>
<p><strong>适应性维护</strong>：<u>使应用软件适应信息技术变化和管理需求变化而进行的修改。</u></p>
</li>
<li>
<p><strong>完善性维护</strong>：<u>为扩充功能和改善性能而进行的修改</u>。</p>
<ul>
<li>主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
<li>还包括对处理效率和编写程序的改进，关系到系统开发质量的重要方面。</li>
</ul>
<p>这方面的维护还要注意将相关的文档资料加入到前面相应的文档中。</p>
</li>
<li>
<p><strong>预防性维护</strong>：<u>为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。</u></p>
<p>例如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化。</p>
</li>
</ol>
<p>这4个维护内容中，正确性和完善性维护是针对来自系统内部的维护，适应性和预防性是针对来自系统外部的维护。</p>
<ul>
<li>
<p>正确性维护针对的是系统内部的错误。</p>
<p>来自系统内部的，与错误有关的都是属于正确性维护。</p>
</li>
<li>
<p>完善性维护针对的是系统内部与功能、性能等方面有关的维护。</p>
<p>来自系统内部的，与系统功能、性能等方面有关的改善都是完善性维护。完善性维护的需求可以来自外部，例如功能的扩展。</p>
</li>
<li>
<p>适应性维护是针对来自系统外部的技术、管理需求等方面的变化。</p>
<p>针对来自系统外部的变化，系统功能等方面没有缺失，仅仅只是适应当前环境变化所做的更改，都是属于适应性维护。</p>
</li>
<li>
<p>预防性维护针对的是未来的环境变化。</p>
</li>
</ul>
<hr>
<h1 id="项目管理" data-numberify>项目管理<a class="anchor ms-1" href="#项目管理"></a></h1>
<h2 id="沟通路径" data-numberify>沟通路径<a class="anchor ms-1" href="#沟通路径"></a></h2>
<p>沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。</p>
<p>软件项目中沟通路径$m$的计算公式（人数$n$）：</p>
<ul>
<li>
<p>沟通图中无主程序员时：</p>
<p>$$
m = \sum_{i=1}^{n} i-1 = \cfrac{(n-1)n}{2}
$$</p>
</li>
<li>
<p>沟通图中有主程序员时：</p>
<p>$$
m = n - 1
$$</p>
</li>
</ul>
<h2 id="软件项目估算" data-numberify>软件项目估算<a class="anchor ms-1" href="#软件项目估算"></a></h2>
<p>软件项目估算涉及人、技术、环境等多种因素，很难在项目完成前准确地估算出开发软件所需的成本、持续时间和工作量。所以需要一些方法和技术来支持项目的估算，常用的估算方法有下列3种：</p>
<ol>
<li>
<p>基于已经完成的类似项目进行估算（常用）。</p>
</li>
<li>
<p>基于分解技术进行估算。</p>
</li>
<li>
<p>基于经验估算模型的估算。</p>
<p>典型的经验估算模型有：</p>
<ul>
<li>IBM估算模型</li>
<li>CoCoMo模型</li>
<li>Putnam模型</li>
</ul>
</li>
</ol>
<p>上述方法可以组合使用，以提高估算的精度。</p>
<h3 id="cocomo-估算模型" data-numberify>COCOMO 估算模型<a class="anchor ms-1" href="#cocomo-估算模型"></a></h3>
<p>COCOMO模型是一种精确的、易于使用的成本估算模型。COCOMO模型按其详细程度分为：</p>
<ol>
<li>
<p><strong>基本COCOMO模型</strong>：是一个<u>静态单变量模型</u>，用于对整个软件系统进行估算。</p>
<p>公式如下：</p>
<p>$$
E = a(L)^b \\
D=cE^d
$$</p>
<ul>
<li>$E$：工作量，单位是人月；</li>
<li>$D$：开发时间，单位是月；</li>
<li>$L$：项目的源代码行估计值，不包括程序中的注释及文档，其单位是千行代码；</li>
<li>$a$、$b$、$c$、$d$：常数。</li>
</ul>
<p>基本COCOMO模型可通过估算代码行的值$L$，然后计算开发工作量$E$和开发时间$D$的估算值。</p>
</li>
<li>
<p><strong>中级COCOMO模型</strong>：是一个<u>静态多变量模型</u>，它<u>将软件系统模型分为系统和部件两个层次</u>，系统由部件构成，它把软件开发所需的人力（成本）看作是程序大小和一系列“成本驱动属性”的函数。</p>
<p>中级COCOMO模型以基本COCOMO模型为基础，并考虑了15种影响软件工作量的因素，通过工作量调节因子（EAF）修正对工作量的估算，从而使估算更合理。其公式如下：</p>
<p>$$
E = a(L)^b \cdot EAF
$$</p>
<ul>
<li>$L$：软件产品的目标代码行数，单位是千行代码数；</li>
<li>$EAF$：工作量调节因子；</li>
<li>$a$、$b$：常数。</li>
</ul>
</li>
<li>
<p><strong>详细COCOMO模型</strong>：<u>将软件系统模型分为系统、子系统和模块3个层次</u>，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。</p>
</li>
</ol>
<h3 id="cocomoii模型" data-numberify>COCOMOII模型<a class="anchor ms-1" href="#cocomoii模型"></a></h3>
<p>和其前身COCOMO一样，COCOMOII也是一种层次结构的估算模型，被分为3个阶段性模型，分别对应三种不同的规模估算选择：</p>
<ol>
<li>
<p><strong>应用组装模型</strong>：在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的。</p>
<p>规模估算选择：<strong>对象点</strong>。</p>
</li>
<li>
<p><strong>早期设计阶段模型</strong>：在需求己经稳定并且基本的软件体系结构己经建立时使用。</p>
<p>规模估算选择：<strong>功能点</strong>。功能点可转换为代码行。</p>
</li>
<li>
<p><strong>体系结构阶段模型</strong>：在软件的构造过程中使用。</p>
<p>规模估算选择：<strong>代码行</strong>。</p>
</li>
</ol>
<h3 id="总结-2" data-numberify>总结<a class="anchor ms-1" href="#总结-2"></a></h3>
<p>COCOMO模型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模型分类</th>
<th style="text-align:left">类型或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本COCOMO模型</td>
<td style="text-align:left">静态单变量模型，对整个软件系统进行估算</td>
</tr>
<tr>
<td style="text-align:center">中级COCOMO模型</td>
<td style="text-align:left">静态多变量模型，将系统模型分为系统和部件2个层次</td>
</tr>
<tr>
<td style="text-align:center">详细COCOMO模型</td>
<td style="text-align:left">将系统模型分为系统、子系统和模块3个层次</td>
</tr>
<tr>
<td style="text-align:center">COCOMOII</td>
<td style="text-align:left">层次结构，分为应用组装模型、早期设计阶段模型和体系结构阶段模型</td>
</tr>
</tbody>
</table>
<p>COCOMOII的使用时期及规模估算选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段性模型</th>
<th style="text-align:center">规模估算选择</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用组装模型</td>
<td style="text-align:center">对象点</td>
</tr>
<tr>
<td style="text-align:center">早期设计阶段模型</td>
<td style="text-align:center">功能点</td>
</tr>
<tr>
<td style="text-align:center">体系结构阶段模型</td>
<td style="text-align:center">代码行</td>
</tr>
</tbody>
</table>
<h2 id="进度管理" data-numberify>进度管理<a class="anchor ms-1" href="#进度管理"></a></h2>
<p>进度安排：</p>
<p>为监控软件项目的进度计划和工作的实际进展情况，表示各项任务之间进度的相互依赖关系，需要采用图示的方法。在图中明确标明如下内容：</p>
<ol>
<li>各个任务的<u>计划开始时间</u>和<u>计划完成时间</u>。</li>
<li>各个任务的<u>完成标志</u>。</li>
<li>各个任务与<u>参与工作的人数</u>，各个任务与<u>工作量之间的衔接情况</u>。</li>
<li>完成各个任务所需的<u>物理资源</u>和<u>数据资源</u>。</li>
</ol>
<p>进度安排的常用图形描述方法有：</p>
<ul>
<li>Gantt图（甘特图）；</li>
<li>项目计划评审技术（Program Evaluation&amp;Review Technique，PERT）图。</li>
</ul>
<h3 id="gantt图" data-numberify>Gantt图<a class="anchor ms-1" href="#gantt图"></a></h3>
<p>Gantt图：一种<u>简单的水平条形图</u>，它<u>以日历为基准</u>描述项目任务。</p>
<ul>
<li>
<p>垂直轴：表示<u>多个不同的任务</u>，每个任务按照左侧任务名称垂直排列。</p>
</li>
<li>
<p>水平轴：表示<u>日历时间线</u>（如时、天、周、月和年等）。</p>
<p>每个水平条表示一个任务：</p>
<ul>
<li>每一水平条的<u>起点</u>：表示该任务的<u>开始时间</u>；</li>
<li>每一水平条的<u>终点</u>：表示该任务的<u>结束时间</u>；</li>
<li>每一水平条的<u>长度</u>：表示<u>完成该任务的持续时间</u>。</li>
</ul>
<p>当日历中同一时段存在多个水平条时，表示任务之间的并发。</p>
</li>
</ul>
<p>如图：</p>
<p><picture><img class="img-fluid " alt="Gantt图示例" src="/docs/ruan-she/software-engineering/uTools_1683683731050.png" loading="lazy" width="795" height="282" />
</picture>

</p>
<ul>
<li>
<p>Gantt图优点：</p>
<p>能清晰地描述：</p>
<ul>
<li>每个任务的开始时间；</li>
<li>每个任务的结束时间；</li>
<li>任务的进展情况；</li>
<li>各个任务之间的并行性。</li>
</ul>
</li>
<li>
<p>Gantt图缺点：</p>
<ul>
<li>不能清晰地反映各任务之间的<u>依赖关系</u>；</li>
<li>难以确定<u>整个项目的关键所在</u>，即不能清晰地确定影响进度的<u>关键任务</u>；</li>
<li>不能反映<u>计划中有潜力的部分</u>。</li>
</ul>
</li>
</ul>
<h3 id="pert图" data-numberify>PERT图<a class="anchor ms-1" href="#pert图"></a></h3>
<p>PERT图是一个<u>有向图</u>：</p>
<ul>
<li>
<p><strong>弧</strong>：表示<strong>任务</strong>。</p>
<p>任务包含以下成分：</p>
<ul>
<li>
<p><u>完成该任务所需的时间</u>（任务持续时间）。</p>
</li>
<li>
<p><u>松弛时间</u>（Slack Time）：表示在<u>不影响整个工期的前提下完成该任务有多少机动余地</u>。</p>
<p>即松弛时间指当前任务的工期可以推迟的时间。</p>
</li>
</ul>
<p>空任务：用虚线箭头表示，表示任务间的关系所添加。完成空任务的所需时间为0。</p>
</li>
<li>
<p><strong>结点</strong>：表示<strong>事件</strong>。</p>
<p>事件是流入结点的任务的结束，或流出结点的任务的开始。事件<u>表示某个时间点</u>，本身不消耗时间和资源。</p>
<p>事件包含以下成分：</p>
<ul>
<li>事件号。</li>
<li>出现该事件的<strong>最早时刻</strong>：表示在此时刻之前从该事件出发的任务不可能开始。</li>
<li>出现该事件的<strong>最迟时刻</strong>：表示从该事件出发的任务最迟在此时刻开始，否则整个工程就不能如期完成。</li>
</ul>
<p><u>只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。</u></p>
<p>特殊的事件：</p>
<ul>
<li>开始事件：没有任何任务流向该事件；</li>
<li>结束事件：没有任务任务从该事件流出。</li>
</ul>
<p>一个项目是从开始事件开始到结束事件结束。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图示例" src="/docs/ruan-she/software-engineering/uTools_1683684995281.png" loading="lazy" width="850" height="490" />
</picture>

</p>
<p>设：</p>
<ul>
<li>$T(e)$：完成任务$e$的所需时间；</li>
<li>$T_s(e)$：完成任务$e$的松弛时间；</li>
<li>$T_e(v)$：事件$v$的最早时刻；</li>
<li>$T_l(v)$：事件$v$的最迟时刻。</li>
</ul>
<p>PERT图各成分取值（不一定需要满足下面的关系，但是可以用下面的式子推出）：</p>
<ul>
<li>
<p>事件$V_{in}$的<u>最早时刻</u>$T_e(V_{in})$：</p>
<ul>
<li>
<p>只有一个任务流入时，设该任务的流出事件为$V_{out}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = T_e(V_{out}) + T
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}, V_{in}&gt;)$简写为了$T$。</p>
</blockquote>
<p>即：<u>该流入任务的流出事件的最早时刻</u> + <u>完成该流入任务的所需时间</u>。</p>
</li>
<li>
<p>多个任务流入时，设与每个任务相对应的流出事件为$V_{out}[ \ i \ ]$，则这些任务为$&lt;V_{out}[ \ i \ ], V_{in}&gt;$：</p>
<p>$$
T_e(V_{in}) = Max(T_e(V_{out}[ \ i \ ]) + T_i)
$$</p>
<blockquote>
<p>这里将$T(&lt;V_{out}[ \ i \ ], V_{in}&gt;)$简写为了$T_i$。</p>
</blockquote>
<p>即<u>流入该事件的每个任务计算出的最早时刻的最大值</u>。</p>
</li>
<li>
<p>开始事件$V_{start}$：</p>
<p>$$
T_e(V_{start}) = 0
$$</p>
</li>
</ul>
</li>
<li>
<p>事件$V_{out}$的<u>最迟时刻</u>$T_l(V_{out})$：</p>
<ul>
<li>
<p>只有一个任务流出时，设该任务的流入事件为$V_{in}$，则该任务为$&lt;V_{out}, V_{in}&gt;$：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - (T + T_s)
$$</p>
<blockquote>
<p>这里将$T_s(&lt;V_{out}, V_{in}&gt;)$简写为$T_s$。</p>
</blockquote>
<p>即：<u>该流出任务的流入事件的最迟时刻</u> -（<u>该流出任务的所需时间</u> + <u>松弛时间</u>）。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = T_l(V_{in}) - T
$$</p>
</li>
<li>
<p>多个任务流出时，设与每个任务相对应的流入事件为$V_{in}[ \ i \ ]$，则这些任务为$&lt;V_{out}, V_{in}[ \ i \ ]&gt;$：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - (T_i + S_i))
$$</p>
<blockquote>
<p>这里把$T(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$T_i$，把$T_s(&lt;V_{out}, V_{in}[ \ i \ ]&gt;)$简写为$S_i$。</p>
</blockquote>
<p>即<u>流出该事件的每个任务计算出的最晚时刻的最大值</u>。</p>
<p>如果松弛时间未知或为0：</p>
<p>$$
T_l(V_{out}) = Min(T_l(V_{in}[ \ i \ ]) - T_i)
$$</p>
</li>
<li>
<p>结束事件$V_{end}$：</p>
<p>$$
T_l(V_{end}) = T_e(V_{end})
$$</p>
<p>即<u>结束事件的最早时刻与最迟时刻相等</u>。</p>
</li>
</ul>
</li>
<li>
<p>设某任务的流入事件为$V_{in}$，流出事件为$V_{out}$，则该任务$&lt;V_{out}, V_{in}&gt;$的<u>松弛时间</u>$T_s(&lt;V_{out}, V_{in}&gt;)$。</p>
<p>$$
T_s = T_l(V_{in}) - T - T_e(V_{out})
$$</p>
<p>即，该任务的流入事件的最迟时刻 - 该任务的所需时间 - 该任务的流出事件的最早时刻</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="PERT图公式参照图" src="/docs/ruan-she/software-engineering/uTools_1683719224977.png" loading="lazy" width="931" height="341" />
</picture>

</p>
<p>PERT图的路径：从开始事件到结束事件的一条通路。</p>
<p>PERT图的<strong>关键路径</strong>：指<u>所有的任务的松弛时间都为0的路径</u>。</p>
<p>关键路径的长度：指结束事件的最早（或最晚）时刻。</p>
<p><picture><img class="img-fluid " alt="PERT图的关键路径示例" src="/docs/ruan-she/software-engineering/uTools_1683706944555.png" loading="lazy" width="785" height="457" />
</picture>

</p>
<p>关键路径的特点：</p>
<ul>
<li>
<p>所有任务的松弛时间都为0。</p>
</li>
<li>
<p>每个事件的最早时刻和最迟时刻都是相等的。</p>
</li>
<li>
<p>所有任务持续时间的和，是PERT图所有路径中最大的，并且与结束事件的最早时刻（或最晚时刻）相等。</p>
<p>设关键路径中所有事件为$V_i$（$i = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_j, V_{j+1}&gt;$（$1 \le j \le n-1$）（表示$V_1$是开始事件，$V_2$是$V_1$往下的一个事件，以此类推，$V_n$是结束事件），那么该关键路径结束事件的最早时刻（或最晚时刻）为：</p>
<p>$$
T_e(V_n) = \sum_{i = 1}^{n-1} T_i
$$</p>
<blockquote>
<p>这里$T_i$代表$T(&lt;V_i, V_{i+1}&gt;)$。</p>
</blockquote>
</li>
</ul>
<p>最迟时刻的另一种求法（PERT图存在关键路径的情况下）：</p>
<p>已知某PERT图结束事件的最晚时刻（最早时刻），该PERT图中某一条路径（假设该路径没有分支）中所有事件为$V_j$（$j = 1, 2, \cdots, n$），且该路径下的任务为$&lt;V_k, V_{k+1}&gt;$（$1 \le k \le n-1$），该路径下任务的持续时间$T(&lt;V_{k-1}, V_k&gt;)$已知，（即$V_1$是开始事件，按照次序往下，$V_n$是结束事件），计算某一事件的最迟时刻$T_l(V_i)$（$1 \le i &lt; n$）：</p>
<p>$$
T_l(V_i) = T_l(V_n) - \sum_{j = i}^{n - 1} T_j
$$</p>
<blockquote>
<p>这里$T_j$代表$T(&lt;V_j, V_{j + 1}&gt;)$。</p>
</blockquote>
<p>即：<u>结束事件的最晚时刻</u> - <u>该事件到结束事件之间所有的任务的持续时间总和</u>。</p>
<blockquote>
<p>注意：如果事件$V_i$到结束事件之间存在多条路径，应该选择那条任务持续时间总和最大的路径。</p>
</blockquote>
<p>PERT图的优点：</p>
<ul>
<li>给出了每个任务的开始时间、结束时间和完成该任务所需的时间；</li>
<li>给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。</li>
</ul>
<p>PERT图不能清晰地描述任务之间的并行情况。</p>
<h3 id="项目活动图" data-numberify>项目活动图<a class="anchor ms-1" href="#项目活动图"></a></h3>
<p>项目活动图是一种有向图（与PERT图十分类似）：</p>
<ul>
<li>
<p>弧：表示活动。弧的权值表示活动的持续时间。</p>
</li>
<li>
<p>顶点：表示项目里程碑。</p>
<p>特殊的里程碑：</p>
<ul>
<li>开始里程碑：没有任何活动指向该里程碑；</li>
<li>结束里程碑：没有任何活动从该里程碑指出。</li>
</ul>
</li>
</ul>
<p>项目活动图的关键路径：按照PERT图的方法求出松弛时间为0的、从开始里程碑到结束里程碑的路径。</p>
<p>关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。</p>
<h2 id="软件配置管理" data-numberify>软件配置管理<a class="anchor ms-1" href="#软件配置管理"></a></h2>
<p>在软件开发过程中变更是不可避免的，而变更时由于没有进行变更控制，可能加剧了项目中的混乱。为了协调软件开发使得混乱减到最小，使用配置管理技术，使变更所产生的错误达到最小并最有效地提高生产率。</p>
<p>软件配置管理（Software Configure Management，SCM）用于整个软件工程过程，它是一组管理整个软件生存周期中各阶段变更的活动。</p>
<p>软件配置管理的主要目标包括：</p>
<ul>
<li>标识变更</li>
<li>控制变更</li>
<li>版本控制</li>
<li>确保变更正确地实现</li>
<li>报告有关变更</li>
</ul>
<p>主要内容有两种版本：</p>
<ol>
<li>
<ul>
<li>版本管理</li>
<li>配置支持</li>
<li>变更支持</li>
<li>过程支持</li>
<li>团队支持</li>
<li>变化报告</li>
<li>审计支持</li>
</ul>
</li>
<li>
<ul>
<li>软件配置标识</li>
<li>变更管理</li>
<li>版本控制</li>
<li>系统建立</li>
<li>配置审核</li>
<li>配置状态报告</li>
</ul>
</li>
</ol>
<h3 id="变更控制" data-numberify>变更控制<a class="anchor ms-1" href="#变更控制"></a></h3>
<p>变更控制是一项最重要的软件配置任务。为了有效地实现变更控制，需借助于配置数据库和基线的概念。</p>
<p>基线：是软件生存周期中各开发阶段的一个特定点，它的作用是使各开发阶段的工作划分更加明确，使本来连续的工作在这些点上断开，以便于检查与肯定阶段成果。</p>
<p>基线可以作为一个检查点。在开发过程中，当采用的基线发生错误时可以知道所处的位置，返回到最近和最恰当的基线上。</p>
<p>配置数据库可分为以下3类：</p>
<ul>
<li>
<p><strong>开发库</strong>：专供开发人员使用，其中的信息可能做频繁修改，对其控制相当宽松。</p>
</li>
<li>
<p><strong>受控库</strong>：在生存期某一阶段工作结束时发布的阶段产品，这些是与软件开发工作相关的计算机可读信息和人工可读信息。</p>
<p>软件配置管理正是对受控库中的各个软件项进行管理，受控库也称为<strong>软件配置库</strong>。</p>
</li>
<li>
<p><strong>产品库</strong>：在开发的软件产品完成系统测试后，作为最终产品存入产品库，等待交付用户或现场安装。</p>
</li>
</ul>
<h3 id="风险管理" data-numberify>风险管理<a class="anchor ms-1" href="#风险管理"></a></h3>
<p>一般认为软件风险包含两个特性：</p>
<ul>
<li><strong>不确定性</strong>：指风险可能发生也可能不发生；</li>
<li><strong>损失</strong>：指如果风险发生，就会产生恶性后果。</li>
</ul>
<p>在进行风险分析时，重要的是量化每个风险的：</p>
<ul>
<li>不确定程度</li>
<li>损失程度</li>
</ul>
<p>项目风险威胁到项目计划。项目风险是指以下各方面的潜在问题以及它们对软件项目的影响：</p>
<ul>
<li>预算</li>
<li>进度</li>
<li>人员：聘用职员及组织</li>
<li>资源</li>
<li>利益相关者</li>
<li>需求</li>
</ul>
<p>以下方面的不确定性也属于项目风险因素：</p>
<ul>
<li>项目复杂度</li>
<li>项目规模</li>
<li>项目结构</li>
</ul>
<p>技术风险威胁到要开发软件的质量及交付时间。技术风险是指以下方面的潜在问题：</p>
<ul>
<li>设计</li>
<li>实现</li>
<li>接口</li>
<li>验证</li>
<li>维护</li>
</ul>
<p>以下方面也属于技术风险因素：</p>
<ul>
<li>规格说明的歧义性</li>
<li>技术的不确定性</li>
<li>技术陈旧</li>
<li>“前沿”技术</li>
</ul>
<p>商业风险威肋到要开发软件的生存能力，且常常会危害到项目或产品。5个主要的商业风险如下：</p>
<ul>
<li><strong>市场风险</strong>：开发了一个没有人真正需要的优良产品或系统。</li>
<li><strong>策略风险</strong>：开发的产品不再符合公司的整体商业策略。</li>
<li><strong>销售风险</strong>：开发了一个销售部门不知道如何去销售的产品。</li>
<li><strong>管理风险</strong>：由于重点的转移或人员的变动而失去了高级管理层的支持。</li>
<li><strong>预算风险</strong>：没有得到预算或人员的保证。</li>
</ul>
<p>Charette提出的风险分类方式：</p>
<ul>
<li>
<p><strong>己知风险</strong>：</p>
<p>通过仔细<u>评估以下内容可以发现</u>的风险：</p>
<ul>
<li><u>项目计划</u></li>
<li><u>开发项目的商业和技术环境</u></li>
<li>其他可靠的信息来源，如：
<ul>
<li><u>不现实的交付时间</u></li>
<li><u>没有文档化需求或文档化软件范围</u></li>
<li><u>恶劣的开发环境</u></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>可预测风险</strong>：</p>
<p>能够<u>从过去项目的经验中推断出来</u>的风险，如：</p>
<ul>
<li>人员变动</li>
<li>与客户缺乏沟通</li>
<li>由于正在进行维护而使开发人员精力分散</li>
</ul>
</li>
<li>
<p><strong>不可预测风险</strong>：可能会真的出现，但<u>很难事先识别</u>。</p>
</li>
</ul>
<h4 id="风险识别" data-numberify>风险识别<a class="anchor ms-1" href="#风险识别"></a></h4>
<p><strong>风险识别</strong>试图<u>系统化地指出对项目计划（估算、进度、资源分配等）的威胁</u>。<u>识别出已知风险和可预测风险后，项目管理者</u>首先要做的是：</p>
<ul>
<li><u>在可能时回避这些风险</u>；</li>
<li><u>在必要时控制这些风险</u>。</li>
</ul>
<p>识别风险的一种方法是<u>建立风险条目检查表</u>，主要用来识别下列几种类型中的一些已知风险和可预测风险：</p>
<ul>
<li><strong>产品规模</strong>：与要开发或要修改的软件的总体规模相关的风险。</li>
<li><strong>商业影响</strong>：与管理者或市场所施加的约束相关的风险。</li>
<li><strong>客户特性</strong>：与客户的素质以及开发者和客户定期沟通的能力相关的风险。</li>
<li><strong>过程定义</strong>：与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险。</li>
<li><strong>开发环境</strong>：与用来开发产品的工具的可得性及质量相关的风险。</li>
<li><strong>开发技术</strong>：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。</li>
<li><strong>人员才干及经验</strong>：与软件工程师的总体技术水平及项目经验相关的风险。</li>
</ul>
<p>与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响。</p>
<p>另一种风险条目检查表格式：仅仅列出与每一种类型有关的特性，最终给出<u>一组风险因素和驱动因子以及它们发生的概率</u>。</p>
<p>风险因素包括：</p>
<ul>
<li><strong>性能</strong>：性能风险是指产品能够满足需求且符合其使用目的的不确定程度。</li>
<li><strong>成本</strong>：成本风险是指能够维持项目预算的不确定程度。</li>
<li><strong>支持</strong>：支特风险是指开发出的软件易于纠错、修改及升级的不确定程度。</li>
<li><strong>进度</strong>：进度风险是指能够维持项目进度且按时交付产品的不确定程度。</li>
</ul>
<h4 id="风险预测" data-numberify>风险预测<a class="anchor ms-1" href="#风险预测"></a></h4>
<p><strong>风险预测</strong>又称<strong>风险估计</strong>，它试图从两个方面评估一个风险：</p>
<ul>
<li>风险发生的可能性或概率；</li>
<li>发生风险所产生的后果。</li>
</ul>
<p>通常，项日计划人员与管理人员、技术人员一起进行以下4步<u>风险预测活动</u>：</p>
<ol>
<li>建立一个尺度或标准，以反映风险发生的可能性。</li>
<li>描述风险产生的后果。</li>
<li>估算风险对项目和产品的影响。</li>
<li>标注风险预测的整体精确度，以免产生误解。</li>
</ol>
<p>一种简单的风险预测技术是建立风险表：</p>
<ul>
<li>
<p>第1列：列出所有的风险（由风险识别活动得到)；</p>
</li>
<li>
<p>第2~4列：列出每个风险的：</p>
<ul>
<li>种类</li>
<li>发生的概率</li>
<li>所产生的影响</li>
</ul>
<p>风险所产生的影响可用一个数字来表示：</p>
<ul>
<li>“1”：表示灾难性的；</li>
<li>“2”：表示严重的；</li>
<li>“3”：表示轻微的；</li>
<li>“4”：表示可忽略的。</li>
</ul>
</li>
</ul>
<p>评估风险影响：</p>
<p>发生风险时，有3个因素可能会影响风险所产生的后果：</p>
<ul>
<li>
<p>风险的<strong>本质</strong>：指当风险发生时可能带来的问题。</p>
</li>
<li>
<p>风险的<strong>范围</strong>：</p>
<p>包括：</p>
<ul>
<li>风险的严重性；</li>
<li>风险的整体分布情况：项目中有多少部分受到影响或有多少客户受到损害。</li>
</ul>
</li>
<li>
<p>风险的<strong>时间</strong>：</p>
<ul>
<li>何时能够感受到风险的影响；</li>
<li>风险的影响会持续多长时间。</li>
</ul>
</li>
</ul>
<h4 id="风险优先级" data-numberify>风险优先级<a class="anchor ms-1" href="#风险优先级"></a></h4>
<p>在进行项目风险管理时，根据风险的优先级来确定风险控制策略。</p>
<ul>
<li><strong>风险优先级</strong>：<u>是根据风险暴露来确定的。</u></li>
<li><strong>风险暴露</strong>：是一种量化风险影响的指标。</li>
</ul>
<p>整体的风险显露度（Risk Exposure，RE）可由下面的关系确定：</p>
<p>$$
RE = P \times C
$$</p>
<ul>
<li>$P$：风险发生的概率；</li>
<li>$C$:风险发生时带来的项目成本。</li>
</ul>
<p>即风险暴露等于风险影响乘以风险概率。风险影响是指当风险发生时造成的损失。</p>
<h4 id="风险评估" data-numberify>风险评估<a class="anchor ms-1" href="#风险评估"></a></h4>
<p>在进行风险评估时，建立了如下形式的三元组：</p>
<p>$$
(r_i, l_i, x_i)
$$</p>
<ul>
<li>$r_i$：表示风险；</li>
<li>$l_i$：表示风险发生的概率；</li>
<li>$x_i$：表示风险产生的影响。</li>
</ul>
<p>一种对风险评估很有用的技术就是<u>定义风险参照水准</u>。对于大多数软件项目来说，有3种典型的风险参照水准</p>
<ul>
<li>成本：成本是否超支</li>
<li>进度：进程是否延期</li>
<li>性能：性能是否下降</li>
</ul>
<p>在风险评估过程中，需要执行以下4个步骤：</p>
<ol>
<li>定义项目的风险参考水平值。</li>
<li>建立每一组$(r_i, l_i, x_i)$与每一个参考水平值之间的关系。</li>
<li>预测一组临界点以定义项目终止区域，该区域由一条曲线或不确定区域所界定。</li>
<li>预测什么样的风险组合会影响参考水平值。</li>
</ol>
<h4 id="风险控制" data-numberify>风险控制<a class="anchor ms-1" href="#风险控制"></a></h4>
<p>风险控制的目的是<u>辅助项目组建立处理风险的策略</u>。一个有效的策略必须考虑以下3个问题：</p>
<ul>
<li>
<p><strong>风险避免</strong>：</p>
<p>应对风险的<u>最好办法是主动地避免风险</u>，即<u>在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生</u>。</p>
</li>
<li>
<p><strong>风险监控</strong>：</p>
<p>项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。</p>
</li>
<li>
<p>RMMM计划：</p>
<p>风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划（RMMM计划）。</p>
<p>RMMM计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用。</p>
<p>建立了RMMM计划，而且项目己经启动之后，风险缓解及监测步骤也就开始了：</p>
<ul>
<li>
<p>风险缓解：一种问题规避活动。</p>
</li>
<li>
<p>风险监测：一种项目跟踪活动。</p>
<p>这种监测活动有3个主要目的：</p>
<ul>
<li>评估所预测的风险是否真的发生了；</li>
<li>保证正确地实施了各风险的缓解步骤；</li>
<li>收集能够用于今后风险缝隙的信息。</li>
</ul>
</li>
</ul>
<p>风险监测的另一个任务就是试图找到“起源”（在整个项目中是哪些风险引起了哪些问题）。</p>
</li>
</ul>
<h4 id="总结-3" data-numberify>总结<a class="anchor ms-1" href="#总结-3"></a></h4>
<p>风险分类总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">项目风险</td>
<td style="text-align:left">威胁到项目计划。<p>风险因素：<br>预算、进度、人员、资源和利益相关者，项目复杂度、规模和结构的不确定性</p></td>
</tr>
<tr>
<td style="text-align:center">技术风险</td>
<td style="text-align:left">威胁到软件的质量及交付时间。<p>风险因素：<br>设计、实现、接口、验证和维护，规格说明的歧义性、技术的不确定性、技术陈旧和使用“前沿”技术</p></td>
</tr>
<tr>
<td style="text-align:center">市场风险</td>
<td style="text-align:left">开发了一个没有人真正需要的产品或系统。</td>
</tr>
<tr>
<td style="text-align:center">策略风险</td>
<td style="text-align:left">开发的产品不再符合公司的整体商业策略。</td>
</tr>
<tr>
<td style="text-align:center">销售风险</td>
<td style="text-align:left">开发了一个销售部门不知道如何去销售的产品。</td>
</tr>
<tr>
<td style="text-align:center">管理风险</td>
<td style="text-align:left">由于重点的转移或人员的变动而失去了高级管理层的支持。</td>
</tr>
<tr>
<td style="text-align:center">预算风险</td>
<td style="text-align:left">没有得到预算或人员的保证。</td>
</tr>
</tbody>
</table>
<p>风险管理总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">风险管理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">风险识别</td>
<td style="text-align:left">指出对项目计划的威胁。可通过建立风险条目检查表识别。</td>
</tr>
<tr>
<td style="text-align:center">风险预测</td>
<td style="text-align:left">从风险发生的可能性或概率、风险产生的后果评估可能发生的风险。</td>
</tr>
<tr>
<td style="text-align:center">风险评估</td>
<td style="text-align:left">从风险发生的概率和产生的影响评估风险。可用定义风险参照水准技术评估。</td>
</tr>
<tr>
<td style="text-align:center">风险控制</td>
<td style="text-align:left">目的是辅助项目建立处理风险的策略。策略是风险避免、风险监控和RMMM计划。</td>
</tr>
<tr>
<td style="text-align:center">风险避免</td>
<td style="text-align:left">应对风险的最好办法是主动地避免风险。</td>
</tr>
<tr>
<td style="text-align:center">风险监控</td>
<td style="text-align:left">项目管理者应监控某些可以提供风险高低变化指示的因素。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="软件质量" data-numberify>软件质量<a class="anchor ms-1" href="#软件质量"></a></h1>
<h2 id="软件质量特性的度量" data-numberify>软件质量特性的度量<a class="anchor ms-1" href="#软件质量特性的度量"></a></h2>
<p>可靠性、可用性和可维护性是软件的质量属性，软件工程中，用$0 \sim 1$之间的数来度量。</p>
<ul>
<li>
<p>可靠性：指一个系统对于<u>给定的时间间隔内、在给定条件下无失效运作的概率</u>。</p>
<p>可以用$\cfrac{MTTF}{1+MTTF}$来度量。</p>
<p>$MTTF$为<u>平均无故障时间</u>。</p>
</li>
<li>
<p>可用性：指<u>在给定的时间点上</u>，一个<u>系统能够按照规格说明正确运作的概率</u>。</p>
<p>可以用$\cfrac{MTBF}{1+MTBF}$来度量。</p>
<p>$MTBF$为<u>平均失效间隔时间</u>。</p>
</li>
<li>
<p>可维护性：<u>在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率</u>。</p>
<p>可以用$\cfrac{1}{1+MTTR}$来度量。</p>
<p>$MTTR$为<u>平均修复时间</u>。</p>
</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">质量属性</th>
<th style="text-align:center">度量公式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center"><p>$\cfrac{MTTF}{1+MTTF}$</p><p>$MTTF$：平均无故障时间</p></td>
<td style="text-align:left">给定时间间隔内、给定条件下，无失效运作的概率</td>
</tr>
<tr>
<td style="text-align:center">可用性</td>
<td style="text-align:center"><p>$\cfrac{MTBF}{1+MTBF}$</p><p>$MTBF$：平均失效间隔时间</p></td>
<td style="text-align:left">给定时间点上、能按照规格说明正确运作的概率</td>
</tr>
<tr>
<td style="text-align:center">可维护性</td>
<td style="text-align:center"><p>$\cfrac{1}{1+MTTR}$</p><p>$MTTR$：平均修复时间</p></td>
<td style="text-align:left">给定使用条件下、规定时间间隔内，使用规定过程和资源完成维护的概率</td>
</tr>
</tbody>
</table>
<h2 id="软件质量模型" data-numberify>软件质量模型<a class="anchor ms-1" href="#软件质量模型"></a></h2>
<p>讨论软件质量首先要了解软件的质量特性，目前己经有多种软件质量模型来描述软件质量特性，如：</p>
<ul>
<li>ISO/IEC 9126 软件质量模型</li>
<li>Me Call 软件质量模型。</li>
</ul>
<h3 id="isoiec-9126-软件质量模型" data-numberify>ISO/IEC 9126 软件质量模型<a class="anchor ms-1" href="#isoiec-9126-软件质量模型"></a></h3>
<p>ISO/IEC 9126软件质量模型由3个层次组成：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>质量子特性</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p>该模型的质量特性和质量子特性：</p>
<table>
<tr>
    <th style="text-align: center;">
        质量特性
    </th>
    <th style="text-align: center;">
        质量子特性
    </th>
</tr>
<tr>
    <td style="text-align: center;" rowspan="6">
        <b>功能性</b>（Functionality）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适合性（Suitability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        准确性（Accurateness）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        互用性（Interoperability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        依从性（Compliance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        安全性（Security）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>可靠性</b>（Reliability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        成熟性（Maturity）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        容错性（Fault tolerance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易恢复性（Recoverability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="4">
        <b>易使用性</b>（Usability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易理解性（Understandability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易学性（Learnability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易操作性（Operability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="3">
        <b>效率</b>（Efficiency）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        时间特性（Time behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        资源特性（Resource behavior）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可维护性</b>（Maintainability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易分析性（Analyzability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易改变性（Changeability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        稳定性（Stability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易测试性（Testability）
    </td>
</tr>
<tr>
    <td style="text-align: center;" rowspan="5">
        <b>可移植性</b>（Portability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        适应性（Adaptability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易安装性（Installability）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        一致性（Conformance）
    </td>
</tr>
<tr>
    <td style="text-align: center;">
        易替换性（Replaceability）
    </td>
</tr>
</table>
<p>质量子特性的含义：</p>
<ul>
<li>功能性：
<ul>
<li><strong>适合性</strong>：与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性。</li>
<li><strong>准确性</strong>：与能够得到正确或相符的结果或效果有关的软件属性。</li>
<li><strong>互用性</strong>：<u>与其他指定系统进行交互操作</u>的能力相关的软件属性。</li>
<li><strong>依从性</strong>：<u>使软件服从有关的标准、约定、法规及类似规定</u>的软件属性。</li>
<li><strong>安全性</strong>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li>
</ul>
</li>
<li>可靠性：
<ul>
<li><strong>成熟性</strong>：与由软件故障引起失效的频度有关的软件属性。</li>
<li><strong>容错性</strong>：与<u>在软件错误或违反指定接口的情况下维持指定的性能水平</u>的能力有关的软件属性。</li>
<li><strong>易恢复性</strong>：与<u>在故障发生后，重新建立其性能水平并恢复直接受影响数据</u>的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li>
</ul>
</li>
<li>易使用性：
<ul>
<li><strong>易理解性</strong>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li>
<li><strong>易学性</strong>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li>
<li><strong>易操作性</strong>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li>
</ul>
</li>
<li>效率：
<ul>
<li><strong>时间特性</strong>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li>
<li><strong>资源特性</strong>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li>
</ul>
</li>
<li>可维护性：
<ul>
<li><strong>易分析性</strong>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li>
<li><strong>易改变性</strong>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li>
<li><strong>稳定性</strong>：与修改造成未预料效果的风险有关的软件属性。</li>
<li><strong>易测试性</strong>：为确认经修改软件所需努力有关的软件属性。</li>
</ul>
</li>
<li>可移植性：
<ul>
<li><strong>适应性</strong>：与软件转移到不同环境时的处理或手段有关的软件属性。</li>
<li><strong>易安装性</strong>：与在指定环境下安装软件所需努力有关的软件属性。</li>
<li><strong>一致性</strong>：使软件服从与可移植性有关的标准或约定的软件属性。</li>
<li><strong>易替换性</strong>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li>
</ul>
</li>
</ul>
<h3 id="mc-call-软件质量模型" data-numberify>Mc Call 软件质量模型<a class="anchor ms-1" href="#mc-call-软件质量模型"></a></h3>
<p>Mc Call软件质量模型从以下3个方面确定了11个质量特性：</p>
<ul>
<li>软件产品的<strong>运行</strong></li>
<li>软件产品的<strong>修正</strong></li>
<li>软件产品的<strong>转移</strong></li>
</ul>
<p>Mc Call也给出了一个三层模型框架：</p>
<ol>
<li>第一层：<strong>质量特性</strong></li>
<li>第二层：<strong>评价准则</strong></li>
<li>第三层：<strong>度量指标</strong></li>
</ol>
<p><picture><img class="img-fluid " alt="Mc Call 软件质量模型" src="/docs/ruan-she/software-engineering/uTools_1683794894507.png" loading="lazy" width="533" height="379" />
</picture>

</p>
<h2 id="软件质量保证" data-numberify>软件质量保证<a class="anchor ms-1" href="#软件质量保证"></a></h2>
<p>软件质量保证是指为保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件。</p>
<p>软件质量保证包括了与以下7个主要活动相关的各种任务：</p>
<ul>
<li>应用技术方法</li>
<li>进行正式的技术评审</li>
<li>测试软件</li>
<li>标准的实施</li>
<li>控制变更</li>
<li>度量（Metrics）</li>
<li>记录保存和报告</li>
</ul>
<h3 id="软件评审" data-numberify>软件评审<a class="anchor ms-1" href="#软件评审"></a></h3>
<p>通常，把“质量”理解为“用户满意程度”。为了使得用户满意，有以下两个必要条件：</p>
<ul>
<li>
<p><strong>设计质量</strong>：设计的规格说明书符合用户的要求。</p>
<p>设计质量的评审对象：</p>
<ul>
<li>软件需求规格说明</li>
<li>数据需求规格说明</li>
<li>软件概要设计说明</li>
</ul>
</li>
<li>
<p><strong>程序质量</strong>：程序按照设计规格说明所规定的情况正确执行。</p>
<p>程序质量的评审通常是从开发者的角度进行，与开发技术直接相关。程序质量的评审对象：</p>
<ul>
<li>软件结构：
<ul>
<li>功能结构：
<ul>
<li>数据结构</li>
<li>功能结构</li>
<li>数据结构和功能结构之间的对应关系</li>
</ul>
</li>
<li>功能的通用性</li>
<li>模块的层次</li>
<li>模块结构：
<ul>
<li>控制流结构</li>
<li>数据流结构</li>
<li>模块结构与功能结构之间的对应关系</li>
</ul>
</li>
<li>处理过程的结构</li>
</ul>
</li>
<li>与运行环境的接口：
<ul>
<li>与硬件的接口</li>
<li>与用户的接口</li>
</ul>
</li>
<li>变更带来的影响</li>
</ul>
</li>
</ul>
<p>软件的规格说明分为：</p>
<ul>
<li>
<p><strong>外部规格说明</strong>：从用户角度来看的规格，包括硬件/软件系统设计、功能设计；</p>
<p>设计质量是由外部规格说明决定的</p>
</li>
<li>
<p><strong>内部规格说明</strong>：为了实现外部规格的更详细的规格，即软件模块结构与模块处理过程的设计。</p>
<p>内部规格说明是从开发者角度来看的规格说明。</p>
<p>程序是由内部规格说明决定的。</p>
</li>
</ul>
<h3 id="软件容错技术" data-numberify>软件容错技术<a class="anchor ms-1" href="#软件容错技术"></a></h3>
<p>提高软件质量和可靠性的技术大致可分为两类：</p>
<ul>
<li>避开错误：在开发的过程中不让差错潜入软件的技术；</li>
<li>容错技术：对某些无法避开的差错，使其影响减至最小的技术。</li>
</ul>
<p>实现容错的<u>主要手段是<strong>冗余</strong></u>。冗余是指<u>对于实现系统规定功能是多余的那部分资源</u>，包括：</p>
<ul>
<li>硬件</li>
<li>软件</li>
<li>信息</li>
<li>时间</li>
</ul>
<p>由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为4类：</p>
<ul>
<li>
<p><strong>结构冗余</strong>：结构冗余是通常采用的冗余技术，按其工作方法可以分为：</p>
<ul>
<li>
<p><strong>静态冗余</strong>：</p>
<p>常用的有：</p>
<ul>
<li>三模冗余（Triple Module Redundancy，TR）</li>
<li>多模冗余</li>
</ul>
<p>静态冗余通过表决和比较来屏蔽系统中出现的错误。</p>
</li>
<li>
<p><strong>动态冗余</strong>：动态冗余的主要方式是多重模块待机储备。</p>
<p>当系统测试到某工作模块出现错误时，就用一个备用模块来顶替它并重新运行。这里包括以下过程：</p>
<ul>
<li>检测</li>
<li>切换</li>
<li>恢复</li>
</ul>
<p>动态冗余有以下两种方式：</p>
<ul>
<li>
<p>热备份系统：每当一个出错模块被其他备用模块顶替后，冗余系统相当于进行了一次重构。</p>
<p>在热备份系统中，备用模块在待机过程中的失效率为0。</p>
</li>
<li>
<p>冷备份系统：各备用模块在其待机时可与主模块一同工作，也可不工作。</p>
</li>
</ul>
</li>
<li>
<p><strong>混合冗余</strong>：兼有静态元余和动态冗余的长处。</p>
</li>
</ul>
</li>
<li>
<p><strong>信息冗余</strong>：指为检测或纠正信息在运算或传输中的错误需外附加的一部分信息。</p>
</li>
<li>
<p><strong>时间冗余</strong>：指以重复执行指令或程序来消除瞬时错误带来的影响。</p>
</li>
<li>
<p><strong>冗余附加技术</strong>：指为实现上述冗余技术所需的资源和技术，包括：</p>
<p>程序、指令、数据、存放和调动它们的空间和通道等。</p>
<p>在屏蔽硬件错误的容错技术中，冗余附加技术包括：</p>
<ol>
<li>关键程序和数据的冗余存储及调用。</li>
<li>检测、表决、切换、重构、纠错和复算的实现。</li>
</ol>
<p>在屏蔽软件错误的容错系统中，冗余附加技术的构成包括：</p>
<ol>
<li><u>冗余备份程序的存储及调用。</u></li>
<li><u>实现错误检测和错误恢复的程序。</u></li>
<li><u>实现容错软件所需的固化程序。</u></li>
</ol>
</li>
</ul>
<hr>
<h1 id="mccabe-软件复杂性度量法" data-numberify>McCabe 软件复杂性度量法<a class="anchor ms-1" href="#mccabe-软件复杂性度量法"></a></h1>
<p><strong>McCabe度量法</strong>又称<strong>环路度量法</strong>，是<u>通过定义环路复杂度，建立程序复杂性的度量，它是一种基于程序控制流的复杂性度量方法</u>，它反映了程序（或模块）的控制结构的复杂性。</p>
<p>MaCabe度量法认为<u>程序的复杂性在很大程度上取决于控制的复杂性</u>。单一的顺序程序结构最为简单，循环和选择构成的环路越多，程序就越复杂。</p>
<p>MaCabe度量法以图论为工具，先画出程序图，然后用该图的环路数作为程序复杂性的度量值。</p>
<p>程序图是退化的程序流程图。把程序流程图中的每个处理符号都退化成一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为程序图。</p>
<p><picture><img class="img-fluid " alt="程序图示例" src="/docs/ruan-she/software-engineering/uTools_1683629835683.png" loading="lazy" width="447" height="416" />
</picture>

</p>
<p>程序图仅描述程序内部的控制流程，完全不表现对数据的具体操作以及分支和循环的具体条件。</p>
<p>根据图论，在一个强连通的有向图$G$中，计算环的个数$V(G)$的公式为：</p>
<p>$$
V(G) = m - n + 2p
$$</p>
<ul>
<li>$V(G)$：$G$中的<u>环路个数</u>；</li>
<li>$m$：$G$中的<u>弧的个数</u>；</li>
<li>$n$：$G$中的<u>结点数</u>；</li>
<li>$p$：$G$中的<u>强连通分量个数</u>。</li>
</ul>
<p>在一个程序中，从程序图的入口点总能到达图中的任何一个结点，因此，程序总是连通的，但不是强连通的。</p>
<p>为了使程序图成为强连通图，<u>从图的入口点到出口点加一条用虚线表示的有向边</u>（如上图所示），使图成为强连通图（但虚线弧并不算入实际的弧数）。这样就可以使用上式计算环路复杂性了，也因此程序图的$p$通常为1。</p>
<p>即，计算有向图$G$的环路复杂性的公式为：</p>
<p>$$
V(G) = m - n + 2
$$</p>
<p>例如上图中，结点数$n=6$，弧数$m=9$，则：</p>
<p>$$
V(G) = 9 - 6 + 2 = 5
$$</p>
<p>即上图McCabe环路复杂的度量值为5。</p>
<blockquote>
<p>$V(G) = 10$是一个实际模块的上限。当$V(G) &gt; 10$时，很难充分测试这个模块。</p>
<p>在白盒测试中，计算环路复杂度可以简单地使用判定条件的数量 + 1。</p>
</blockquote>
<hr>
<h1 id="软件工具" data-numberify>软件工具<a class="anchor ms-1" href="#软件工具"></a></h1>
<h2 id="软件开发工具" data-numberify>软件开发工具<a class="anchor ms-1" href="#软件开发工具"></a></h2>
<p>对应于软件开发过程的各种活动，软件开发工具通常有：</p>
<ul>
<li>需求分析工具</li>
<li>设计工具</li>
<li>编码与排错工具</li>
<li>测试工具</li>
</ul>
<h2 id="软件维护工具" data-numberify>软件维护工具<a class="anchor ms-1" href="#软件维护工具"></a></h2>
<p>辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：</p>
<ul>
<li><u>版本控制</u>工具</li>
<li><u>文档分析</u>工具</li>
<li><u>开发信息库</u>工具</li>
<li><u>逆向工程</u>工具</li>
<li><u>再工程</u>工具</li>
</ul>
<h2 id="软件管理和软件支持工具" data-numberify>软件管理和软件支持工具<a class="anchor ms-1" href="#软件管理和软件支持工具"></a></h2>
<p>软件管理和软件支持工具用来辅助管理人员和软件支持人员的管理活动和支持活动，以确保软件高质量地完成。</p>
<p>常用的铺助软件管理和软件支持的工具有：</p>
<ul>
<li>项目管理工具</li>
<li>配置管理工具</li>
<li>软件评价工具</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>结构化开发篇</title>
      <link>/docs/ruan-she/structured-dev/</link>
      <pubDate>Sun, 07 May 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/ruan-she/structured-dev/</guid>
      <description><![CDATA[概述 结构化方法是一种面向数据流的开 发方法，它由以下构成： 结构化分析：根据分解与抽象的原则，按照系统中数据处理的流程，用数据流图来建立系统的功]]></description>
      <content:encoded><![CDATA[<h1 id="概述" data-numberify>概述<a class="anchor ms-1" href="#概述"></a></h1>
<p>结构化方法是一种面向数据流的开
发方法，它由以下构成：</p>
<ul>
<li>结构化分析：根据分解与抽象的原则，按照系统中数据处理的流程，用数据流图来建立系统的功能模型，从而完成需求分析工作。</li>
<li>结构化设计：根据模块独立性准则、软件结构优
化准则将数据流图转换为软件的体系结构，用软件结构图来建立系统的物理模型，实现系统的
概要设计。</li>
<li>结构化程序设计：使用3种基本控制结构构造程序，任何程序都可以由顺序、选择和重复3种基本控制结构构造。</li>
</ul>
<p>结构化方法总的指导思想是自顶向下、逐层分解，它的基本原则是功能的分解与抽象。它是软件工程中最早出现的开发方法，特别适合于数据处理领域的问题，但是不适合解决大规模的、特别复杂的项目，且难以适应需求的变化。</p>
<hr>
<h1 id="系统设计" data-numberify>系统设计<a class="anchor ms-1" href="#系统设计"></a></h1>
<h2 id="抽象" data-numberify>抽象<a class="anchor ms-1" href="#抽象"></a></h2>
<p>抽象是一种设计技术，重点说明一个实体的本质方面，而忽略或者掩盖不太重要或非本质的方面。</p>
<p>抽象是一种重要的工具，用来将复杂的现象简化到可以分析、实验或者可以理解的程度。</p>
<p>软件工程中从软件定义到软件开发要经历多个阶段，在这个过程中每前进一步都可看作是对软件解法的抽象层次的一次细化。</p>
<p>抽象的最底层就是实现该软件的源程序代码。在进行模块化设计时也可以有多个抽象层次，最高抽象层次的模块用概括的方式叙述问题的解法，较低抽象层次的模块是较高抽象层次模块对问题解法描述的细化。</p>
<h2 id="模块化" data-numberify>模块化<a class="anchor ms-1" href="#模块化"></a></h2>
<ul>
<li>
<p><strong>模块</strong>：是在程序中是数据说明、可执行语句等<u>程序对象的集合</u>，或者是单独命名和编址的元素，例如高级语言中的过程、函数和子程序等。</p>
<p>在软件的体系结构中，模块是可组合、分解和更换的单元。</p>
</li>
<li>
<p><strong>模块化</strong>：是指<u>将一个待开发的软件分解成若干个小的简单部分一模块</u>，<u>每个模块可独立地开发、测试，最后组装成完整的程序</u>。</p>
<p>这是一种<u>复杂问题“分而治之”的原则</u>。</p>
<p>模块化的<u>目的是使程序的结构清晰，容易阅读、理解、测试和修改。</u></p>
</li>
<li>
<p><strong>模块独立</strong>：是指<u>每个模块完成一个相对独立的特定子功能</u>，并且<u>与其他模块之间的联系简单</u>。</p>
<p>衡量模块独立程度的标准有（模块独立性的两个定性标准）：</p>
<ul>
<li><strong>耦合性</strong>；</li>
<li><strong>内聚性</strong>。</li>
</ul>
<p>在将软件系统划分模块时，应尽量做到<strong>高内聚</strong>、<strong>低耦合</strong>，提高模块的独立性。</p>
</li>
</ul>
<p>通常，可以按照在软件系统中的功能将模块分为四种类型：</p>
<ul>
<li>传入模块：取得数据或输入数据，经过某些处理，再将其传送给其他模块。</li>
<li>传出模块：输出数据，在输出前可能进行某些处理。数据可能被输出到系统的外部，或者会输出到其他模块进行进一步处理。</li>
<li>变换模块：从上级调用模块得到数据，进行特定的处理，转换成其他形式，再将加工结果返回给调用模块。</li>
<li>协调模块：一般不对数据进行加工，主要是通过调用、协调和管理其他模块来完成特定的功能。</li>
</ul>
<h3 id="耦合" data-numberify>耦合<a class="anchor ms-1" href="#耦合"></a></h3>
<p>耦合是模块之间的相对独立性（互相连接的紧密程度）的度量。</p>
<p>模块之间的耦合取决于：</p>
<ul>
<li>各个模块之间接口的复杂程度；</li>
<li>调用模块的方式；</li>
<li>通过接口的信息类型。</li>
</ul>
<p>一般模块之间可能的耦合方式有7种类型：</p>
<p><picture><img class="img-fluid " alt="耦合的种类" src="/docs/ruan-she/structured-dev/uTools_1683443957893.png" loading="lazy" width="874" height="133" />
</picture>

</p>
<ul>
<li>
<p><strong>无直接耦合</strong>：指两个模块之间<u>没有直接的关系</u>，它们分别从属于不同模块的控制与调用，<u>它们之间不传递任何信息</u>。</p>
<p>无直接耦合的模块间：</p>
<ul>
<li><u>耦合性最弱</u>；</li>
<li><u>模块独立性最高</u>。</li>
</ul>
</li>
<li>
<p><strong>数据耦合</strong>：指两个模块之间<u>有调用关系</u>，<u>传递的是简单的数据值</u>，相当于高级语言中的值传递。</p>
</li>
<li>
<p><strong>标记耦合</strong>：指两个模块之间<u>传递的是数据结构</u>。</p>
</li>
<li>
<p><strong>控制耦合</strong>：指一个模块调用另一个模块时，<u>传递的是控制变量</u>，<u>被调用模块通过该控制变量的值有选择地执行模块内的某一功能</u>。</p>
</li>
<li>
<p><strong>外部耦合</strong>：模块间<u>通过软件之外的环境联结</u>（如I/O将模块耦合到特定的设备、格式、通信协议上）时称为外部耦合。</p>
</li>
<li>
<p><strong>公共耦合</strong>：指<u>通过一个公共数据环境相互作用</u>的那些模块间的耦合。</p>
</li>
<li>
<p><strong>内容耦合</strong>：当一个模块<u>直接使用另一个模块的内部数据</u>，或<u>通过非正常入口转入另一个模块内部时</u>，这种模块之间的耦合称为内容耦合。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">耦合类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无直接耦合</td>
<td style="text-align:left">没有直接关系，不传递任何信息</td>
</tr>
<tr>
<td style="text-align:center">数据耦合</td>
<td style="text-align:left">调用关系，传递简单数据值</td>
</tr>
<tr>
<td style="text-align:center">标记耦合</td>
<td style="text-align:left">传递数据结构</td>
</tr>
<tr>
<td style="text-align:center">控制耦合</td>
<td style="text-align:left">调用关系，被调模块传递给主调模块控制变量</td>
</tr>
<tr>
<td style="text-align:center">外部耦合</td>
<td style="text-align:left">通过软件之外的环境联结</td>
</tr>
<tr>
<td style="text-align:center">公共耦合</td>
<td style="text-align:left">通过公共数据环境相互作用</td>
</tr>
<tr>
<td style="text-align:center">内容耦合</td>
<td style="text-align:left">直接使用另一个模块的内部数据<br>或通过非正常入口转入另一个模块内部</td>
</tr>
</tbody>
</table>
<blockquote>
<p>解耦：降低模块之间的耦合性的过程。</p>
</blockquote>
<h3 id="内聚" data-numberify>内聚<a class="anchor ms-1" href="#内聚"></a></h3>
<p>内聚是<u>对一个模块内部各个元素彼此结合的紧密程度的度量</u>。<u>一个内聚程度高的模块（在理想情况下）应当只做一件事。</u></p>
<p>一般模块的内聚性分为7种类型：</p>
<p><picture><img class="img-fluid " alt="内聚的种类" src="/docs/ruan-she/structured-dev/uTools_1683460613634.png" loading="lazy" width="852" height="150" />
</picture>

</p>
<ul>
<li>
<p><strong>偶然内聚</strong>（<strong>巧合内聚</strong>）：指一个模块内的各<u>处理元素之间没有任何联系</u>。</p>
<p>偶然内聚具有最低的内聚性。</p>
<p>具有偶然内聚的模块具有以下特点（缺点）：</p>
<ul>
<li>不易修改、理解和维护；</li>
<li>会影响到模块间的耦合关系。</li>
</ul>
</li>
<li>
<p><strong>逻辑内聚</strong>：指模块内<u>执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能</u>。</p>
</li>
<li>
<p><strong>时间内聚</strong>：把<u>需要同时执行的动作组合在一起形成的模块</u>。</p>
</li>
<li>
<p><strong>过程内聚</strong>：指一个模块<u>完成多个任务，这些任务必须按指定的过程执行</u>。</p>
</li>
<li>
<p><strong>通信内聚</strong>：指模块内的<u>所有处理元素都在同一个数据结构上操作</u>，或者<u>各处理使用相同的输入数据或者产生相同的输出数据</u>。</p>
</li>
<li>
<p><strong>顺序内聚</strong>：指一个模块中的<u>各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入</u>。</p>
</li>
<li>
<p><strong>功能内聚</strong>：指模块内的<u>所有元素共同作用完成一个功能，缺一不可</u>。</p>
<p>这是最强的内聚。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">内聚类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偶然内聚<br>（巧合内聚）</td>
<td style="text-align:left">各处理之间没有任何联系</td>
</tr>
<tr>
<td style="text-align:center">逻辑内聚</td>
<td style="text-align:left">执行若干个逻辑上相似的功能，<br>通过参数确定该模块完成哪一个功能</td>
</tr>
<tr>
<td style="text-align:center">时间内聚</td>
<td style="text-align:left">把需要同时执行的动作组合在一起</td>
</tr>
<tr>
<td style="text-align:center">过程内聚</td>
<td style="text-align:left">完成多个任务，这些任务必须按指定的过程执行</td>
</tr>
<tr>
<td style="text-align:center">通信内聚</td>
<td style="text-align:left">所有处理都在同一个数据结构上操作，<br>或者各处理使用相同的输入数据或者产生相同的输出数据</td>
</tr>
<tr>
<td style="text-align:center">顺序内聚</td>
<td style="text-align:left">各处理都与同一功能密切相关且必须顺序执行，<br>前一功能元素的输出就是下一功能元素的输入</td>
</tr>
<tr>
<td style="text-align:center">功能内聚</td>
<td style="text-align:left">所有元素共同作用完成一个功能，缺一不可</td>
</tr>
</tbody>
</table>
<h2 id="系统结构设计原则" data-numberify>系统结构设计原则<a class="anchor ms-1" href="#系统结构设计原则"></a></h2>
<p>为保证总体结构设计顺利完成，应遵循以下几条原则：</p>
<ul>
<li>
<p><strong>分解——协调原则</strong>：</p>
<p>系统整体，具有其整体的目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</p>
</li>
<li>
<p><strong>自顶向下的原则</strong>：</p>
<p>从上往下，逐层分解；先确定上层模块的功能，再确定下层模块的功能。</p>
</li>
<li>
<p><strong>信息隐蔽、抽象的原则</strong>：</p>
<p><u>上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做</u>，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。</p>
</li>
<li>
<p><strong>一致性原则</strong>：</p>
<p>要保证整个软件设计过程中具有：</p>
<ul>
<li><strong>统一的规范</strong>、</li>
<li><strong>统一的标准</strong>、</li>
<li><strong>统一的文件模式</strong></li>
<li>……</li>
</ul>
</li>
<li>
<p><strong>明确性原则</strong>：</p>
<p>每个模块必须：</p>
<ul>
<li>功能明确、接口明确；</li>
<li>消除多重功能和无用接口。</li>
</ul>
</li>
<li>
<p><strong>高内聚、低耦合</strong>：</p>
<p>模块之间的耦合尽可能小，模块的内聚度尽可能高。</p>
</li>
<li>
<p><strong>模块的扇入系数和扇出系数要合理</strong>：</p>
<ul>
<li><strong>扇出系数</strong>：模块直接调用其他模块的个数。</li>
<li><strong>扇入系数</strong>：模块被其他模块调用时，直接调用它的模块个数。</li>
</ul>
<p>经验表明，<u>一个设计得好的系统的平均扇入、扇出系数通常是 3 或 4，一般不应超过 7</u>，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系数可以大一些，公用模块的扇入系数可以大一些。</p>
</li>
<li>
<p><strong>模块的规模适当</strong>：</p>
<ul>
<li><u>过大的模块常常使系统分解得不充分；</u></li>
<li><u>过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</u></li>
</ul>
</li>
<li>
<p><u>模块的作用范围应该在其控制范围之内。</u></p>
</li>
<li>
<p>避免或减少使用病态连接：病态连接是指从中部进入或访问一个模块。</p>
</li>
</ul>
<h2 id="系统文档" data-numberify>系统文档<a class="anchor ms-1" href="#系统文档"></a></h2>
<p>信息系统的文档是系统建设过程的“痕迹”，是系统维护人员的指南，是开发人员与用户交流的工具。</p>
<p>对文档在<u>系统开发人员</u>、<u>项目管理人员</u>、<u>系统维护人员</u>、<u>系统评价人员</u>以及<u>用户</u>之间的多种作用总结如下：</p>
<ul>
<li>
<p><u>用户</u>与<u>系统分析人员</u>在<u>系统规划</u>和<u>系统分析阶段</u>通过文档进行沟通。</p>
<p>这里的文档主要包括：</p>
<ul>
<li><strong>可行性研究报告</strong>、</li>
<li><strong>总体规划报告</strong>、</li>
<li><strong>系统开发合同</strong>、</li>
<li><strong>系统方案说明书</strong>。</li>
</ul>
</li>
<li>
<p><u>系统开发人员</u>与<u>项目管理人员</u>通过文档在<u>项目期内</u>进行沟通。</p>
<p>这里的文档是指项目管理文件，主要有：</p>
<ul>
<li>
<p><strong>系统开发计划</strong>，</p>
<p>包括：</p>
<ul>
<li><strong>工作任务分解表</strong>、</li>
<li><strong>PERT图</strong>、</li>
<li><strong>甘特图</strong>、</li>
<li><strong>预算分配表</strong>；</li>
</ul>
</li>
<li>
<p><strong>系统开发月报</strong>；</p>
</li>
<li>
<p><strong>系统开发总结报告</strong>。</p>
</li>
</ul>
<p>有了这些文档可以：</p>
<ul>
<li>不同阶段开发人员工作的顺利交接；</li>
<li>降低因为人员流动带来的风险。</li>
</ul>
</li>
<li>
<p><u>系统测试人员</u>与<u>系统开发人员</u>通过文档进行沟通。</p>
<p>系统测试人员可以根据以下文档对系统开发人员所开发的系统进行测试：</p>
<ul>
<li><strong>系统方案说明书</strong>、</li>
<li><strong>系统开发合同</strong>、</li>
<li><strong>系统设计说明书</strong>、</li>
<li><strong>测试计划</strong>。</li>
</ul>
<p>系统测试人员再将评估结果撰写成<strong>系统测试报告</strong>。</p>
</li>
<li>
<p><u>系统开发人员</u>与<u>用户</u>在<u>系统运行期间</u>进行沟通。</p>
<p>用户通过系统开发人员撰写的文档运行系统。这里的文档主要是：</p>
<ul>
<li><strong>用户手册</strong>、</li>
<li><strong>操作指南</strong>。</li>
</ul>
</li>
<li>
<p><u>系统开发人员</u>与<u>系统维护人员</u>通过文档进行沟通。</p>
<p>这里的文档主要有：</p>
<ul>
<li>
<p><strong>系统设计说明书</strong>；</p>
</li>
<li>
<p><strong>系统开发总结报告</strong>。</p>
<p>开发总结报告还可分为以下3个文档：</p>
<ul>
<li><strong>研制报告</strong>；</li>
<li><strong>技术报告</strong>；</li>
<li><strong>技术手册</strong>：记录了系统开发过程中的各种主要技术细节。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><u>用户</u>与<u>维修人员</u>在<u>运行维护期间</u>进行沟通。</p>
<p>用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成：</p>
<ul>
<li><strong>系统运行报告</strong>、</li>
<li><strong>维护修改建议</strong>。</li>
</ul>
<p>系统维护人员根据以下文档对系统进行维护和升级：</p>
<ul>
<li>维护修改建议；</li>
<li>系统开发人员留下的技术手册等文档。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">人员</th>
<th style="text-align:center">阶段</th>
<th style="text-align:left">文档</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用户<br>系统分析人员</td>
<td style="text-align:center">系统规划<br>系统分析</td>
<td style="text-align:left">沟通文档，主要是<strong>规划报告</strong>、<strong>合同</strong>、<strong>方案</strong>：<br><ul><li>可行性研究报告</li><li>总体规划报告</li><li>系统开发合同</li><li>系统方案说明书</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>项目管理人员</td>
<td style="text-align:center">项目期内</td>
<td style="text-align:left">沟通文档（项目管理文件），主要是<strong>计划</strong>、<strong>报告</strong>类文档：<br><ul><li>系统开发计划<ul><li>工作任务分解表</li><li>PERT图</li><li>甘特图</li><li>预算分配表</li></ul></li><li>系统开发月报</li><li>系统开发总结报告</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统测试人员<br>系统开发人员</td>
<td style="text-align:center">测试</td>
<td style="text-align:left">系统测试人员根据以下文档对系统进行测试：<br><ul><li>系统方案说明书</li><li>系统开发合同</li><li>系统设计说明书</li><li>测试计划</li></ul>系统测试人员再将评估结果撰写成系统测试报告</td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>用户</td>
<td style="text-align:center">系统运行期间</td>
<td style="text-align:left">用户通过系统开发人员撰写的文档运行系统：<br><ul><li>用户手册</li><li>操作指南</li></ul></td>
</tr>
<tr>
<td style="text-align:center">系统开发人员<br>系统维护人员</td>
<td style="text-align:center">维护</td>
<td style="text-align:left">沟通文档：<ul><li>系统设计说明书</li><li>系统开发总结报告<ul><li>研制报告</li><li>研制报告</li><li>技术手册</li></ul></li></ul></td>
</tr>
<tr>
<td style="text-align:center">用户<br>维修人员</td>
<td style="text-align:center">运维</td>
<td style="text-align:left">用户将运行过程中的问题进行记载：<ul><li>系统运行报告</li><li>维护修改建议</li></ul>系统维护人员根据以下文档对系统进行维护和升级：<ul><li>维护修改建议</li><li>系统开发人员留下的技术手册等文档</li></ul></td>
</tr>
</tbody>
</table>
<hr>
<h1 id="结构化分析方法" data-numberify>结构化分析方法<a class="anchor ms-1" href="#结构化分析方法"></a></h1>
<h2 id="数据流图" data-numberify>数据流图<a class="anchor ms-1" href="#数据流图"></a></h2>
<p><strong>数据流图</strong>也称<strong>数据流程图</strong>（Data Flow Diagram，<strong>DFD</strong>），是一种便于用户理解、分析系统数据流程的图形工具。它<u>摆脱了系统的物理内容</u>，精确地在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p>
<p>数据流图中的基本图形元素包括：</p>
<ul>
<li>
<p><strong>数据流</strong>（Data Flow）：由一组固定成分的数据组成，表示数据的流向。</p>
<p><picture><img class="img-fluid " alt="数据流" src="/docs/ruan-she/structured-dev/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</p>
<p>在DFD种，数据流的流向由以下几种：</p>
<ul>
<li>从<u>加工</u>流向另一个<u>加工</u>；</li>
<li>从<u>加工</u>流向<u>数据存储</u>（写）；</li>
<li>从<u>数据存储</u>流向<u>加工</u>（读）；</li>
<li>从<u>外部实体</u>流向<u>加工</u>（输入）；</li>
<li>从<u>加工</u>流向<u>外部实体</u>（输出）。</li>
</ul>
<p>即数据流的<u>起点或终点必须至少有一个是加工</u>。</p>
<p>除了与数据存储有关的数据流（流向数据存储或从数据存储流出），DFD中的每个数据流都必须用一个定义明确的名字表示。</p>
</li>
<li>
<p><strong>加工</strong>（Process）：加工描述了输入数据流到输出数据流之间的变换，也就是<u>输入数据流经过什么处理后变成了输出数据流</u>。</p>
<p><picture><img class="img-fluid " alt="加工" src="/docs/ruan-she/structured-dev/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</p>
<p>每个加工都有一个名字和编号。</p>
<p>一个加工可以有多个输入数据流和多个输出数据流，但<u>至少有一个输入数据流和一个输出数据流</u>。</p>
<p>数据流图中常见的3种错误如下所示：</p>
<ul>
<li>
<p><strong>黑洞</strong>：加工只有输入，没有输出。</p>
<p>如下图加工1。</p>
</li>
<li>
<p><strong>白洞</strong>：加工只有输出但没有输入。</p>
<p>如下图加工2。</p>
</li>
<li>
<p><strong>灰洞</strong>：加工中输入数据不足以产生输出数据。</p>
<p>有几种可能的原因：</p>
<ul>
<li>一个错误的命名过程；</li>
<li>错误命名的输入或输出；</li>
<li>不完全的事实。</li>
</ul>
<p>如下图加工3。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="数据流图中常见错误" src="/docs/ruan-she/structured-dev/1683528176745.png" loading="lazy" width="793" height="542" />
</picture>

</p>
</li>
<li>
<p><strong>数据存储</strong>（Data Store）：存储和提供数据。</p>
<p><picture><img class="img-fluid " alt="数据存储" src="/docs/ruan-she/structured-dev/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</p>
<p>每个数据存储都有一个定义明确的名字标识。</p>
<p>数据存储可以：</p>
<ul>
<li>存储加工的输出数据：数据流流入数据存储，表示数据的写入操作；</li>
<li>提供加工的输入数据：数据流从数据存储流出，表示数据的读操作。</li>
<li>双向箭头的数据流指向数据存储，表示对数据的修改。</li>
</ul>
<p>DFD中的数据存储在具体实现时可以用以下方式实现：</p>
<ul>
<li>文件系统实现；</li>
<li>数据库系统实现。</li>
</ul>
<p>数据存储的存储介质可以是：</p>
<ul>
<li>磁盘、</li>
<li>磁带、</li>
<li>其他存储介质。</li>
</ul>
</li>
<li>
<p><strong>外部实体</strong>（External Agent，外部主体）：指<u>存在于软件系统之外的人员、组织、物体或外部系统</u>，它指出系统所需数据的<u>发源地（源）</u>和<u>系统所产生的数据的归宿地（宿）</u>。</p>
<p><picture><img class="img-fluid " alt="外部实体" src="/docs/ruan-she/structured-dev/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</p>
<p>例如：</p>
<ul>
<li>人员：学生、老师、员工、主观、医生、客户……</li>
<li>组织：供应商、采购部门……</li>
<li>物体：传感器、控制器、单车、车辆……</li>
<li>外部系统：支付系统、车辆交易系统、库存管理系统、道闸控制系统……</li>
</ul>
<p>在许多系统中，某个源和某个宿可以是同一个人员、组织、物体或外部系统，此时，在DFD中可以用同一个符号表示：</p>
<ul>
<li>当数据流从该符号流出时，表示它是源；</li>
<li>当数据流流向该符号时，表示它是宿；</li>
<li>当两者皆有时，表示它既是源又是宿。</li>
</ul>
<p>外部实体表示存在于系统之外的对象，用来帮助用户理解系统数据的来源和去向。</p>
</li>
</ul>
<p>软件系统内部的<strong>数据处理模型</strong>：使用<u>数据流</u>、<u>加工</u>和<u>数据存储</u>构建。</p>
<p>数据流图描述了系统的分解，但没有对图中各成分进行说明。</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本元素</th>
<th style="text-align:center">图形表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据流</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据流" src="/docs/ruan-she/structured-dev/uTools_1683518468182.png" loading="lazy" width="193" height="71" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">加工</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="加工" src="/docs/ruan-she/structured-dev/1683518239889.png" loading="lazy" width="282" height="105" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">数据存储</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="数据存储" src="/docs/ruan-she/structured-dev/uTools_1683517944926.png" loading="lazy" width="350" height="79" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">外部实体</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="外部实体" src="/docs/ruan-she/structured-dev/uTools_1683517896893.png" loading="lazy" width="118" height="79" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>数据流图必须确保：</p>
<ul>
<li>数据流的起点或终点必须至少有一个是加工。</li>
<li>加工至少有一个输入数据流和一个输出数据流。</li>
</ul>
<p>分层数据流图：</p>
<ol>
<li>
<p>顶层图：描述系统的输入和输出。</p>
<p>即描述系统从哪些外部实体接受数据流，以及系统发送数据流到哪些外部实体。</p>
<ul>
<li>顶层图只有一个加工，即待开发的软件系统。</li>
<li>顶层图中的数据流就是系统的输入/输出信息。</li>
<li>顶层图中通常没有数据存储。</li>
</ul>
</li>
<li>
<p>0层图：分解顶层图的加工。</p>
</li>
<li>
<p>再分解：将DFD中某些比较复杂的加工再次分解成一张DFD子图。</p>
</li>
</ol>
<h2 id="数据字典" data-numberify>数据字典<a class="anchor ms-1" href="#数据字典"></a></h2>
<p>数据字典（DD）是为数据流图中的以下成分做出说明：</p>
<ul>
<li><strong>数据流</strong>；</li>
<li><strong>文件</strong>；</li>
<li><strong>加工</strong>：对加工的描述称为“小说明”或“加工逻辑说明”；</li>
<li>组成数据流或文件的<strong>数据项</strong>。</li>
</ul>
<p>数据字典有以下4类条目：</p>
<ul>
<li>
<p><strong>数据流</strong>条目：对DFD中数据流的定义，通常列出该数据流的各组成数据项。</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">含义</th>
<th style="text-align:left">举例及说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$=$</td>
<td style="text-align:center">被定义为</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">$+$</td>
<td style="text-align:center">与</td>
<td style="text-align:left">$x = a + b$：$x$由$a$和$b$组成</td>
</tr>
<tr>
<td style="text-align:center">$[a|b]$</td>
<td style="text-align:center">或</td>
<td style="text-align:left">$x = [a</td>
</tr>
<tr>
<td style="text-align:center">$\{a\}$</td>
<td style="text-align:center">重复</td>
<td style="text-align:left">$x = \{a\}$：$x$由任意个$a$组成</td>
</tr>
<tr>
<td style="text-align:center">$m\{a\}n$<br>或<br>$\big\{ a \big\}^{n}_{m}$</td>
<td style="text-align:center">重复</td>
<td style="text-align:left">$x=m\{a\}n$ 或 $x=\big\{a\big\}^{n}_{m}$：$x$中出现$m \sim n$次$a$<br><ul><li>$n$：重复次数的上限</li><li>$m$：重复次数的下限</li></ul></td>
</tr>
<tr>
<td style="text-align:center">$(a)$</td>
<td style="text-align:center">可选</td>
<td style="text-align:left">$x = (a)$：$a$在$x$中出现$0$或$1$次</td>
</tr>
<tr>
<td style="text-align:center">$&ldquo;a&rdquo;$</td>
<td style="text-align:center">基本数据元素</td>
<td style="text-align:left">$x = &ldquo;a&rdquo;$：$x$是取值为字符$a$的数据元素</td>
</tr>
<tr>
<td style="text-align:center">$m..n$</td>
<td style="text-align:center">连接符</td>
<td style="text-align:left">$x = m..n$：$x$可取$m \sim n$中的任意一个值</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>数据项</strong>条目：组成数据流和数据存储的最小元素，是不可再分解的数据单位。</p>
</li>
<li>
<p><strong>数据存储</strong>条目：对DFD中数据存储的定义。</p>
</li>
<li>
<p><strong>基本加工</strong>条目：用来说明DFD中（下层）基本加工的处理逻辑（加工逻辑）。</p>
<ul>
<li>对每一个基本加工，必须有一个加工规格说明（加工逻辑描述）。</li>
<li>加工规格说明（加工逻辑描述）必须描述基本加工如何把输入数据流变换为输出数据流的加工规则。</li>
<li>加工规格说明必须描述实现加工的策略，而不是实现加工的细节。</li>
<li>加工规格说明中包含的信息应是充足的，完备的，有用的，没有重复的多余信息。</li>
</ul>
<p>结构化语言、判定树和判定表可以用来表示加工逻辑。</p>
</li>
</ul>
<p>源点、终点不在系统之内，故一般不在字典中说明。</p>
<hr>
<h1 id="用户界面设计" data-numberify>用户界面设计<a class="anchor ms-1" href="#用户界面设计"></a></h1>
<p>用户界面（UI）设计在人与计算机之间搭建了一个有效的交流媒介。</p>
<h2 id="黄金原则" data-numberify>黄金原则<a class="anchor ms-1" href="#黄金原则"></a></h2>
<p>黄金原则一共有3条：</p>
<ul>
<li>用户操纵控制</li>
<li>减少用户的记忆负担</li>
<li>保持界面一致</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>数据库篇</title>
      <link>/docs/ruan-she/data-base/</link>
      <pubDate>Sat, 22 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/ruan-she/data-base/</guid>
      <description><![CDATA[数据库体系结构 数据描述有两种形式： 逻辑描述：指程序员或用户用以操作的数据形式，是抽象的概念化数据。 物理描述：指数据在存储设备上的存储方式，物]]></description>
      <content:encoded><![CDATA[<h1 id="数据库体系结构" data-numberify>数据库体系结构<a class="anchor ms-1" href="#数据库体系结构"></a></h1>
<p>数据描述有两种形式：</p>
<ul>
<li>逻辑描述：指程序员或用户用以操作的数据形式，是抽象的概念化数据。</li>
<li>物理描述：指数据在存储设备上的存储方式，物理数据是实际存放在存储设备上的数据。</li>
</ul>
<h2 id="三级模式结构" data-numberify>三级模式结构<a class="anchor ms-1" href="#三级模式结构"></a></h2>
<p>实际上有许多不同的数据库产品，但它们的体系结构基本上都具有相同的特征，采用“三级模式和两级映像”：</p>
<p><picture><img class="img-fluid " alt="三级模式两级映像" src="/docs/ruan-she/data-base/uTools_1681373319410.png" loading="lazy" width="486" height="377" />
</picture>

</p>
<p>三级结构有3类数据模型：</p>
<ul>
<li><strong>外模型</strong>：用户使用的<strong>数据视图</strong>，是一种局部的逻辑数据视图，表示用户所理解的实体、实体属性和实体关系。</li>
<li><strong>概念模型</strong>：全局的<strong>逻辑数据视图</strong>，是数据库管理员所看到的实体、实体属性和实体之间的联系。</li>
<li><strong>内模型</strong>：数据的物理<strong>存储模型</strong>。</li>
</ul>
<p>三个物理模型分别对应数据库系统的3层结构：</p>
<ul>
<li>
<p><strong>外模式（子模式、用户模式）</strong>：数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。</p>
<p>外模式用DBMS的外模式描述语言（外模式DDL)来定义。</p>
</li>
<li>
<p><strong>概念模式（模式）</strong>：所有用户的公共数据视图，与具体的应用程序和应用程序开发工具无关。</p>
<p>概念模式用DBMS的模式描述语言（模式DDL)来定义。</p>
</li>
<li>
<p><strong>内模式（物理模式、存储模式）</strong>：是数据在数据库内部的表示方式。</p>
<p>内模式由DBMS的内模式描述语言（内模式DDL)来描述，由设备介质语言来定义。</p>
<p>定义<u>所有的<strong>内部记录类型</strong>、<strong>索引</strong>和<strong>文件</strong>的组织方式</u>。</p>
</li>
</ul>
<h2 id="两级模式映象" data-numberify>两级模式映象<a class="anchor ms-1" href="#两级模式映象"></a></h2>
<p>数据库系统在三级模式之间提供了两级映像：</p>
<ul>
<li>模式——内模式映像存在于<u>概念级和内部级</u>之间，实现<u>概念模式和内模式</u>间的相互转换。</li>
<li>外模式——模式映像：存在于<u>外部级和概念级</u>之间，实现了<u>外模式和概念模式</u>之间的相互转换。</li>
</ul>
<p>数据的独立性（指数据与程序独立）是由DBMS的二级映像功能来保证的。数据的独立性包括：</p>
<ul>
<li>
<p><strong>物理独立性</strong>：指当数据库的<u>内模式发生改变时，数据的逻辑结构不变</u>。</p>
<p>物理独立性可以保证，当数据的物理结构改变时，应用程序不用改变。</p>
<p>但是，为了保证应用程序能够正确执行，<u>需要修改概念模式和内模式之间的映像</u>。</p>
</li>
<li>
<p><strong>逻辑独立性</strong>：指用户的<u>应用程序与数据库的逻辑结构是相互独立的</u>。</p>
<p>数据的逻辑结构发生变化后，用户程序也可以不修改。</p>
<p>但是，为了保证应用程序能够正确执行，<u>需要修改外模式和概念模式之间的映像</u>。</p>
</li>
</ul>
<hr>
<h1 id="数据模型" data-numberify>数据模型<a class="anchor ms-1" href="#数据模型"></a></h1>
<p>在数据库技术中，表示实体类型及实体类型间联系的模型称为数据模型。</p>
<p>数据模型有以下类型：</p>
<ul>
<li>概念数据模型：从信息世界中抽象的数据模型；</li>
<li>结构数据模型：从计算机世界中抽象出的DBMS支持的数据模型。</li>
</ul>
<h2 id="概念数据模型" data-numberify>概念数据模型<a class="anchor ms-1" href="#概念数据模型"></a></h2>
<p>概念数据模型用于信息世界建模，一般采用实体-联系方法（E-R方法）。概念数据模型的常用术语有：</p>
<ul>
<li>
<p><strong>实体</strong>：客观存在并可以相互区别的事物称为实体。</p>
<p>如一个单位、一个职工、一个部门或一个项目等。</p>
</li>
<li>
<p><strong>属性</strong>：描述实体的特性称为属性，一个实体可以由若干个属性来刻画。</p>
<p>属性的具体取值称为属性值，用以表示一个具体实体。</p>
</li>
<li>
<p><strong>码</strong>：<u>唯一标识</u>实体的属性集称为码。</p>
</li>
<li>
<p><strong>域</strong>：属性的<u>取值范围</u>称为该属性的域。</p>
</li>
<li>
<p><strong>实体型</strong>：具有相同属性的实体必然具有共同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</p>
<p>例如，学生（学号，姓名，性别，班号）就是一个实体型。</p>
</li>
<li>
<p><strong>实体集</strong>：同型实体的集合称为实体集。</p>
<p>例如，全体学生就是一个实体集。</p>
</li>
<li>
<p><strong>联系</strong>：实体（型）之间的对应关系称为联系。联系分为两种：</p>
<ul>
<li>实体内部各属性之间的联系；</li>
<li>实体之间的联系。</li>
</ul>
<p>两个实体型之间的联系有3种类型：</p>
<ul>
<li>一对一联系(1:1)；</li>
<li>一对多联系(1:n)；</li>
<li>多对多联系(m:n)。</li>
</ul>
</li>
</ul>
<p>实体-联系方法表示的概念数据模型称为E-R图。E-R图是抽象和描述现实世界的有力工具：</p>
<ul>
<li><strong>实体型</strong>：用<strong>矩形</strong>表示，矩形框内写明实体名；</li>
<li><strong>属性</strong>：用<strong>椭圆形</strong>表示，并用无向边将其与相应的实体连接起来；</li>
<li><strong>联系</strong>：用<strong>菱形</strong>表示，菱形框内写明联系名，并用无向边将其分别与有关实体连接起来，同时在无向边旁标上联系的类型。</li>
</ul>
<p><picture><img class="img-fluid " alt="E-R图示例" src="/docs/ruan-she/data-base/uTools_1681289395117.png" loading="lazy" width="240" height="242" />
</picture>

</p>
<h2 id="结构数据模型" data-numberify>结构数据模型<a class="anchor ms-1" href="#结构数据模型"></a></h2>
<p>结构数据模型是直接面向数据库的逻辑结构。这类模型涉及到计算机系统和数据库管理系统，所以称为结构数据模型。任何一个DBMS都以某个结构数据模型为基础，或者说支持某个结构数据模型。</p>
<p>常用术语：</p>
<ul>
<li>
<p><strong>数据项</strong>：又称<strong>字段</strong>，是数据库中可以命名的最小逻辑数据单位。可以是一个数或个字符串，用它描述属性的数据。</p>
</li>
<li>
<p><strong>记录</strong>：是数据项的有序集，即一个记录是由若干个数据项或字段组成，用它描述实体。</p>
<p>一般来说，数据只有被组成记录的形式才有实际意义。</p>
</li>
<li>
<p><strong>文件</strong>：文件是一个具有符号名的一组同类记录的集合。文件包含记录的结构和记录的值。</p>
</li>
</ul>
<p>结构数据模型主要包括：层次、网状、关系和面向对象模型。</p>
<p>关系模型是一种用二维表格结构快表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合。</p>
<blockquote>
<p>目前大多数数据库管理系统都是关系型的。</p>
</blockquote>
<hr>
<h1 id="关系模型" data-numberify>关系模型<a class="anchor ms-1" href="#关系模型"></a></h1>
<h2 id="术语" data-numberify>术语<a class="anchor ms-1" href="#术语"></a></h2>
<p>有关关系模型的术语：</p>
<ul>
<li>
<p><strong>关系</strong>：一个关系就是一张<strong>二维表</strong>，每个关系有一个关系名</p>
</li>
<li>
<p><strong>元组</strong>：表中的一行即为一个<strong>元组</strong>，对应存储文件中的一个<strong>记录值</strong>。</p>
</li>
<li>
<p><strong>属性</strong>：表中的<strong>列</strong>称为属性，每一列有一个属性名。</p>
<p>属性值相当于记录中的数据项或者字段值。</p>
</li>
<li>
<p><strong>域</strong>：属性的<strong>取值范围</strong>。</p>
</li>
<li>
<p><strong>关系模式</strong>：对关系的<strong>描述</strong>称为关系模式，由关系名和其属性集合构成，关系模式的格式为：关系名（属性名1，属性名2，…，属性名n）</p>
</li>
<li>
<p><strong>候选码</strong>（候选健）：属性或属性组合其值能够<strong>唯一地标识</strong>一个元组。</p>
</li>
<li>
<p><strong>主码</strong>（主键）：在一个关系中可能有<u>多个候选码，从中选择一个</u>作为主码。</p>
</li>
<li>
<p><strong>主属性</strong>：所有候选键都称为主属性，其他的属性都称为<strong>非码属性</strong>。</p>
</li>
<li>
<p><strong>外码</strong>（或外键）：如果一个关系中的属性或属性组并非该关系（二维表）的码，但它们是<u>另外一个关系（二维表）的码</u>，则称其为该关系的外码。</p>
</li>
<li>
<p><strong>全码</strong>：关系模式的<u>所有属性组是这个关系模式的候选码</u>，称为全码。</p>
</li>
<li>
<p><strong>超码</strong>（超键）：一个<u>包含码的属性集称为超码</u>。</p>
<p>例如学号是码，则（学号，姓名）就是一个超码。</p>
</li>
</ul>
<h2 id="完整性约束" data-numberify>完整性约束<a class="anchor ms-1" href="#完整性约束"></a></h2>
<p>完整性规则保证用户对数据库做修改时不会破坏数据的一致性。</p>
<ul>
<li>
<p><strong>实体完整性</strong>（Entity Integrity，引用完整性）：规定基本关系R的主属性A不能取空值。</p>
<p>即<u>主属性不能为空</u>。</p>
</li>
<li>
<p><strong>参照完整性</strong>（Referential Integrity）：若F是基本关系R的外码，它与基本关系S的主码K<sub>s</sub>相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值可以取：</p>
<ul>
<li>空值（F的每个属性值均为空值）；</li>
<li>S中某个元组的主码值。</li>
</ul>
<p>即实体之间的关联可以变现为：关系R用外码F与关系S关联，外码F的值可以为空也可以为关系S中某个元组（记录）的主码值。</p>
</li>
<li>
<p><strong>用户定义完整性</strong>（User Defined Integrity）：针对某一具体的关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求，由应用的环境决定。</p>
<p>例如，银行的用户账户规定必须大于等于100000、小于999999。</p>
</li>
</ul>
<h2 id="关系代数运算符" data-numberify>关系代数运算符<a class="anchor ms-1" href="#关系代数运算符"></a></h2>
<p>关系操作的特点是操作对象和操作结果都是集合，而非关系数据模型的数据操作方式则为一次一个记录的方式。</p>
<p>关系数据语言分为三类：</p>
<ul>
<li>关系代数语言；</li>
<li>关系演算语言；</li>
<li>具有关系代数和关系演算双重特点的语言。</li>
</ul>
<p>关系演算语言包含：</p>
<ul>
<li>元组关系演算语言；</li>
<li>域关系演算语言。</li>
</ul>
<p>关系代数运算符有4类：</p>
<p><picture><img class="img-fluid " alt="关系代数运算符" src="/docs/ruan-she/data-base/uTools_1681431891302.png" loading="lazy" width="735" height="301" />
</picture>

</p>
<p>基本关系代数运算是对两个具有<u>相同的关系模式</u>的关系进行运算。关系$R$与$S$具有<u>相同的关系模式</u>，即$R$与$S$的元数相同（结构相同）。</p>
<p>基本关系代数运算包含：</p>
<ul>
<li>
<p><strong>并</strong>（Union）：关系$R$与$S$的并是由属于$R$或属于$S$的元组构成的集合，记作$R \cup S$，其形式定义如下：</p>
<p>$$
R \cup S = \{ t | (t \in R) \vee (t \in S) \}
$$</p>
<blockquote>
<p>式中$t$为元组变量。</p>
</blockquote>
</li>
<li>
<p><strong>差</strong>（Difference）：关系$R$与$S$的差是由<u>属于$R$但不属于$S$</u>的元组构成的集合，记作$R-S$，其形式定义如下：</p>
<p>$$
R-S = \{ t| (t \in R) \wedge (t \not\in S) \}
$$</p>
</li>
<li>
<p><strong>交</strong>（Intersection）：关系$R$与$S$的交是由属于$R$同时又属于$S$的元组构成的集合，记作$R \cap S$,其形式定义如下：</p>
<p>$$
R \cap S = \{ t| (t \in R) \wedge (t \in S) \}
$$</p>
<blockquote>
<p>$R \cap S = R-(R-S)$，或者$R \cap S = S-(S-R)$。</p>
</blockquote>
</li>
</ul>
<p>扩展的关系代数运算可以从基本的关系运算中导出，包括：</p>
<ul>
<li>
<p><strong>广义笛卡儿积</strong>（Extended Cartesian Product）：两个元组分别为$n$目和$m$目的关系$R$和$S$的广义笛卡儿积是一个$(n+m)$列的元组的集合。</p>
<p>元组的前$n$列是关系$R$的一个元组，后$m$列是关系$S$的一个元组，记作$R \times S$，其形式定义如下：</p>
<p>$$
R \times S = \{ t| (t \ = \ &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \}
$$</p>
<p>如果$R$和$S$中有相同的属性名，可在属性名前加关系名作为限定，以示区别。若$R$有$K_1$,个元组，$S$有$K_2$个元组，则$R$和$S$的广义笛卡儿积有$K_1 \times K2$个元组。</p>
<blockquote>
<p>$&lt;t^n, t^m&gt;$是一个元组$t^n$和$t^m$拼接成的一个元组。</p>
</blockquote>
</li>
<li>
<p><strong>投影</strong>（Projection）：投影运算是从关系的<u>垂直方向</u>进行运算，在关系$R$中选出若干属性列$A$组成新的关系，记作$\pi_A (R)$，其形式定义如下：</p>
<p>$$
\pi_A (R) = \{ t[A]|t \in R \}
$$</p>
</li>
<li>
<p><strong>选择</strong>（Selection）：选择运算是从关系的<u>水平方向</u>进行运算，是从关系$R$中选择满足给定条件的诸元组，记作$\sigma_F (R)$其形式定义如下：</p>
<p>$$
\sigma_A (R) = \{ t| (t \in R) \wedge F(t) = True \}
$$</p>
<p>其中，$F(t)$中的运算对象可以是：</p>
<ul>
<li>属性名（或列的序号）；</li>
<li>常数；</li>
<li>运算符；</li>
<li>算术比较符（$&lt;, \le, &gt;, \ge, \neq$）；</li>
<li>逻辑运算符（$\wedge, \vee, \neg$）。</li>
</ul>
</li>
<li>
<p><strong>连接</strong>（Join）：连接运算是从两个关系$R$和$S$的笛卡儿积中选取满足条件的元组。</p>
<blockquote>
<p>可以认为笛卡儿积是无条件连接，其他的连接操作认为是有条件连接。</p>
</blockquote>
<ul>
<li>
<p><strong>$\theta$连接</strong>：从$R$与$S$的笛卡儿积中选取属性间满足一定条件的元组。记作：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[X] \ \theta \ t^m[Y]) \}
$$</p>
<p>其中：</p>
<ul>
<li>$X \theta Y$：连接的条件；</li>
<li>$\theta$：比较运算符；</li>
<li>$X$和$Y$分别为$R$和$S$上度数相等且可比的属性组；</li>
<li>$t^n\left[ X \right]$表示$R$中$t^n$元组的对应于属性$X$的一个分量；</li>
<li>$t^m[Y]$表示$S$中$t^m$元组的对应于属性$Y$的一个分量。</li>
</ul>
<p>$\theta$连接也可以表示为：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] \ \theta \ t^m[j]) \}
$$</p>
<p>其中，</p>
<ul>
<li>
<p>$i=1,2,3,\cdots,n$；</p>
</li>
<li>
<p>$j=1,2,3,\cdots,m$；</p>
</li>
<li>
<p>$i \theta j$：</p>
<p>从两个关系$R$和$S$中选取$R$的第$i$列和$S$的第$j$列之间满足$\theta$运算的元组进行连接。</p>
</li>
</ul>
<p>$\theta$连接可以由基本的关系运算笛卡儿积和选取运算导出。因此，$\theta$连接可表示为：</p>
<p>$$
R \mathop{\Join}\limits_{X \theta Y} S = \sigma_{X \theta Y}(R \times S)
$$</p>
<p>或：</p>
<p>$$
R \mathop{\Join}\limits_{i \theta j} S = \sigma_{i \theta j}(R \times S)
$$</p>
</li>
<li>
<p><strong>等值连接</strong>：当$\theta$为“=”时，称之为等值连接，记为$R \mathop{\Join}\limits_{i = j} S$，其形式定义如下：</p>
<p>$$
R \mathop{\Join}\limits_{i = j} S = \{ t| (t=&lt;t^n,t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (t^n[i] = t^m[j]) \}
$$</p>
</li>
<li>
<p>$F$连接：从关系$R$和$S$的笛卡尔积中选取属性值满足某一公式$F$的元组，记为$\mathop{\Join}\limits_{F}$。</p>
<p>$F$是形为$F_1 \wedge F_2 \wedge \cdots \wedge F_n$的公式，每个$F_p$是形为$i \theta j$的式子。</p>
</li>
<li>
<p><strong>自然连接</strong>：自然连接是一种特殊的等值连接，它要求两个关系中<u>进行比较的分量必须是相同的属性组</u>，并且在结果集中<u>将重复属性列去掉</u>。</p>
<p>若：</p>
<ul>
<li>
<p>$t^n \in R$，$t^m \in S$；</p>
</li>
<li>
<p>$R$和$S$具有相同的属性组$B$，且$B=(B_1,B_2,,B_k)$；</p>
</li>
<li>
<p>假定$R$关系的属性：</p>
<p>$$
A_1,A_2,\cdots,A_{n-k},B_1,B_2,\cdots,B_k
$$</p>
</li>
<li>
<p>$S$关系的属性：</p>
<p>$$
B_1,B2,\cdots,B_k,B_{k+1},B_{k+2},\cdots,B_m
$$</p>
</li>
</ul>
<p>自然连接可以记为$R \Join S$,其形式定义如下：</p>
<p>$$
R \Join S = \{ t| (t = &lt;t^n, t^m&gt;) \wedge (t^n \in R) \wedge (t^m \in S) \wedge (R.B_1 = S.B_1) \wedge (R.B_2 = S.B_2) \wedge \cdots \wedge (R.B_k = S.B_k) \}
$$</p>
<blockquote>
<p>一般连接是从关系的水平方向运算，而自然连接<u>不仅要从关系的水平方向运算，而且要从关系的垂直方向运算</u>（去掉重复属性）。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>外连接</strong>（Outer Jion）：外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息。</p>
<p>外连接运算有3种：</p>
<ul>
<li>
<p><strong>左外连接</strong>（Left Outer Jion，⟕）：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值$null$充填所有来自右侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>右外连接</strong>（Right Outer Jion，⟖）：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值$null$填充所有来自左侧关系的属性，构成新的元组，将其加入自然连接的结果中。</p>
</li>
<li>
<p><strong>全外连接</strong>（Full Outer Jion，⟗）。完成左外连接和右外连接的操作。即填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生的新元组加入自然连接的结果中。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/data-base/uTools_1681454087063.png" loading="lazy" width="762" height="575" />
</picture>

</p>
</li>
<li>
<p><strong>除</strong>（Division）：给定关系$R(X,Y)$和$S(Y,Z)$，$X、Y、Z$为属性组。$R \div S$应当满足元组在$X$上的分量值$x$的象集$Y_x$包含关系$S$在属性组$Y$上投影的集合。其形式定义如下：</p>
<p>$$
R \div S = \{ t^n[X] | (t^n \in R) \wedge (\pi_y (S) \subseteq Y_x) \}
$$</p>
<p>其中，$Y_x$为$x$在$R$中的象集，$x=t^n[X]$，且$R \div S$的结果集的属性组为$X$。</p>
<blockquote>
<p>除运算是同时从关系的水平方向和垂直方向进行运算。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="sql-语句" data-numberify>SQL 语句<a class="anchor ms-1" href="#sql-语句"></a></h1>
<p><strong>SQL</strong>（<strong>Structured Query Language</strong>，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。</p>
<blockquote>
<p>标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。</p>
<p>查看更多 <a href="../sql-%e8%af%ad%e5%8f%a5">SQL语句</a> 相关内容。</p>
</blockquote>
<h2 id="分类" data-numberify>分类<a class="anchor ms-1" href="#分类"></a></h2>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。</p>
<p>关键字：<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。</p>
<p>关键字：<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。</p>
<p>关键字：<code>SELECT</code>等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。</p>
</li>
</ol>
<h2 id="数据定义语言ddl" data-numberify>数据定义语言（DDL）<a class="anchor ms-1" href="#数据定义语言ddl"></a></h2>
<p><code>CREATE</code>——创建：</p>
<ul>
<li>
<p>建立数据库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="err">数据库名</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>建立基本表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tab_name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">列名</span><span class="w">    </span><span class="err">数据类型</span><span class="w"> </span><span class="p">[</span><span class="err">列级完整性约束条件</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">表级完整性约束条件</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>完整性约束有3种子句：</p>
<ul>
<li><code>PRIMARY KEY</code>：主键约束；</li>
<li><code>CHECK</code>：检查约束；</li>
<li><code>FOREIGN KEY</code>：外键约束；</li>
<li><code>NOT NULL</code>：非空约束；</li>
<li><code>UNIQUE</code>：唯一约束；</li>
<li><code>DEFAULT</code>：默认约束。</li>
</ul>
<p>定义列时使用的基本数据类型如下：</p>
<ul>
<li><code>NTEGER</code>：整数（也可写成<code>INT</code>）。</li>
<li><code>FLOAT(n)</code>：浮点数，精度至少为n位数字。</li>
<li><code>NUMERIC(p,d)</code>：定点数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字（也可写成<code>DECIMAL(p,d)</code>或<code>DEC(p,d)</code>）。</li>
<li><code>CHAR(n)</code>：长度为n的定长字符串。</li>
<li><code>DATETIME</code>：日期时间型。</li>
</ul>
</li>
</ul>
<p><code>ALTER TABLE</code>——修改表结构：</p>
<ul>
<li>
<p>增加新列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="err">列名</span><span class="w"> </span><span class="err">类型</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>修改列的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="k">ALTER</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="err">列名</span><span class="w"> </span><span class="err">新类型</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>删除列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="err">列名</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p><code>DROP TABLE</code>——删除基本表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="err">表名</span><span class="w">
</span></span></span></code></pre></div><h2 id="数据操纵语言dml" data-numberify>数据操纵语言（DML）<a class="anchor ms-1" href="#数据操纵语言dml"></a></h2>
<p><code>INSERT INTO</code>——插入：</p>
<ul>
<li>
<p>直接插入元组值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="err">表名（列名序列）</span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="err">元组值</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>或者：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="p">(</span><span class="err">列名</span><span class="w"> </span><span class="err">序列</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">TABLE</span><span class="w"> </span><span class="p">(</span><span class="err">元组值</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="err">元组值</span><span class="p">),</span><span class="w"> </span><span class="p">...)</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>插入一个查询的结果值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="p">(</span><span class="err">列名序列</span><span class="p">)</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="err">查询语句</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p><code>DELETE FROM</code>——删除：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="err">表名</span><span class="w"> </span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="err">条件表达式</span><span class="p">]</span><span class="w">
</span></span></span></code></pre></div><p><code>UPDATE</code>——修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="err">表名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="err">列名</span><span class="o">=</span><span class="err">值表达式</span><span class="p">[,</span><span class="w"> </span><span class="err">列名</span><span class="o">=</span><span class="err">值表达式</span><span class="p">...]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="n">WHERE</span><span class="err">条件表达式</span><span class="p">]</span><span class="w">
</span></span></span></code></pre></div><h2 id="数据查询语言dql" data-numberify>数据查询语言（DQL）<a class="anchor ms-1" href="#数据查询语言dql"></a></h2>
<p><code>SELECT</code>——查询：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="err">行条件表达式</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="err">列名序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">HAVING</span><span class="w"> </span><span class="err">组条件表达式</span><span class="p">]]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="err">列名</span><span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">]...]</span><span class="w">
</span></span></span></code></pre></div><h3 id="where-条件查询" data-numberify>WHERE 条件查询<a class="anchor ms-1" href="#where-条件查询"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="err">行条件表达式</span><span class="w">
</span></span></span></code></pre></div><p>运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>说明</strong></th>
<th><strong>运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>等于</td>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> 或 <code>!=</code></td>
<td>不等于</td>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>!&gt;</code></td>
<td>不大于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>BETWEEN</code></td>
<td>范围在指定的两个值之间</td>
</tr>
<tr>
<td><code>!&lt;</code></td>
<td>不小于</td>
<td><code>IS NULL</code></td>
<td>为 NULL 的值</td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td>不为 NULL 的值</td>
<td><code>AND</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或</td>
<td><code>NOT</code>逻辑非</td>
<td></td>
</tr>
<tr>
<td><code>IN</code></td>
<td>匹配包含在集合中的值</td>
<td><code>NOT IN</code></td>
<td>指定不包含在集合中的值</td>
</tr>
<tr>
<td><code>LIKE</code></td>
<td>字符模糊配对</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>LIKE</code>字符模糊配对包含以下通配符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">WHRER</span><span class="w"> </span><span class="err">列名</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;_ABC%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>%</code>：表示任何字符出现任意次数。</li>
<li><code>_</code>：表示匹配单个任意字符。</li>
</ul>
<h3 id="order-by-排序数据" data-numberify>ORDER BY 排序数据<a class="anchor ms-1" href="#order-by-排序数据"></a></h3>
<p><code>ORDER BY</code>可以指定多个列来排序，排序规则有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">规则说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ASC</code></td>
<td style="text-align:center">升序排序</td>
</tr>
<tr>
<td style="text-align:center"><code>DESC</code></td>
<td style="text-align:center">降序排序</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[...]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="err">列名</span><span class="w"> </span><span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">]</span><span class="w"> </span><span class="p">...]</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>ORDER BY子句必须是SELECT命令中的最后一个子句。</p>
</blockquote>
<h3 id="group-by-分组数据" data-numberify>GROUP BY 分组数据<a class="anchor ms-1" href="#group-by-分组数据"></a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="err">列名序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">HAVING</span><span class="w"> </span><span class="err">组条件表达式</span><span class="p">]]</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>HAVING</code>是<code>GROUP BY</code>的分组条件控制语句。</li>
<li><code>HAVING</code>的操作符和<code>WHERE</code>相同。</li>
<li>被<code>WHERE</code>过滤掉的记录并不会出现在分组中。</li>
</ul>
<h3 id="聚合函数" data-numberify>聚合函数<a class="anchor ms-1" href="#聚合函数"></a></h3>
<p>聚合函数实现数据统计等功能。</p>
<p>函数名|功能
<code>AVG</code>|计算一个数值型表达式的平均值
<code>COUNT</code>|计算指定表达式中选择的项数，<code>COUNT(*)</code>统计查询输出的行数
<code>MIN</code>|计算指定表达式中的最小值
<code>MAX</code>|计算指定表达式中的最大值
<code>SUM</code>|计算指定表达式中的数值总和
<code>STDEV</code>|计算指定表达式中所有数据的标准差
<code>STDEVP</code>|计算总体标准差</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">目标表的列名或列表达式序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="err">使用了聚合函数的条件判断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></span></span></code></pre></div><p>或：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="err">聚合函数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="err">关系名表序列</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>聚合函数可以使用算数运算符。</p>
<p>聚合函数常与<code>GROUP BY</code>子句一起使用。</p>
</blockquote>
<h3 id="连接" data-numberify>连接<a class="anchor ms-1" href="#连接"></a></h3>
<table>
<thead>
<tr>
<th style="text-align:center">连接符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>INNER JOIN</code></td>
<td style="text-align:center">内连接（默认）。<br>内连接又包括等值连接、非等值连接和自连接。</td>
</tr>
<tr>
<td style="text-align:center"><code>OUTER JOIN</code></td>
<td style="text-align:center">外连接。<br>又包括：<br><code>LEFT OUTER JOIN</code>（左外连接）；<br><code>RIGHT OUTER JOIN</code>（右外连接）；<br><code>FULL OUTER JOIN</code>（全外连接）</td>
</tr>
</tbody>
</table>
<h3 id="子查询" data-numberify>子查询<a class="anchor ms-1" href="#子查询"></a></h3>
<p>子查询是指将<code>SELECT</code>作为其它语句的子句使用。例如在<code>WHERE</code>、<code>FROM</code>中使用<code>SELECT</code>。</p>
<h2 id="数据控制语言dcl" data-numberify>数据控制语言（DCL）<a class="anchor ms-1" href="#数据控制语言dcl"></a></h2>
<p>数据控制控制的是<strong>用户对数据的存储访问权力</strong>，是由DBA决定的。但是，某个用户对某类数据具有何种权利，是个<strong>政策问题</strong>而不是技术问题。</p>
<p>授权语句格式（<code>GRANT</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">GRANT</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">TO</span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">WITH</span><span class="w"> </span><span class="k">GRANT</span><span class="w"> </span><span class="k">OPTION</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><p>不同类型的操作对象有不同的操作权限，常见的操作权限如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">对象类型</th>
<th style="text-align:left">操作权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">属性列</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">视图</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">基本表</td>
<td style="text-align:center"><code>TABLE</code></td>
<td style="text-align:left"><code>SELECT</code>、<br><code>INSERT</code>、<br><code>UPDATE</code>、<br><code>DELETE</code>、<br><code>ALTER</code>、<br><code>INDEX</code>、<br><code>ALL PRIVILEGES</code></td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:center"><code>DATABASE</code></td>
<td style="text-align:left"><code>CREATETAB</code></td>
</tr>
</tbody>
</table>
<ul>
<li>建立表的权限，可由DBA授予普通用户；</li>
<li><code>WITH GRANT OPTION</code>：表示获得了这些权限的用户还可以将权限赋给其他用户。</li>
</ul>
<p>收回权限语句格式（<code>REVOKE</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">REVOKE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">权限</span><span class="o">&gt;</span><span class="p">]...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">对象名</span><span class="o">&gt;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">[,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">用户</span><span class="o">&gt;</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><h2 id="视图" data-numberify>视图<a class="anchor ms-1" href="#视图"></a></h2>
<p>视图是从一个或者多个基本表或视图中导出的虚拟表。</p>
<p>创建视图：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="err">视图名</span><span class="w"> </span><span class="p">(</span><span class="err">列表名</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="err">查询子句</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="k">WITH</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="k">OPTION</span><span class="p">];</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>子查询可以是任意复杂的<code>SELECT</code>语句，但通常不允许含有<code>ORDER BY</code>子句和<code>DISTINCT</code>短语。</li>
<li><code>WITH CHECK OPTION</code>：表示对<code>UPDATE</code>、<code>INSERT</code>、<code>DELETE</code>操作时保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。</li>
<li>组成视图的属性列名或者全部省略或者全部指定。如果省略属性列名，则隐含该视图由<code>SELECT</code>子查询目标列的主属性组成。</li>
<li>对视图进行的增改操作实际上是对基本表进行操作。</li>
</ul>
<p>删除视图：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DROP</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="err">视图名</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h2 id="索引" data-numberify>索引<a class="anchor ms-1" href="#索引"></a></h2>
<p>数据库中的索引是<u>某个表中一列或者若干列值的集合</u>和<u>相应的指向表中物理标识这些值的数据页的逻辑指针清单</u>。</p>
<p>索引分为：</p>
<ul>
<li>聚集索引：指索引表中索引项的顺序与表中记录的物理顺序一致的索引；</li>
<li>非聚集索引。</li>
</ul>
<blockquote>
<p>对数据库表创建和删除索引，修改的是数据库的内模式。</p>
</blockquote>
<hr>
<h1 id="关系数据库的规范化" data-numberify>关系数据库的规范化<a class="anchor ms-1" href="#关系数据库的规范化"></a></h1>
<h2 id="关系模式" data-numberify>关系模式<a class="anchor ms-1" href="#关系模式"></a></h2>
<p>一个关系模式应当是一个五元组（含关系名）：$R&lt;U,D,dom,F&gt;$。</p>
<p>其中：</p>
<ul>
<li>$R$：<u>关系名，是符号化的元祖语义；</u></li>
<li>$U$：<u>一组属性名；</u></li>
<li>$D$：属性组$U$中的属性来自域$D$；</li>
<li>$dom$：属性到域的映射；</li>
<li>$F$：<u>属性组$U$上的一组数据依赖（函数依赖）。</u></li>
</ul>
<p>$D$和$dom$对模式设计关系不大，通常将关系模式看作是一个三元组：$R&lt;U,F&gt;$。</p>
<p>当且仅当$U$上的一个关系$r$满足$F$时，称$r$为关系模式$R&lt;U,F&gt;$的一个关系。</p>
<h2 id="函数依赖" data-numberify>函数依赖<a class="anchor ms-1" href="#函数依赖"></a></h2>
<p>数据依赖是<u>通过一个关系中属性间值的相等与否</u>体现出来的<u>数据间的相互关系</u>。</p>
<ul>
<li>
<p><strong>函数依赖</strong>：设$R(U)$是属性集U上的关系模式，<u>$X$、$Y$是$U$的子集</u>。若对$R(U)$的任何一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等（即，<u>在关系$r$中，元组在$X$上的属性值相等，那么在$Y$上的属性值也相等</u>），则称<strong>X函数决定Y</strong>或<strong>Y函数依赖于X</strong>，记作$X \rightarrow Y$。</p>
<p>如，学生表中，$学号 \rightarrow 姓名$。</p>
<p>属性之间有3种关系，但并不是每一种都存在函数依赖。如果$X$和$Y$之间的对应关系是：</p>
<ul>
<li>$1-1$：存在函数依赖$X \rightarrow Y$和$Y \rightarrow Y$；</li>
<li>$n:1$：存在函数依赖$X \rightarrow Y$；</li>
<li>$n:m$：不存在函数依赖。</li>
</ul>
</li>
<li>
<p><strong>非平凡的函数依赖</strong>：$X \rightarrow Y$，但$Y \not\subseteq X$，则称$X \rightarrow Y$是非平凡的函数依赖。</p>
<p>例如，$姓名 \not\subseteq 学号$，则$学号 \rightarrow 姓名$是一个非平凡的函数依赖。</p>
</li>
<li>
<p><strong>平凡的函数依赖</strong>：如果$X \rightarrow Y$，但$Y \subseteq X$，则称$X \rightarrow Y$是平凡的函数依赖。</p>
<p>例如，$学号 \subset (学号,课程号)$，则$(学号,课程号) \rightarrow 学号$是一个平凡的函数依赖。</p>
</li>
<li>
<p><strong>完全函数依赖</strong>：在R(U)中，如果$X \rightarrow Y$，并且对于X的任何一个真子集$X&rsquo;$都有**$X&rsquo;$不能决定$Y$**，则称$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$。</p>
<p>即需要由$X$的所有属性才能决定$Y$的，才能称为完全函数依赖。</p>
<p>如，$(学号,课程号) \rightarrow 成绩$。</p>
<p>如果$X$仅包含一个属性，那么此时必为完全函数依赖。</p>
</li>
<li>
<p><strong>部分函数依赖</strong>：如果$X \rightarrow Y$，但<strong>Y不完全函数依赖于X</strong>，则称Y对X部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$。部分函数依赖也称为局部函数依赖。</p>
<p>如，（学号，班级代号） $\rightarrow$ 姓名，因为学号 $\rightarrow$ 姓名，所以（学号，班级代号） $\stackrel{P}{\longrightarrow}$ 姓名。</p>
</li>
<li>
<p><strong>传递依赖</strong>：在$R(U,F)$中（F是U上的一组函数依赖），如果$X \rightarrow Y,\ Y \not\subseteq X,\ Y \rightarrow Z$，则称<strong>Z对X传递依赖</strong>（$X \rightarrow Z$）。</p>
<p>即$X \stackrel{f}{\longrightarrow} Y$，且$Y \rightarrow Z$，则$X \rightarrow Z$。</p>
</li>
<li>
<p><strong>码</strong>：设$K$为$R(U,F)$中属性的组合，若$K \rightarrow U$，且对于$K$的任何一个真子集$K&rsquo;$都有$K&rsquo;$不能决定$U$，则$K$为$R$的候选码。</p>
<p>即$K \stackrel{f}{\rightarrow} U$，那么K是R的候选码。</p>
<p>若有多个候选码，则选一个作为主码（主键，主关键字）。候选码通常也称为<strong>候选关键字</strong>（候选键，键）。</p>
</li>
<li>
<p><strong>主属性</strong>和<strong>非主属性</strong>：<strong>包含在任何一个候选码中</strong>的属性称为主属性，否则称为非主属性。</p>
</li>
<li>
<p><strong>外码</strong>：若$R(U)$中的属性或属性组<u>$X$非$R$的码，但$X$是另一个关系的码</u>，则称$X$为外码。</p>
</li>
</ul>
<p><strong>函数依赖的公理系统</strong>（Armstrong公理系统）：</p>
<p>设关系模式$R(U,F)$，其中$U$为属性集，$F是$U$上的一组函数依赖，那么有以下推理规则：</p>
<ul>
<li>
<p><strong>自反律</strong>（A1）：若$Y \subseteq X \subseteq U$，则$X \rightarrow Y$为$F$所蕴涵（蕴含）。</p>
<p>如，（学号，姓名） $\rightarrow$ 姓名是函数依赖所蕴涵的。</p>
</li>
<li>
<p><strong>增广律</strong>（A2）：若$X \rightarrow Y$为F所蕴涵，且$Z \subseteq U$,则$XZ \rightarrow YZ$为$F$所蕴涵。</p>
<p>如，学号 $\rightarrow$ 姓名，班级 $\subseteq$ 学生表，那么（学号，班级） $\rightarrow$ （姓名，班级）是函数依赖所蕴涵的。</p>
</li>
<li>
<p><strong>传递律</strong>（A3）：若$X \rightarrow Y,\ Y \rightarrow Z$为$F$所蕴涵，则$X \rightarrow Z$为$F$所蕴涵。</p>
</li>
</ul>
<p>根据上述3条推理规则又可推出下述3条推理规则：</p>
<ul>
<li><strong>合并规则</strong>：若$X \rightarrow Y,\ X \rightarrow Z$，则$X \rightarrow YZ$为F所蕴涵。</li>
<li><strong>伪传递律</strong>：若$X \rightarrow Y,\ WY \rightarrow Z$，则$XW \rightarrow Z$为F所蕴涵。</li>
<li><strong>分解规则</strong>：若$X \rightarrow Y,\ Z \subseteq Y$，则$X \rightarrow Z$为F所蕴涵。</li>
</ul>
<blockquote>
<p>合并规则和分解规则是两个互逆的规则。即$X \rightarrow Y,\ X \rightarrow Z$，可得$X \rightarrow YZ$；那么$X \rightarrow YZ$，也可得$X \rightarrow Y,\ X \rightarrow Z$（因为$Y,Z \sub YZ$）。</p>
</blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">结论</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">函数依赖</td>
<td style="text-align:left">元组在$X$上的属性值相等，那么在$Y$上的属性值也相等</td>
<td style="text-align:left">$X$函数决定$Y$或$Y$函数依赖于$X$，记作$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">非平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是非平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">平凡的函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \subseteq X$</td>
<td style="text-align:left">$X \rightarrow Y$是平凡的函数依赖</td>
</tr>
<tr>
<td style="text-align:center">完全函数依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$X&rsquo; \subset X$，$X&rsquo; \not\rightarrow Y$</td>
<td style="text-align:left">$Y$对$X$完全函数依赖，记作$X \stackrel{f}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">部分函数依赖（局部函数依赖）</td>
<td style="text-align:left">$X \rightarrow Y$，$X \stackrel{f}{\not\longrightarrow} Y$</td>
<td style="text-align:left">$Y$对$X$部分函数依赖，记作$X \stackrel{P}{\longrightarrow} Y$</td>
</tr>
<tr>
<td style="text-align:center">传递依赖</td>
<td style="text-align:left">$X \rightarrow Y$，$Y \not\subseteq X$，$Y \rightarrow Z$</td>
<td style="text-align:left">$Z$对$X$传递依赖</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">码（候选码，候选关键字）</td>
<td style="text-align:left">若$K \stackrel{f}{\rightarrow} U$，则$K$为$R$的候选码</td>
</tr>
<tr>
<td style="text-align:center">主属性</td>
<td style="text-align:left">包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">非主属性</td>
<td style="text-align:left">不包含在任何一个候选码中的属性</td>
</tr>
<tr>
<td style="text-align:center">外码</td>
<td style="text-align:left">$X$非$R$的码，但$X$是另一个关系的码，则称$X$为外码</td>
</tr>
</tbody>
</table>
<p>Armstrong公理系统：</p>
<table>
<thead>
<tr>
<th style="text-align:center">定律</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自反律</td>
<td style="text-align:left">$Y \subseteq X \subseteq U$</td>
<td style="text-align:left">$X \rightarrow Y$</td>
</tr>
<tr>
<td style="text-align:center">增广律</td>
<td style="text-align:left">$X \rightarrow Y$，$Z \subseteq U$</td>
<td style="text-align:left">$XZ \rightarrow XZ$</td>
</tr>
<tr>
<td style="text-align:center">传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ Y \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:left">条件</th>
<th style="text-align:left">F蕴含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">合并规则</td>
<td style="text-align:left">$X \rightarrow Y,\ X \rightarrow Z$</td>
<td style="text-align:left">$X \rightarrow YZ$</td>
</tr>
<tr>
<td style="text-align:center">伪传递律</td>
<td style="text-align:left">$X \rightarrow Y,\ WY \rightarrow Z$</td>
<td style="text-align:left">$XW \rightarrow Z$</td>
</tr>
<tr>
<td style="text-align:center">分解规则</td>
<td style="text-align:left">$X \rightarrow Y,\ Z \subseteq Y$</td>
<td style="text-align:left">$X \rightarrow Z$</td>
</tr>
</tbody>
</table>
<h2 id="闭包计算" data-numberify>闭包计算<a class="anchor ms-1" href="#闭包计算"></a></h2>
<p>设关系模式$R&lt;U,F&gt;$，其中$U$为属性集，$F$是$U$上的一组函数依赖。称所有用Armstrong公理从F推出的函数依赖$X \rightarrow A_i$中，$A_i(X,A_i \subseteq U)$的属性集合为$X$的属性闭包，记为$X^{+}_{F}$或$X^{+}$。</p>
<p>定理：</p>
<p>设关系模式$R&lt;U,F&gt;$，其中$F$为函数依赖集，$X,Y \subseteq U$，则从$F$推出$X \rightarrow Y$的充要条件是$Y \subseteq X^{+}$。</p>
<blockquote>
<p>属性的闭包计算用于求主键。</p>
</blockquote>
<p>例如，给定关系$R(U,F)$，其中$U={A,B,C,D,E,H}$，$F={A \rightarrow B, B \rightarrow DH, A \rightarrow H, C \rightarrow E }$。</p>
<p>先根据$F$选取仅在$\rightarrow$左边出现的属性集（例如，$A$、$C$和$AC$）。根据选取的属性集进行闭包运算（先对$A$进行运算）：</p>
<p>$$
(A)^{+} \rightarrow (A \ BH)^{+} \rightarrow (AB \ D \ H)^{+} \rightarrow (ABDH)
$$</p>
<p>此时，$(ABDH)^{+}$无论再怎么推，结果都是$(ABDH)$，说明对$A$的闭包计算已经结束了，结果就是$(ABDH)$。</p>
<p>而$(ABDH) \neq U$，说明$A$并不是关系$R$的主键。</p>
<p>而对于$C$的函数依赖仅有$C \rightarrow E$，所以此时应该对$(AC)$进行闭包运算：</p>
<p>$$
(AC)^{+} \rightarrow (ABDH \ CE)^{+} \rightarrow (ABCDEH)
$$</p>
<p>此时对$(AC)$的闭包计算结果$(ABCDEH) = U$，说明$(AC)$是关系$R$的主键。</p>
<h2 id="关系模式的分解" data-numberify>关系模式的分解<a class="anchor ms-1" href="#关系模式的分解"></a></h2>
<p>对存在<strong>数据冗余</strong>、<strong>插入异常</strong>、<strong>删除异常</strong>问题的关系模式，应采取<u>将一个关系模式分解为多个关系模式的方法进行处理</u>（原来存储在一个二维表内的数据就要分散到多个二维表中）。要求是分解后的二维表不能丢失分解前二维表的信息。</p>
<p>为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有：</p>
<ul>
<li>无损连接性；</li>
<li>保持函数依赖性。</li>
</ul>
<h3 id="无损连接" data-numberify>无损连接<a class="anchor ms-1" href="#无损连接"></a></h3>
<p>无损连接性指的是对关系模式分解时，原关系模式下，任一合法的关系实例，在<u>分解之后应能通过<strong>自然连接</strong>运算恢复</u>起来。</p>
<p>设$\rho = \{ R_1&lt;U_1,F_1&gt;,\ R_2&lt;U_2,F_2&gt;,\ \cdots,\ R_k&lt;U_k,F_k&gt; \}$是关系模式$R&lt;U,F&gt;$的一个分解，如果对于$R$的任一满足$F$的关系$r$都有：</p>
<p>$$
r = \pi_{R1}(r) \Join \pi_{R2}(r) \Join \cdots \Join \pi_{Rk}(r)
$$</p>
<p>则称这个分解$\rho$是满足依赖集$F$的无损连接。</p>
<blockquote>
<ul>
<li>
<p>$\pi()$运算是投影运算。</p>
</li>
<li>
<p>$\Join$运算是自然连接运算。</p>
</li>
</ul>
<p>个人理解：</p>
<p>无损连接性就是指，关系模式拆分后（分成若干个小的关系模式，即$\rho$），$\rho$中的关系模式从总体上看，保持着与$R$一致的连接。$\rho$中的关系模式通过自然连接保持着原本的关系模式。<u>重要的是$rho$中的关系模式可以通过<strong>自然连接</strong>恢复到原关系模式。</u></p>
</blockquote>
<p>验证无损连接的充要条件：</p>
<p>如果$R$的分解为$\rho = \{R_1,R_2\}$，$F$为$R$所满足的函数依赖集合，则分解$\rho$具有无损连接性的充分必要条件为：</p>
<p>$$
R_1 \cap R_2 \rightarrow (R_1 - R_2) \\
或 \\
R_1 \cap R_2 \rightarrow (R_2 - R_1)
$$</p>
<p>无损连接的判定算法：</p>
<ol>
<li>
<p>构造一个$k$行$n$列的表：</p>
<ul>
<li>每一列对应一个属性$A_j$；</li>
<li>每一行对应分解$rho$中的一个关系模式$R_i&lt;U_i, F_i&gt;$。</li>
</ul>
<p>若属性$A_j$属于$U_i$，则在第$i$行第$j$列上放符号$a_j$，否则放符号$b_{ij}$。</p>
</li>
<li>
<p>逐个检查$F$中的每一个函数依赖$FD_i$，并修改表中的元素：</p>
<p>取$F$中一个函数依赖$X_i \rightarrow A_j$（$X_i$要属于$rho$中的任一关系），考虑这些行中第$j$列元素：</p>
<ul>
<li>若其中有$a_j$，则全部改为$a_j$；</li>
<li>否则全部改为$b_{mj}$，$m$为这些行的行号最小值。</li>
</ul>
<p>若某一行变成了$(a_1, a_2, \cdots, a_n)$，则分解$rho$具有无损连接性，算法终止。</p>
</li>
<li>
<p>比较扫描前后，表有无变化。</p>
<ul>
<li>如有变化，则返回第2步；</li>
<li>否则算法终止，分解$rho$是有损连接。</li>
</ul>
</li>
</ol>
<p>例如，关系模式$R&lt;U,F&gt;$，其中，$U = \{ A, B, C \}$，$F = \{ A \rightarrow B, C \rightarrow B \}$。</p>
<p>判断$\rho = \{ AC, BC \}$是否具有无损连接性：</p>
<ol>
<li>
<p>构造初始表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_i$</th>
<th style="text-align:center">$A$</th>
<th style="text-align:center">$B$</th>
<th style="text-align:center">$C$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center">$a_1$</td>
<td style="text-align:center">$b_{12}$</td>
<td style="text-align:center">$a_3</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">$b_{21}$</td>
<td style="text-align:center">$a_2$</td>
<td style="text-align:center">$a_3$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>考察$A \rightarrow B$，将$AC$行的$B$列改为$a_2$：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_i$</th>
<th style="text-align:center">$A$</th>
<th style="text-align:center">$B$</th>
<th style="text-align:center">$C$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center">$a_1$</td>
<td style="text-align:center">$a_2$</td>
<td style="text-align:center">$a_3</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">$b_{21}$</td>
<td style="text-align:center">$a_2$</td>
<td style="text-align:center">$a_3$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>从上表中看出$AC$行为${a_1, a_2, a_3}$，所以判断该关系模式具有无损连接性。</p>
</li>
</ol>
<h3 id="保持函数依赖" data-numberify>保持函数依赖<a class="anchor ms-1" href="#保持函数依赖"></a></h3>
<p>设有关系模式$R$，$F$是$R$的函数依赖集，$Z$是$R$的一个属性集合，则称$Z$所涉及到的$F^+$中所有函数依赖为$F$在$Z$上的投影，即为$\pi_Z(F)$，有：</p>
<p>$$
\pi_Z(F) = \{ x \rightarrow y | (x \rightarrow y) \in F^+ 且 xy \subseteq z \}
$$</p>
<p>设关系模式$R$的一个分解$\rho = \{ R_1&lt;U_1,F_1&gt;,\ R_2&lt;U_2,F_2&gt;,\ \cdots,\ R_k&lt;U_k,F_k&gt; \}$，$F$是$R$的依赖集，如果$F$等价于$\pi_{R1}(F) \cup \pi_{R2}(F) \cup \cdots \cup \pi_{Rk}(F)$，则称分解$\rho$具有依赖保持性。</p>
<blockquote>
<p>该定义中的&quot;等价&quot;并不代表相等，而是$F$中所包含的函数依赖在分解的函数依赖中也被包含，或者在分解的函数依赖中能被推出。</p>
</blockquote>
<ul>
<li>一个无损连接分解不一定具有依赖保持性；</li>
<li>一个依赖保持性分解不一定具有无损连接性。</li>
</ul>
<h2 id="范式" data-numberify>范式<a class="anchor ms-1" href="#范式"></a></h2>
<p>关系数据库中的<u>关系必须满足一定的规范化要求</u>，对于不同的规范化程度可用范式来衡量。</p>
<p><u>范式是符合某一种级别的关系模式的集合</u>，是衡量关系模式规范化程度的标准，达到范式的关系才是规范化的。</p>
<p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化。</p>
<p>主要有6种范式，高一级范式是在低一级范式的基础上进一步满足一些要求，按要求从低到高分为：</p>
<ol>
<li>
<p>第一范式（1NF）：若关系模式R的<u>每一个分量是不可再分的数据项</u>，则关系模式R属于第一范式。</p>
<p>如，关系模式$R&lt;U,F&gt;$：</p>
<p>$$
U = \{ 学号,姓名,学院,院长,课程号,课程名,成绩 \} \\
F = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长,课程号 \rightarrow 课程名,(学号,课程号) \rightarrow 成绩 \}
$$</p>
<p>1NF可能存在的问题：</p>
<ul>
<li>
<p><strong>数据冗余</strong>：数据的冗余度大，R中可能出现多个元组在多个属性集中值相同；</p>
</li>
<li>
<p><strong>修改异常</strong>：引起修改操作的不一致性，修改一条记录可能需要修改其他多条记录才能保持数据一致性（由数据冗余引起）；</p>
</li>
<li>
<p><strong>插入异常</strong>：主码不能取空值或部分空值，会出现插入异常；</p>
</li>
<li>
<p><strong>删除异常</strong>：本该删除但又客观存在的元组，会出现删除异常。</p>
<p>即，删除掉的数据可能包含着其他本不该被删除的属性。</p>
</li>
</ul>
<p>问题的原因是1NF中可能存在<u>部分函数依赖</u>。</p>
</li>
<li>
<p>第二范式（2NF）：若关系模式$R \in 1NF$，且<u>每一个非主属性完全依赖于码</u>，则关系模式$R \in 2NF$。</p>
<p>即当<u>1NF消除了对主键的部分函数依赖后就能满足2NF</u>。</p>
<p>例如，$学号 \rightarrow 学院$，即$(学号,课程号) \stackrel{P}{\rightarrow} 学院$（部分依赖于码），所以$R \not\in 2NF$。</p>
<p><u>模式的分解需要保持函数依赖。</u>根据$F$，将$R$分解为：</p>
<ul>
<li>
<p>$R_1&lt;U_1,F_1&gt;$：</p>
<p>$$
U_1 = \{ 学号,姓名,学院,院长 \} \\
F_1 = \{ 学号 \rightarrow 姓名,学号 \rightarrow 学院,学院 \rightarrow 院长 \}
$$</p>
</li>
<li>
<p>$R_2&lt;U_2,F_2&gt;$：</p>
<p>$$
U_2 = \{ 课程号,课程名 \} \\
F_2 = \{ 课程号 \rightarrow 课程名 \}
$$</p>
</li>
<li>
<p>$R_3&lt;U_3,F_3&gt;$：</p>
<p>$$
U_3 = \{ 学号,课程号,成绩 \} \\
F_3 = \{ (学号,课程号) \rightarrow 成绩 \}</p>
</li>
</ul>
<p>则，$R1 \in 2NF$，$R2 \in 2NF$，$R3 \in 2NF$。</p>
<blockquote>
<p>2NF可能依然会存在数据冗余、修改异常、插入异常删除异常等问题。</p>
</blockquote>
</li>
<li>
<p>第三范式（3NF）：若关系模式$R(R \in 2NF)$中<u>任何一个非主属性都不传递函数依赖于码</u>。</p>
<p>若关系模式$R&lt;U,F&gt;$（$U$为关系集，$F$为函数依赖集）中不存在这样的码$X$，使得：</p>
<ul>
<li>$X \rightarrow Y(Y \not\rightarrow X)$，</li>
<li>$Y \rightarrow Z$，</li>
</ul>
<p>则关系模式$R \in 3NF$，其中：</p>
<ul>
<li>$Y$为属性组，</li>
<li>$Z(Z \not\subseteq Y)$为非主属性。</li>
</ul>
<p>即当<u>2NF消除了非主属性对主键的传递函数依赖</u>，则称为3NF。</p>
<p>如，$R_1$中有$学号 \rightarrow 学院$，$学院 \rightarrow 院长$（非主属性&quot;院长&quot;传递依赖于主键&quot;学号&quot;）。可将$R_1$分解为：</p>
<ul>
<li>
<p>$R_{11}&lt;U_{11},F_{11}&gt;$：</p>
<p>$$
U_{11} = \{ 学号,姓名,学院 \} \\
F_{11} = \{ 学号 \rightarrow 姓名, 学号 \rightarrow 学院 \}
$$</p>
</li>
<li>
<p>$R_{12}&lt;U_{12},F_{12}&gt;$：</p>
<p>$$
U_{12} = \{ 学院,院长 \} \\
F_{12} = \{ 学院 \rightarrow 院长 \}
$$</p>
</li>
</ul>
</li>
<li>
<p>BC范式（BCNF）：关系模式$R&lt;U,F&gt;$属于BCNF（$R$首先得满足3NF），当且仅当其$F$中<u>每个依赖的决定因素必定包含R的某个候选码</u>。</p>
<p>由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：</p>
<ul>
<li>
<p>满足3NF。</p>
</li>
<li>
<p>所有<u>非主属性</u>对每一个<u>码</u>都是<u>完全函数依赖</u>。</p>
<p>$$
码 \stackrel{f}{\longrightarrow} 非主属性
$$</p>
</li>
<li>
<p>所有的<u>主属性对每一个</u>不包含它的码</u>，也是<u>完全函数依赖</u>。</p>
</li>
<li>
<p>没有任何属性完全函数依赖于非码的任何一组属性。</p>
</li>
</ul>
<p>一个满足BCNF的关系模式R己<u>消除了<strong>插入</strong>和<strong>删除异常</strong></u>。</p>
</li>
<li>
<p>第四范式（4NF）：</p>
<p>多值依赖：</p>
<p>给定的关系模式$R(U,F)$：</p>
<ul>
<li>$X,Y,Z \subseteq U$，</li>
<li>$Z=U-X-Y$（$Z$是$X \cup Y$的差集）。</li>
</ul>
<p>当且仅当对$R$的任一关系$r$，给定的一对$(x,z)$值，有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。则关系模式$R$中的多值依赖$X \rightarrow\rightarrow Y$成立。</p>
<p>平凡的多值依赖：</p>
<ul>
<li>$X \rightarrow\rightarrow Y$成立，</li>
<li>$Z = \Phi$，</li>
</ul>
<p>则$X \rightarrow\rightarrow Y$为平凡的多值依赖。</p>
<p>例如，课程$\rightarrow\rightarrow$任课老师，课程$\rightarrow\rightarrow$参考书。</p>
<p><picture><img class="img-fluid " alt="多值依赖表示例" src="/docs/ruan-she/data-base/uTools_1681986736869.png" loading="lazy" width="401" height="168" />
</picture>

</p>
<p>4NF定义：</p>
<p>设有一关系模式$R(U,F)$是1NF，如果对于$R$的每个<u>非平凡多值依赖</u>$X \rightarrow\rightarrow Y(Y \not\subseteq X)$，<u>$X$都包含了$R$的一个候选码</u>，则称$R$是第四范式，记为4NF。</p>
<p>例如，课程$\rightarrow\rightarrow$任课老师，课程$\rightarrow\rightarrow$参考书都是非平凡多值依赖，而课程不是码，所以不属于4NF。</p>
</li>
<li>
<p>第五范式（5NF）。</p>
</li>
</ol>
<p>范式之间的关系：</p>
<p>$$
5NF \sub 4NF \sub BCNF \sub 3NF \sub 2NF \sub 1NF
$$</p>
<p><picture><img class="img-fluid " alt="规范化范式的包含关系" src="/docs/ruan-she/data-base/uTools_1681894653450.png" loading="lazy" width="564" height="309" />
</picture>

</p>
<p>3NF和BCNE它们是进行规范化的主要目标。</p>
<p>1NF到4NF之间的转换关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">范式</th>
<th style="text-align:left">转换关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1NF</td>
<td style="text-align:left">每一个分量是不可再分的数据项</td>
</tr>
<tr>
<td style="text-align:center">2NF</td>
<td style="text-align:left">1NF消除了部分函数依赖后满足2NF</td>
</tr>
<tr>
<td style="text-align:center">3NF</td>
<td style="text-align:left">2NF消除了非主属性对码的传递函数依赖后满足3NF</td>
</tr>
<tr>
<td style="text-align:center">BCNF</td>
<td style="text-align:left">3NF消除了主属性对码的部分和传递函数依赖后满足BCNF</td>
</tr>
<tr>
<td style="text-align:center">4NF</td>
<td style="text-align:left">BCNF消除非平凡且非函数依赖的多值依赖后满足4NF</td>
</tr>
</tbody>
</table>
<p><picture><img class="img-fluid " alt="规范化步骤" src="/docs/ruan-she/data-base/uTools_1681988070233.png" loading="lazy" width="288" height="303" />
</picture>

</p>
<p>几种范式及其分解的性质：</p>
<table>
<thead>
<tr>
<th style="text-align:left">性质</th>
<th style="text-align:center">3NF</th>
<th style="text-align:center">BCNF</th>
<th style="text-align:center">4NF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">消除函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">消除多值函数依赖带来冗余</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">保持函数依赖</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">保持多值函数依赖</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="数据库设计" data-numberify>数据库设计<a class="anchor ms-1" href="#数据库设计"></a></h1>
<p>新奥尔良（New Orleans）法式目前公认的数据库设计方法，它将数据库设计分为以下几个阶段：</p>
<ol>
<li>用户需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
</ol>
<p>这几个阶段之后是与数据库建立和运行有关的阶段：</p>
<ol>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ol>
<p><picture><img class="img-fluid " alt="数据库设计步骤" src="/docs/ruan-she/data-base/uTools_1682505975157.png" loading="lazy" width="382" height="711" />
</picture>

</p>
<h2 id="需求分析" data-numberify>需求分析<a class="anchor ms-1" href="#需求分析"></a></h2>
<p>需求分析是项目确定后，对数据库应用系统所要设计的<u>内容（数据）</u>和<u>功能（行为）</u>的整理和描述，是以用户的角度来认识系统。</p>
<p>需求分析是后面几个阶段，<u>逻辑结构设计</u>、<u>物理结构设计</u>以及<u>应用程序设计</u>的依据。</p>
<p>需求分析将收集到的零碎的、局部的数据分析整理后，建立<u>需求说明文档</u>、<u>数据字典</u>和<u>数据流程图</u>。</p>
<p>需求分析还包含：</p>
<ul>
<li>
<p>数据流分析：是对事务处理所需的原始数据的收集，及经过处理后所得数据及其流向。</p>
<p>使用数据流图（DFD）表示。DFD能指出数据的流向和需要进行的事物处理（不涉及如何处理）。</p>
</li>
<li>
<p>数据字典：是关于数据库中数据的描述，即元数据（不是数据本身）。</p>
<p>数据字典包括5个部分：</p>
<ul>
<li>数据项；</li>
<li>数据结构；</li>
<li>数据流；</li>
<li>数据存储；</li>
<li>加工。</li>
</ul>
</li>
</ul>
<p><u>系统需求说明书是需求分析阶段的成果</u>，主要包括<u>数据流图</u>、<u>数据字典</u>、<u>各种说明性表格</u>、<u>统计输出表和系统功能结构图</u>等。</p>
<p>需求分析阶段的工作：</p>
<p><picture><img class="img-fluid " alt="需求分析阶段的工作步骤" src="/docs/ruan-she/data-base/uTools_1682560887456.png" loading="lazy" width="646" height="291" />
</picture>

</p>
<h2 id="概念结构设计" data-numberify>概念结构设计<a class="anchor ms-1" href="#概念结构设计"></a></h2>
<p>概念设计阶段的目标是产生整体数据库概念结构，即概念模型，它是与DBMS无关的。</p>
<p>概念结构设计的方法：</p>
<ul>
<li>自顶向下</li>
<li>自底向上</li>
<li>逐步扩张</li>
<li>混合策略（自顶向下和自底向上相结合）</li>
</ul>
<p>概念结构是对现实世界的一种抽象，从数据库设计角度看，主要是数据抽象，一般有如下3种数据抽象：</p>
<ul>
<li>分类</li>
<li>聚集</li>
<li>概括</li>
</ul>
<p>局部视图设计就是对某个局部应用设计其分一R图，也称局部E-R图。其基本步骤如下：</p>
<p><picture><img class="img-fluid " alt="概念结构设计的工作步骤" src="/docs/ruan-she/data-base/uTools_1682560993863.png" loading="lazy" width="717" height="341" />
</picture>

</p>
<ol>
<li>确定局部结构范围；</li>
<li>定义实体；</li>
<li>联系定义；</li>
<li>属性分配。</li>
</ol>
<p>概念模型的建立采用E-R模型。</p>
<h3 id="e-r-模型" data-numberify>E-R 模型<a class="anchor ms-1" href="#e-r-模型"></a></h3>
<p>E-R模型用E-R图（ERD）表示，E-R图有以下几个成分：</p>
<ul>
<li>
<p><strong>实体</strong>：用<strong>矩形</strong>表示。</p>
</li>
<li>
<p><strong>联系</strong>：用<strong>棱形</strong>表示，并用无向边分别与有关实体连接起来，同时在无向边标注联系的类型（$1:1$，$1:n$ 或 $m:n$）。</p>
</li>
<li>
<p><strong>属性</strong>：用<strong>椭圆形</strong>表示，并用无向边将其与相应的实体连接起来</p>
<p>E-R模型中的属性有以下分类：</p>
<ul>
<li>
<p>简单属性和复合属性：</p>
<ul>
<li>简单属性是原子的、不可再分的；</li>
<li>复合属性可以细分为更小的部分。</li>
</ul>
</li>
<li>
<p>单值属性和多值属性：</p>
<ul>
<li>单值属性是一个属性对应一个值；</li>
<li>多值属性是一个属性对应一组值。</li>
</ul>
</li>
<li>
<p>NULL属性：实体在某个属性上没有值或属性值未知时，使用NULL值表示。</p>
</li>
<li>
<p>派生属性：派生属性可以从其他属性得来（通过运算等方式求出）。</p>
</li>
</ul>
</li>
</ul>
<p>扩充的E-R模型（用来表达更多具有特殊语义的成分）有以下成分：</p>
<ul>
<li>
<p><strong>弱实体</strong>：使用<strong>双线矩形框</strong>表示。将需要依赖其他实体存在的实体。</p>
<p>实体间的所有（Ownership，拥有）关系代表一个实体对另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提。</p>
<p>例如职工与家属的联系，家属总是属于某职工的（在关系模式中需要依赖职工而存在），所以家属是弱实体。</p>
</li>
<li>
<p><strong>特殊化</strong>：将一个实体集<u>按照某些特性区分为几个<strong>子实体</strong></u>。这种从普遍到特殊的过程即为特殊化。</p>
<p>子实体的图形表示如下：</p>
<p><picture><img class="img-fluid " alt="子实体" src="/docs/ruan-she/data-base/uTools_1684564987147.png" loading="lazy" width="256" height="145" />
</picture>

</p>
<p>子实体由称为子类，它会有一个超类，并且能继承超类的属性，超类的属性是实体集中所有子实体的相同属性。</p>
</li>
</ul>
<p>E-R图中的主要构件（包含扩充的E-R模型成分）：</p>
<p><picture><img class="img-fluid " alt="E-R图中的主要构件" src="/docs/ruan-she/data-base/uTools_1682508598814.png" loading="lazy" width="1035" height="391" />
</picture>

</p>
<h3 id="建立概念结构模型" data-numberify>建立概念结构模型<a class="anchor ms-1" href="#建立概念结构模型"></a></h3>
<p>建立概念结构模型的步骤如下：</p>
<ol>
<li>
<p>选择局部应用：</p>
<p>需求分析阶段得到的大量数据分散杂乱，许多数据会应用于不同的处理，数据与数据之间关联关系也较为复杂。要最终<u>确定实体、属性和联系，必须根据数据流图这一线索理清数据</u>。</p>
<p>数据流图是对业务处理过程从高层到底层的一级抽象：</p>
<ul>
<li>高层抽象流图一般反映系统的概貌，对数据的引用较为笼统；</li>
<li>底层又可能过于细致，不能体现数据的关联关系。</li>
</ul>
<p>因此要<u>选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能。从这一层入手，就能很好地设计<strong>分E-R图</strong></u>。</p>
</li>
<li>
<p>逐一设计分E-R图。</p>
</li>
<li>
<p>E-R图合并：</p>
<p>根据局部应用设计好各局部E-R图之后，就可以对各分E-R图进行合并。</p>
<p>合并的目的在于，在合并过程中解决分E-R图中相互存在的冲突。</p>
</li>
</ol>
<p>分E-R图之间的冲突主要有：</p>
<ul>
<li><strong>属性冲突</strong>：同一属性在不同的分E-R图上的属性类型、取值范围和数据单位等可能会不一致。</li>
<li><strong>命名冲突</strong>：相同意义的属性在不同的分E-R图上可能会有不同的命名。</li>
<li><strong>结构冲突</strong>：同一实体在不同的分E-R图中可能会有不同的属性；同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又可能被抽象为属性，反之亦然。</li>
</ul>
<h2 id="逻辑结构设计" data-numberify>逻辑结构设计<a class="anchor ms-1" href="#逻辑结构设计"></a></h2>
<p>逻辑结构设计就是在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型。</p>
<p>通常是把概念模型转换成为<u>某个具体的数据库管理系统所支持的结构数据模型</u>（与DBMS有关）。即，将概念结构设计所得的E-R模型转换成关系模式。</p>
<p>逻辑结构设计的工作步骤：</p>
<p><picture><img class="img-fluid " alt="逻辑结构设计的工作步骤" src="/docs/ruan-she/data-base/uTools_1682577339219.png" loading="lazy" width="581" height="296" />
</picture>

</p>
<h3 id="e-r-模型转换关系模式" data-numberify>E-R 模型转换关系模式<a class="anchor ms-1" href="#e-r-模型转换关系模式"></a></h3>
<ol>
<li>
<p>实体向关系模式的转换：</p>
<p>将E-R图中的实体逐一转换成为一个关系模式：</p>
<ul>
<li>实体名：对应关系模式的名称；</li>
<li>实体的属性：转换成关系模式的属性；</li>
<li>实体标识符：关系的码（键）。</li>
</ul>
<p>超类和子类的转换：超类和子类定义为两个关系模式，将超类的主键加到子类中。</p>
</li>
<li>
<p>联系向关系模式的转换：</p>
<ul>
<li>
<p>一对一联系的转换：</p>
<p>有两种方式：</p>
<ul>
<li>
<p>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码。</p>
<p>那么一个一对一联系需要转换成三个关系模式。</p>
</li>
<li>
<p>方式2（一般使用该方式）：将联系归并到关联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体码保持不变。</p>
<p>一个一对一联系仅需转换成两个关系模式。</p>
</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="联系向关系模式的转换示例" src="/docs/ruan-she/data-base/uTools_1682562445900.png" loading="lazy" width="304" height="358" />
</picture>

</p>
<ul>
<li>
<p>方式1：</p>
<p>厂长（<strong>姓名</strong>，性别，年龄）</p>
<p>工厂（<strong>厂号</strong>，厂名，地点）</p>
<p>管理（（厂长）<strong>姓名</strong>，厂号，任期）</p>
<blockquote>
<p>粗体代表该关系模式的码。管理的码可以为姓名或厂号。</p>
</blockquote>
</li>
<li>
<p>方式2：</p>
<p>厂长（姓名，性别，年龄）</p>
<p>工厂（厂号，厂名，地点，（厂长）姓名，任期）</p>
</li>
</ul>
</li>
<li>
<p>一对多联系的转换：</p>
<p>两种方式：</p>
<ul>
<li>方式1：将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，<u>关系的码是多方实体的码</u>；</li>
<li>方式2（一般使用该方式）：将联系<u>归并到关联的两个实体的多方</u>，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变。</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="一对多联系转换的例子" src="/docs/ruan-she/data-base/uTools_1682563544291.png" loading="lazy" width="315" height="361" />
</picture>

</p>
<ul>
<li>
<p>方式1:</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格）</p>
<p>仓储（<strong>货号</strong>，仓库号，数量）</p>
</li>
<li>
<p>方式2：</p>
<p>仓库（<strong>仓库号</strong>，地点，面积）</p>
<p>商品（<strong>货号</strong>，商品名，价格，仓库号，数量）</p>
</li>
</ul>
</li>
<li>
<p>多对多联系的转换：</p>
<p>多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组。</p>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="多对多联系转换的示例" src="/docs/ruan-she/data-base/uTools_1682564018777.png" loading="lazy" width="327" height="373" />
</picture>

</p>
<p>转换成：</p>
<p>学生（<strong>学号</strong>，姓名，性别，年龄）</p>
<p>课程（<strong>课程号</strong>，课程名，学时）</p>
<p>选修（<strong>（学号，课程号）</strong>，成绩）</p>
</li>
</ul>
</li>
</ol>
<h3 id="关系模式的规范化" data-numberify>关系模式的规范化<a class="anchor ms-1" href="#关系模式的规范化"></a></h3>
<p>转换后的关系模式可能存在数据冗余、更新异常等问题，所以需要进一步的规范化处理。</p>
<ol>
<li>
<p>根据语义确定各关系模式的数据依赖（函数依赖）。</p>
</li>
<li>
<p>根据数据依赖确定关系模式的范式。判定关系模式是否达到了3NF或4NF。</p>
</li>
<li>
<p>如果关系模式不符合要求，要根据关系模式的分解算法对其进行分解，达到3NF、BCNF或4NF。</p>
</li>
<li>
<p>关系模式的评价及修正。</p>
<p>根据规范化理论对关系模式分解之后，就可以在理论上消除冗余和更新异常。但根据处理要求，可能还需要增加部分冗余以满足处理要求，这就需要做部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>
</li>
</ol>
<hr>
<h1 id="事务管理" data-numberify>事务管理<a class="anchor ms-1" href="#事务管理"></a></h1>
<p>事务是一个操作序列，这些操作“要么都做，要么都不做”。</p>
<p>事务和程序是两个不同的概念，一般一个程序可包含多个事务。</p>
<p>在SQL语言中，事务定义的语句有以下三条。</p>
<ul>
<li>
<p><code>BEGIN TRANSACTION</code>：事务开始。</p>
</li>
<li>
<p><code>COMMIT</code>：事务提交。</p>
<p>该操作表示事务成功地结束，它将通知事务管理器该事务的<u>所有更新操作现在可以被提交或永久地保留</u>。</p>
</li>
<li>
<p><code>ROLLBACK</code>：事务回滚。</p>
<p>该操作表示事务非成功地结束，它将通知事务管理器<u>出故障</u>了，数据库可能处于不一致状态，该事务的<u>所有更新操作必须回滚或撤销</u>。</p>
</li>
</ul>
<p>事务的ACID性质：</p>
<ul>
<li>
<p><strong>原子性</strong>（Atomicity）：事务是原子的，要么都做，要么都不做。</p>
</li>
<li>
<p><strong>一致性</strong>（Consistency）：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。</p>
<p>因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。</p>
</li>
<li>
<p><strong>隔离性</strong>（Isolation）：事务相互隔离。</p>
<p>当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的</p>
</li>
<li>
<p><strong>持久性</strong>（Durability）：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。</p>
</li>
</ul>
<hr>
<h1 id="数据库故障" data-numberify>数据库故障<a class="anchor ms-1" href="#数据库故障"></a></h1>
<p>在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前的正确状态，就是数据库恢复技术。</p>
<p>故障类型：</p>
<ul>
<li><strong>事务内部故障</strong>：有的可以通过事务程序本身发现；有的是非预期的，不能由事务程序处理。</li>
<li><strong>系统故障</strong>（软故障）：是指造成系统停止运行的任何事件，使得系统要重新启动，例如CPU故障、操作系统故障和突然停电等。</li>
<li><strong>介质故障</strong>（硬故障）：如磁盘损坏、磁头碰撞和瞬时强磁干扰。此类故障发生的几率小，但破坏性最大。</li>
<li><strong>计算机病毒</strong>：计算机病毒是一种人为的故障和破坏，是在计算机程序中插入的破坏，计算机功能或者数据可以繁殖和传播的一组计算机指令或程序代码。</li>
</ul>
<h2 id="备份方法" data-numberify>备份方法<a class="anchor ms-1" href="#备份方法"></a></h2>
<p>恢复的基本原理是“建立数据冗余”（重复存储）。建立冗余数据的方法是进行<u>数据转储</u>和<u>登记日志文件</u>，分为：</p>
<ul>
<li>
<p>静态转储和动态转储：</p>
<ul>
<li>
<p><strong>静态转储</strong>：在转储期间不允许对数据库进行任何存取、修改操作；</p>
</li>
<li>
<p><strong>动态转储</strong>：在转储期间允许对数据库进行存取、修改操作。</p>
<p>动态转储和用户事务可并发执行。</p>
</li>
</ul>
</li>
<li>
<p>海量转储和增量转储：</p>
<ul>
<li><strong>海量转储</strong>：指每次转储全部数据；</li>
<li><strong>增量转储</strong>：指每次只转储上次转储后更新过的数据。</li>
</ul>
</li>
<li>
<p><strong>日志文件</strong>：</p>
<p>在事务处理的过程中，DBMS把以下操作写入日志文件：</p>
<ul>
<li>事务开始、事务结束；</li>
<li>对数据库的插入、删除和修改。</li>
</ul>
<p>一旦发生故障，DBMS的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复。</p>
</li>
</ul>
<h2 id="恢复" data-numberify>恢复<a class="anchor ms-1" href="#恢复"></a></h2>
<p>事务恢复有以下3个步骤：</p>
<ol>
<li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li>
<li>对事务的更新操作执行逆操作。</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志。</li>
</ol>
<hr>
<h1 id="并发控制" data-numberify>并发控制<a class="anchor ms-1" href="#并发控制"></a></h1>
<p>所谓并发操作，是指在多用户共享的系统中许多用户可能同时对同一数据进行操作。并发操作带来的问题是数据的不一致性，主要有三类：</p>
<ul>
<li><strong>丢失更新</strong></li>
<li><strong>不可重复读</strong></li>
<li><strong>读脏数据</strong></li>
</ul>
<p>其主要原因是事务的并发操作破坏了事务的隔离性。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。</p>
<h2 id="封锁" data-numberify>封锁<a class="anchor ms-1" href="#封锁"></a></h2>
<p>并发控制的主要技术是封锁。基本封锁的类型有：</p>
<ul>
<li>
<p>排它锁（X锁或写锁）：若事务T对数据对象A加上X锁，则<u>只允许T读取和修改A，其他事务都不能再对A加任何类型的锁</u>，直到T释放A上的锁。</p>
</li>
<li>
<p>共享锁（S锁或读锁）：若事务T对数据对象A加上S锁，则<u>只允许T读取A，但不能修改A，其他事务只能再对A加S锁</u>，直到T释放A上的S锁。</p>
<p>这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A进行任何修改。</p>
</li>
</ul>
<hr>
<h1 id="分布式数据库" data-numberify>分布式数据库<a class="anchor ms-1" href="#分布式数据库"></a></h1>
<p>分布式数据库系统是指数据存放在计算机网络的不同场地的计算机中，每一场地都有自治处理能力并能完成局部应用；而每一场地也参与（至少一种）全局应用程序的执行，全局应用程序可通过网络通信访问系统中多个场地的数据。其定义强调分布性和逻辑整体性两点。</p>
<p>分布式数据库中有以下基本概念：</p>
<ul>
<li><strong>分片透明</strong>：指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的。</li>
<li><strong>复制透明</strong>：指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。</li>
<li><strong>位置透明</strong>：指用户无须知道数据存放的物理位置。</li>
<li><strong>逻辑透明</strong>：指用户或应用程序无需知道局部场地使用的是哪种数据模型。</li>
</ul>
<p>具有以下性质：</p>
<ul>
<li><strong>共享性</strong>：数据存储在不同的结点数据共享。</li>
<li><strong>自治性</strong>：指每结点对本地数据都能独立管理。</li>
<li><strong>可用性</strong>：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。</li>
<li><strong>分布性</strong>：指数据在不同场地上的存储。</li>
</ul>
<hr>
<h1 id="存储过程" data-numberify>存储过程<a class="anchor ms-1" href="#存储过程"></a></h1>
<p>存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p>
<p>存储过程是数据库所提供的一种数据库对象，通过存储过程定义一段代码，提供给应用程序调用来执行。从安全性的角度考虑，更新数据时，通过提供存储过程正第三方调用，将需要更新的数据传入存储过程，而在存储过程内部用代码分别对需要的多个表进行更新，从而避免了向第三方提供系统的表结构，保证了系统的数据安全。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>面向对象篇</title>
      <link>/docs/ruan-she/object-oriented/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/ruan-she/object-oriented/</guid>
      <description><![CDATA[面向对象基本概念 面向对象（Object-Oriented，00） = 对象（Object）+ 分类（Classification）+ 继承（Inhe]]></description>
      <content:encoded><![CDATA[<h1 id="面向对象基本概念" data-numberify>面向对象基本概念<a class="anchor ms-1" href="#面向对象基本概念"></a></h1>
<p><strong>面向对象</strong>（Object-Oriented，00） = <strong>对象</strong>（Object）+ <strong>分类</strong>（Classification）+ <strong>继承</strong>（Inheritance）+ <strong>通过消息的通信</strong>（Communication with Messages）</p>
<h2 id="对象" data-numberify>对象<a class="anchor ms-1" href="#对象"></a></h2>
<p>在面向对象的系统中，对象是基本的运行时的实体，它包括：</p>
<ul>
<li><strong>属性</strong>：数据；</li>
<li><strong>行为</strong>：作用于数据的操作。</li>
</ul>
<p>一个对象把属性和行为封装为一个整体。</p>
<blockquote>
<p>封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。</p>
<p>对象可以看作是一个程序模块。</p>
</blockquote>
<p>一个对象通常由以下成分组成：</p>
<ul>
<li>对象名；</li>
<li>属性；</li>
<li>方法。</li>
</ul>
<h2 id="消息" data-numberify>消息<a class="anchor ms-1" href="#消息"></a></h2>
<p>对象之间进行通信的一种构造叫件消息。</p>
<h2 id="类" data-numberify>类<a class="anchor ms-1" href="#类"></a></h2>
<p>类可以分为三种：</p>
<ul>
<li>
<p><strong>实体类</strong>：实体类的对象表示现实世界中真实的实体；</p>
</li>
<li>
<p><strong>接口类</strong>：接口类的对象为用户提供一种与系统合作交互的方式，分
为人和系统两大类（边界类）；</p>
<ul>
<li>人的接口可以是显示屏、窗口、Wb窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。</li>
<li>系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</li>
</ul>
</li>
<li>
<p><strong>控制类</strong>：控制类的对象用来控制活动流，充当协调者。</p>
</li>
</ul>
<h2 id="继承" data-numberify>继承<a class="anchor ms-1" href="#继承"></a></h2>
<p>继承是<u>父类</u>和<u>子类</u>之间<u>共享数据</u>和<u>方法</u>的机制。这是<u>类之间的一种关系</u>，在定义和实现一个类的时候，可以在一个已经存在的类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p>
<p>一个父类可以有多个子类。所以继承又分为：</p>
<ul>
<li>
<p>单重继承：只从一个父类得到继承；</p>
</li>
<li>
<p>多重继承：一个子类有两个或更多个父类。</p>
<p>多重继承中可能导致子类存在二义性的成员。</p>
</li>
</ul>
<h2 id="多态" data-numberify>多态<a class="anchor ms-1" href="#多态"></a></h2>
<p>多态（Polymorphism）：不同的对象收到同一消息可以产生完全不同的结果。</p>
<p>同一消息就可以调用不同的方法。多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。</p>
<p>多态有不同的形式：</p>
<ul>
<li><strong>通用</strong>的多态：
<ul>
<li><strong>参数</strong>多态：应用比较广泛，被称为最纯的多态；</li>
<li><strong>包含</strong>多态：在许多语言中都存在，最常见的例子就是子类型化。即一个类型是另一个类型的子类型。</li>
</ul>
</li>
<li><strong>特定</strong>的多态：
<ul>
<li><strong>过载</strong>（Overloading）多态：同一个名字在不同的上下文中所代表的含义不同；</li>
<li><strong>强制</strong>多态。</li>
</ul>
</li>
</ul>
<h2 id="绑定" data-numberify>绑定<a class="anchor ms-1" href="#绑定"></a></h2>
<p>绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。</p>
<p>绑定分为：</p>
<ul>
<li>
<p><strong>静态绑定</strong>：在编译时进行的；</p>
</li>
<li>
<p><strong>动态绑定</strong>：在运行时进行的。</p>
<p>一个给定的过程调用和代码的结合直到调用发生时才进行。</p>
<p>动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类对象可以出现的地方，子类对象也可以出现。</p>
<p>在运行过程中，当一个对象发送消息请求服务时，要根据匿收对象的其体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>
</li>
</ul>
<hr>
<h1 id="面向对象分析" data-numberify>面向对象分析<a class="anchor ms-1" href="#面向对象分析"></a></h1>
<p>同其他分析方法一样，面向对象分析（Object-Oriented Analysis，OOA）的目的是为了获得对应用问题的理解。</p>
<p>面向对象分析包含5个活动：</p>
<ul>
<li>认定对象；</li>
<li>组织对象；</li>
<li>描述对象间的相互作用；</li>
<li>确定对象的操作</li>
<li>定义对象的内部信息。</li>
</ul>
<h2 id="认定对象" data-numberify>认定对象<a class="anchor ms-1" href="#认定对象"></a></h2>
<p>在应用领域中，按自然存在的实体确立对象。</p>
<p>在定义域中，首先将自然存在的“名词”作为一个对象，这通常是研究问题、定义域实体的良好开始。</p>
<h2 id="组织对象" data-numberify>组织对象<a class="anchor ms-1" href="#组织对象"></a></h2>
<p>分析对象间的关系，将相关对象抽象成类，其目的是为了简化关联对象，利用类的继承性建立具有继承性层次的类结构。</p>
<p>抽象类时可从以下方面考虑：</p>
<ul>
<li>对象间的操作；</li>
<li>一个对象是另一个对象的一部分，如房子是由门和窗构成的。</li>
</ul>
<hr>
<h1 id="面向对象设计" data-numberify>面向对象设计<a class="anchor ms-1" href="#面向对象设计"></a></h1>
<p><strong>程序设计范型</strong>（Programming Paradigm）是人们在<u>程序设计时所采用的基本方式模型</u>，决定了程序设计时采用的<u>思维方式</u>、<u>使用的工具</u>，同时又<u>有一定的应用范畴</u>。</p>
<p>程序设计范型的发展经历了：</p>
<ul>
<li>过程程序设计；</li>
<li>模块化程序设计；</li>
<li>函数程序设计；</li>
<li>逻辑程序设计；</li>
<li>面向对象程序设计范型。</li>
</ul>
<p><strong>面向对象程序设计</strong>（Object-Oriented Programming，<strong>OOP</strong>）的<u>实质是选用一种<strong>面向对象程序设计语言</strong>（Object-Oriented Programming Language，<strong>OOPL</strong>）</u>：</p>
<ul>
<li>采用对象、类及其相关概念所进行的程序设计；</li>
<li>关键在于加入了类和继承性，从而进一步提高了抽象程度。</li>
</ul>
<p>特定的OOP概念一般是通过OOPL中特定的语言机制来体现的。</p>
<p>OOP现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念。</p>
<h2 id="设计原则" data-numberify>设计原则<a class="anchor ms-1" href="#设计原则"></a></h2>
<p>面向对象方法中的五大原则：</p>
<ul>
<li>
<p><strong>责任原则</strong>（Single Responsibility Principle，SRP）：当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>（Open &amp; Close Principle，OCP）：软件实体（类、模块、函数等）应
该可以扩展的，即<strong>开放的</strong>；但是不可修改的，即<strong>封闭的</strong>。</p>
</li>
<li>
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类型必须能够替换掉他们的基
类型。</p>
<p>即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有是一个（is-a）关系。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>（Dependence Inversion Principle，DP）：抽象不应该依赖于细节，细
节应该依赖于抽象。即，<u>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</u>。</p>
</li>
<li>
<p><strong>接口分离原则</strong>（Interface Segregation Principle，ISP）：不应该强迫客户依赖于它们不
用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>即：<u>依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。</u></p>
<p>这样做的好处就在于可以最大限度地应对可能的变化。</p>
</li>
</ul>
<p>Robert C. Martin提出的面向对象设计原则还包括以下几个：</p>
<ul>
<li>重用发布等价原则（Release Reuse Equivalency Principle，REP）：重用的粒度就是发布的粒度。</li>
<li><strong>共同封闭原则</strong>（Common Closure Principle，CCP）：包中的所有类对于同一类性质的变化应该是共同到闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响。</li>
<li><strong>共同重用原则</strong>（Common Reuse Principle，CRP）：一个包中的所有类应该是共同重用
的。如果重用了包中的一个类那么就要重用包中的所有类。</li>
<li>无环依赖原则（Acyclic Dependencies Principle，ADP）：在包的依赖关系图中不允许存
在环，即包之间的结构必须是一个直接的五环图形。</li>
<li>稳定依赖原则（Stable Dependencies Principle,SDP）：朝着稳定的方向进行依赖。</li>
<li>稳定抽象原则（Stable Abstractions Principle，SAP）：包的抽象程度应该和其稳定程
度一致。</li>
</ul>
<hr>
<h1 id="uml" data-numberify>UML<a class="anchor ms-1" href="#uml"></a></h1>
<p>面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法，例如：</p>
<ul>
<li>Peter Coad和Edward Yourdon的OOA和OOD方法（又称Coad/Yourdon方法或Coad方法）；</li>
<li>Booch的OOD方法（又称Booch方法）；</li>
<li>OMT（Object Modeling Technique，面向对象建模技术）方法；</li>
<li>UML（Unified Modeling Language，统一建模语言）。</li>
</ul>
<p>UML是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前己经成为可视化建模语言事实上的工业标准。</p>
<p>UML中包含3种基本构造块：</p>
<ul>
<li>事物；</li>
<li>关系；</li>
<li>图。</li>
</ul>
<h2 id="事物" data-numberify>事物<a class="anchor ms-1" href="#事物"></a></h2>
<p>UML中有4种事物：</p>
<ul>
<li>
<p><strong>结构事物</strong>（Structural Thing）：是UML模型中的名词。它们<u>通常是模型的<strong>静态部分</strong>，描述概念或物理元素</u>。</p>
<p>结构事物包括：</p>
<ul>
<li>
<p>类（Class）；</p>
</li>
<li>
<p>接口（Interface）；</p>
</li>
<li>
<p>协作（Collaboration）；</p>
</li>
<li>
<p>用例（Use Case）；</p>
</li>
<li>
<p>主动类（Active Class）；</p>
</li>
<li>
<p>构件（Component）；</p>
</li>
<li>
<p>制品（Artifact）；</p>
</li>
<li>
<p>结点（Node）；</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="结构事物的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682055522161.png" loading="lazy" width="708" height="294" />
</picture>

</p>
</li>
<li>
<p><strong>行为事物</strong>（Behavior Thing）：<u>是UML模型的<strong>动态部分</strong></u>。它们是模型中的动词，描述了跨越时间和空间的行为。</p>
<p>行为事物包括：</p>
<ul>
<li>
<p>交互（Interaction）；</p>
</li>
<li>
<p>状态机（State Machine）；</p>
</li>
<li>
<p>活动（Activity）；</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="行为事物的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682055712246.png" loading="lazy" width="621" height="133" />
</picture>

</p>
</li>
<li>
<p><strong>分组事物</strong>（Grouping Thing）：UML模型的<strong>组织部分</strong>，是一些由模型分解成的“盒子”。</p>
<p><u>在所有的分组事物中，最主要的分组事物是包（Package）</u>。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。</p>
<p>包与构件（仅在运行时存在）不同，它纯粹是概念上的（即它仅在开发时存在）。</p>
<p><picture><img class="img-fluid " alt="包的图形化表示" src="/docs/ruan-she/object-oriented/uTools_1682055987585.png" loading="lazy" width="224" height="157" />
</picture>

</p>
</li>
<li>
<p><strong>注释事物</strong>（Annotational Thing）：注释事物是UML模型的<strong>解释部分</strong>。这些注释事物用来描述、说明和标注模型的任何元素。</p>
<p>注解（Note）是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号。</p>
</li>
</ul>
<h2 id="关系" data-numberify>关系<a class="anchor ms-1" href="#关系"></a></h2>
<p>UML中有4种关系，这4种关系是UML模型中可以包含的基本关系事物：</p>
<ul>
<li>
<p><strong>依赖</strong>（Dependency）：是<u>两个事物间的语义关系，其中一个事物（<strong>独立事物</strong>）发生变化会影响另一个事物（<strong>依赖事物</strong>）的语义</u>。</p>
<p>在图形上，把一个依赖画成一条<u>可能有方向的虚线</u>，如图：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p>依赖的变体有：</p>
<ul>
<li>精化；</li>
<li>跟踪；</li>
<li>包含；</li>
<li>延伸。</li>
</ul>
<p>依赖有偶然性和临时性，即需要的时候依赖，不需要的时候不依赖。</p>
</li>
<li>
<p><strong>关联</strong>（Association）：是一种<u>结构关系</u>，它描述了一组链，<u>链是对象之间的连接</u>。</p>
<p>关联使用<u>实线</u>表示，在关联上可以标注重复度（Multiplicity）和角色（Role）。</p>
<p>描述了<u>整体和部分</u>间的结构关系的特殊类型的关联：</p>
<ul>
<li>
<p><strong>聚集</strong>（Aggregation，聚合）：<u>部分和整体的生命周期不一致</u>，整体消失了，部分仍然存在，<u>部分可以脱离整体存在</u>。</p>
<p>使用一端带<u>空心菱形</u>的实线表示。</p>
</li>
<li>
<p><strong>组合</strong>：<u>部分和整体的生命周期一致</u>，整体消失了，部分也消失了，<u>部分不可以脱离整体而存在</u>。</p>
<p>使用一端带<u>实心菱形</u>的实线表示。</p>
</li>
</ul>
<p>关联和聚集的图形化表示如图：</p>
<p><picture><img class="img-fluid " alt="关联和聚集的图形化表示" src="/docs/ruan-she/object-oriented/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<p>聚合和组合中，带菱形的一端指向整体，另一端指向部分。</p>
<p>单向关联：用<u>带箭头实线</u>表示。</p>
<blockquote>
<p>关联的关系强度比依赖的关系强度要强一点。</p>
</blockquote>
<p>多重度：</p>
<p>进行面向对象设计时，类图中可以展现类之间的关联关系，还可以在类图中图示<u>关联中的数量关系</u>，即多重度。表示数量关系时，<u>用多重度说明数量或数量范围</u>，<u>表示有多少个实例（对象）能被连接起来</u>，即<u>一个类的实例能够与另一个类的多少个实例相关联</u>。</p>
<p>关联类：</p>
<p>当两个类之间的关联的重复度是多对多时，需要借助额外的属性来帮助表达它们之间的关系，而这个属性就需要定义在一个新的关联类中。关联类记录了这两个类之间的关联信息。关联中这些额外的属性用一条<u>垂直于关联的实线</u>表示，实线的一段连接接到关联的实线上，另一端指向这些属性。</p>
</li>
<li>
<p><strong>泛化</strong>（Generalization）：是一种特殊/一般关系，<u>特殊元素（子元素）的对象可替代一般元素（父元素）的对象</u>。用这种方法，<u>子元素共享了父元素的结构和行为</u>。</p>
<p>在图形上，把一个泛化关系画成一条<u>带有空心箭头的实线</u>，它指向父元素：</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
<li>
<p><strong>实现</strong>（Realization）：是<u>类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约</u>。</p>
<p>在两种情况下会使用实现关系：</p>
<ul>
<li>在接口和实现它们的类或构件之间：</li>
<li>在用例和实现它们的协作之间。</li>
</ul>
<p>在图形上，把一个实现关系画成一条<u>带有空心箭头的虚线</u>，箭头指向模板类，另一端于实现类连接。</p>
<p><picture><img class="img-fluid " alt="实现的图形化表示" src="/docs/ruan-she/object-oriented/uTools_1682058026631.png" loading="lazy" width="167" height="61" />
</picture>

</p>
</li>
</ul>
<h2 id="uml中的图" data-numberify>UML中的图<a class="anchor ms-1" href="#uml中的图"></a></h2>
<p>UML2.0提供了13种图，分别是（<strong>加粗</strong>是重点，其它的作为了解）：</p>
<ul>
<li><strong>类图</strong></li>
<li><strong>对象图</strong></li>
<li><strong>用例图</strong></li>
<li><strong>状态图</strong></li>
<li><strong>活动图</strong></li>
<li><strong>构件图</strong></li>
<li>组合结构图</li>
<li><strong>部署图</strong></li>
<li>包图</li>
<li><strong>交互图</strong>：
<ul>
<li><strong>序列图</strong></li>
<li><strong>通信图</strong></li>
<li>交互概览图</li>
<li>计时图</li>
</ul>
</li>
</ul>
<h3 id="类图" data-numberify>类图<a class="anchor ms-1" href="#类图"></a></h3>
<p><u>类图</u>（Class Diagram）<u>展现了一组对象、接口、协作和它们之间的关系</u>。在面向对象系统的建模中所建立的<u>最常见的图就是类图</u>。类图给出系统的静态设计视图，包含主动类的类图（少见）给出了系统的静态进程视图。</p>
<p>类图中通常包括下述内容：</p>
<ul>
<li>
<p>类：</p>
<p><picture><img class="img-fluid " alt="类的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684570702111.png" loading="lazy" width="106" height="243" />
</picture>

</p>
<p>类中的方法和属性前面有以下三种修饰符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>public</code> 公有的</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>private</code> 私有的</td>
</tr>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:center"><code>protected</code> 受保护的</td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>package</code> 包的</td>
</tr>
</tbody>
</table>
<p>例如：</p>
  <table style="width: 200px; margin: auto;">
      <tr><th>Student</th></tr>
      <tr>
      <td>
      <p>
          <code>- id&nbsp;&nbsp;&nbsp;:&nbsp;int</code>
          <br>
          <code>+ name&nbsp;:&nbsp;String</code>
          <br>
          <code>+ age&nbsp;&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
      <tr>
      <td>
      <p>
          <code>+ getId()&nbsp;:&nbsp;int</code>
      </p>
      </td>
      </tr>
  </table>
</li>
<li>
<p>接口：</p>
<p><picture><img class="img-fluid " alt="接口的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</p>
</li>
<li>
<p>协作：</p>
<p><picture><img class="img-fluid " alt="协作的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</p>
</li>
<li>
<p>依赖、泛化和关联关系：</p>
<p><picture><img class="img-fluid " alt="依赖的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="关联图形化表示" src="/docs/ruan-she/object-oriented/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="泛化的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="类图示例" src="/docs/ruan-she/object-oriented/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
<p>类图中也可以包含：</p>
<ul>
<li>注解和约束；</li>
<li>包或子系统。</li>
</ul>
<p>类图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="类图中的类的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684650129674.png" loading="lazy" width="142" height="139" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">接口</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="类图接口的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684570786524.png" loading="lazy" width="135" height="74" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">协作</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="协作的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684570820946.png" loading="lazy" width="107" height="67" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">依赖</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="依赖的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057108089.png" loading="lazy" width="200" height="48" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="泛化的图形表示" src="/docs/ruan-she/object-oriented/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">关联</td>
<td style="text-align:left"><picture><img class="img-fluid " alt="关联图形化表示" src="/docs/ruan-she/object-oriented/1682057458153.png" loading="lazy" width="408" height="101" />
</picture>

</td>
</tr>
</tbody>
</table>
<p>类图用于对系统的静态设计视图建模，<u>这种视图主要支持系统的功能需求</u>，通常以下述3种方式之一使用类图：</p>
<ul>
<li>
<p>对系统的词汇建模：</p>
<p>涉及做出这样的决定：</p>
<ul>
<li>哪些抽象是考虑中的系统的一部分；</li>
<li>哪些抽象处于系统边界之外。</li>
</ul>
<p>用类图详细描述这些抽象和它们的职责。</p>
</li>
<li>
<p>对简单的协作建模：协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。</p>
</li>
<li>
<p>对逻辑数据库模式建模：将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。</p>
</li>
</ul>
<h3 id="对象图" data-numberify>对象图<a class="anchor ms-1" href="#对象图"></a></h3>
<p>对象图（Object Diagram）展现了<u>某一时刻一组对象以及它们之间的关系</u>，<u>描述了在类图中所建立的事物的实例的静态快照</u>。</p>
<p>对象图一般包括对象和链，如图：</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/docs/ruan-she/object-oriented/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
<p>对象：对象图中的对象包含了类名、对象名和属性。</p>
<p>其图形化如下：</p>
<table style="width: 150px; text-align: center;">
    <tr>
    <th style="text-align: center;">
        对象名 : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>匿名对象（没有对象名）：</p>
<table style="width: 150px;">
    <tr>
    <th style="text-align: center;">
        : 类名
    </th>
    </tr>
    <tr>
    <td style="text-align: center;">
    <p>
        <code>属性1 = 值1</code>
        <br>
        <code>属性2 = 值2</code>
        <br>
        ......
    </p>
    </td>
    </tr>
</table>
<p>和类图一样，对象图给出系统的静态设计视图或静态进程视图，但它们是从真实的或原型实例的角度建立的。</p>
<h3 id="用例图" data-numberify>用例图<a class="anchor ms-1" href="#用例图"></a></h3>
<p>用例图（Use Case Diagram）展现了一组用例、参与者（Actor）以及它们之间的关系。</p>
<p>用例图通常包括以下内容：</p>
<ul>
<li>
<p>用例：是从<strong>用户角度</strong>描述<strong>系统的行为</strong>，它将<strong>系统的一个功能</strong>描述成一系列的事件，这些事件最终对操作者产生有价值的观测结果。</p>
<p>用例是一个类，它代表<strong>一类功能</strong>而不是使用该功能的某一具体实例。</p>
<p><picture><img class="img-fluid " alt="用例的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</p>
</li>
<li>
<p>参与者：是与系统交互的<strong>外部实体</strong>，可能是<strong>使用者</strong>，也可能是与系统交互的<strong>外部系统</strong>、<strong>基础设备</strong>等。</p>
<p>参与者用一个<u>人形图标</u>表示。</p>
</li>
<li>
<p>关系：</p>
<ul>
<li>
<p>用例之间的关系：</p>
<ul>
<li>
<p>包含关系：用带<code>&lt;&lt;include&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="包含关系" src="/docs/ruan-she/object-oriented/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</p>
</li>
<li>
<p>扩展关系：用带<code>&lt;&lt;extend&gt;&gt;</code>的虚线箭头表示，如：</p>
<p><picture><img class="img-fluid " alt="扩展关系" src="/docs/ruan-she/object-oriented/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</p>
<p>扩展用例是指，一个用例中，符合某些特定情况才会触发的另一个用例。</p>
<p>即一个用例执行的时候，可能会发生一些特殊情况或可选情况，这种情况就是这个用例的扩展用例。</p>
</li>
</ul>
</li>
<li>
<p>参与者和用例之间的关联关系。</p>
</li>
<li>
<p>用例与用例以及参与者与参与者之间的泛化关系。</p>
</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="用例图示例" src="/docs/ruan-she/object-oriented/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
<p>用例图成分总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">图示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用例</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例的图形表示" src="/docs/ruan-she/object-oriented/uTools_1684574449513.png" loading="lazy" width="114" height="73" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">包含关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的包含关系" src="/docs/ruan-she/object-oriented/uTools_1684578078948.png" loading="lazy" width="613" height="182" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">扩展关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例之间的扩展关系" src="/docs/ruan-she/object-oriented/uTools_1684578542547.png" loading="lazy" width="607" height="136" />
</picture>

</td>
</tr>
<tr>
<td style="text-align:center">泛化关系</td>
<td style="text-align:center"><picture><img class="img-fluid " alt="用例与用例以及参与者与参与者之间的泛化关系" src="/docs/ruan-she/object-oriented/uTools_1682057764410.png" loading="lazy" width="162" height="53" />
</picture>

</td>
</tr>
</tbody>
</table>
<h3 id="交互图" data-numberify>交互图<a class="anchor ms-1" href="#交互图"></a></h3>
<p>交互图用于<u>对系统的动态方面进行建模</u>。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的消息。</p>
<p>每种交互图针对不同的目的，能适用于不同的情况。交互图表现为：</p>
<ul>
<li><strong>序列图</strong>：强调<strong>消息时间顺序</strong>的交互图；</li>
<li><strong>通信图</strong>：强调<strong>接收和发送消息的对象的结构组织</strong>的交互图；</li>
<li><strong>交互概览图</strong>：强调<strong>控制流</strong>的交互图；</li>
<li><strong>计时图</strong>。</li>
</ul>
<p>其中顺序图和通信图是同构的，它们之间可以相互转换。</p>
<p>在多数情况下，交互图包括对以下内容的具体的或原型化的实例以及它们之间传递的消息进行建模：</p>
<ul>
<li>类；</li>
<li>接口；</li>
<li>构件；</li>
<li>结点。</li>
</ul>
<p>所有这些都位于一个表达行为的脚本的语境中。</p>
<p>交互图一般包含：</p>
<ul>
<li>
<p>对象；</p>
</li>
<li>
<p>链；</p>
</li>
<li>
<p>消息</p>
<p>&hellip;&hellip;</p>
</li>
</ul>
<h4 id="序列图" data-numberify>序列图<a class="anchor ms-1" href="#序列图"></a></h4>
<p>序列图（Sequence Diagram，<strong>顺序图</strong>）是场景（Scenario）的图形化表示，<u>描述了以时间顺序组织的对象之间的交互活动</u>，<u>强调消息时间顺序</u>。</p>
<p>序列图的组成：</p>
<ol>
<li>
<p>把参加交互的对象放在图的上方，沿水平方向排列。</p>
<p>通常把发起交互的对象放在左边，下级对象依次放在右边。</p>
</li>
<li>
<p>把这些对象发送和接收的消息，沿垂直方向，按时间顺序从上到下放置。</p>
</li>
</ol>
<p><picture><img class="img-fluid " alt="序列图示例" src="/docs/ruan-she/object-oriented/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
<p>序列图的组成部分：</p>
<ul>
<li>
<p>对象：用方框框起来的<code>对象名:类名</code>，没有属性和方法等成分。</p>
</li>
<li>
<p><strong>对象生命线</strong>：表示<u>一个对象存在的时间段</u>。</p>
<p>如上图中对象下方垂直的虚线。</p>
<ul>
<li>对象可以在交互过程中创建：生命线从接收到构造型<code>create</code>消息开始；</li>
<li>也可以在交互过程中撤销：生命线从接收到构造型<code>destroy</code>消息结束，并且给出一个大$\times$的标记表明生命线的结束。</li>
</ul>
</li>
<li>
<p><strong>控制焦点</strong>：控制焦点表示<u>一个对象执行一个动作所经历的时间段</u>。</p>
<p>如上图中对象下方的空表矩形条框。</p>
</li>
<li>
<p><strong>消息</strong>：</p>
<p>普通的消息用<u>带箭头的实线</u>表示。所有消息的箭头都是指向接收对象。</p>
<ul>
<li>返回消息：用<u>带箭头的虚线</u>表示。</li>
<li>同步消息（调用消息）：指消息发送给接收对象后，需要等待接收对象返回后才可进行下一步操作。</li>
<li>异步消息：指消息发送给接收对象后，无需等待接收对象返回即可进行下一步操作。</li>
</ul>
</li>
</ul>
<p>序列图有两个不同于通信图的特性：</p>
<ul>
<li>序列图有对象生命线；</li>
<li>序列图有控制焦点。</li>
</ul>
<h4 id="通信图" data-numberify>通信图<a class="anchor ms-1" href="#通信图"></a></h4>
<p><u>通信图</u>（Communication Diagram，<strong>协作图</strong>）<u>强调收发消息的对象的结构组织</u>。</p>
<p>通信图的组成：</p>
<ol>
<li>将参加交互的<u>对象</u>作为图的<u>顶点</u>；</li>
<li>把连接这些对象的<u>链</u>表示为图的<u>弧</u>；</li>
<li>用对象发送和接收的<u>消息</u>来<u>修饰这些链</u>。</li>
</ol>
<p>这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹。</p>
<p><picture><img class="img-fluid " alt="通信图示例" src="/docs/ruan-she/object-oriented/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
<p>通信图有以下成分：</p>
<ul>
<li>
<p>对象：与序列图一样，是用一个方框框起来的<code>对象名:类名</code>。</p>
</li>
<li>
<p><strong>路径</strong>（链接）：用实线表示，可以在链的末端附上一个路径构造型。</p>
<p>通常仅需显式地表示以下几种链的路径：</p>
<table>
<thead>
<tr>
<th style="text-align:center">构造型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;local&gt;&gt;</code></td>
<td style="text-align:center">局部</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;parameter&gt;&gt;</code></td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;global&gt;&gt;</code></td>
<td style="text-align:center">全局</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;self&gt;&gt;</code></td>
<td style="text-align:center">自身</td>
</tr>
</tbody>
</table>
<p>不必表示<code>association</code>（关联）。</p>
</li>
<li>
<p><strong>序号</strong>：用来表示消息的时间顺序。是消息前的一个数字前缀，可使用带小数点的号码表示嵌套消息，嵌套可为任意深度。</p>
<p>如2表示第2个消息，2.1表示嵌套在消息2中的第1个消息。</p>
</li>
<li>
<p>消息：沿同一个链可以显示许多消息（可能发自不同方向），并且每个消息都有唯一的序号。</p>
</li>
</ul>
<p>通信图有两个不同于序列图的特性：</p>
<ul>
<li>通信图有路径；</li>
<li>通信图有序号。</li>
</ul>
<h4 id="总结" data-numberify>总结<a class="anchor ms-1" href="#总结"></a></h4>
<p>顺序图和通信图是同构的，它们之间可以相互转换。它们的差异如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:left"><center>序列图</center></th>
<th style="text-align:left"><center>通信图</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>强调</strong></td>
<td style="text-align:left"><center>消息时间顺序</center></td>
<td style="text-align:left"><center>收发消息的对象的结构组织</center></td>
</tr>
<tr>
<td style="text-align:center"><strong>不同的特性</strong></td>
<td style="text-align:left"><ul><li>有对象生命线：对象存在的时间段</li><li>有控制焦点：对象执行动作所经历的时间段</li></ul></td>
<td style="text-align:left"><ul><li>有路径：表示对象之间有交互</li><li>有序号：表示消息的时间顺序，可嵌套表示</li></ul></td>
</tr>
</tbody>
</table>
<h3 id="状态图" data-numberify>状态图<a class="anchor ms-1" href="#状态图"></a></h3>
<p>状态图（State Diagram，状态转换图）展现了一个状态机。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，<u>强调对象行为的事件顺序</u>。</p>
<p>状态图由以下组成：</p>
<ul>
<li>
<p><strong>状态</strong>：指对象的生命周期中某个条件或者状态，是<u>任何可以被观察到的系统行为模式</u>，<u>一个状态代表系统的一种行为模式</u>。</p>
<p>状态规定了系统内对事件的响应方式。</p>
<p>系统对事件的响应：</p>
<ul>
<li>可以是<u>做一个（或一系列）动作</u>；</li>
<li>可以是仅仅<u>改变系统本身的状态</u>；</li>
<li>可以是<u>即改变状态，又做动作</u>。</li>
</ul>
<p>状态转换图中定义的状态主要有：</p>
<ul>
<li><strong>初态</strong>（初始状态）：用一个<u>实心圆点</u>表示。一张状态图<u>只能有一个初态</u>。</li>
<li><strong>终态</strong>（最终状态）：用一个<u>实心圆点外加一个圆圈</u>表示。一张状态图<u>可以没有终态，也可以有多个</u>。</li>
<li><strong>中间状态</strong>。</li>
</ul>
<p>状态图中的状态用一个<u>圆角矩形</u>表示，可以用两条水平横线将其分为上中下3个部分：</p>
<ol>
<li>上面部分（必须）：状态的名称；</li>
<li>中间部分（可选）：状态变量的名称和值；</li>
<li>下面部分（可选）：活动表。</li>
</ol>
<p>状态还可分为：</p>
<ul>
<li>
<p>简单状态。</p>
</li>
<li>
<p>组合状态：含有子状态的状态，这个状态也称为其子状态的超状态。</p>
<p>子状态：嵌套在另外一个状态中的状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>转换</strong>（迁移）：是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生，而且某个特定的警界（监护）条件满足时进入目标状态。</p>
<p>状态转换用一条<u>带箭头的实线</u>表示。</p>
</li>
<li>
<p><strong>事件</strong>：是在某个特定时刻发生的事情，<u>它是对引起系统做动作或（和）从一个状态转换到另个状态的外界事件的抽象</u>。</p>
<ul>
<li>
<p><u>事件触发</u>状态转换：<u>状态变迁通常是由事件触发的。</u>状态之间带箭头实线上的事件发生时，状态转换开始（还可称之为状态“点火”或状态被“触发”）。</p>
<p>这种情况下应在表达状态转换的箭头线上标出触发转换的<u>事件表达式</u>：</p>
<pre tabindex="0"><code>事件说明 [守卫条件] / 动作表达式
</code></pre><p>事件说明的语法为：</p>
<pre tabindex="0"><code>事件名 (参数表)
</code></pre><p>守卫条件（监护条件）：一个布尔表达式。</p>
<ul>
<li>当且仅当事件发生且守卫条件为真时，状态转换才发生；</li>
<li>只有守卫条件没有事件说明时，只要守卫条件为真，状态转换就发生。</li>
</ul>
<p>动作表达式是一个过程表达式，当状态转换（事件）开始时执行。</p>
</li>
<li>
<p><u>自动触发</u>状态转换：如果箭头线上未标明事件，则表示<u>在源状态的内部活动执行完之后自动触发转换</u>。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图中的事件和转换" src="/docs/ruan-she/object-oriented/uTools_1684587930655.png" loading="lazy" width="717" height="135" />
</picture>

</p>
</li>
<li>
<p><strong>活动</strong>：指状态中的活动表中的活动。</p>
<p>语法如下：</p>
<pre tabindex="0"><code>事件名 (参数表) /动作表达式
</code></pre><p>事件名：可以是任何事件的名称。</p>
<p>在活动表中经常使用以下3中标准事件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>entry</code></td>
<td style="text-align:left"><u>入口动作</u>，指定<u>进入该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>exit</code></td>
<td style="text-align:left"><u>出口动作</u>，指定<u>退出该状态</u>的动作，立即执行</td>
</tr>
<tr>
<td style="text-align:center"><code>do</code></td>
<td style="text-align:left"><u>内部活动</u>，指定<u>在该状态下</u>的动作，占有有限时间，并可中断地工作</td>
</tr>
</tbody>
</table>
<p>活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。</p>
</li>
</ul>
<p><picture><img class="img-fluid " alt="状态图示例" src="/docs/ruan-she/object-oriented/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
<p>可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括：</p>
<ul>
<li>类（各主动类）；</li>
<li>接口；</li>
<li>构件；</li>
<li>结点。</li>
</ul>
<p>当状态图对系统、类或用例的动态方面建模时，通常是对反应型对象建模。</p>
<h3 id="活动图" data-numberify>活动图<a class="anchor ms-1" href="#活动图"></a></h3>
<p>活动图（Activity Diagram）是一种特殊的状态图，它<u>展现了在系统内从一个活动到另一个活动的流程</u>。活动图<u>专注于系统的动态视图</u>，它对于系统的功能建模特别重要，并<u>强调对象间的控制流程</u>。</p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/docs/ruan-she/object-oriented/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
<p>活动图一般包括：</p>
<ul>
<li>
<p>状态：</p>
<p>活动图的状态也包含初态和终态。其余的状态还可分为：</p>
<ul>
<li>动作状态：不能被分解，动作不能被中断。</li>
<li>活动状态：能够被进一步分解，可以被中断，其活动由其它的活动图来表示。</li>
</ul>
</li>
<li>
<p>流（转换）。</p>
</li>
<li>
<p>对象。</p>
</li>
</ul>
<p>活动图可以表示：</p>
<ul>
<li>分支（判断）：分支的流上用<code>[]</code>标记的是监护表达式；</li>
<li>（并发）分岔：将一个流分为多个可并发执行的流；</li>
<li>（并发）汇合：将分岔出去的多个流合并为同一个流。</li>
</ul>
<p>当对一个系统的动态方面建模时，有以下几种使用活动图的方式：</p>
<ul>
<li>对工作流建模；</li>
<li>对操作建模；</li>
<li>对业务的复杂流程建模。</li>
</ul>
<h3 id="构件图" data-numberify>构件图<a class="anchor ms-1" href="#构件图"></a></h3>
<p>构件图（Component Diagram，<strong>组件图</strong>）展现了<u>一组构件之间的组织和依赖</u>。构件图<u>专注于系统的静态实现视图</u>，它<u>与类图相关，通常把构件映射为一个或多个类、接口或协作</u>。</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/docs/ruan-she/object-oriented/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
<p>构件图的成分有：</p>
<ul>
<li>构件：用<u>矩形</u>表示，在矩形<u>右上方有一个小标记</u>。</li>
<li>供接口：用一个<u><strong>圆圈</strong>和连接到构件上的实线</u>表示。构件提供接口给其它构件使用。</li>
<li>需接口：用一个<u><strong>半圆</strong>和连接到构件上的实线</u>表示。构件使用需接口表示需要调用其它构件提供接口。</li>
<li>依赖：将供接口（圆圈）和虚接口（半圆）连接到一起，表示两个构件通过这个接口相依赖。</li>
</ul>
<h3 id="部署图" data-numberify>部署图<a class="anchor ms-1" href="#部署图"></a></h3>
<p>部署图（Deployment Diagram）是用来<u>对面向对象系统的<strong>物理方面</strong>建模</u>的方法，展现了运行时处理结点以及其中构件（制品）的配置。部署图<u>对系统的静态部署视图进行建模</u>，它与构件图相关。</p>
<p>部署图<u>展现了系统的软件和硬件之间的关系，在实施阶段使用</u>。</p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/docs/ruan-she/object-oriented/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
<blockquote>
<p><code>&lt;&lt;artifact&gt;&gt;</code>表示制品。</p>
</blockquote>
<h3 id="总结-1" data-numberify>总结<a class="anchor ms-1" href="#总结-1"></a></h3>
<table>
<thead>
<tr>
<th style="text-align:center">UML图</th>
<th style="text-align:center">静态建模</th>
<th style="text-align:center">动态建模</th>
<th style="text-align:center">物理建模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">构件图（组件图)</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">序列图（顺序图，时序图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">通信图（协作图）</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">状态图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
</tr>
</tbody>
</table>
<p>活动图是一种特殊的状态图，它们的差异如下：</p>
<ul>
<li>相同点：状态中都有初态和终态。</li>
<li>主要差异：
<ul>
<li>活动图的转换称为流；</li>
<li>活动图有分支、并发分岔和并发汇合。</li>
</ul>
</li>
</ul>
<p>以下是UML图的总结：</p>
<ul>
<li>
<p><strong>类图</strong>：展现一组<u>对象（类）</u>、<u>接口</u>、<u>协作</u>和它们之间的<u>关系</u></p>
<p><picture><img class="img-fluid " alt="类图示例" src="/docs/ruan-she/object-oriented/uTools_1682061210921.png" loading="lazy" width="619" height="467" />
</picture>

</p>
</li>
<li>
<p><strong>对象图</strong>：展现某一时刻的一组<u>对象</u>以及它们之间的<u>关系</u>，描述了在类图中所建立事物的实例的静态快照</p>
<p><picture><img class="img-fluid " alt="对象图示例" src="/docs/ruan-she/object-oriented/uTools_1682061786263.png" loading="lazy" width="713" height="312" />
</picture>

</p>
</li>
<li>
<p><strong>用例图</strong>：展现了一组<u>用例</u>、<u>参与者</u>以及它们之间的<u>关系（包含、扩展、关联和泛化）</u></p>
<p><picture><img class="img-fluid " alt="用例图示例" src="/docs/ruan-she/object-oriented/uTools_1682062071630.png" loading="lazy" width="756" height="382" />
</picture>

</p>
</li>
<li>
<p><strong>序列图（顺序图，时序图）</strong>：描述了以<u>时间顺序</u>组织的<u>对象</u>之间的<u>交互活动</u>，强调<u>消息时间顺序</u></p>
<p><picture><img class="img-fluid " alt="序列图示例" src="/docs/ruan-she/object-oriented/uTools_1682064874751.png" loading="lazy" width="691" height="471" />
</picture>

</p>
</li>
<li>
<p><strong>通信图（协作图）</strong>：强调<u>收发消息的对象的结构组织</u></p>
<p><picture><img class="img-fluid " alt="通信图" src="/docs/ruan-she/object-oriented/uTools_1682065157645.png" loading="lazy" width="719" height="314" />
</picture>

</p>
</li>
<li>
<p><strong>状态图（状态转换图）</strong>：展现了一个状态机，强调<u>对象行为的事件顺序</u></p>
<p><picture><img class="img-fluid " alt="状态图示例" src="/docs/ruan-she/object-oriented/uTools_1682066287326.png" loading="lazy" width="831" height="431" />
</picture>

</p>
</li>
<li>
<p><strong>活动图</strong>：一种特殊的状态图，展现了在<u>系统内从一个活动到另一个活动的流程</u>，强调<u>对象间的控制流程</u></p>
<p><picture><img class="img-fluid " alt="活动图示例" src="/docs/ruan-she/object-oriented/1682067363114.png" loading="lazy" width="654" height="744" />
</picture>

</p>
</li>
<li>
<p><strong>构件图（组件图)</strong>：展现了一组<u>构件之间的组织和依赖</u>，将构件映射为类、接口或协作</p>
<p><picture><img class="img-fluid " alt="构件图示例" src="/docs/ruan-she/object-oriented/uTools_1682068370459.png" loading="lazy" width="638" height="332" />
</picture>

</p>
</li>
<li>
<p><strong>部署图</strong>：对物理建模，展现了<u>运行时处理结点以及其中构件（制品）的配置</u></p>
<p><picture><img class="img-fluid " alt="部署图示例" src="/docs/ruan-she/object-oriented/uTools_1682073176388.png" loading="lazy" width="491" height="327" />
</picture>

</p>
</li>
</ul>
<hr>
<h1 id="设计模式" data-numberify>设计模式<a class="anchor ms-1" href="#设计模式"></a></h1>
<blockquote>
<p>设计模式代码仓库：<a href="https://gitee.com/linner_cheng/design-patterns" target="_blank" rel="noopener noreferrer">https://gitee.com/linner_cheng/design-patterns<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
</blockquote>
<p>每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。使用设计模式能减少一些重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地<u>复用成功的设计和体系结构</u>。</p>
<p>设计模式一般有以下4个要素：</p>
<ul>
<li>模式名称（Pattern Name）</li>
<li>问题（Problem）</li>
<li>解决方案（Solution）</li>
<li>效果（Consequences）</li>
</ul>
<p>设计模式：</p>
<ul>
<li>确定了所包含的<u>类</u>和<u>实例</u>的：
<ul>
<li><u>角色</u></li>
<li><u>协作方式</u></li>
<li><u>职责分配</u></li>
</ul>
</li>
<li>每一个设计模式都：
<ul>
<li>集中于一个特定的<u>面向对象设计问题</u>或设计要点</li>
<li>描述了什么时候使用它</li>
<li>在另一些设计约束条件下是否还能使用</li>
<li>使用的效果和如何取舍</li>
</ul>
</li>
</ul>
<p>设计模式分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:left">创建型</th>
<th style="text-align:left">结构型</th>
<th style="text-align:left">行为型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:left">与对象的创建有关</td>
<td style="text-align:left">处理类或对象的组合</td>
<td style="text-align:left">描述类或对象的交互和职责分配</td>
</tr>
<tr>
<td style="text-align:center">类模式</td>
<td style="text-align:left">Factory Method（工厂方法模式）</td>
<td style="text-align:left">Adapter（适配器模式）</td>
<td style="text-align:left">Interpreter（解释器模式）<br>Template Method（模板方法模式）</td>
</tr>
<tr>
<td style="text-align:center">对象模式</td>
<td style="text-align:left">Abstract Factory（抽象工厂模式）<br>Builder（生成器模式）<br>Prototype（原型模式）<br>Singleton（单例模式）</td>
<td style="text-align:left">Adapter（适配器模式）<br>Bridge（桥接模式）<br>Composite（组合模式）<br>Decorator（装饰器模式）<br>Facade（外观模式）<br>Flyweight（享元模式）<br>Proxy（代理模式）</td>
<td style="text-align:left">Chain of Responsibility（责任链模式）<br>Command（命令模式）<br>Iterator（迭代器模式）<br>Mediator（中介者模式）<br>Memento（备忘录模式）<br>Observer（观察者模式）<br>State（状态模式）<br>Strategy（策略模式）<br>Visitor（访问者模式）</td>
</tr>
</tbody>
</table>
<h2 id="创建型设计模式" data-numberify>创建型设计模式<a class="anchor ms-1" href="#创建型设计模式"></a></h2>
<p>创建型模式<u>抽象了实例化过程</u>。</p>
<ul>
<li>类创建型模式（工厂方法）：使用继承改变被实例化的类；</li>
<li>对象创建型模式（剩余的其它）：将实例化委托给另一个对象。</li>
</ul>
<h3 id="简单工厂模式" data-numberify>简单工厂模式<a class="anchor ms-1" href="#简单工厂模式"></a></h3>
<p>简单工厂模式属于创建型模式，但不属于23种设计模式之一。</p>
<p>简单工厂模式定义了一个工厂类，它可以根据参数的不同，返回不同类的实例，被创建的实例通常都具有共同的父类。</p>
<p>在简单工厂模式中用于创建实例的方法通常长为静态（<code>static</code>）方法，因此简单工厂模式又称为静态工厂方法（Static Factroy Method）。</p>
<p>简单工厂模式包含以下三种角色：</p>
<ul>
<li>工厂（核心）：负责实现创建所有产品的内部逻辑。工厂类可以被外界直接调用，创建所需对象。</li>
<li>抽象产品：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象。</li>
<li>具体产品：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例，它要实现抽象产品中声明的抽象方法。</li>
</ul>
<p><picture><img class="img-fluid " alt="简单工厂模式示例" src="/docs/ruan-she/object-oriented/uTools_1684673603980.png" loading="lazy" width="388" height="389" />
</picture>

</p>
<p>代码示例如下：</p>
<p><code>Product</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 抽象产品
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 抽象方法，返回产品信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ProductA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 具体产品A
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductA</span> <span class="kd">extends</span> <span class="n">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;产品的信息：A&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ProductB</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 具体产品B
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductB</span> <span class="kd">extends</span> <span class="n">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;产品的信息：B&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Factory</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 静态工厂类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 根据参数获取Product
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param type 指定创建的对象的类型
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Product</span> <span class="nf">createProduct</span><span class="o">(</span><span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 判读参数，声明对应的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;B&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProductB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;没有&#34;</span> <span class="o">+</span> <span class="n">type</span> <span class="o">+</span> <span class="s">&#34;类型的产品&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">product</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productA</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="na">createProduct</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productB</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="na">createProduct</span><span class="o">(</span><span class="s">&#34;B&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">productB</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productC</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="na">createProduct</span><span class="o">(</span><span class="s">&#34;C&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">productC</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="工厂方法" data-numberify>工厂方法<a class="anchor ms-1" href="#工厂方法"></a></h3>
<p>工厂方法（Factory Method）模式定义一个用于<u>创建对象的接口</u>，让<u>子类决定实例化哪一个类</u>。工厂模式<u>使一个类的实例化延迟到其子类</u>。</p>
<blockquote>
<p>简单工厂违反了开放封闭原则，对扩展是开发的，对修改是封闭的。所以工厂方法的接口不创建具体的对象，而是交由子类来实现。</p>
</blockquote>
<p>工厂方法结构：</p>
<p><picture><img class="img-fluid " alt="工厂方法结构" src="/docs/ruan-she/object-oriented/uTools_1682232330534.png" loading="lazy" width="725" height="268" />
</picture>

</p>
<ul>
<li>
<p><code>Product</code>：定义工厂方法所创建的对象的接口。</p>
</li>
<li>
<p><code>ConcreteProduct</code>：实现<code>Product</code>接口。</p>
</li>
<li>
<p><code>Creator</code>：声明工厂方法，该方法返回一个<code>Product</code>类型的对象。</p>
<p><code>Creator</code>也可以定义一个工厂方法的默认实现，它返回一个默认的<code>ConcreteProduct</code>对象。</p>
</li>
<li>
<p><code>ConcreteCreator</code>：重定义工厂方法以返回一个<code>ConcreteProduct</code>实例。</p>
</li>
</ul>
<p>代码示例：</p>
<p><picture><img class="img-fluid " alt="工厂方法示例" src="/docs/ruan-she/object-oriented/uTools_1684730369571.png" loading="lazy" width="485" height="463" />
</picture>

</p>
<p><code>Product</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 产品接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     这里抽象产品是接口还是抽象类不重要，重要的是Factory一定得是接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接口方法，返回产品信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ProductA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductA</span> <span class="kd">implements</span> <span class="n">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;产品的信息：A&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ProductB</code>与<code>ProductA</code>类似，代码略。</p>
<p><code>Factory</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 工厂方法接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">    * 接口方法，获取Product
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Product</span> <span class="nf">createProduct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>FactoryA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 工厂A
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     只负责生产ProductA
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryA</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 实现方法创建ProductA
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Product</span> <span class="nf">createProduct</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 直接返回ProductA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">ProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>FactoryB</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 工厂B
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     只负责生产ProductB
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryB</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 实现方法创建ProductB
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Product</span> <span class="nf">createProduct</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 直接返回ProductB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">ProductB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryMethod</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Factory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FactoryA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productA</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProduct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FactoryB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productB</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProduct</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productB</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Factory Method模式适用于：</p>
<ul>
<li>当一个类<u>不知道它所必须创建的对象的类</u>（不知道要创建的具体类）的时候。</li>
<li>当一个类希望<u>由它的子类来指定它所创建的对象</u>的时候。</li>
<li>当类<u>将创建对象的职责委托给多个帮助子类中的某一个</u>，并且你希望将哪一个<u>帮助子类是代理者</u>这一信息局部化的时候。</li>
</ul>
<p>工厂方法：</p>
<ul>
<li>特点：用户类和工厂类分开。</li>
<li>优点：用户需要什么对象，只需向工厂请求即可。用户无需修改就可使用对象。</li>
<li>缺点：对象修改时，工厂类也需要做相应的修改。</li>
</ul>
<h3 id="抽象工厂模式" data-numberify>抽象工厂模式<a class="anchor ms-1" href="#抽象工厂模式"></a></h3>
<p>抽象工厂（Abstract Factory）提供一个<u>创建一系列相关或相互依赖对象的接口</u>，而<u>无须指定它们具体的类</u>。</p>
<blockquote>
<p>抽象工厂的工厂类是<code>abstract class</code>（抽象类），工厂方法是<code>interface</code>。抽象工厂可以创建更多的类。</p>
</blockquote>
<p>抽象工厂模式的结构：</p>
<p><picture><img class="img-fluid " alt="抽象工厂模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682230457950.png" loading="lazy" width="704" height="330" />
</picture>

</p>
<ul>
<li><code>AbstractFactory</code>：声明一个创建抽象产品对象的操作接口。</li>
<li><code>ConcreteFactory</code>：实现创建具体产品对象的操作。</li>
<li><code>AbstractProduct</code>：为一类产品对象声明一个接口。</li>
<li><code>ConcreteProduct</code>：定义一个将被相应的具体工厂创建的产品对象，实现<code>AbstractProduct</code>接口。</li>
<li><code>Client</code>：仅使用由<code>AbstractFactory</code>和<code>AbstractProduct</code>类声明的接口。</li>
</ul>
<p>代码示例：</p>
<p>创建两个产品接口<code>ProductA</code>和<code>ProductB</code>，并分别创建这两个产品接口的实现类<code>ProductA1</code>和<code>ProductA2</code>以及<code>ProductB1</code>和<code>ProductB2</code>。代码略。需要注意的是这里<code>ProductA</code>和<code>ProductB</code>代表两种不同的产品，它们的类型可以完全不相同。</p>
<p><code>Factory</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接口方法获取ProductA
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ProductA</span> <span class="nf">createProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接口方法获取ProductB
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ProductB</span> <span class="nf">createProductB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Factory1</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 工厂1创建产品ProductA1和ProductB1
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory1</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 创建产品ProductA1
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ProductA</span> <span class="nf">createProductA</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">ProductA1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 创建产品ProductB1
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ProductB</span> <span class="nf">createProductB</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">ProductB1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Factory2</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 工厂2创建产品ProductA2和ProductB2
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory2</span> <span class="kd">implements</span> <span class="n">Factory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 代码与Factory1类似，略 */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Factory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Factory1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProductA</span> <span class="n">productA1</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProductB</span> <span class="n">productB1</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProductB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA1</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productB1</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Factory2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProductA</span> <span class="n">productA2</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ProductB</span> <span class="n">productB2</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createProductB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA2</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productB2</span><span class="o">.</span><span class="na">info</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Abstract Factory模式适用于：</p>
<ul>
<li>一个系统要<u>独立于它的产品的创建、<strong>组合</strong>和表示</u>时。</li>
<li>一个系统要由<u>多个产品系列中的一个来配置</u>时。</li>
<li>当要强调<u>一系列相关的产品</u>对象的设计以便进行<u>联合使用</u>时。</li>
<li>当提供一个<u>产品类库</u>，只想<u>显示它们的接口而不是实现</u>时。</li>
</ul>
<p>抽象工厂模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类（具体工厂）去做。它仅负责给存储具体工厂类必须实现的接口。</p>
<h3 id="生成器模式" data-numberify>生成器模式<a class="anchor ms-1" href="#生成器模式"></a></h3>
<p>生成器（Builder，<strong>建造者</strong>）模式将一个<u>复杂对象的<strong>构建</strong>与它的<strong>表示</strong>分离</u>，使得<u>同样的构建过程可以创建不同的表示</u>。</p>
<p>生成器模式结构：</p>
<p><picture><img class="img-fluid " alt="生成器模式结构" src="/docs/ruan-she/object-oriented/uTools_1682231345251.png" loading="lazy" width="729" height="261" />
</picture>

</p>
<ul>
<li>
<p><code>Product</code>：表示被构造的复杂对象。</p>
</li>
<li>
<p><code>Builder</code>：为创建一个<code>Product</code>对象的各个部件指定抽象接口。</p>
<p><code>BuildPart()</code>：生成零件。</p>
</li>
<li>
<p><code>ConcreteBuilder</code>：实现<code>Builder</code>的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口。</p>
<p><code>ConcreteBuilder</code>创建<code>Product</code>对象产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。</p>
<p><code>GetResult()</code>：获取生成（组装完成）的产品。</p>
</li>
<li>
<p><code>Director</code>：构造一个使用<code>Builder</code>接口的对象。最终是使用<code>Director</code>来构造<code>Product</code>。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>Product</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">parts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// 零件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 添加零件
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param part 要添加的零件
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">String</span> <span class="n">part</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">parts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">part</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;Product{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;parts=&#34;</span> <span class="o">+</span> <span class="n">parts</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Builder</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 生成产品零件
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildPart</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 获取结果
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Product</span> <span class="nf">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Builder1</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Builder1</span> <span class="kd">extends</span> <span class="n">Builder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildPart</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;B&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;C&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;D&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;E&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;F&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Product</span> <span class="nf">getResult</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">product</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Builder2</code>与<code>Builder1</code>类似，略。</p>
<p><code>Director</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Director</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 根据指定的Builder来生产零件
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param builder 指定用来生产零件的Builder
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">construct</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">builder</span><span class="o">.</span><span class="na">buildPart</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BuilderTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Director</span> <span class="n">director</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Director</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Builder</span> <span class="n">builder1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Builder1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">(</span><span class="n">builder1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">product1</span> <span class="o">=</span> <span class="n">builder1</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">product1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Builder2</span> <span class="n">builder2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Builder2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">director</span><span class="o">.</span><span class="na">construct</span><span class="o">(</span><span class="n">builder2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">product2</span> <span class="o">=</span> <span class="n">builder2</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">product2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Builder模式适用于：</p>
<ul>
<li>当<u>创建复杂对象的算法</u>应该<u>独立于该对象的组成部分以及它们的装配方式</u>时。</li>
<li>当<u>构造过程必须允许被构造的对象有不同的表示</u>时。</li>
</ul>
<h3 id="原型模式" data-numberify>原型模式<a class="anchor ms-1" href="#原型模式"></a></h3>
<p>原型（Prototype）模式用<u>原型实例指定创建对象的种类</u>，并且<u>通过复制这些原型创建新的对象</u>。</p>
<p>原型模式结构：</p>
<p><picture><img class="img-fluid " alt="原型模式结构" src="/docs/ruan-she/object-oriented/uTools_1682233376386.png" loading="lazy" width="638" height="298" />
</picture>

</p>
<ul>
<li><code>Prototype</code>：声明一个复制自身的接口。</li>
<li><code>ConcretePrototype</code>：实现一个复制自身的操作。</li>
<li><code>Client</code>：让一个原型复制自身从而创建一个新的对象。</li>
</ul>
<p>代码示例：</p>
<p><code>Prototype</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Prototype</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 克隆方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Product</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="kd">implements</span> <span class="n">Prototype</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Double</span> <span class="n">price</span><span class="o">;</span>   <span class="c1">// 价格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Product</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="n">Integer</span> <span class="n">id</span><span class="o">,</span> <span class="n">Double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="o">();</span>    <span class="c1">// 这里也可以直接使用带参的构造方法，而不必使用setter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">object</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">object</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">price</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">object</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略 getter, setter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;Product{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;id=&#34;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;, price=&#34;</span> <span class="o">+</span> <span class="n">price</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrototypeTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">product1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="mi">2023</span><span class="o">,</span> <span class="mf">5.22</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;product1: &#34;</span> <span class="o">+</span> <span class="n">product1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">product2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Product</span><span class="o">)</span> <span class="n">product1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;product2: &#34;</span> <span class="o">+</span> <span class="n">product2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Prototype模式适用于：</p>
<ul>
<li>当一个系统应该<u>独立于它的产品创建、<strong>构成</strong>和表示</u>时。</li>
<li>当要实例化的类是在<u>运行时刻指定</u>时，例如，通过动态装载。</li>
<li>为了<u>避免创建</u>一个<u>与产品类层次平行的工厂类层次</u>时。</li>
<li>当一个类的<u>实例只能有几个不同状态组合中的一种</u>时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<p>原型模式：</p>
<ul>
<li>特点：通过给出一个原型对象来指明所要创建的对象的类型，然后复制这个原型对象的方法创建出更多同类型的对象。</li>
<li>优点：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。</li>
<li>缺点：每一个类都必须配备一个克隆方法。</li>
</ul>
<h3 id="单例模式" data-numberify>单例模式<a class="anchor ms-1" href="#单例模式"></a></h3>
<p>单例（Singleton，单态）模式保证<u>一个类仅有一个实例</u>，并<u>提供一个访问它的全局访问点</u>。</p>
<blockquote>
<p>就好像Spring中的Bean，每个Bean默认有且仅有一个实例，通过<code>@Autowired</code>自动装配（来访问）。</p>
</blockquote>
<p>单例模式结构：</p>
<p><picture><img class="img-fluid " alt="单例模式结构" src="/docs/ruan-she/object-oriented/uTools_1682233866165.png" loading="lazy" width="464" height="169" />
</picture>

</p>
<ul>
<li><code>Singleton</code>：指定一个<code>Instance</code>操作，允许客户访问它的唯一实例。</li>
<li><code>Instance</code>：是一个类操作；可能负责创建它自己的唯一实例。</li>
</ul>
<p>代码示例：</p>
<p><code>Singleton</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在内部示例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 定义私有的构造方法，让其它外部类无法通过构造方法示例化对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 全局访问方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * &lt;p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">     *     因为该类为单例，所以使用静态方法获取即可
</span></span></span><span class="line"><span class="cl"><span class="cm">     * &lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 验证Singleton是否为单例，打印它的地址即可
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Singleton</span> <span class="n">singleton1</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Singleton</span> <span class="n">singleton2</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Singleton模式适用于：</p>
<ul>
<li>当类<u>只能有一个实例</u>而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个<u>唯一实例</u>应该是通过子类化可扩展的，并且<u>客户无须更改代码就能使用一个扩展的实例</u>时。</li>
</ul>
<p>单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<h2 id="结构型设计模式" data-numberify>结构型设计模式<a class="anchor ms-1" href="#结构型设计模式"></a></h2>
<p>结构型设计模式涉及<u>如何组合类或对象以获得更大的结构</u>。</p>
<ul>
<li>
<p>结构型类模式：<u>采用继承机制来组合接口或实现</u>。</p>
<p>一个简单的例子是<u>采用多重继承方法将两个以上的类组合成一个类</u>，结果这个类包含了所有父类的性质。</p>
<p>这一模式尤其有助于多个独立开发的类库协同工作。</p>
</li>
<li>
<p>结构型对象模式：描述了<u>如何对一些对象进行组合，从而实现新功能的一些方法</u>（不是对接口和实现进行组合）。</p>
<p>因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。</p>
</li>
</ul>
<h3 id="适配器模式" data-numberify>适配器模式<a class="anchor ms-1" href="#适配器模式"></a></h3>
<p>适配器（Adapter，<strong>变压器</strong>）模式<u>将一个类的接口转换成客户希望的另外一个接口</u>。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<ul>
<li>
<p>类适配器使用多重继承对一个接口与另一个接口进行匹配：</p>
<p><picture><img class="img-fluid " alt="类适配器模式结构" src="/docs/ruan-she/object-oriented/uTools_1684742134174.png" loading="lazy" width="834" height="283" />
</picture>

</p>
</li>
<li>
<p>对象适配器依赖于对象组合：</p>
<p><picture><img class="img-fluid " alt="对象适配器模式结构" src="/docs/ruan-she/object-oriented/uTools_1682299306295.png" loading="lazy" width="885" height="340" />
</picture>

</p>
</li>
</ul>
<p>其中：</p>
<ul>
<li><code>Target</code>：定义<code>Client</code>使用的与特定领域相关的接口。</li>
<li><code>Client</code>：与符合<code>Target</code>接口的对象协同。</li>
<li><code>Adaptee</code>：定义一个已经存在的接口，这个接口需要适配。</li>
<li><code>Adapter</code>（适配器）：对<code>Adaptee</code>的接口与<code>Target</code>接口进行适配。</li>
</ul>
<p>对象适配器对象模式代码示例：</p>
<p><code>Target</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 目标接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Target</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Target request...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Adaptee</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 需适配接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Adaptee</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">specificRequest</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Adaptee specificRequest...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Adapter</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Adapter</span> <span class="kd">extends</span> <span class="n">Target</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对象适配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Adaptee</span> <span class="n">adaptee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Adaptee</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 重写并在其中调用Adaptee的对应方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">adaptee</span><span class="o">.</span><span class="na">specificRequest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Target</span> <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Adapter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">target</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Adapter模式适用于：</p>
<ul>
<li>想使用一个已经存在的类，而它的<u>接口不符合要求</u>。</li>
<li>想创建一个可以复用的类，该类可以<u>与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作</u>。</li>
<li>（仅适用于对象Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。<u>对象适配器可以适配它的父类接口。</u></li>
</ul>
<p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h3 id="桥接模式" data-numberify>桥接模式<a class="anchor ms-1" href="#桥接模式"></a></h3>
<p>桥接（Bridge）模式<u>将抽象部分与其实现部分分离，使它们都可以独立地变化</u>。</p>
<p>桥接模式结构：</p>
<p><picture><img class="img-fluid " alt="桥接模式结构" src="/docs/ruan-she/object-oriented/uTools_1682299992836.png" loading="lazy" width="932" height="387" />
</picture>

</p>
<ul>
<li>
<p><code>Abstraction</code>：定义<u>抽象类的接口</u>，维护一个指向<code>Implementor</code>类型对象的指针。</p>
</li>
<li>
<p><code>RefinedAbstraction</code>：扩充由<code>Abstraction</code>定义的接口。</p>
</li>
<li>
<p><code>Implementor</code>：定义<u>实现类的接口</u>，该接口不一定要与<code>Abstraction</code>的接口完全一致；事实上这两个接口可以完全不同。</p>
<p>一般来说，<code>Implementor</code>接口仅提供基本操作，而<code>Abstraction</code>定义了基于这些基本操作的较高层次的操作。</p>
</li>
<li>
<p><code>ConcreteImplementor</code>：实现<code>Implementor</code>接口并定义它的具体实现。</p>
</li>
</ul>
<p>代码实现：</p>
<p><code>Color</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 产品颜色接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Color</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationImp</span><span class="o">(</span><span class="n">Product</span> <span class="n">product</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Product</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 产品接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 默认名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="na">class</span> <span class="o">+</span> <span class="s">&#34;@&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">Color</span> <span class="n">color</span><span class="o">;</span>  <span class="c1">// 指向Implementor的指针，其实用private也可以，只需要为其定义getter、setter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Color</span> <span class="nf">getColor</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setColor</span><span class="o">(</span><span class="n">Color</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;Product{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;, color=&#34;</span> <span class="o">+</span> <span class="n">color</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Red</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Red</span> <span class="kd">implements</span> <span class="n">Color</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationImp</span><span class="o">(</span><span class="n">Product</span> <span class="n">product</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Bule</code>与<code>Red</code>类似，略。</p>
<p><code>ProductA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductA</span> <span class="kd">extends</span> <span class="n">Product</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">color</span><span class="o">.</span><span class="na">operationImp</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bridge</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productA1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Color</span> <span class="n">red</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Red</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA1</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">red</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA1</span><span class="o">.</span><span class="na">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Product</span> <span class="n">productA2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProductA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Color</span> <span class="n">blue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Blue</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA2</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">blue</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">productA2</span><span class="o">.</span><span class="na">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Bridge模式适用于：</p>
<ul>
<li>
<p><u>不希望在抽象和它的实现部分之间有一个固定的绑定关系。</u></p>
<p>例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</p>
</li>
<li>
<p>类的<u>抽象</u>以及它的<u>实现都</u>应该<u>可以通过生成子类的方法加以扩充</u>。</p>
<p>这是Bridge模式使得开发者<u>可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充</u>。</p>
</li>
<li>
<p>对一个<u>抽象的实现部分的修改</u>应对客户不产生影响，即<u>客户代码不必重新编译</u>。</p>
</li>
<li>
<p>（C++）想对客户完全<u>隐藏抽象的实现部分</u>。</p>
</li>
<li>
<p>有许多类要生成的类层次结构。</p>
</li>
<li>
<p>想在<u>多个对象间共享实现</u>（可能使用引用计数），但同时要求<u>客户并不知道这一点</u>。</p>
</li>
</ul>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联。也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h3 id="组合模式" data-numberify>组合模式<a class="anchor ms-1" href="#组合模式"></a></h3>
<p>组合（Composite，<strong>合成</strong>）模式<u>将对象组合成树型结构以表示“部分——整体”的层次结构</u>。Composite使得用户<u>对单个对象和组合对象的使用具有一致性</u>。</p>
<p>组合模式的结构：</p>
<p><picture><img class="img-fluid " alt="组合模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682300973563.png" loading="lazy" width="940" height="440" />
</picture>

</p>
<ul>
<li>
<p><code>Component</code>：为组合中的对象<u>声明接口</u>。</p>
<ul>
<li>在适当情况下<u>实现所有类共有接口的默认行为</u>；</li>
<li>声明一个接口用于访问和管理<code>Component</code>的子组件；</li>
<li>（可选）<u>在递归结构中定义一个接口，用于访问一个父组件</u>，并在合适的情况下<u>实现</u>它。</li>
</ul>
</li>
<li>
<p><code>Leaf</code>：在组合中表示<u>叶结点对象</u>，叶结点没有子结点；在组合中<u>定义图元对象的行为</u>。</p>
</li>
<li>
<p><code>Composite</code>：</p>
<ul>
<li>定义有子组件的那些组件的行为；</li>
<li>存储子组件；</li>
<li>在<code>Component</code>接口中实现与子组件有关的操作。</li>
</ul>
</li>
<li>
<p><code>Client</code>：通过<code>Component</code>接口操纵组合组件的对象。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>AbstractFile</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractFile</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 模范Linux tree命令的输出
</span></span></span><span class="line"><span class="cl"><span class="cm">     * &lt;p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">     *     只是为了展示，并不重要
</span></span></span><span class="line"><span class="cl"><span class="cm">     * &lt;/p&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">toTreeString</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">treeString</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="n">childrenList</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">getChildrenList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">childrenList</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">treeString</span> <span class="o">+=</span> <span class="sc">&#39;\n&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">AbstractFile</span> <span class="n">children</span> <span class="o">=</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">String</span> <span class="n">childTreeString</span> <span class="o">=</span> <span class="n">toTreeString</span><span class="o">(</span><span class="n">children</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">childTreeString</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&#34;\n&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">childTreeString</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">split</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39;├&#39;</span>
</span></span><span class="line"><span class="cl">                     <span class="o">||</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39;└&#39;</span>
</span></span><span class="line"><span class="cl">                     <span class="o">||</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39;│&#39;</span>
</span></span><span class="line"><span class="cl">                     <span class="o">||</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="s">&#34;    &#34;</span> <span class="o">+</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="s">&#34;│   &#34;</span> <span class="o">+</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="s">&#34;└── &#34;</span> <span class="o">+</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="s">&#34;├── &#34;</span> <span class="o">+</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="sc">&#39;\n&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">childTreeString</span> <span class="o">+=</span> <span class="n">split</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">treeString</span> <span class="o">+=</span> <span class="n">childTreeString</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">treeString</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="nf">getChildrenList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>File</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">File</span> <span class="kd">extends</span> <span class="n">AbstractFile</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">File</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="nf">getChildrenList</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Folder</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Folder</span> <span class="kd">extends</span> <span class="n">AbstractFile</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="n">childrenList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Folder</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">AbstractFile</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="nf">getChildrenList</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">childrenList</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">toTreeString</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Composite</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 模仿Linux的文件结构
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">AbstractFile</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Folder</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">String</span><span class="o">[]</span> <span class="n">childrenNameList</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;sbin&#34;</span><span class="o">,</span> <span class="s">&#34;boot&#34;</span><span class="o">,</span> <span class="s">&#34;sys&#34;</span><span class="o">,</span> <span class="s">&#34;etc&#34;</span><span class="o">,</span> <span class="s">&#34;usr&#34;</span><span class="o">,</span> <span class="s">&#34;home&#34;</span><span class="o">,</span> <span class="s">&#34;root&#34;</span><span class="o">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">childrenName</span> <span class="o">:</span> <span class="n">childrenNameList</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">AbstractFile</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Folder</span><span class="o">(</span><span class="n">childrenName</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">children</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">List</span><span class="o">&lt;</span><span class="n">AbstractFile</span><span class="o">&gt;</span> <span class="n">childrenList</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">getChildrenList</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">AbstractFile</span> <span class="n">myFolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Folder</span><span class="o">(</span><span class="s">&#34;linner&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">AbstractFile</span> <span class="n">homeFolder</span> <span class="o">=</span> <span class="n">childrenList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">homeFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">myFolder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">AbstractFile</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;file&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">            <span class="n">myFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">AbstractFile</span> <span class="n">folder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Folder</span><span class="o">(</span><span class="s">&#34;folder&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">                <span class="n">myFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">AbstractFile</span> <span class="n">folderFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;file&#34;</span>
</span></span><span class="line"><span class="cl">                            <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                            <span class="o">+</span> <span class="sc">&#39;_&#39;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">                    <span class="n">folder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folderFile</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>输出如下：</p>
<pre tabindex="0"><code>/
├── sbin
├── boot
├── sys
├── etc
├── usr
├── home
│   └── linner
│       ├── file1
│       ├── folder1
│       │   ├── file1_1
│       │   ├── file1_2
│       │   └── file1_3
│       ├── file2
│       ├── file3
│       ├── folder3
│       │   ├── file3_1
│       │   ├── file3_2
│       │   └── file3_3
│       ├── file4
│       ├── file5
│       └── folder5
│           ├── file5_1
│           ├── file5_2
│           └── file5_3
└── root
</code></pre><p>Composite模式适用于：</p>
<ul>
<li>想表示对象的<u>部分——整体层次结构</u>。</li>
<li>希望用户<u>忽略组合对象与单个对象的不同</u>，用户将<u>统一地使用组合结构中的所有对象</u>。</li>
</ul>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h3 id="装饰器模式" data-numberify>装饰器模式<a class="anchor ms-1" href="#装饰器模式"></a></h3>
<p>装饰器（Decorator）模式<u>动态地给一个对象添加一些额外的职责</u>。装饰器提供了用子类扩展功能的灵活替代。就增加功能而言，<u>Decorator模式比派生子类更加灵活</u>。</p>
<p>装饰器模式结构：</p>
<p><picture><img class="img-fluid " alt="装饰器模式结构" src="/docs/ruan-she/object-oriented/uTools_1682302304911.png" loading="lazy" width="862" height="392" />
</picture>

</p>
<ul>
<li><code>Component</code>：定义一个<u>对象接口</u>，可以给这些对象<u>动态地添加职责</u>。</li>
<li><code>ConcreteComponent</code>：定义一个对象，可以<u>给这个对象添加一些职责</u>。</li>
<li><code>Decorator</code>：<u>维持一个指向<code>Component</code>对象的指针</u>，并<u>定义一个与<code>Component</code>接口一致的接口</u>。</li>
<li><code>ConcreteDecorator</code>：<u>向组件添加职责。</u></li>
</ul>
<p>代码示例：</p>
<p><code>Person</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 职责
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Student</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#34;的职责：学习&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Decorator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Decorator</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">Person</span> <span class="n">person</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>DecoratorA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecoratorA</span> <span class="kd">extends</span> <span class="n">Decorator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">DecoratorA</span><span class="o">(</span><span class="n">Person</span> <span class="n">person</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">person</span> <span class="o">=</span> <span class="n">person</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">person</span><span class="o">.</span><span class="na">operation</span><span class="o">();</span> <span class="c1">// 原本的职责
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#34;新职责：摸鱼&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>DecoratorB</code>与<code>DecoratorA</code>类似，略；</p>
<p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecoratorPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Person</span> <span class="n">zhangsan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;张三&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">zhangsan</span><span class="o">.</span><span class="na">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;============================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*Decorator decoratorA = new DecoratorA(zhangsan);
</span></span></span><span class="line"><span class="cl"><span class="cm">        decoratorA.operation();*/</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 装饰器对象也相当于Person
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 装饰链
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">zhangsan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DecoratorA</span><span class="o">(</span><span class="n">zhangsan</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">zhangsan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DecoratorB</span><span class="o">(</span><span class="n">zhangsan</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">zhangsan</span><span class="o">.</span><span class="na">operation</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Decorator模式适用于：</p>
<ul>
<li>在<u>不影响其他对象的情况下</u>，以动态、透明的方式给单个对象<u>添加职责</u>。</li>
<li><u>处理那些可以撤销的职责</u>。</li>
<li>当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>
<h3 id="外观模式" data-numberify>外观模式<a class="anchor ms-1" href="#外观模式"></a></h3>
<p>外观（Facade，<strong>门面</strong>）模式<u>为子系统中的一组接口提供一个一致的门面（界面）</u>，Facade模式<u>定义了</u>一个<u>高层接口</u>，这个接口<u>使得这一子系统更加容易使用</u>。</p>
<p>外观模式的结构：</p>
<p><picture><img class="img-fluid " alt="外观模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682302810965.png" loading="lazy" width="950" height="376" />
</picture>

</p>
<ul>
<li>
<p><code>Facade</code>：知道哪些子系统类负责处理请求；<u>将客户的请求代理给适当的子系统对象</u>。</p>
</li>
<li>
<p><code>Subsystem classes</code>：</p>
<ul>
<li>实现子系统的功能；</li>
<li>处理有<code>Facade</code>对象指派的任务；</li>
<li>没有<code>Facade</code>的任何相关信息，即没有指向<code>Facade</code>的指针。</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<p><code>SubSystem1</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SubSystem1</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;执行子系统1的功能&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>SubSystem2</code>和<code>SubSystem3</code>与<code>SubSystem1</code>类似，代码略。</p>
<p><code>Facade</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Facade</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SubSystem1</span> <span class="n">subSystem1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SubSystem2</span> <span class="n">subSystem2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SubSystem3</span> <span class="n">subSystem3</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Facade</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubSystem1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubSystem2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubSystem3</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodA</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem1</span><span class="o">.</span><span class="na">method1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodB</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem2</span><span class="o">.</span><span class="na">method2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">methodC</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">subSystem3</span><span class="o">.</span><span class="na">method3</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FacadePattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Facade</span> <span class="n">facade</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Facade</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">facade</span><span class="o">.</span><span class="na">methodA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">facade</span><span class="o">.</span><span class="na">methodB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">facade</span><span class="o">.</span><span class="na">methodC</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Facade模式适用于：</p>
<ul>
<li>
<p>Facade可以提供一个简单的默认视图，供大多数用户使用。</p>
<p>要<u>为一个复杂子系统提供一个简单接口</u>时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。</p>
<p>Facade提供的简单默认视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。</p>
</li>
<li>
<p><u>客户程序与抽象类的实现部分之间存在着很大的依赖性</u>。引入Facade将这个子系统与客户以及其他的子系统分离，可以<u>提高子系统的独立性和可移植性</u>。</p>
</li>
<li>
<p>当需要<u>构建一个层次结构的子系统</u>时，<u>使用Facade模式定义子系统中每层的入口点</u>。如果子系统之间是相互依赖的，则可以让它们仅通过Facade进行通信，从而<u>简化了它们之间的依赖关系</u>。</p>
</li>
</ul>
<p>外观模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>
<p>外观模式提供一个高层次的接口，使得子系统更易于使用：</p>
<ul>
<li>每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个<u>单例模式</u>。</li>
<li>整个系统可以有多个门面类。</li>
</ul>
<h3 id="享元模式" data-numberify>享元模式<a class="anchor ms-1" href="#享元模式"></a></h3>
<p>享元（Flyweight）模式<u>运用共享技术有效地支持大量细粒度的对象</u>。</p>
<blockquote>
<p>细粒度对象：在业务模型上，按照业务需求将对象加以细分，从而得到更多的业务模型对象。</p>
</blockquote>
<p>享元模式的结构：</p>
<p><picture><img class="img-fluid " alt="享元模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682305434953.png" loading="lazy" width="870" height="561" />
</picture>

</p>
<ul>
<li>
<p><code>Flyweight</code>：描述一个接口，通过这个接口<code>Flyweight</code>可以<u>接受并作用于外部状态</u>。</p>
</li>
<li>
<p><code>ConcreteFlyweight</code>：<u>实现<code>Flyweight</code>接口，并为内部状态（如果有）增加存储空间。</u></p>
<p><code>ConcreteFlyweight</code>对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于<code>ConcreteFlyweight</code>对象的场景。</p>
</li>
<li>
<p>并非所有的<code>Flyweight</code>子类都需要被共享。</p>
<p><code>Flyweight</code>接口使共享成为可能，但它并不强制共享。在<code>Flyweight</code>对象结构的某些层次，<code>UnsharedConcreteFlyweight</code>对象通常将<code>ConcreteFlyweight</code>对象作为子结点。</p>
</li>
<li>
<p><code>FlyweightFactory</code>：<u>创建并管理<code>Flyweight</code>对象</u>；确保合理地共享<code>Flyweight</code>，当用户请求一个<code>Flyweight</code>时，<code>FlyweightFactory</code>对象提供一个已创建的实例或者在不存在时创建一个实例。</p>
</li>
<li>
<p><code>Client</code>：维持一个对<code>Flyweight</code>的引用；计算或存储一个或多个<code>Flyweight</code>的外部状态。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>Piece</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Piece</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">String</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getColor</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>WhitePiece</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WhitePiece</span> <span class="kd">extends</span> <span class="n">Piece</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">WhitePiece</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">PieceFactory</span><span class="o">.</span><span class="na">WHITE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 打印地址和坐标信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">piece</span> <span class="o">=</span> <span class="s">&#34;WhitePiece@&#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="sc">&#39;{&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                       <span class="s">&#34;x=&#34;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#34;, &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                       <span class="s">&#34;y=&#34;</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                       <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">piece</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>BlackPiece</code>与<code>WhitePiece</code>类似，代码略。</p>
<p><code>PieceFactory</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PieceFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">WHITE</span> <span class="o">=</span> <span class="s">&#34;white&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">BLACK</span> <span class="o">=</span> <span class="s">&#34;black&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Piece</span><span class="o">&gt;</span> <span class="n">piecesMap</span> <span class="o">=</span> <span class="n">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">WHITE</span><span class="o">,</span> <span class="k">new</span> <span class="n">WhitePiece</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">            <span class="n">BLACK</span><span class="o">,</span> <span class="k">new</span> <span class="n">BlackPiece</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Piece</span> <span class="nf">getPiece</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">piecesMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Flyweight</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PieceFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PieceFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Piece</span> <span class="n">whitePiece1</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getPiece</span><span class="o">(</span><span class="n">PieceFactory</span><span class="o">.</span><span class="na">WHITE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">whitePiece1</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="mi">20</span><span class="o">,</span> <span class="mi">23</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Piece</span> <span class="n">whitePiece2</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getPiece</span><span class="o">(</span><span class="n">PieceFactory</span><span class="o">.</span><span class="na">WHITE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">whitePiece2</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">27</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Piece</span> <span class="n">blackPiece1</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getPiece</span><span class="o">(</span><span class="n">PieceFactory</span><span class="o">.</span><span class="na">BLACK</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">blackPiece1</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Piece</span> <span class="n">blackPiece2</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getPiece</span><span class="o">(</span><span class="n">PieceFactory</span><span class="o">.</span><span class="na">BLACK</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">blackPiece2</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">28</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Flyweight模式适用于：</p>
<ul>
<li>一个应用程序<u>使用了大量的对象</u>。</li>
<li>完全由于<u>使用大量的对象，造成很大的存储开销</u>。</li>
<li>对象的<u>大多数状态都可变为外部状态</u>。
<ul>
<li>外部状态：容易发生改变的状态；</li>
<li>内部状态：不容易发生改变的状态。</li>
</ul>
</li>
<li>如果<u>删除对象的外部状态</u>，那么<u>可以用相对较少的共享对象取代很多组对象</u>。</li>
</ul>
<p>享元模式能做到共享的关键是区分状态：</p>
<ul>
<li>内蕴状态：存储在享元内部，不会随环境的改变而有所不同。</li>
<li>外蕴状态：随环境的改变而改变的。</li>
</ul>
<p>外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>享元模式：将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h3 id="代理模式" data-numberify>代理模式<a class="anchor ms-1" href="#代理模式"></a></h3>
<p>代理（Proxy）模式为其他对象<u>提供一种代理以控制对这个对象的访问</u>。</p>
<p>代理模式的结构：</p>
<p><picture><img class="img-fluid " alt="代理模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682306107287.png" loading="lazy" width="807" height="348" />
</picture>

</p>
<ul>
<li>
<p><code>Proxy</code>：保存一个引用使得<u>代理可以访问实体</u>；提供一个与<code>Subject</code>的接口相同的接口，使<u>代理可以用来代替实体</u>；<u>控制对实体的存取</u>，并可能负责创建和删除它。</p>
<p>其他功能依赖于代理的类型：</p>
<ul>
<li><code>Remote Proxy</code>：负责对请求及其参数进行编码，并向不同地址空间中的实体发送己编码的请求；</li>
<li><code>Virtual Proxy</code>：可以缓存实体的附加信息，以便延迟对它的访问；</li>
<li><code>Protection Proxy</code>：检查调用者是否具有实现一个请求所必需的访问权限。</li>
</ul>
</li>
<li>
<p><code>Subject</code>：定义<code>RealSubject</code>和<code>Proxy</code>的共用接口，这样就在任何使用<code>RealSubject</code>的地方都可以使用<code>Proxy</code>。</p>
</li>
<li>
<p><code>RealSubject</code>：定义<code>Proxy</code>所代表的实体。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>Subject</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subject</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>RealSubject</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 代理实体
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RealSubject</span> <span class="kd">implements</span> <span class="n">Subject</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;RealSubject request...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Proxy</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 代理
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Proxy</span> <span class="kd">implements</span> <span class="n">Subject</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">RealSubject</span> <span class="n">realSubject</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Proxy</span><span class="o">(</span><span class="n">RealSubject</span> <span class="n">realSubject</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">realSubject</span> <span class="o">=</span> <span class="n">realSubject</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Proxy pre-request...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">realSubject</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Proxy post-request...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RealSubject</span> <span class="n">realSubject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealSubject</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Proxy</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Proxy</span><span class="o">(</span><span class="n">realSubject</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">proxy</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Proxy模式适用于在<u>需要比较通用和复杂的对象指针代替简单的指针的时候</u>，常见情况有:</p>
<ul>
<li>
<p>远程代理（Remote Proxy）：为一个对象在不同地址空间提供局部代表。</p>
</li>
<li>
<p>虚代理(Virtual Proxy）：根据需要创建开销很大的对象。</p>
</li>
<li>
<p>保护代理（Protection Proxy）：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。</p>
</li>
<li>
<p>智能引用（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作。</p>
<p>典型用途包括：</p>
<ul>
<li>对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；</li>
<li>当第一次引用一个持久对象时，将它装入内存；</li>
<li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ul>
</li>
</ul>
<p>某些情况下，用户不想或者不能够直接引用一个对象，代理对象可以在用户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h2 id="行为型设计模式" data-numberify>行为型设计模式<a class="anchor ms-1" href="#行为型设计模式"></a></h2>
<p>行为模式涉及<u>算法和对象间职责的分配</u>。行为模式不仅<u>描述对象或类的模式</u>，还<u>描述它们之间的通信模式</u>。</p>
<ul>
<li>
<p>行为类模式：使用<u>继承机制</u>在类间分派行为。</p>
</li>
<li>
<p>行为对象模式：使用<u>对象复合</u>。</p>
<p>一些行为对象模式<u>描述了一组<strong>对等</strong>的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务</u>。</p>
</li>
</ul>
<h3 id="责任链模式" data-numberify>责任链模式<a class="anchor ms-1" href="#责任链模式"></a></h3>
<p>责任链（Chain of Responsibility）模式<u>使多个对象都有机会处理请求</u>，从而避免请求的发送者和接收者之间的耦合关系。<u>将这些对象连成一条链</u>，并<u>沿着这条链传递该请求，直到有一个对象处理它为止</u>。</p>
<blockquote>
<p>JavaWeb中<code>Filter</code>（过滤器）就是责任链模式。</p>
</blockquote>
<p>责任链模式的结构：</p>
<p><picture><img class="img-fluid " alt="责任链模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682307471896.png" loading="lazy" width="680" height="348" />
</picture>

</p>
<ul>
<li>
<p><code>Handler</code>：</p>
<ul>
<li>定义一个处理请求的接口；</li>
<li>（可选）实现后继链。</li>
</ul>
</li>
<li>
<p><code>ConcreteHandler</code>：</p>
<ul>
<li>处理它所负责的请求；</li>
<li>可访问它的后继者；</li>
<li>如果可处理该请求，就处理它，否则将该请求转发给后继者。</li>
</ul>
</li>
<li>
<p><code>Client</code>：向链上的具体处理者（<code>ConcreteHandler</code>）对象提交请求。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>Handler</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">Handler</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setNext</span><span class="o">(</span><span class="n">Handler</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">handlerRequest</span><span class="o">(</span><span class="kt">int</span> <span class="n">request</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>FuDaoYuan</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 辅导员
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FuDaoYuan</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 审批7天内的假期
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param request
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handlerRequest</span><span class="o">(</span><span class="kt">int</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">request</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;FuDaoYuan allow...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">next</span><span class="o">.</span><span class="na">handlerRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;无法审批&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>YuanZhang</code>和<code>XiaoZhang</code>与<code>FuDaoYuan</code>类似，代码略。</p>
<p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChainOfResponsibility</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Handler</span> <span class="n">fuDaoYuan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FuDaoYuan</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Handler</span> <span class="n">yuanZhang</span> <span class="o">=</span> <span class="k">new</span> <span class="n">YuanZhang</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Handler</span> <span class="n">xiaoZhang</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XiaoZhang</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fuDaoYuan</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">yuanZhang</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">yuanZhang</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">xiaoZhang</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fuDaoYuan</span><span class="o">.</span><span class="na">handlerRequest</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">fuDaoYuan</span><span class="o">.</span><span class="na">handlerRequest</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">fuDaoYuan</span><span class="o">.</span><span class="na">handlerRequest</span><span class="o">(</span><span class="mi">29</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">fuDaoYuan</span><span class="o">.</span><span class="na">handlerRequest</span><span class="o">(</span><span class="mi">31</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Chain of Responsibility模式适用于以下条件：</p>
<ul>
<li>有<u>多个的对象可以处理一个请求</u>，哪个对象处理该请求<u>运行时刻自动确定</u>。</li>
<li>想在<u>不明确指定接收者的情况下向多个对象中的一个提交一个请求</u>。</li>
<li>可处理一个请求的对象集合应被<u>动态指定</u>。</li>
</ul>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。</p>
<p>处理者有两个选择：承担责任或者把责任推给下家。</p>
<p>一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="命令模式" data-numberify>命令模式<a class="anchor ms-1" href="#命令模式"></a></h3>
<p>命令（Command）模式将<u>一个请求封装为一个对象</u>，从而使得可以<u>用不同的请求对客户进行参数化</u>；对<u>请求排队</u>或<u>记录请求日志</u>，以及<u>支持可撤销的操作</u>。</p>
<p>命令模式的结构：</p>
<p><picture><img class="img-fluid " alt="命令模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682311014909.png" loading="lazy" width="924" height="305" />
</picture>

</p>
<ul>
<li>
<p><code>Command</code>：声明执行操作的接口。</p>
</li>
<li>
<p><code>ConcreteCommand</code>：将<u>一个接收者对象绑定于一个动作；调用接收者相应的操作</u>，以实现<code>Execute</code>。</p>
</li>
<li>
<p><code>Client</code>：创建一个具体命令对象并设定它的接收者<code>Receiver</code>。</p>
</li>
<li>
<p><code>Invoker</code>：要求该命令执行这个请求。</p>
</li>
<li>
<p><code>Receiver</code>：知道如何实施与执行一个请求相关的操作。</p>
<p>任何类都可能作为一个接收者。</p>
</li>
</ul>
<p>代码示例：</p>
<p><code>Command</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 命令接口
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Command</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行命令
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Tv</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tv</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 开机行为
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">powerOnAction</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Tv power-on...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 关机行为
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">powerOffAction</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Tv power-off...&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>PowerOn</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 开机命令
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PowerOn</span> <span class="kd">implements</span> <span class="n">Command</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Tv</span> <span class="n">tv</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">PowerOn</span><span class="o">(</span><span class="n">Tv</span> <span class="n">tv</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">tv</span> <span class="o">=</span> <span class="n">tv</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tv</span><span class="o">.</span><span class="na">powerOnAction</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>PowerOff</code>与<code>PowerOn</code>类似，代码略。</p>
<p><code>Invoker</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 请求者
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Invoker</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Command</span> <span class="n">command</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 设置请求命令
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCommand</span><span class="o">(</span><span class="n">Command</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">command</span> <span class="o">=</span> <span class="n">command</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行命令
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommandPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Tv</span> <span class="n">tv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tv</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Command</span> <span class="n">powerOn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PowerOn</span><span class="o">(</span><span class="n">tv</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Command</span> <span class="n">powerOff</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PowerOff</span><span class="o">(</span><span class="n">tv</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Invoker</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Invoker</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">invoker</span><span class="o">.</span><span class="na">setCommand</span><span class="o">(</span><span class="n">powerOn</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">invoker</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">invoker</span><span class="o">.</span><span class="na">setCommand</span><span class="o">(</span><span class="n">powerOff</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">invoker</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Command模式适用于：</p>
<ul>
<li>
<p><u>抽象出待执行的动作以参数化某对象。</u></p>
<p>Command模式是过程语言中的<u>回调</u>（Callback）<u>机制</u>的一个面向对象的<u>替代品</u>。</p>
</li>
<li>
<p>在<u>不同的时刻指定、排列和执行请求</u>。</p>
<p>一个Command对象可以有一个与初始请求无关的生存期。</p>
<p>如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程，并在那实现该请求。</p>
</li>
<li>
<p><u>支持取消操作</u>。</p>
<p>Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。</p>
<p>Command接口必须添加一个Unexecute操作，该操作取消上一次Execute 调用的效果。</p>
<p>执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消和“重做”。</p>
</li>
<li>
<p><u>支持修改日志</u>。</p>
<p>这样当系统崩溃时，这些修改可以被重做一遍。</p>
<p>在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。</p>
<p>从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。</p>
</li>
<li>
<p>用构建在原语操作上的高层操作构造一个系统。</p>
<p>这样一种结构在支持事务（Transaction）的信息系统中很常见。</p>
<p>Command模式提供了对事务进行建模的方法。Command有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。</p>
</li>
</ul>
<p>命令模式：把一个请求或者操作封装到一个对象中。命令模式把<u>发出命令的责任</u>和<u>执行命令的责任</u>分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方：</p>
<ul>
<li>不必知道接收请求的一方的接口；</li>
<li>不必知道请求是怎么被接收</li>
<li>不必知道请求的操作是否执行，何时被执行以及是怎么被执行的。</li>
</ul>
<h3 id="解释器模式" data-numberify>解释器模式<a class="anchor ms-1" href="#解释器模式"></a></h3>
<p>解释器（Interpreter）模式<u>给定一个语言，定义它的文法的一种表示，并定义一个解释器</u>，这个解释器使用该表示来解释语言中的句子。</p>
<blockquote>
<p>可用于实现程序语言设计中的上下文无关文法。</p>
</blockquote>
<p>解释器模式结构：</p>
<p><picture><img class="img-fluid " alt="解释器模式结构" src="/docs/ruan-she/object-oriented/uTools_1682311888750.png" loading="lazy" width="705" height="369" />
</picture>

</p>
<ul>
<li>
<p><code>AbstractExpression</code>：声明一个<u>程序的解释操作</u>，这个接口为抽象语法树中所有的结点所共享。</p>
</li>
<li>
<p><code>TerminalExpression</code>：<u>实现与文法中的终结符相关联的解释操作</u>；一个句子中的每个终结符需要该类的一个实例。</p>
</li>
<li>
<p><code>NonterminalExpression</code>：对文法中的每一条规则都需要一个<code>NonterminalExpression</code>类。</p>
<ul>
<li>为每个符号都维护一个<code>AbstractExpression</code>类型的实例变量；</li>
<li>为文法中的非终结符实现解释（<code>Interpret</code>）操作。</li>
</ul>
</li>
<li>
<p><code>Context</code>：包含解释器之外的一些<u>全局信息</u>。</p>
</li>
<li>
<p><code>Client</code>：构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由<code>NonterminalExpression</code>和<code>TerminalExpression</code>的实例装配而成；调用解释操作。</p>
</li>
</ul>
<p>Interpreter模式适用于当<u>有一个语言需要解释执行</u>，且<u>可将该语言中的句子表示为一个抽象语法树</u>时，以下情况效果最好:</p>
<ul>
<li>
<p>该<u>文法简单</u>。</p>
<p>对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间。</p>
<p>即Interpreter模式需要构建抽象语法树，如果文法太复杂，需要构建复杂的语法树，不便于管理。</p>
</li>
<li>
<p><u>效率不是一个关键问题。</u></p>
<p>最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现。</p>
</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<p>有一个语言需要<u>解释执行</u>，并且可将句子表示为一个<u>抽象语法树</u>。</p>
</blockquote>
<p>解释器模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<h3 id="迭代器模式" data-numberify>迭代器模式<a class="anchor ms-1" href="#迭代器模式"></a></h3>
<p>迭代器（Iterator）模式<u>提供一种方法顺序访问</u>一个<u>聚合对象中的各个元素</u>，且<u>不需要暴露该对象的内部表示</u>。</p>
<blockquote>
<p>多个对象聚在一起形成的总体称之为聚合（聚集），聚合对象是能够包容一组对象的容器对象。</p>
</blockquote>
<p>迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代器模式的结构：</p>
<p><picture><img class="img-fluid " alt="迭代器模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682312615849.png" loading="lazy" width="845" height="401" />
</picture>

</p>
<ul>
<li><code>Iterator</code>（迭代器）：定义访问和遍历元素的接口。</li>
<li><code>ConcreteIterator</code>（具体迭代器）：实现迭代器接口；对该聚合遍历时跟踪当前位置。</li>
<li><code>Aggregate</code>（聚合）：定义创建相应迭代器对象的接口。</li>
<li><code>ConcreteAggregate</code>（具体聚合）：实现创建相应迭代器的接口，该操作返回<code>ConcreteIterator</code>的一个适当的实例。</li>
</ul>
<p>代码示例：</p>
<p><code>Book</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Double</span> <span class="n">price</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// getter、setter和toString，略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p><code>Aggregate</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Aggregate</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Iterator</span> <span class="nf">iterator</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Iterator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>BookAggregate</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookAggregate</span> <span class="kd">implements</span> <span class="n">Aggregate</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">Book</span><span class="o">&gt;</span> <span class="n">books</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Book</span> <span class="n">book</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">books</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Book</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">books</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">books</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Iterator</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">BookIterator</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>BookIterator</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 迭代对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookIterator</span> <span class="kd">implements</span> <span class="n">Iterator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">BookAggregate</span> <span class="n">bookAggregate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">BookIterator</span><span class="o">(</span><span class="n">BookAggregate</span> <span class="n">bookAggregate</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">bookAggregate</span> <span class="o">=</span> <span class="n">bookAggregate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">bookAggregate</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">bookAggregate</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">++);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IteratorPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">BookAggregate</span> <span class="n">bookAggregate</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookAggregate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">booksMap</span> <span class="o">=</span> <span class="n">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;数据结构&#34;</span><span class="o">,</span> <span class="mf">10.24</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;操作系统&#34;</span><span class="o">,</span> <span class="mf">20.48</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;计算机网络&#34;</span><span class="o">,</span> <span class="mf">40.96</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;计算机组成原理&#34;</span><span class="o">,</span> <span class="mf">81.92</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">booksMap</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">bookAggregate</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Book</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bookAggregate</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="o">(</span><span class="n">Book</span><span class="o">)</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Iterator模式适用于：</p>
<ul>
<li><u>访问</u>一个<u>聚合对象的内容</u>而<u>无须暴露它的内部表示</u>。</li>
<li>支持<u>对聚合对象的多种遍历</u>。</li>
<li>为<u>遍历不同的聚合结构提供一个统一的接口</u>。</li>
</ul>
<h3 id="中介者模式" data-numberify>中介者模式<a class="anchor ms-1" href="#中介者模式"></a></h3>
<p>中介者模式（Mediator，调停者）用一个<u>中介对象来封装一系列的对象交互</u>。中介者<u>使各对象不需要显式地相互引用</u>，从而使其<u>耦合松散</u>，而且<u>可以独立地改变它们之间的交互</u>。</p>
<p>中介者模式的结构：</p>
<p><picture><img class="img-fluid " alt="中介者模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682313139750.png" loading="lazy" width="855" height="236" />
</picture>

</p>
<ul>
<li><code>Mediator</code>（中介者）：定义一个接口用于各同事（<code>Colleague</code>）对象通信。</li>
<li><code>ConcreteMediator</code>（具体中介者）：通过协调各同事对象实现协作行为；了解并维护它的各个同事。</li>
<li><code>Colleague</code>（同事类）：知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。</li>
</ul>
<p>Mediator模式适用于：</p>
<ul>
<li><u>一组对象以定义良好但是复杂的方式进行通信</u>，产生的<u>相互依赖关系结构混乱且难以理解</u>。</li>
<li><u>一个对象引用其他很多对象</u>并且<u>直接与这些对象通信</u>，<u>导致难以复用该对象</u>。</li>
<li>想<u>定制一个分布在多个类中的行为</u>，而又<u>不想生成太多的子类</u>。</li>
</ul>
<p>中介者模式：包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。</p>
<p>中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="备忘录模式" data-numberify>备忘录模式<a class="anchor ms-1" href="#备忘录模式"></a></h3>
<p>备忘录（Memento）模式在<u>不破坏封装性的前提下，捕获一个对象的内部状态</u>，并在对象之外保存这个状态。这样以后就可以<u>将对象恢复到原先保存的状态</u>。</p>
<p>Memento模式的结构：</p>
<p><picture><img class="img-fluid " alt="Memento模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682314218216.png" loading="lazy" width="847" height="266" />
</picture>

</p>
<ul>
<li><code>Memento</code>（备忘录）：存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录。</li>
<li><code>Originator</code>（原发器）：创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态。</li>
<li><code>Caretaker</code>（管理者）负责保存好备忘录；不能对备忘录的内容进行操作或检查。</li>
</ul>
<p>Memento模式适用于：</p>
<ul>
<li>必须<u>保存</u>一个<u>对象在某一个时刻的（部分）状态</u>，这样以后需要时它才能<u>恢复到先前的状态</u>。</li>
<li>如果用接口来让其他对象直接得到这些状态，将会<u>暴露对象的实现细节并破坏对象的封装性</u>。</li>
</ul>
<blockquote>
<p>题目选项描述：</p>
<ul>
<li>将对象的状态恢复到先前的状态。</li>
<li>在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存。</li>
<li>必须保存一个对象在某一个时刻的（部分）状态。</li>
</ul>
<p>关键词：<u>状态</u>。</p>
</blockquote>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="观察者模式" data-numberify>观察者模式<a class="anchor ms-1" href="#观察者模式"></a></h3>
<p>观察者（Observer）模式<u>定义对象间的一种一对多的依赖关系</u>，当<u>一个对象的状态发生改变</u>时，<u>所有依赖于它的对象都得到通知并被自动更新</u>。</p>
<p>即，观察者模式让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<blockquote>
<p>JavaWeb中<code>Listener</code>就是观察者模式。</p>
</blockquote>
<p>观察者模式的结构：</p>
<p><picture><img class="img-fluid " alt="观察者模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682314647475.png" loading="lazy" width="814" height="315" />
</picture>

</p>
<ul>
<li><code>Subject</code>（目标）：提供注册和删除观察者对象的接口；知道它的观察者，可以有任意多个观察者观察同一个目标。</li>
<li><code>Observer</code>（观察者）：为那些在目标发生改变时需获得通知的对象<u>定义</u>一个<u>更新接口</u>。</li>
<li><code>ConcreteSubject</code>（具体目标）：将<u>有关状态存入各<code>ConcreteObserver</code>对象</u>；当它的<u>状态发生改变</u>时，向它的各个观察者<u>发出通知</u>。</li>
<li><code>ConcreteObserver</code>（具体观察者）：维护一个指向<code>ConcreteSubject</code>对象的引用；<u>存储有关状态</u>，这些状态应与目标的状态保持一致；实现<code>Observer</code>的更新接口，以<u>使自身状态与目标的状态保持一致</u>。</li>
</ul>
<p>代码实现：</p>
<p><code>Observer</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 观察者
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Observer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新观察者状态
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 观察目标
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subject</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 注册观察者
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 删除观察者
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">detach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 状态改变，通知所有观察者
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">notifyAllObservers</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getState</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ConcreteObserver</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteObserver</span> <span class="kd">implements</span> <span class="n">Observer</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Subject</span> <span class="n">subject</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">ConcreteObserver</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">subject</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">subject</span> <span class="o">=</span> <span class="n">subject</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">subject</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">subject</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">subject</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[收到通知] &#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;ConcreteObserver{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34; , state=&#39;&#34;</span> <span class="o">+</span> <span class="n">state</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34; , subject=&#34;</span> <span class="o">+</span> <span class="n">subject</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>ConcreteSubject</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteSubject</span> <span class="kd">implements</span> <span class="n">Subject</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;</span> <span class="n">observerList</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">ConcreteSubject</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">observerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">observerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">detach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">observerList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">notifyAllObservers</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[发出通知] &#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observerList</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">observer</span><span class="o">.</span><span class="na">update</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[状态改变] &#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">notifyAllObservers</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;ConcreteSubject{&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34; , state=&#39;&#34;</span> <span class="o">+</span> <span class="n">state</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObserverPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Subject</span> <span class="n">subject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteSubject</span><span class="o">(</span><span class="s">&#34;主题&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Observer</span> <span class="n">zhangsan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="o">(</span><span class="s">&#34;张三&#34;</span><span class="o">,</span> <span class="n">subject</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Observer</span> <span class="n">lisi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="o">(</span><span class="s">&#34;李四&#34;</span><span class="o">,</span> <span class="n">subject</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Observer</span> <span class="n">wangwu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="o">(</span><span class="s">&#34;王五&#34;</span><span class="o">,</span> <span class="n">subject</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">subject</span><span class="o">.</span><span class="na">notifyAllObservers</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">subject</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="s">&#34;new&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Observer模式适用于：</p>
<ul>
<li>当一个抽象模型有两个方面，其中<u>一个方面依赖于另一个方面</u>，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对<u>一个对象的改变需要同时改变其他对象</u>，而<u>不知道具体有多少对象有待改变</u>时。</li>
<li>当<u>一个对象必须通知其他对象</u>，而它又不能假定其他对象是谁，即<u>不希望这些对象是紧耦合的</u>。</li>
</ul>
<h3 id="状态模式" data-numberify>状态模式<a class="anchor ms-1" href="#状态模式"></a></h3>
<p>状态（State）模式允许一个对象在其<u>内部状态改变时改变它的行为</u>。对象看起来似乎修改了它的类。</p>
<p>状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<p>状态模式的结构：</p>
<p><picture><img class="img-fluid " alt="状态模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682315217521.png" loading="lazy" width="644" height="245" />
</picture>

</p>
<ul>
<li><code>Context</code>（上下文）：定义客户感兴趣的接口；维护一个<code>ConcreteState</code>子类的实例，这个实例定义当前状态。</li>
<li><code>State</code>（状态）：定义一个接口以封装与<code>Context</code>的一个特定状态相关的行为。</li>
<li><code>ConcreteState</code>（具体状态子类）：每个子类实现与<code>Context</code>的一个状态相关的行为。</li>
</ul>
<p>代码示例：</p>
<p><code>State</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">State</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Context</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 贩卖机
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Context</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">State</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Context</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateA</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateB</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 购买饮料
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">State</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="n">State</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>StateA</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 有货
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StateA</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;购买成功&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">context</span><span class="o">.</span><span class="na">setCount</span><span class="o">(--</span><span class="n">count</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">context</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="k">new</span> <span class="n">StateB</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;购买失败&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;State@&#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="sc">&#39;{&#39;</span> <span class="o">+</span> <span class="s">&#34;有货&#34;</span> <span class="o">+</span> <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>StateB</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 有货
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StateB</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;购买失败，等待补货&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">context</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;补货成功，请重新购买&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">context</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="k">new</span> <span class="n">StateA</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;State@&#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">+</span> <span class="sc">&#39;{&#39;</span> <span class="o">+</span> <span class="s">&#34;无货&#34;</span> <span class="o">+</span> <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StatePattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Context</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>State模式适用于：</p>
<ul>
<li>
<p>一个<u>对象的行为决定于它的状态</u>，并且它<u>必须在运行时刻根据状态改变它的行为</u>。</p>
</li>
<li>
<p>一个<u>操作中含有庞大的多分支的条件语句</u>，且<u>这些分支依赖于该对象的状态</u>。</p>
<p>这个状态常用一个或多个<u>枚举常量</u>表示。</p>
<p>State模式<u>将每一个条件分支放入一个独立的类中</u>。</p>
</li>
</ul>
<h3 id="策略模式" data-numberify>策略模式<a class="anchor ms-1" href="#策略模式"></a></h3>
<p>策略（Strategy）模式<u>定义一系列的算法</u>，把它们一个个封装起来，并且<u>使它们可以相互替换</u>。此模式使得算法可以独立于使用它们的客户而变化。</p>
<p>即，策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<p><picture><img class="img-fluid " alt="策略模式的结构" src="/docs/ruan-she/object-oriented/uTools_1684936229743.png" loading="lazy" width="712" height="246" />
</picture>

</p>
<ul>
<li>
<p><code>Strategy</code>（策略）：定义所有支持的算法的公共接口。</p>
<p><code>Context</code>使用这个接口来调用某<code>ConcreteStrategy</code>定义的算法。</p>
</li>
<li>
<p><code>ConcreteStrategy</code>（具体策略）：以<code>Strategy</code>接口实现某具体算法。</p>
</li>
<li>
<p><code>Context</code>（上下文）：用一个<code>ConcreteStrategy</code>对象来配置；维护一个对<code>Strategy</code>对象的引用；可定义一个接口来让<code>Strategy</code>访问它的数据。</p>
</li>
</ul>
<p>代码实现：</p>
<p><code>Strategy</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Strategy</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">twoNumberOperation</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>OperationContext</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OperationContext</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Strategy</span> <span class="n">strategy</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">operation</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">strategy</span><span class="o">.</span><span class="na">twoNumberOperation</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStrategy</span><span class="o">(</span><span class="n">Strategy</span> <span class="n">strategy</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>AddStrategy</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddStrategy</span> <span class="kd">implements</span> <span class="n">Strategy</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">twoNumberOperation</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>与<code>AddStrategy</code>类似，代码略。</p>
<p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StrategyPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">OperationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Strategy</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AddStrategy</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Strategy</span> <span class="n">sub</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubStrategy</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Strategy</span> <span class="n">multiply</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MultiplyStrategy</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 我觉得下面这部分代码应该是放在OperationContext.operation()中实现的&lt;br&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 因为策略模式就是要让用户不知道使用的是哪种算法&lt;br&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 但是对于这个案例来说不适合这样实现
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">setStrategy</span><span class="o">(</span><span class="n">add</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">operation</span><span class="o">(</span><span class="mi">2023</span><span class="o">,</span> <span class="mi">527</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">setStrategy</span><span class="o">(</span><span class="n">sub</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">operation</span><span class="o">(</span><span class="mi">2023</span><span class="o">,</span> <span class="mi">527</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">context</span><span class="o">.</span><span class="na">setStrategy</span><span class="o">(</span><span class="n">multiply</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">operation</span><span class="o">(</span><span class="mi">2023</span><span class="o">,</span> <span class="mi">527</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Strategy模式适用于：</p>
<ul>
<li><u>许多相关的类仅仅是行为有异</u>。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li><u>需要使用一个算法的不同变体</u>。例如，定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使厨策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的<code>Strategy</code>类中，以代替这些条件语句。</li>
</ul>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p>
<p>策略模把行为和环境分开：环境类负责维持和查询行为类，各种算法在具体的策略类中提供。</p>
<p>由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<h3 id="模板方法模式" data-numberify>模板方法模式<a class="anchor ms-1" href="#模板方法模式"></a></h3>
<p>模板方法模式（Template Method）定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法模式的结构：</p>
<p><picture><img class="img-fluid " alt="模板方法模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682316789017.png" loading="lazy" width="610" height="352" />
</picture>

</p>
<ul>
<li>
<p><code>AbstractClass</code>（抽象类）：</p>
<ul>
<li>定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；</li>
<li>实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在<code>AbstractClass</code>或其他对象中的操作。</li>
</ul>
</li>
<li>
<p><code>ConcreteClass</code>（具体类）：实现原语操作以完成算法中与特定子类相关的步骤。</p>
</li>
</ul>
<p>Template Method模式适用于：</p>
<ul>
<li>
<p><u>一次性实现</u>一个<u>算法的不变的部分</u>，并将<u>可变的行为留给子类来实现</u>。</p>
</li>
<li>
<p>各<u>子类中公共的行为应被提取出来并集中到一个公共父类</u>中，以<u>避免代码重复</u>。</p>
</li>
<li>
<p>控制子类扩展。</p>
<p>模板方法旨在特定点调用“hook”操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展。</p>
</li>
</ul>
<p>模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="访问者模式" data-numberify>访问者模式<a class="anchor ms-1" href="#访问者模式"></a></h3>
<p>访问者（Visitor）模式<u>表示一个作用于某<strong>对象结构</strong>中的<strong>各元素</strong>的操作</u>。它<u>允许在不改变各元素的类的前提下，定义作用于这些元素的新操作</u>。</p>
<p>即，访问者模式的目的是<u>封装一些施加于某种数据结构元素之上的操作</u>。一旦<u>这些操作需要修改</u>的话，<u>接受这个操作的数据结构可以保持不变</u>。</p>
<blockquote>
<p>就是结构和行为分离，结构被定义在具体对象中（具体对象实现操作的一小部分），行为被定义在访问者中（操作的大部分由访问者实现）。</p>
</blockquote>
<p>访问者模式的结构：</p>
<p><picture><img class="img-fluid " alt="访问者模式的结构" src="/docs/ruan-she/object-oriented/uTools_1682316261510.png" loading="lazy" width="823" height="653" />
</picture>

</p>
<ul>
<li>
<p><code>ConcreteVisitor</code>（具体访问者）：实现每个有<code>Visitor</code>声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。</p>
<p><code>ConcreteVisitor</code>为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。</p>
</li>
<li>
<p><code>Element</code>（元素）：定义以一个访问者为参数的<code>Accept</code>操作。</p>
</li>
<li>
<p><code>ConcreteElement</code>（具体元素）：实现以一个访问者为参数的<code>Accept</code>操作。</p>
</li>
<li>
<p><code>ObjectStructure</code>（对象结构）：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合。</p>
</li>
</ul>
<p>代码实现：</p>
<p><code>Person</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接受访问对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">&#34;\\.&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">split</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">split</span><span class="o">[</span><span class="n">last</span><span class="o">]</span> <span class="o">+</span> <span class="sc">&#39;{&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Visitor</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Visitor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 访问学生
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Student</span> <span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 访问老师
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Teacher</span> <span class="n">teacher</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Student</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">setName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">visitor</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Teacher</code>与<code>Student</code>类似，代码略。</p>
<p><code>Visitor1</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Visitor1</span> <span class="kd">implements</span> <span class="n">Visitor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Student</span> <span class="n">student</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Visitor1 &#34;</span> <span class="o">+</span> <span class="n">student</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Teacher</span> <span class="n">teacher</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Visitor1 &#34;</span> <span class="o">+</span> <span class="n">teacher</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>Visitor2</code>与<code>Visitor1</code>类似，代码略。</p>
<p><code>PersonStructure</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonStructure</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">PersonStructure</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;张三&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;李四&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;王五&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Teacher</span><span class="o">(</span><span class="s">&#34;李老师&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Teacher</span><span class="o">(</span><span class="s">&#34;陈老师&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Teacher</span><span class="o">(</span><span class="s">&#34;刘老师&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 使用访问者访问集合中所有对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">Person</span> <span class="n">person</span> <span class="o">:</span> <span class="n">people</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">person</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">visitor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VisitorPattern</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PersonStructure</span> <span class="n">structure</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PersonStructure</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Visitor</span> <span class="n">visitor1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Visitor1</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">structure</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">visitor1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==============================&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Visitor</span> <span class="n">visitor2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Visitor2</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">structure</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">visitor2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Visitor模式适用于：</p>
<ul>
<li>
<p>一个<u>对象结构包含很多类对象</u>，它们有不同的接口，而用户想对这些对象<u>实施一些依赖于其具体类的操作</u>。</p>
</li>
<li>
<p>需要对一个<u>对象结构中的对象进行很多不同的并且不相关的操作</u>，而又想要避免这些操作“污染”这些对象的类。</p>
<p>Visitor使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。</p>
</li>
<li>
<p><u>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作</u>。</p>
<p>改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</p>
</li>
</ul>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
<h2 id="设计模式总结" data-numberify>设计模式总结<a class="anchor ms-1" href="#设计模式总结"></a></h2>
<p>创建型设计模式（抽象了对象的实例化过程）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:center">动态生产对象</td>
<td style="text-align:left">定义创建对象的接口，由子类实例化对象。让类的实例化延迟到其子类。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:center">生成系列对象</td>
<td style="text-align:left">提供创建一系列对象的接口，无需指定具体的类。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:center">构造复杂对象</td>
<td style="text-align:left">将复杂对象的构建与表示分离。使得同样的构建可以创建不同的表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:center">克隆对象</td>
<td style="text-align:left">用原型实例指定创建对象的类型，通过复制原型来创建对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:center">一个实例</td>
<td style="text-align:left">保证一个类仅有一个实例，并提供一个全局访问点。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left"><ul><li>一个类不知道它所必须创建对象的类</li><li>由子类来指定创建的对象</li><li>将创建对象的职责委托给多个帮助子类中的某一个</li></ul></td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left"><ul><li>系统独立于它产品的创建、<u>组合</u>和表示</li><li>系统由多个产品系列中的一个来配置</li><li>强调一系列相关产品对象的设计，以便进行联合使用</li><li>提供一个产品类库，只显示它们的接口而不是实现</li></ul></td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left"><ul><li>创建复杂对象的算法，独立于该对象的组成部分以及它们的装配方式</li><li>构造过程必须允许被构造的对象有不同的表示</li></ul></td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left"><ul><li>系统独立于它产品创建、<u>构成</u>和表示</li><li>要实例化的类是在运行时刻指定，如动态装载</li><li>避免创建一个与产品类层次平行的工厂类层次</li></ul></td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left"><ul><li>类只能有一个实例，用户可从一个全局点访问</li><li>这个唯一实例是通过子类化可扩展的，客户无须更改代码就能使用扩展实例</li></ul></td>
</tr>
</tbody>
</table>
<p>结构型模式（组合类或对象获得新的结构）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器（类/对象）</td>
<td style="text-align:center">接口转换</td>
<td style="text-align:left">将类的接口转换成兼容其他类的接口。<br>使原本接口不兼容的类可以一起工作。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:center">抽象与实现分离</td>
<td style="text-align:left">将类的抽象与实现分离，使它们可以独立变化。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">组合对象</td>
<td style="text-align:left">将对象组合成树型结构以表示“部分——整体”的层次结构。<br>使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td style="text-align:center">装饰</td>
<td style="text-align:center">动态附加职责</td>
<td style="text-align:left">动态地给一个对象添加一些额外的职责，比用子类来扩展功能更灵活。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:center">对外统一接口</td>
<td style="text-align:left">为子系统定义和提供一个统一的对外高层接口（外观）。<br>简化了该子系统的使用。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:center">共享大量细粒度对象</td>
<td style="text-align:left">提供支持大量细粒度对象共享的有效方法。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:center">中介代理</td>
<td style="text-align:left">为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left"><ul><li>使用接口不符合要求的类</li><li>创建可复用、可与其它不相关类或不可预见类协同工作</li><li>（仅适用于对象适配器）想使用子类，但又不想对它们子类化来匹配接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left"><ul><li>在抽象和实现之间没有固定的绑定关系</li><li>抽象以及实现都可以通过生成子类的方法扩充</li><li>对抽象的实现部分的修改不会对用户产生影响</li><li>隐藏抽象的实现</li><li>在多个对象间共享实现，用户并不知道</li></ul></td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left"><ul><li>表示对象的部分——整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，并统一地使用它们</li></ul></td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left"><ul><li>不影响其他对象，而动态透明地添加职责</li><li>处理那些可以撤销的职责</li><li>不能采用子类进行扩充</li></ul></td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left"><ul><li>为一个复杂子系统提供一个简单接口</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性</li><li>需要构建一个层次结构的子系统时</li></ul></td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left"><ul><li>使用了大量的对象，造成很大开销</li><li>对象的大多数状态都可变为外部状态</li><li>删除对象的外部状态后，可以用相对较少的共享对象取代很多组对象</li></ul></td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left"><ul><li>在需要比较通用和复杂对象指针代替简单指针时</li></ul></td>
</tr>
</tbody>
</table>
<p>行为型模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">关键字</th>
<th style="text-align:left">意图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:center">职责传递</td>
<td style="text-align:left">将处理请求的多个对象连成一条链，请求在链中传递，直到有对象处理。<br>给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:center">请求封装为对象</td>
<td style="text-align:left">将一个请求封装为一个对象，可用不同请求对客户进行参数化。<br>将请求排队或记录日志，支持撤销操作。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:center">语句解释</td>
<td style="text-align:left">给定一种语言，定义其文法和解释器，解释器根据文法解释语言中的句子。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:center">顺序访问数据集</td>
<td style="text-align:left">提供一个顺序访问聚合对象中元素的方法，不需要暴露对象的内部表示。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:center">不直接引用</td>
<td style="text-align:left">用对象封装一系列的对象交互。<br>使各对象不需显式地相互调用，达到低耦合。<br>可以独立改变对象间的交互。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:center">保存状态</td>
<td style="text-align:left">不破坏封装的前提下，捕获对象的内部状态，并在该对象之外保存。<br>可以在以后恢复保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:center">联动</td>
<td style="text-align:left">定义对象间的一种一对多依赖关系。<br>一个对象状态改变，所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">状态封装成类</td>
<td style="text-align:left">把对象的行为封装在不同的状态对象中。<br>允许一个对象在其内部状态改变时改变它的行为。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:center">多方案切换</td>
<td style="text-align:left">定义并封装一系列算法，使它们可以在不影响客户端的情况下相互替换。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:center">框架</td>
<td style="text-align:left">定义一个操作中的算法骨架，让其子类来实现算法中的剩余逻辑。<br>可以不改变算法结构而重新定义其某些特定步骤。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:center">数据与操作分离</td>
<td style="text-align:left">封装作用与某对象结构中元素的操作。<br>可以在不改变元素类的前提下，定义或修改作用于这些元素的操作。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left"><ul><li>有多个对象处理请求，运行时刻自动确定由谁处理</li><li>不明指定接收者的情况下向多个对象中的一个提交请求</li><li>可处理请求的对象集合被动态指定</li></ul></td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left"><ul><li>抽象出待执行的动作以参数化某对象</li><li>不同的时刻指定、排列和执行请求</li><li>支持取消操作，支持修改日志</li></ul></td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left"><ul><li>文法简单</li><li>效率不是关键问题</li></ul></td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left"><ul><li>访问聚合对象的内容而不暴露其内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left"><ul><li>一组对象以复杂的方式进行通信</li><li>一个对象引用其他很多对象并且直接与这些对象通信</li><li>定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul></td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left"><ul><li>必须保存一个对象在某一个时刻的（部分）状态</li><li>如果用接口让其他对象直接得到这些状态，会暴露对象的实现细节并破坏对象的封装性</li></ul></td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left"><ul><li>当抽象模型有两个方面，其中一个方面依赖于另一个方面</li><li>当改变一个对象的同时需要改变其他对象，又不知道有多少对象待改变</li><li>当一个对象必须通知其他对象，又不能假定其他对象是谁（不能紧耦合）</li></ul></td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left"><ul><li>对象的行为决定于它的状态，且在运行时刻根据状态改变行为</li><li>操作中含有庞大的多分支的条件语句</li></ul></td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left"><ul><li>许多相关的类仅仅是行为有异</li><li>需要使用一个算法的不同变体</li></ul></td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left"><ul><li>一次性实现算法中不变的部分，将可变的行为留给子类实现</li><li>各子类中公共行为被提取到公共父类中，避免代码重复</li></ul></td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left"><ul><li>对象结构包含很多类对象，用户想对这些对象实施操作</li><li>对对象结构中的对象进行很多不同且不相关的操作</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新操作</li></ul></td>
</tr>
</tbody>
</table>
<p>个人理解的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工厂方法</td>
<td style="text-align:left">具体工厂（工厂接口的实现）创建具体对象。</td>
</tr>
<tr>
<td style="text-align:center">抽象工厂</td>
<td style="text-align:left">一个具体工厂（抽象工厂的子类）创建多个产品，不同工厂用不同方式创建这一系列产品。</td>
</tr>
<tr>
<td style="text-align:center">生成器</td>
<td style="text-align:left">复杂对象通过切换构建<code>construct(Builder)</code>来创建不同表示。</td>
</tr>
<tr>
<td style="text-align:center">原型</td>
<td style="text-align:left">多个原型之间通过克隆<code>Prototype.clone()</code>来复制对象。</td>
</tr>
<tr>
<td style="text-align:center">单例</td>
<td style="text-align:left">通过私有化无参构造方法、静态<code>Singleton instance</code>属性和静态<code>getInstance()</code>方法使对象保持单例。</td>
</tr>
<tr>
<td style="text-align:center">适配器</td>
<td style="text-align:left">适配器继承目标类，重写目标类的方法，方法将不兼容的接口包装成与目标类一致的接口。</td>
</tr>
<tr>
<td style="text-align:center">桥接</td>
<td style="text-align:left">将产品（抽象）与其某属性（实现）分开，通过桥接（组合）产品与其属性独立出来的类来制造不同产品。</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:left">用树形结构和一致的抽象类让部分和整体的操作一致。如文件树。</td>
</tr>
<tr>
<td style="text-align:center">装饰器</td>
<td style="text-align:left">装饰器继承被装饰类，通过构造器传入被装饰对象，然后在与被装饰类一致的方法中添加新操作。多个装饰器嵌套可组成一条装饰链。</td>
</tr>
<tr>
<td style="text-align:center">外观</td>
<td style="text-align:left">复杂子系统有很多操作，外观将其简化。跟适配器很像。</td>
</tr>
<tr>
<td style="text-align:center">享元</td>
<td style="text-align:left">让一个对象假装成许多个对象。就是很多个对象之间可能有一部分属性的值是一样的，定义一个对象然后共享这部分属性。</td>
</tr>
<tr>
<td style="text-align:center">代理</td>
<td style="text-align:left">代理就是给被代理对象加一些操作，跟适配器和外观不同的是代理的接口是与被代理对象一致的。</td>
</tr>
<tr>
<td style="text-align:center">责任链</td>
<td style="text-align:left">有多个接口一致的对象，将请求在这些对象间层层转发，请求可以被其中一个对象处理（JavaWeb里的过滤器）。和嵌套的装饰器很像。</td>
</tr>
<tr>
<td style="text-align:center">命令</td>
<td style="text-align:left">就是一个命令一个对象，调用这些对象的方式一致（对象接口一致）。</td>
</tr>
<tr>
<td style="text-align:center">解释器</td>
<td style="text-align:left">解释语言的上下文。</td>
</tr>
<tr>
<td style="text-align:center">迭代器</td>
<td style="text-align:left">在集合对象的外部，通过迭代器访问集合中的元素，对应的迭代器可由集合对象给出<code>iterator()</code>。跟Java里的迭代器一个样。</td>
</tr>
<tr>
<td style="text-align:center">中介者</td>
<td style="text-align:left">有多个类似对象，这些对象通过中介互相发送消息（就好像微信聊天一样，微信就是中介）。</td>
</tr>
<tr>
<td style="text-align:center">备忘录</td>
<td style="text-align:left">捕获并保存对象的内部状态，并且可以恢复到原型保存的状态。</td>
</tr>
<tr>
<td style="text-align:center">观察者</td>
<td style="text-align:left">在目标对象状态更新时，观察者们可以收到通知<code>update()</code>，然后更新自身状态，与目标对象的状态保持一致。</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:left">一个状态一个类，在状态中通过判断变换到其它状态。</td>
</tr>
<tr>
<td style="text-align:center">策略</td>
<td style="text-align:left">就是动态切换算法。</td>
</tr>
<tr>
<td style="text-align:center">模板方法</td>
<td style="text-align:left">模板实现算法操作中不变的部分，其余的交给子类去实现。</td>
</tr>
<tr>
<td style="text-align:center">访问者</td>
<td style="text-align:left">就是在<code>Visitor.visit(访问对象)</code>中定义对象的操作，然后在结构类中提供<code>accept(Visitor)</code>来访问这些对象。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>知识产权篇</title>
      <link>/docs/ruan-she/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/</link>
      <pubDate>Sat, 15 Apr 2023 12:29:35 +0800</pubDate>
      
      <guid>/docs/ruan-she/%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/</guid>
      <description><![CDATA[著作权 著作权（也称为版权）：是指作者对其创作的作品享有的人身权和财产权。 人身权包括： 发表权 署名权 修改权 保护作品完整权 财产权包括： 作品的使用权]]></description>
      <content:encoded><![CDATA[<h1 id="著作权" data-numberify>著作权<a class="anchor ms-1" href="#著作权"></a></h1>
<p>著作权（也称为版权）：是指作者对其创作的作品享有的人身权和财产权。</p>
<p>人身权包括：</p>
<ul>
<li>发表权</li>
<li>署名权</li>
<li>修改权</li>
<li>保护作品完整权</li>
</ul>
<p>财产权包括：</p>
<ul>
<li>作品的使用权</li>
<li>获得报酬</li>
</ul>
<blockquote>
<p>著作权中，发表权有时限，时限是作者终身及其死亡后50年。署名权、修改权、保护作品完整权等不受时间限制，受到永久保护。</p>
</blockquote>
<hr>
<h1 id="知识产权的特点" data-numberify>知识产权的特点<a class="anchor ms-1" href="#知识产权的特点"></a></h1>
<p>知识产权的特点包括：</p>
<ul>
<li>无形性</li>
<li>双重性</li>
<li>确认性</li>
<li>独占性</li>
<li>地域性</li>
<li>时间性</li>
</ul>
<h2 id="地域性" data-numberify>地域性<a class="anchor ms-1" href="#地域性"></a></h2>
<p>各国主管机关依照本国法律授予的知识产权，<u>只能在不国领域内受法律保护</u>。著作权虽然自动产生，但它受地域限制。</p>
<h2 id="时间性" data-numberify>时间性<a class="anchor ms-1" href="#时间性"></a></h2>
<p>知识产权具有法定的保护期限。</p>
<p>例如，我国发明专利的保护期为20年，自专利申请日起计算。</p>
<ul>
<li>
<p>我国公民的作品发表权的保护期为作者终生及其死亡后50年。</p>
</li>
<li>
<p>我国商标权的保护期限自核准注册之日起10年内有效。</p>
<p>但可以根据其所有人的需要无限地延长权利期限：</p>
<ul>
<li>在期限届满前6个月内申请续展注册，</li>
<li>每次续展注册的有效期为10年，</li>
<li>续展注册的次数不限。</li>
</ul>
<p>商业秘密受法律保护的期限是不确定的。</p>
</li>
</ul>
<hr>
<h1 id="计算机软件著作权" data-numberify>计算机软件著作权<a class="anchor ms-1" href="#计算机软件著作权"></a></h1>
<p>计算机软件著作权有两个对象：</p>
<ul>
<li>
<p><strong>主体</strong>：指享有著作权的人，包括：</p>
<ul>
<li>公民</li>
<li>法人</li>
<li>其他组织</li>
</ul>
</li>
<li>
<p><strong>客体</strong>：指著作权法保护的计算机软件著作权的范围（受保护的对象）。</p>
<p>著作权法保护的计算机软件是指：</p>
<ul>
<li>
<p><strong>计算机程序</strong>，包括：</p>
<ul>
<li>源程序，</li>
<li>目标程序；</li>
</ul>
</li>
<li>
<p>计算机程序<strong>有关文档</strong>，文档一般以以下形式出现：</p>
<ul>
<li>程序设计说明书，</li>
<li>流程图，</li>
<li>用户手册。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>计算机软件著作权受到以下两个法律的保护：</p>
<ul>
<li>《中华人民共和国著作权法》，简称著作权法；</li>
<li>《计算机软件保护条例》。</li>
</ul>
<p>时限：计算机软件著作权的权利自软件开发完成之日起产生。</p>
<h2 id="保护条件" data-numberify>保护条件<a class="anchor ms-1" href="#保护条件"></a></h2>
<p>《计算机软件保护条例》规定，依法受到保护的计算机软件作品必须符合下列条件：</p>
<ul>
<li>
<p>独立创作。</p>
<p>不可抄袭。使用他人软件作品的逻辑步骤的组合方式，对他人构成侵权。</p>
</li>
<li>
<p>可被感知。</p>
<p>受保护的软件必须固定在某种有形物体上，例如固定在存储器、磁盘和磁带等设备上，也可以是其他的有形物，如纸张等。</p>
</li>
<li>
<p>逻辑合理。</p>
<p>软件作品必须具备合理的逻辑思想，并以正确的逻辑步骤表现出来。</p>
</li>
</ul>
<h2 id="权利" data-numberify>权利<a class="anchor ms-1" href="#权利"></a></h2>
<ul>
<li>
<p>计算机软件的著作人身权</p>
<ul>
<li>发表权</li>
<li>开发者身份权（也称为署名权）</li>
</ul>
</li>
<li>
<p>计算机软件的著作财产权</p>
<ul>
<li>使用权</li>
<li>复制权</li>
<li>修改权</li>
<li>发行权</li>
<li>翻译权</li>
<li>注释权</li>
<li>信息网络传播权</li>
<li>出租权</li>
<li>使用许可权</li>
<li>获得报酬权</li>
<li>转让权</li>
</ul>
</li>
<li>
<p>软件合法持有人的权利</p>
<p>软件的合法复制品所有人享有下述权利：</p>
<ul>
<li>根据使用的需要把软件装入计算机等能存储信息的装置内。</li>
<li>根据需要进行必要的复制。</li>
<li>为了防止复制品损坏而制作备份复制品（不能给他人使用）。</li>
<li>为了把该软件用于实际的计算机应用环境或者改进其功能性能而进行必要的修改。</li>
</ul>
</li>
</ul>
<h2 id="保护期" data-numberify>保护期<a class="anchor ms-1" href="#保护期"></a></h2>
<p>计算机软件著作权的权利自软件开发完成之日起产生，保护期为50年。保护期满，除开发者身份权以外，其他权利终止。</p>
<p>一旦计算机软件著作权超出保护期，软件就进入公有领域。计算机软件著作权人的单位终止和计算机软件著作权人的公民死亡均无合法继承人时，除开发者身份权以外，该软件的其他权利进入公有领域。软件进入公有领域后成为社会公共财富，公众可无偿使用。</p>
<h2 id="职务作品" data-numberify>职务作品<a class="anchor ms-1" href="#职务作品"></a></h2>
<p>职务软件作品是指公民在单位任职期间为热行本单位工作任务所开发的计算机软件作品。</p>
<p>根据《计算机软件保护条例》可以判断软件作品的归属。</p>
<p>构成职务软件作品的条件：</p>
<ul>
<li>公民在单位任职期间所开发的软件如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，则该软件的著作权属于该单位。</li>
<li>当公民作为某单位的雇员时，如其开发的软件属于执行本职工作的结果，该软件著作权应当归单位享有。</li>
<li>如果该雇员主要使用了单位的设备，著作权不能属于该雇员个人享有。</li>
</ul>
<blockquote>
<p>如果软件作品属于职务软件作品，那开发者只有署名权。</p>
</blockquote>
<p>构成非职务软件（个人）作品的条件：</p>
<ul>
<li>
<p>所开发的软件作品不是执行其本职工作的结果。</p>
<p>若雇员开发创作的软件不是执行本职工作的结果，则构成非职务计算机软件著作权的条件之一。</p>
</li>
<li>
<p>开发的软件作品与开发者在单位中从事的工作内容无直接联系。</p>
<p>雇员所开发的软件作品与其本职工作没有直接的关系，则构成非职务计算机软件著作权的第二个条件。</p>
</li>
<li>
<p>开发的软件作品未使用单位的物质技术条件。</p>
<p>开发软件作品所必须的设备、数据、资金和其他软件开发环境，不属于雇员所在的单位所有。没有使用受雇单位的任何物质技术条件构成非职务软件著作权的第三个条件。</p>
</li>
</ul>
<h2 id="委托开发" data-numberify>委托开发<a class="anchor ms-1" href="#委托开发"></a></h2>
<p>委托开发的软件作品属于著作权法规定的委托软件作品。委托开发软件作品著作权关系的建立，<u>一般由委托方与受委托方订立合同而成立</u>。</p>
<p>委托开发软件作品关系中：</p>
<ul>
<li>委托方：主要责任是提供资金、设备等物质条件，并不直接参与开发软件作品的创作开发活动。</li>
<li>受托方：主要责任是根据委托合同规定的目标开发出符合条件的软件。</li>
</ul>
<p>接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定：无书面合同或者合同未作明确约定的，其著作权由受托人享
有。</p>
<p>委托开发的软件著作权的归属按以下标准确定：</p>
<ul>
<li>软件著作权的归属应当根据委托开发软件的合同来确定。</li>
<li>若<u>没有签订书面协议</u>，或者<u>在协议中未对软件著作权归属作出明确的约定</u>，则<u>软件著作权属于受委托者</u>，即<u>属于实际完成软件的开发者</u>。</li>
</ul>
<h2 id="侵权行为" data-numberify>侵权行为<a class="anchor ms-1" href="#侵权行为"></a></h2>
<p>计算机软件著作权侵权行为：</p>
<ul>
<li>
<p>未经软件著作权人的同意而发表或者登记其软件作品。</p>
<p>侵犯著作权人的发表权。</p>
</li>
<li>
<p>将他人开发的软件当作自己的作品发表或者登记。</p>
<p>侵犯开发者身份权和署名权。</p>
</li>
<li>
<p>未经合作者的同意将与他人合作开发的软件当作自己独立完成的作品发表或者登记。</p>
<p>合作开发的软件，软件作品的发表权也应由全体开发者共同行使。</p>
</li>
<li>
<p>在他人开发的软件上署名或者更改他人开发的软件上的署名。</p>
<p>侵犯了软件著作人的开发者身份权及署名权。</p>
</li>
<li>
<p>未经软件著作权人或者其合法受让者的许可，修改、翻译其软件作品。</p>
<p>侵犯了著作权人或其合法受让者的使用权中的修改权、翻译权。</p>
<p>如果征得软件作品著作人的同意，修改和改善新增加的部分，创作者应享有著作权。</p>
</li>
<li>
<p>未经软件著作权人或其合法受让者的许可，复制或部分复制其软件作品。</p>
<p>侵犯了著作权人或其合法受让者的使用权中的复制权。</p>
</li>
<li>
<p>未经软件著作权人及其合法受让者同意，向公众发行、出租其软件的复制品。</p>
<p>此种行为侵犯了著作权人或其合法受让者的发行权与出租权。</p>
</li>
<li>
<p>未经软件著作权人或其合法受让者同意，向任何第三方办理软件权利许可或转让事宜。</p>
<p>侵犯了软件著作权人或其合法受让者的使用许可权和转让权。</p>
</li>
<li>
<p>未经软件著作权人及其合法受让者同意，通过信息网络传播著作权人的软件。</p>
<p>侵犯了软件著作权人或其合法受让者的信息网络传播权。</p>
</li>
</ul>
<hr>
<h1 id="商业秘密权" data-numberify>商业秘密权<a class="anchor ms-1" href="#商业秘密权"></a></h1>
<p>商业秘密的定义：“指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息”。</p>
<p>商业秘密的基本内容：</p>
<ul>
<li>经营秘密：未公开的经营信息，是指与生产经营销售活动有关的经营方法、
管理方法、产销策略、货源情报、客户名单、标底和标书内容等专有知识。</li>
<li>技术秘密：未公开的技术信息，是指与产品生产和制造有关的技术诀窍、生产方案、工艺流程、设计图纸、化学配方和技术情报等专有知识。</li>
</ul>
<p>商业秘密的构成条件：</p>
<ul>
<li>必须具有未公开性，即不为公众所知悉；</li>
<li>必须具有实用性，即能为权利人带来经济效益；</li>
<li>必须具有保密性，即采取了保密措施。</li>
</ul>
<p>商业秘密的丧失：一项商业秘密受到法律保护的依据是必须具备上述构成商业秘密的3个条件，当缺少上述3个条件之一时就会造成商业秘密丧失保护。</p>
<hr>
<h1 id="专利权" data-numberify>专利权<a class="anchor ms-1" href="#专利权"></a></h1>
<p>专利申请的原则：</p>
<ul>
<li><u>专利申请人及其代理人</u>在办理各种手续时都应当采用<strong>书面</strong>形式。</li>
<li>遵循<u>“一份申请一项发明”</u>原则。</li>
<li>多人就<u>同样</u>的发明创造申请专利的，专利权<u>授给最先申请人</u>。</li>
<li>相同的发明，多人<u>同时</u>申请，由所有申请人<u>协商确定</u>专利权归属。</li>
</ul>
<p>专利的时限（均自申情日起计算）：</p>
<table>
    <tr>
        <td>发明专利权</td>
        <td>20年</td>
    </tr>
    <tr>
        <td>实用新型专利权</td>
        <td>10年</td>
    </tr>
    <tr>
        <td>外观设计专利权</td>
        <td>15年</td>
    </tr>
</table>
<h2 id="商标权" data-numberify>商标权<a class="anchor ms-1" href="#商标权"></a></h2>
<ul>
<li>
<p>商标权保护期限自核准注册之日起<u>10年内有效</u>。</p>
</li>
<li>
<p>商标权保护期限可以<u>根据其所有人的需要无限地延长权利期限</u>。</p>
<p>在期限届满<u>前6个月内</u>申请续展注册，每次续展注册的<u>有效期为10年</u>，<u>续展注册的次数不限</u>。</p>
<p>如果商标权人逾期不办理续展注册，其商标权也将终止。</p>
</li>
</ul>
<p>商标权注册先申请注册先得，同一天申请先使用商标先得，都没使用过则协商。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统篇</title>
      <link>/docs/ruan-she/operating-system/</link>
      <pubDate>Wed, 12 Apr 2023 16:28:00 +0800</pubDate>
      
      <guid>/docs/ruan-she/operating-system/</guid>
      <description><![CDATA[概述 计算机系统由两部分组成： 硬件 软件 通常把未配置软件的计算机称为裸机。 操作系统（Operating System）目的是为了填补人与机器之间的]]></description>
      <content:encoded><![CDATA[<h1 id="概述" data-numberify>概述<a class="anchor ms-1" href="#概述"></a></h1>
<p>计算机系统由两部分组成：</p>
<ul>
<li><strong>硬件</strong></li>
<li><strong>软件</strong></li>
</ul>
<p>通常把未配置软件的计算机称为裸机。</p>
<p>操作系统（Operating System）目的是为了填补人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。</p>
<p>操作系统也包括了系统软件。</p>
<p>操作系统在计算机系统中的地位：</p>
<p><picture><img class="img-fluid " alt="操作系统在计算机系统中的地位" src="/docs/ruan-she/operating-system/uTools_1682583172164.png" loading="lazy" width="309" height="145" />
</picture>

</p>
<p>操作系统是用户与计算机之间的接口，它在计算机系统中占据重要而特殊的地位，所有其他软件，如编辑程序、汇编程序、编译程序、数据库管理系统等系统软件，以及大量的应用软件都是建立在操作系统基础上的，并得到它的支持和取得它的服务。</p>
<hr>
<h1 id="进程管理" data-numberify>进程管理<a class="anchor ms-1" href="#进程管理"></a></h1>
<p>进程管理也称<strong>处理机管理</strong>。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是<u>资源分配和独立运行的基本单位</u>。</p>
<p>进程有两个基本属性：</p>
<ul>
<li>可拥有资源的独立单位；</li>
<li>可独立调度和分配的基本单位。</li>
</ul>
<h2 id="程序执行顺序" data-numberify>程序执行顺序<a class="anchor ms-1" href="#程序执行顺序"></a></h2>
<h3 id="程序顺序执行" data-numberify>程序顺序执行<a class="anchor ms-1" href="#程序顺序执行"></a></h3>
<p>前驱图是一种有向无循环图，由结点和有向边组成：</p>
<ul>
<li>结点：代表各程序段的操作；</li>
<li>有向边：表示两个程序段（结点）操作之间存在的前驱关系（$\rightarrow$）。</li>
</ul>
<p>前驱关系：</p>
<p>程序段$P_i$和$P_j$的前趋关系表示成$P_i \rightarrow P_j$，其中，$P_i$是$P_j$的前驱，$P_j$是$P_i$的后继，其含义是：</p>
<p>$P_i$执行结束后$P_j$才能执行。例如，输入、计算和输出：</p>
<p><picture><img class="img-fluid " alt="3个结点的前驱图" src="/docs/ruan-she/operating-system/uTools_1682753834678.png" loading="lazy" width="358" height="107" />
</picture>

</p>
<p>程序顺序执行时的主要特征包括：</p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="程序并发执行" data-numberify>程序并发执行<a class="anchor ms-1" href="#程序并发执行"></a></h3>
<p>若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。</p>
<p>虽然每个作业有前趋关系的各程序段不能在CPU和输入/输出各部件（同一个部件）中并行执行，但是同一个作业内没有前趋关系的程序段或不同作业的程序段可以分别在CPU和各输入/输出部件上（不同部件中）并行执行。</p>
<p>例如，某系统中有一个CPU、一台输入设备和一台输出设备，每个作业具有3个程序段输入I<sub>i</sub>、计算C<sub>i</sub>和输出P<sub>i</sub>（i = 1，2，3）。其前驱图如（其中，在同一垂直方向上的作业并行执行）：</p>
<p><picture><img class="img-fluid " alt="程序并发执行的前驱图" src="/docs/ruan-she/operating-system/uTools_1682754585700.png" loading="lazy" width="480" height="203" />
</picture>

</p>
<p>程序并发执行时的特征：</p>
<ul>
<li>失去了程序的封闭性；</li>
<li>程序和机器的执行程序的活动不再一一对应；</li>
<li>并发程序间的相互制约性。</li>
</ul>
<p>程序并发执行带来的问题：并发程序间共享了变量，破坏了程序的封闭性和可再现性。</p>
<p>并发程序的问题可以通过研究进程间的同步和互斥解决。</p>
<h2 id="进程的三态模型" data-numberify>进程的三态模型<a class="anchor ms-1" href="#进程的三态模型"></a></h2>
<p>在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有3种基本状态：</p>
<ul>
<li><strong>运行</strong>：当一个进程在处理机上运行时。</li>
<li><strong>就绪</strong>：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行（还未得到）。</li>
<li><strong>阻塞</strong>（等待或睡眠）：一个进程正在等待某一事件发生而暂时停止运行，这时即使把处理机分配给进程也无法运行。</li>
</ul>
<p><picture><img class="img-fluid " alt="进程的三态模型" src="/docs/ruan-she/operating-system/uTools_1682757000186.png" loading="lazy" width="314" height="275" />
</picture>

</p>
<h2 id="进程间的通信" data-numberify>进程间的通信<a class="anchor ms-1" href="#进程间的通信"></a></h2>
<p>在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。</p>
<h3 id="同步和互斥" data-numberify>同步和互斥<a class="anchor ms-1" href="#同步和互斥"></a></h3>
<ul>
<li>
<p><strong>同步</strong>：合作进程间的直接制约问题。</p>
<p>进程间的同步：是指在系统中一些需要相互合作，协同工作的进程，这样的相互联系称为进程的同步。</p>
<p>例如，进程A向缓冲区送数据，进程B从缓冲区取数据加工，当进程B要取数据加工时，必须是进程A完成了向缓冲区送数据的操作，否则进程B必须停下来等待进程A的操作结束。</p>
</li>
<li>
<p><strong>互斥</strong>：申请临界资源进程间的间接制约问题。</p>
<p>进程间的互斥：是指系统中多个进程因争用临界资源而互斥执行。</p>
<blockquote>
<p>临界资源（Critical Resource，CR）：在多道程序系统环境中，那些一次只能供一个进程使用的资源。如打印机、共享变量和表格等。</p>
</blockquote>
</li>
</ul>
<p>临界区管理的原则：</p>
<blockquote>
<p>临界区（Critical Section，CS）：是进程中对临界资源实施操作的那段程序。</p>
</blockquote>
<p>对互斥临界区管理的4条原则如下：</p>
<ul>
<li><strong>有空即进</strong>：当<u>无进程处于临界区</u>时，<u>允许</u>进程<u>进入</u>临界区，并且<u>只能在临界区运行有限
的时间</u>。</li>
<li><strong>无空则等</strong>：当<u>有一个进程在临界区</u>时，<u>其他欲进入临界区的进程必须等待</u>，以保证进程互斥地访问临界资源。</li>
<li><strong>有限等待</strong>：<u>对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“<strong>饥饿</strong>”状态</u>。</li>
<li><strong>让权等待</strong>：<u>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入<strong>忙等</strong>状态。</u></li>
</ul>
<h3 id="信号量机制" data-numberify>信号量机制<a class="anchor ms-1" href="#信号量机制"></a></h3>
<p>信号量机制是一种有效的进程同步与互斥工具。</p>
<p>信号量机制主要有：</p>
<ul>
<li>整型信号量</li>
<li>记录型信号量</li>
<li>信号量集机制</li>
</ul>
<p>整型信号量：</p>
<p>信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类：</p>
<ul>
<li>公用信号量：实现进程间的互斥，初值为<code>1</code>或资源的数目。</li>
<li>私用信号量：实现进程间的同步，初值为<code>0</code>或某个正整数。</li>
</ul>
<p>信号量$S$的物理意义：</p>
<ul>
<li>$S \ge 0$：表示某资源的可用数，此时<strong>有可用资源</strong>；</li>
<li>$S &lt; 0$：则其绝对值表示阻塞队列中等待该资源的进程数，此时无可用资源，并且有进程被阻塞。</li>
</ul>
<h3 id="pv操作" data-numberify>PV操作<a class="anchor ms-1" href="#pv操作"></a></h3>
<p>PV操作：实现进程同步与互斥的常用方法。</p>
<p>P操作和V操作是低级通信原语，在执行期间不可分割。其中：</p>
<ul>
<li>
<p><strong>P操作</strong>（减）：表示<strong>申请</strong>一个资源；</p>
<p>定义：$S := S-1$（$S$表示信号量）。</p>
<ul>
<li>$S \ge 0$：执行P操作的进程继续执行；</li>
<li>$S &lt; 0$：无可用资源，置该进程为<strong>阻塞</strong>状态，并将其插入阻塞队列。</li>
</ul>
</li>
<li>
<p><strong>V操作</strong>（加）：表示<strong>释放</strong>一个资源。</p>
<p>定义：$S := S+1$。</p>
<ul>
<li>$S &gt; 0$：执行V操作的进程继续执行；</li>
<li>$S \le 0$：表示释放前有程序被阻塞，从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续。</li>
</ul>
</li>
</ul>
<blockquote>
<p>P减V加，P进V出。</p>
</blockquote>
<p>利用PV操作实现进程的互斥：</p>
<ol>
<li>令信号量<code>mutex</code>的初始值为1；</li>
<li>进入临界区：执行P操作；</li>
<li>推出临界区：执行V操作。</li>
</ol>
<p>利用PV操作实现进程的同步：</p>
<p>实现进程的同步可用一个信号量与消息联系起来。</p>
<p>信号量的值：</p>
<ul>
<li>为<code>0</code>：表示希望的消息未产生；</li>
<li>非<code>0</code>：表示希望的消息已经存在。</li>
</ul>
<p>假定信号量S表示某条消息，进程可以：</p>
<ul>
<li>调用P操作：测试消息是否到达；</li>
<li>调用V操作：通知消息已经准备好。</li>
</ul>
<p>例如：</p>
<ul>
<li>生产者进程$P_1$：不间断地生产产品送入缓冲区；</li>
<li>消费者进程$P_2$：不断地从缓冲区中取产品消费。</li>
</ul>
<p>为实现$P_1$与$P_2$间同步问题，分别设置信号量：</p>
<ul>
<li>$S_1$：初值为1，表示缓冲区空，可以将产品送入缓冲区；</li>
<li>$S_2$：初值为0，表示缓冲区有产品。</li>
</ul>
<p>同步过程如图：</p>
<p><picture><img class="img-fluid " alt="PV实现进程同步例子" src="/docs/ruan-she/operating-system/1682764456232.png" loading="lazy" width="979" height="310" />
</picture>

</p>
<p>若缓冲区可存放$n$件产品，生产者不断生产，消费者不断消费。可以设置3个信号量：</p>
<ul>
<li>$S$：互斥信号量，初值为1；</li>
<li>$S_1$：表示是否可以将产品放入缓冲区，初值为$n$；</li>
<li>$S_2$：表示缓冲区是否存有产品，初值为0。</li>
</ul>
<p>其同步过程如图：</p>
<p><picture><img class="img-fluid " alt="n缓冲区的同步" src="/docs/ruan-she/operating-system/uTools_1682764884289.png" loading="lazy" width="550" height="368" />
</picture>

</p>
<h3 id="死锁现象" data-numberify>死锁现象<a class="anchor ms-1" href="#死锁现象"></a></h3>
<p>死锁是指两个以上的进程互相都要请求对方己经占有的资源，导致这些进程都无法继续运行下去的现象。</p>
<p>产生死锁的原因有：</p>
<ul>
<li>
<p>进程间互相<u>竞争资源</u>：</p>
<p>多个进程所共享的资源不足以满足它们的需求时，将引起它们对资源的竞争，从而导致死锁。</p>
</li>
<li>
<p><u>进程推进顺序非法</u>：</p>
<p>进程在运行的过程中请求和释放资源的顺序不当，从而导致死锁。</p>
</li>
</ul>
<p>产生死锁的4个必要条件：</p>
<ul>
<li>互斥条件</li>
<li>请求保持条件</li>
<li>不可剥夺条件</li>
<li>环路条件</li>
</ul>
<p>发生死锁时，在进程资源有向图中必构成环路（每个进程占有了下一个进程申请的一个或多个资源），如：</p>
<p><picture><img class="img-fluid " alt="2个进程死锁的资源有向图" src="/docs/ruan-she/operating-system/uTools_1682766203339.png" loading="lazy" width="323" height="242" />
</picture>

</p>
<ul>
<li>
<p>资源：用<strong>方框</strong>表示资源的集合，<strong>方框中的圆圈</strong>表示资源；</p>
</li>
<li>
<p>进程：用<strong>圆圈</strong>表示；</p>
</li>
<li>
<p>有向边：</p>
<ul>
<li>
<p>请求资源：箭头由进程指向资源</p>
<p>$$
\bigcirc \rightarrow \Box
$$</p>
</li>
<li>
<p>分配资源：箭头由资源指向进程</p>
<p>$$
\bigcirc \leftarrow \Box
$$</p>
</li>
</ul>
</li>
</ul>
<p>造成死锁的情况有：</p>
<ul>
<li>
<p>进程推进顺序不当：</p>
<p>设有两个互斥资源$A$和$B$被两个并发执行的进程$P_1$和$P_2$共享。假如它们按照如下次序请求，则系统会发生死锁：</p>
<ol>
<li>$P_1.Request(A)$：请求成功，资源$A$被$P_1$占用；</li>
<li>$P_2.Request(B)$：请求成功，资源$B$被$P_2$占用；</li>
<li>$P_1.Request(B)$：请求失败，资源$B$已被$P_2$占用；</li>
<li>$P_2.Request(A)$：请求失败，资源$A$已被$P_1$占用。</li>
</ol>
<blockquote>
<p>上述请求顺序中，1和2的顺序可以交换，3和4的顺序可以交换。</p>
</blockquote>
</li>
<li>
<p>同类资源分配不当：</p>
<ul>
<li>$m$：资源数，</li>
<li>$n$：进程数，</li>
<li>$k$：每个进程都要求的资源数。</li>
</ul>
<p>若满足$m \ge n \times (k-1) + 1$，则不会发生死锁。</p>
<p>若每个进程要求的资源数不同，为$k_i$（$i = 1,2,\cdots,n$），那么此时可能会引起死锁的原因是：</p>
<p>$$
m &lt; \sum_{i=1}^{n}{k_i}
$$</p>
</li>
<li>
<p>PV操作使用不当：</p>
<p>如图：</p>
<p><picture><img class="img-fluid " alt="PV死锁示例" src="/docs/ruan-she/operating-system/uTools_1682767634275.png" loading="lazy" width="577" height="290" />
</picture>

</p>
<p>当信号量$S_1=S_2=0$时将发生死锁。</p>
<ul>
<li>$P_2.P(S_2)$：执行前$S_2 = 0$，执行后$S_2 = -1$，$P_2$等待；</li>
<li>$P_1.P(S_1)$：执行前$S_1 = 0$，执行后$S_1 = -1$，$P_1$等待。</li>
</ul>
<p>此时$P_1$和$P_2$都无法继续运行，造成死锁。</p>
</li>
</ul>
<h3 id="死锁的处理" data-numberify>死锁的处理<a class="anchor ms-1" href="#死锁的处理"></a></h3>
<p>死锁的处理策略主要有4种：</p>
<ul>
<li>鸵鸟策略（不理睬策略）</li>
<li>预防策略</li>
<li>避免策略</li>
<li>检测与解除死锁</li>
</ul>
<p>死锁预防：</p>
<p>死锁预防是<u>采用某种策略限制并发进程对资源的请求，破坏死锁产生的4个必要条件之一，严格防止死锁的产生</u>，使系统在任何时刻都不满足死锁的必要条件。预防死锁的两种策略如下：</p>
<ul>
<li>
<p>预先静态分配法：破坏了“不可剥夺条件”，<u>预先分配所需资源，保证不等待资源</u>。</p>
<p>该方法的问题是降低了对资源的利用率，降低进程的并发程度；有时可能无法预先知道所需资源。</p>
</li>
<li>
<p>资源有序分配法：破坏了“环路条件”，<u>把资源分类按顺序排列，保证不形成环路</u>。</p>
<p>该方法存在的问题是限制进程对资源的请求：由于资源的排序占用系统开销。</p>
</li>
</ul>
<p>死锁避免：</p>
<p>比起死锁预防，<u>死锁避免则不那么严格地限制产生死锁的必要条件</u>。最著名的死锁避免算法是银行家算法，死锁避免算法需要很大的系统开销。</p>
<h3 id="银行家算法" data-numberify>银行家算法<a class="anchor ms-1" href="#银行家算法"></a></h3>
<p>银行家算法对于进程发出的、每一个系统可以满足的<u>资源请求命令加以检测</u>，若分配资源后系统：</p>
<ul>
<li>进入不安全状态，则不予分配；</li>
<li>仍处于安全状态，则实施分配。</li>
</ul>
<p>与死锁预防策略相比，银行家算法提高了资源的利用率，但对于分配资源后系统是否安全的检测，增加了系统开销。</p>
<ul>
<li>
<p>安全状态：指系统能按某种顺序如$&lt;P_1, P_2, \cdots, P_n&gt;$来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。</p>
<p>通常称$&lt;P_1, P_2, \cdots, P_n&gt;$序列为安全序列。</p>
</li>
<li>
<p>不安全状态：若系统不存在这样一个安全序列，则称系统处于不安全状态。</p>
</li>
</ul>
<p>假设系统有$n$个进程（$P_i, i = 1, 2, \cdots, n$），使用银行家算法求系统安全序列的一般步骤为：</p>
<ol>
<li>
<p>根据目前可用资源数和仍需资源数求得序列当前的第$k$（$1 \le k \le n$）个进程应为$P_i$。</p>
<blockquote>
<p>$P_i$的仍需资源数$\le$系统可用资源数。</p>
</blockquote>
</li>
<li>
<p>根据$P_i$的已分配资源数 + 分配前系统可用资源数，求出系统执行完$P_i$后的可用资源数。</p>
<blockquote>
<p>系统执行完$P_4$后，会释放$P_4$占用的资源。</p>
</blockquote>
</li>
<li>
<p>重复执行步骤1到步骤2，直到能判断系统处于安全状态还是不安全状态。若为安全状态，则可求出安全序列。</p>
</li>
</ol>
<p>假设系统种有三类互斥资源$R_1$、$R_2$和$R_3$，可用资源数分别为8、7和4。在$T_0$时刻系统种有$P_1$、$P_2$、$P_3$、$P_4$和$P_5$这5个进程，这些进程对资源的最大需求量和已分配资源数如图：</p>
<p><picture><img class="img-fluid " alt="进程对资源的最大需求量和已分配资源数" src="/docs/ruan-she/operating-system/uTools_1682941260775.png" loading="lazy" width="490" height="231" />
</picture>

</p>
<p>由上图可得系统的仍需资源数（最大需求量 - 已分配资源数）为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>可得系统目前可用资源数（可用资源数 - 所有进程的最大需求量）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>求出安全序列的过程：</p>
<ol>
<li>
<p>根据目前可用资源数和仍需资源数可得序列中第1个进程应为$P_4$。</p>
<blockquote>
<p>因为$P_4$仅仅只需要再分配一个$R_1$，而系统目前恰好剩余1个$R_1$和$R_2$。</p>
</blockquote>
<p>系统执行完$P_4$后，会释放$P_4$占用的资源，那么此时系统可用资源数为（已分配资源数 + 分配前可用资源数）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>与上一步类似，可求得序列中第2个进程为$P_2$或$P_5$。</p>
<ul>
<li>
<p>若为$P_2$，执行完$P_2$后，系统可用资源数为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>若为$P_5$，执行完$P_5$后，系统可用资源数为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>根据上一步，有两个可能的安全序列：</p>
<ul>
<li>若序列的上一个进程为$P_2$，序列的第3个进程为$P_5$。</li>
<li>若序列的上一个进程为$P_5$，序列的第3个进程为$P_2$。</li>
</ul>
<p>此时，无论当前序列为$&lt;P_4, P_2, P_5&gt;$还是$&lt;P_4, P_5, P_2&gt;$，它们执行完序列的第3个进程后，系统可用资源数都为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>根据上一步的系统可用资源数，上一步所得的两个序列的第4个进程都为$P_1$。</p>
<p>此时，它们执行完$P_1$后，系统可用资源数为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>两个序列的第4个进程都为$P_3$。</p>
<p>它们执行完$P_3$后，系统可用资源数为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$R_1$</th>
<th style="text-align:center">$R_2$</th>
<th style="text-align:center">$R_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>此时系统可用资源数与检测前的可用资源数相等，即所有资源都被释放，没有被任何进程占用。</p>
<p>那么该系统处于安全状态，且一共有两个安全序列，分别为：</p>
<ul>
<li>$&lt;P_4, P_2, P_5, P_4, P_3&gt;$；</li>
<li>$&lt;P_4, P_5, P_2, P_4, P_3&gt;$。</li>
</ul>
</li>
</ol>
<h2 id="线程" data-numberify>线程<a class="anchor ms-1" href="#线程"></a></h2>
<blockquote>
<p>传统进程有两个基本属性：</p>
<ul>
<li>可拥有资源的独立单位；</li>
<li>可独立调度和分配的基本单位。</li>
</ul>
</blockquote>
<p>引入线程的原因是，进程的系统必须付出较大的时空开销。引入线程后，将传统进程的两个基本属性分开：</p>
<ul>
<li>线程：作为调度和分配的基本单位；</li>
<li>进程：作为独立分配资源的单位。</li>
</ul>
<p>线程是进程中的一个实体，是被系统独立分配和调度的基本单位。</p>
<p>线程的特点：</p>
<ul>
<li>线程<u>基本上不拥有资源</u>，只拥有一点运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li>
<li>线程<u>也具有就绪、运行和阻塞3种基本状态</u>。</li>
<li><u>线程可创建另一个线程。</u></li>
<li><u>同一个进程中的多个线程可并发执行。</u></li>
</ul>
<p>线程因其具有许多传统进程所具有的特性，故称为&quot;轻型进程（Light-Weight Process）&quot;；而传统进程称为&quot;重型进程（Heavy-Weight Process）&quot;。</p>
<p>线程分为：</p>
<ul>
<li>用户级线程（User-Level Threads）：不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现；</li>
<li>内核支持线程（Kernel-Supported Threads）：依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撤销和切换都利用系统调用来实现。</li>
</ul>
<p>某些系统同时实现了两种类型的线程。</p>
<blockquote>
<p>与线程不同的是，不论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程调度。因此，不论是什么进程都是与内核有关的，是在内核支持下进行切换的。</p>
</blockquote>
<hr>
<h1 id="存储管理" data-numberify>存储管理<a class="anchor ms-1" href="#存储管理"></a></h1>
<h2 id="程序局部性原理" data-numberify>程序局部性原理<a class="anchor ms-1" href="#程序局部性原理"></a></h2>
<p>程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分。相应地，它所访问的存储空间也局限于某个区域内。</p>
<p>程序的局限性表现在以下两个方面：</p>
<ul>
<li>
<p><strong>时间局限性</strong>：</p>
<ul>
<li>如果程序中的某条<u>指令一旦执行</u>，则不久的将来该指令<u>可能再次被执行</u>；</li>
<li>如果某个<u>存储单元被访问</u>，则不久以后该存储单元<u>可能再次被访问</u>。</li>
</ul>
<p>产生时间局限性的典型原因是<u>在程序中存在着大量的循环操作</u>。</p>
</li>
<li>
<p><strong>空间局限性</strong>：指一旦<u>程序访问了某个存储单元</u>，则在不久的将来，<u>其附近的存储单元也最有可能被访问</u>。</p>
<p>即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型原因为<u>程序是顺序执行的</u>。</p>
</li>
</ul>
<h2 id="分页存储管理" data-numberify>分页存储管理<a class="anchor ms-1" href="#分页存储管理"></a></h2>
<p>分页原理：</p>
<ul>
<li><strong>页</strong>：将一个进程的地址空间划分成若干个大小相等的区域，称为页。</li>
<li><strong>块</strong>（<strong>页框</strong>）：将主存空间划分成与页相同大小的若干个物理块，称为块或页框。</li>
</ul>
<p>在为进程分配主存时，将进程中若干页分别装入多个不相邻接的块中。</p>
<p>地址结构：</p>
<p><picture><img class="img-fluid " alt="分页地址结构" src="/docs/ruan-she/operating-system/uTools_1683184749140.png" loading="lazy" width="496" height="55" />
</picture>

</p>
<p>其中，页内地址是同一页（页号）中的偏移量。</p>
<p>分页的过程是由操作系统完成的，对用户是透明的，所以用户不必关心分页的过程，其优点是能有效地提高主存利用率，其缺点是不易实现共享。</p>
<h2 id="分段存储管理" data-numberify>分段存储管理<a class="anchor ms-1" href="#分段存储管理"></a></h2>
<p>在分段存储管理方式中，作业的地址空间被划分为若干个段。每个段是一组完整的逻辑信息，例如有主程序段、子程序段、数据段及堆栈段等。每个段都有自己的名字，都是从0开始编址的一段连续的地址空间，各段的长度是不等的。</p>
<p>分段系统的地址结构如：</p>
<p><picture><img class="img-fluid " alt="分段的地址结构" src="/docs/ruan-she/operating-system/uTools_1683184796335.png" loading="lazy" width="504" height="61" />
</picture>

</p>
<p>段是信息的逻辑单位，其优点是易于实现段的共享，即允许若干个进程共享一个或多个段，而且对段的保护也十分简单。</p>
<h2 id="段页式存储管理" data-numberify>段页式存储管理<a class="anchor ms-1" href="#段页式存储管理"></a></h2>
<p>结合分页和分段存储管理方式，形成一种新的存储管理方式，即段页式存储管理。段页式系统有两种系统的优点。</p>
<p>段页式系统的基本原理是：</p>
<ol>
<li>将整个主存划分成大小相等的存储块（页框）。</li>
<li>将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名。</li>
<li>将每个段划分成若干页，以页框为单位离散分配。</li>
</ol>
<p>段页式地址空间的结构：</p>
<p><picture><img class="img-fluid " alt="段页式的地址结构" src="/docs/ruan-she/operating-system/uTools_1683185435872.png" loading="lazy" width="507" height="59" />
</picture>

</p>
<hr>
<h1 id="设备管理" data-numberify>设备管理<a class="anchor ms-1" href="#设备管理"></a></h1>
<h2 id="缓冲技术" data-numberify>缓冲技术<a class="anchor ms-1" href="#缓冲技术"></a></h2>
<p>缓冲技术可提高外设利用率，尽可能使外设处于忙状态。缓冲技术可以采用两种方式：</p>
<ul>
<li>硬件缓冲：利用专门的硬件寄存器作为缓冲；</li>
<li>软件缓冲：通过操作系统来管理的。</li>
</ul>
<h3 id="单缓冲" data-numberify>单缓冲<a class="anchor ms-1" href="#单缓冲"></a></h3>
<p>单缓冲工作过程图：</p>
<p><picture><img class="img-fluid " alt="单缓冲工作过程图" src="/docs/ruan-she/operating-system/uTools_1683187166221.png" loading="lazy" width="601" height="138" />
</picture>

</p>
<p>当第1块数据送入用户工作区后（进行数据处理），缓冲区是空闲的，可以传送第2块数据（输入）。即第1块数据的处理$C_1$与第2块数据的输入$T_2$是可以并行的，以此类推：</p>
<p><picture><img class="img-fluid " alt="单缓冲并行工作示意图" src="/docs/ruan-she/operating-system/uTools_1683189558038.png" loading="lazy" width="1251" height="272" />
</picture>

</p>
<p>若$T$为输入的时间，$M$为传输的时间，$C$为处理的时间系统对每一块数据的处理时间为：$Max(C, T) + M$：</p>
<ul>
<li>$T &gt; C$：处理时间为$M + T$；</li>
<li>$T &lt; C$：处理时间为$M + C$。</li>
</ul>
<p>$n$个作业的单缓冲所花费的时间为：</p>
<p>$$
(Max(C, T) + M) \times n + Min(C, T)
$$</p>
<h3 id="双缓冲" data-numberify>双缓冲<a class="anchor ms-1" href="#双缓冲"></a></h3>
<p>双缓冲进一步加快了I/O的速度，提高了设备的利用率。其工作基本过程是在设备输入时，先将数据输入到缓冲区1，装满后便转向缓冲区2。</p>
<p>双缓冲工作过程图：</p>
<p><picture><img class="img-fluid " alt="双缓冲工作过程图" src="/docs/ruan-she/operating-system/uTools_1683187304566.png" loading="lazy" width="586" height="141" />
</picture>

</p>
<p>双缓冲的工作特点是，可以实现对缓冲中数据的输入$T$和提取$M$，与CPU的计算$C$，三者并行工作：</p>
<p><picture><img class="img-fluid " alt="双缓冲并行工作示意图" src="/docs/ruan-she/operating-system/uTools_1683189296831.png" loading="lazy" width="1147" height="257" />
</picture>

</p>
<p>在双缓冲时，系统处理一块数据的时间可以粗略地认为是$Max(C, T)$：</p>
<ul>
<li>$C &lt; T$：可使块设备连续输入；</li>
<li>$C &gt; T$：可使系统不必等待设备输入。</li>
</ul>
<p>$n$个作业的双缓冲所花费的时间为：</p>
<p>$$
Max(T, M, C) \times n + T + M + C - Max(T, M, C)
$$</p>
<p>即，</p>
<p>$$
Max(T, M, C) \times (n - 1) + T + M + C
$$</p>
<h2 id="磁盘调度算法" data-numberify>磁盘调度算法<a class="anchor ms-1" href="#磁盘调度算法"></a></h2>
<ul>
<li>
<p><strong>先来先服务</strong>（First-Come First-Served，FCFS）：根据进程请求访问磁盘的先后次序进行调度。</p>
<ul>
<li>优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某进程的请求长期得不到满足的情况。</li>
<li>缺点：此算法由于未对寻道进行优化，致使平均寻道时间可能较长。</li>
</ul>
</li>
<li>
<p><strong>最短寻道时间优先</strong>（Shortest Seek Time First，SSTF，最短移臂算法）：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，使得每次的寻道时间最短。</p>
<ul>
<li>优点：可能会出现饥饿现象。</li>
<li>缺点：不能保证平均寻道时间最短。</li>
</ul>
</li>
<li>
<p><strong>扫描算法</strong>（SCAN，电梯调度算法）：总是从磁头当前位置开始，沿磁头的移动方向去选择离当前磁头最近的那个柱面的请求。如果沿磁头的方向无请求访问时，就改变磁头的移动方向。</p>
<p>在这种调度方法下磁头的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<ul>
<li>优点：避免了饥饿现象的出现。</li>
<li>缺点：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，再从外向里扫描完所有要访问的磁道后才处理该进程的请求，致使该进程的请求被严重地推迟。</li>
</ul>
</li>
<li>
<p><strong>单向扫描算法</strong>（CSCAN，循环扫描算法）：为了减少上述SCAN缺点中存在的这种延迟，算法规定磁头只做单向移动。</p>
<p>例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求访问时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环，进行循环扫描。</p>
</li>
</ul>
<h2 id="旋转调度算法" data-numberify>旋转调度算法<a class="anchor ms-1" href="#旋转调度算法"></a></h2>
<p>旋转调度要考虑的问题是，当移动臂定位后，有多个进程等待访问该柱面时，应当如何决定这些进程的访问顺序。显然，系统应该选择延迟时间最短的进程对磁盘的扇区进行访问。</p>
<p>当有若干等待进程请求访问磁盘上的信息时，旋转调度应考虑如下情况：</p>
<ol>
<li>进程请求访问的是同一磁道上不同编号的扇区。</li>
<li>进程请求访问的是不同磁道上不同编号的扇区。</li>
<li>进程请求访问的是不同磁道上具有相同编号的扇区。</li>
</ol>
<p>对于情况1和2，旋转调度总是让首先到达读/写磁头位置下的扇区先进行传送操作：对于情况3，旋转调度可以任选一个读/写磁头位置下的扇区进行传送操作。</p>
<p>例如：</p>
<p>假设磁盘旋转速度为20ms/圈，每读一个记录后处理需要4ms。若格式化时每个磁道被分为10个扇区，有10个逻辑记录存放在同一磁道上，其排序顺序如下图所示：</p>
<p><picture><img class="img-fluid " alt="旋转调度算法例题排序表" src="/docs/ruan-she/operating-system/uTools_1683254658689.png" loading="lazy" width="799" height="84" />
</picture>

</p>
<p>初始时读写头停在记录A处，程序顺序处理这些记录（A～J）。</p>
<p>顺序处理完这些记录的总时间：</p>
<p><picture><img class="img-fluid " alt="初始逻辑记录分布情况" src="/docs/ruan-she/operating-system/uTools_1683268410250.png" loading="lazy" width="322" height="311" />
</picture>

</p>
<ol>
<li>
<p>经过一个扇区的时间 $= 20ms /10 = 2ms$。</p>
</li>
<li>
<p>处理完A，磁盘转到读写头指向B开始处时，这个过程的时间为$2ms + 20ms = 22ms$。</p>
<p>因为磁盘是一直在旋转的，而读取A扇区（2ms）后，处理A扇区花费4ms。此时磁盘可以再经过两个扇区，来到记录D的开始处。</p>
<p>为了顺序处理记录，磁盘需要再旋转8个扇区回到B开始处。相当于处理完A后磁盘需要再旋转一圈以开始读取B。这样一个过程所耗费的时间即为$2ms + 20ms = 22ms$。</p>
</li>
<li>
<p>顺序处理完所有记录的总时间 $= 9 \times (2ms + 20ms) + 2ms + 4ms = 204ms$。</p>
<p>前9个记录（A～J）的一个过程所耗费的时间是一样的（$ 9 \times (2ms + 20ms)$）。</p>
<p>当处理完记录I并旋转到J开始处时，只需要读取J（2ms）并且处理完（4ms）即可。这个过程的时间应为（$2ms + 4ms$）。</p>
</li>
</ol>
<p>记录优化分布方案：</p>
<p>让下一个要读取的记录，刚好在上一个记录处理完成后读写头所停的扇区。</p>
<p><picture><img class="img-fluid " alt="优化后记录的分布情况" src="/docs/ruan-she/operating-system/uTools_1683268275593.png" loading="lazy" width="370" height="358" />
</picture>

</p>
<p>优化后的总时间 $= 10 \times (2ms + 4ms) = 60ms$。</p>
<p>设$n$个扇区的磁盘，经过一个扇区的时间为$t$，读取一个记录后处理的时间为$c$，那么：</p>
<ul>
<li>
<p>顺序处理完所有记录的总时间为：</p>
<p>$$
(t + nt) (n-1) + t + c
$$</p>
<p>即：</p>
<p>$$
t \times n^2 + c
$$</p>
</li>
<li>
<p>记录优化后的总时间：</p>
<p>$$
n(t + c)
$$</p>
</li>
</ul>
<hr>
<h1 id="文件管理" data-numberify>文件管理<a class="anchor ms-1" href="#文件管理"></a></h1>
<h2 id="多级索引结构" data-numberify>多级索引结构<a class="anchor ms-1" href="#多级索引结构"></a></h2>
<p>磁盘索引是指在索引表中记录磁盘的地址项，地址项直接或间接地记录了磁盘数据块的地址。</p>
<p>磁盘索引有以下几种结构：</p>
<ul>
<li>
<p><strong>直接索引</strong>：索引表中的地址项直接指向磁盘数据块。</p>
<p><picture><img class="img-fluid " alt="直接索引" src="/docs/ruan-she/operating-system/uTools_1683271855209.png" loading="lazy" width="670" height="659" />
</picture>

</p>
</li>
<li>
<p><strong>一级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的记录是地址项，这些地址项直接指向磁盘数据块。</p>
<p>称这个磁盘索引块为<strong>一级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="一级间接地址索引" src="/docs/ruan-she/operating-system/uTools_1683274982800.png" loading="lazy" width="904" height="737" />
</picture>

</p>
</li>
<li>
<p><strong>二级间接地址索引</strong>：索引表中的地址项指向一个磁盘索引块。这个索引块中的一个记录指向一个一级索引块。</p>
<p>称这个记录指向一级索引块的磁盘索引块为<strong>二级索引块</strong>。</p>
<p><picture><img class="img-fluid " alt="二级间接地址索引" src="/docs/ruan-she/operating-system/uTools_1683275164015.png" loading="lazy" width="1121" height="784" />
</picture>

</p>
</li>
</ul>
<h2 id="文件目录" data-numberify>文件目录<a class="anchor ms-1" href="#文件目录"></a></h2>
<ul>
<li>
<p><strong>文件控制块</strong>（FCB）：用于文件的描述和控制的数据结构，实现了文件的“按名存取”。</p>
<p>文件控制块至少要包括文件名和存放文件的物理地址。</p>
<p>文件控制块也称为<strong>文件的说明</strong>或<strong>文件目录项</strong>（简称<strong>目录项</strong>）。</p>
</li>
<li>
<p><strong>文件目录</strong>：文件控制块的有序集合。</p>
<p>即文件目录是由文件控制块组成的，专门用于文件的检索。</p>
</li>
</ul>
<h3 id="文件控制块" data-numberify>文件控制块<a class="anchor ms-1" href="#文件控制块"></a></h3>
<p>文件控制块中包含以下信息：</p>
<ul>
<li>
<p>基本信息类：例如文件名、文件的物理地址、文件长度和文件块数等。</p>
</li>
<li>
<p>存取控制信息类：文件的存取权限。</p>
<p>UNIX中，用户分成三类：</p>
<ul>
<li>文件主用户</li>
<li>同组用户</li>
<li>一般用户</li>
</ul>
<p>以上三类用户对文件的权限为：</p>
<ul>
<li>读</li>
<li>写</li>
<li>执行</li>
</ul>
</li>
<li>
<p>使用信息类：文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的
信息（如打开文件的进程数、在文件上的等待队列）等。</p>
</li>
</ul>
<h3 id="目录结构" data-numberify>目录结构<a class="anchor ms-1" href="#目录结构"></a></h3>
<p>组织好文件的目录是设计文件系统的重要环节，文件目录结构的组织方式直接影响到文件的存取速度，关系到文件的共享性和安全性。</p>
<p>常见的目录结构有：</p>
<ul>
<li>
<p><strong>一级目录结构</strong>：一级目录的整个目录组织是一个<u>线性结构</u>，在整个系统中<u>只需建立一张目录表</u>，系统为每个文件分配一个目录项。</p>
<p>优点：结构简单；</p>
<p>缺点：查找速度慢，不允许重名和不便于实现文件共享等。</p>
<p>主要用在单用户环境中。</p>
</li>
<li>
<p><strong>二级目录结构</strong>：为了克服一级目录结构存在的缺点引入了二级目录结构。</p>
<p>二级目录结构的组成为：</p>
<ul>
<li><strong>主文件目录</strong>（Master File Directory，MFD）：每个用户文件目录都占有一个目录项，其目录项中包括用户名和指向该用户目录文件的指针；</li>
<li><strong>用户目录</strong>（User File Directory，UFD）：由用户所有文件的目录项组成的。</li>
</ul>
<p>优点：提高了检索目录的速度，较好地解决了重名问题。</p>
<p>缺点：该结构虽然能有效地将多个用户隔离开（这种隔离在各个用户之间完全无关时是一个优点），但当多个用户之间要相互合作去共同完成一个大任务，且一个用户又需要去访问其他用户的文件时，这种隔离便成为一个缺点，因为这种隔离使诸用户之间不便于共享文件。</p>
</li>
<li>
<p><strong>多级目录结构</strong>：在多道程序设计系统中常采用多级目录结构。</p>
<p>多级目录结构是树型目录结构。从根结点向下，每一个结点是一个目录，叶结点是文件。</p>
<p>在采用多级目录结构的文件系统中，用户要访问一个文件，必须指出文件所在的路径名：</p>
<ul>
<li>
<p><strong>路径名</strong>：从某个目录开始到该文件的通路上所有各级目录名拼起来得到的。</p>
<p>在各目录名之间、目录名与文件名之间需要用分隔符隔开。</p>
</li>
<li>
<p><strong>绝对路径名</strong>（Absolute Path Name）：指从根目录开始的完整路径。</p>
<p><strong>全文件名</strong>：指绝对路径名加上该文件的文件名。</p>
</li>
<li>
<p><strong>相对路径名</strong>：从当前所在目录开始到其他目录或文件的路径。</p>
</li>
</ul>
</li>
</ul>
<h2 id="位示图" data-numberify>位示图<a class="anchor ms-1" href="#位示图"></a></h2>
<p>位示图（Bitmap）是一种空闲空间管理方法。通过在外存上建立一张位示图，记录文件存储器的使用情况。</p>
<p>位示图用二进制的一位来表示一个物理块的使用情况：</p>
<ul>
<li><code>0</code>：表示空闲；</li>
<li><code>1</code>：表示占用。</li>
</ul>
<p>例如：</p>
<p><picture><img class="img-fluid " alt="位示图示例" src="/docs/ruan-she/operating-system/uTools_1683253664111.png" loading="lazy" width="569" height="256" />
</picture>

</p>
<p>位示图的大小由磁盘空间的大小（物理块总数）决定。</p>
<p>位示图的描述能力强，适合各种物理结构。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>数据结构篇</title>
      <link>/docs/ruan-she/data-structure/</link>
      <pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/ruan-she/data-structure/</guid>
      <description><![CDATA[复杂度 算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应]]></description>
      <content:encoded><![CDATA[<h1 id="复杂度" data-numberify>复杂度<a class="anchor ms-1" href="#复杂度"></a></h1>
<p>算法时间复杂度以算法中基本操附重复执行的次数（简称为频度）作为算法的时间度量。一般不必要精确计算出算法的时间复杂度，只要大致计算出相应的数量级即可，使用大$O$表示法表示（空间复杂度也是）。</p>
<ul>
<li>加法规则：多项相加，保留最高阶项，并将系数化为1；</li>
<li>乘法规则：多项相乘都保留，并将系数化为1。</li>
</ul>
<p><picture><img class="img-fluid " alt="算法复杂度大小比较" src="/docs/ruan-she/data-structure/1681099842666.png" loading="lazy" width="1014" height="100" />
</picture>

</p>
<p>递归式的时间（空间）复杂度：</p>
<p>$$
递归的次数 \times 每次递归的时间（空间）复杂度
$$</p>
<h1 id="逻辑结构分类" data-numberify>逻辑结构分类<a class="anchor ms-1" href="#逻辑结构分类"></a></h1>
<ul>
<li>线性结构
<ul>
<li>线性表（一般线性表）</li>
<li>特殊线性表
<ul>
<li>栈</li>
<li>队列</li>
<li>字符串</li>
</ul>
</li>
<li>线性表的推广
<ul>
<li>数组</li>
<li>广义表</li>
</ul>
</li>
</ul>
</li>
<li>非线性结构
<ul>
<li>树结构
<ul>
<li>二叉树</li>
<li>多叉树</li>
</ul>
</li>
<li>图结构
<ul>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
<li>集合结构</li>
</ul>
</li>
</ul>
<hr>
<h1 id="线性表" data-numberify>线性表<a class="anchor ms-1" href="#线性表"></a></h1>
<p><u>由 $n(n \geq 0)$ 个<strong>数据特性相同</strong>的元素构成的<strong>有限序列</strong>称为<strong>线性表</strong></u>。$n=0$ 时，称为空表。非空表的特点如下：</p>
<ul>
<li>存在唯一一个“第一个”元素。</li>
<li>存在唯一一个“最后一个”元素。</li>
<li>相邻元素之间存在序偶关系：
<ul>
<li>除第一个之外，结构中的每个数据元素均只有一个<strong>前驱</strong>；</li>
<li>除最后一个之外，结构中的每个数据元素均只有一个<strong>后继</strong>。</li>
</ul>
</li>
</ul>
<p>线性表的存储结构分为：</p>
<ul>
<li>顺序存储；</li>
<li>链式存储</li>
</ul>
<h2 id="顺序存储结构" data-numberify>顺序存储结构<a class="anchor ms-1" href="#顺序存储结构"></a></h2>
<p>线性表的<strong>顺序存储</strong>是指用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。在这种存储方式下，元素间的逻辑关系无须占用额外的空间来存储。</p>
<p>其存储结构如图所示：</p>
<p><picture><img class="img-fluid " alt="顺序表存储结构" src="/docs/ruan-she/data-structure/uTools_1680610120418.png" loading="lazy" width="130" height="266" />
</picture>

</p>
<p>假设线性表的每个元素占用的存储空间为$L$，$LOC(a_i)$为第$i$个元素的存储位置（$0 \le i \le n-1$，$n$为线性表的长度）：</p>
<ul>
<li>
<p>第$i+1$个元素和第$i$个元素的存储位置满足：</p>
<p>$$
LOC(a_{i+1})=LOC(a_i)+L
$$</p>
</li>
<li>
<p>第$i$个元素的存储位置：</p>
<p>$$
LOC(a_i)=LOC(a_0) + i \times L
$$</p>
<p>如果下标从1开始：</p>
<p>$$
LOC(a_i)=LOC(a_1) + (i-1) \times L
$$</p>
</li>
</ul>
<p>顺序存储结构的线性表的特点：</p>
<ul>
<li>优点：<strong>可以随机存取表中的元素</strong>，不需要额外的存储空间来表达元素之间的逻辑关系；</li>
<li>缺点：<strong>插入和删除操作不方便、效率低、比较耗时</strong>（<strong>插入和删除操作需要移动元素</strong>），顺序表的长度是固定的。</li>
</ul>
<p>在表为$n$的线性表中，有$n+1$个插入位置（不考虑插入是否会导致溢出）：</p>
<ul>
<li>
<p>在第$i$个插入位置插入，需要移动$n+1-i$个元素。</p>
<ul>
<li>在第1个位置插入（$a_1$）需要移动$n$个元素；</li>
<li>在第$n+1$个位置插入（$a_n$后面）不需要移动元素。</li>
</ul>
</li>
<li>
<p>设在第$i$个插入位置插入的概率为$p_i$，<u>等概率下</u>（假如这$n+1$个插入位置插入的概率相同）<u>插入</u>一个新元素需要移动的元素个数的<u>期望值$E_{insert}$</u>为：</p>
<p>$$
E_{insert} = \sum_{i=1}^{n+1}{ \Big( p_i \times (n-i+1) \Big) } = \cfrac{1}{n+1} \sum_{i=1}^{n+1}{(n-i+1)} = \cfrac{n+1}{2}
$$</p>
<p>$$
p_i = \cfrac{1}{n+1}
$$</p>
<p>即，$E_{insert} = \cfrac{插入位置数-1}{2} = \cfrac{n+1}{2}$</p>
</li>
</ul>
<p>在表长为$n$的线性表中删除元素时，共有$n$个可删除的元素：</p>
<ul>
<li>
<p>删除第$i$个元素$a_i$需要移动$n-i$个元素。</p>
<ul>
<li>删除元素$a_1$需要移动$n-1$个元素；</li>
<li>删除元素$a_n$不需要移动元素。</li>
</ul>
</li>
<li>
<p>设$a_i$被删除的概率为$q_i$，<u>等概率下删除元素</u>时需要移动的元素个数的<u>期望值$E_{delete}$</u>为：</p>
<p>$$
E_{delete} = \sum_{i=1}^{n}{\Big( q_i \times (n-i) \Big)} = \cfrac{1}{n} \sum_{i=1}^{n}{(n-i)} = \cfrac{n-1}{2}
$$</p>
<p>$$
q_i = \cfrac{1}{n}
$$</p>
<p>即，$E_{delete} = \cfrac{删除位置数}{2} = \cfrac{n-1}{2}$</p>
</li>
</ul>
<p><strong>插入操作时间复杂度</strong>：</p>
<ul>
<li>最好情况（在第$n+1$个位置插入）：$O(1)$；</li>
<li>最坏情况（在第1个位置插入）：$O(n)$；</li>
<li>平均复杂度：$O(n)$。</li>
</ul>
<p><strong>查找元素时间复杂度</strong>（根据下标查找）：$O(1)$。</p>
<blockquote>
<p>累加求和公式：</p>
<p>$$
\sum_{i=0}^{n} i = \cfrac{n(1+n)}{2}
$$</p>
<p>即等差数列求和中的：</p>
<p>$$
S_n = \cfrac{n(a_1 + a_n)}{2}
$$</p>
</blockquote>
<h2 id="链式存储结构" data-numberify>链式存储结构<a class="anchor ms-1" href="#链式存储结构"></a></h2>
<p>线性表的<strong>链式存储</strong>是指<strong>通过指针链接起来</strong>的结点来存储数据元素。</p>
<p>其存储结构如下所示：</p>
<p><picture><img class="img-fluid " alt="链式表存储结构" src="/docs/ruan-she/data-structure/uTools_1680610469403.png" loading="lazy" width="403" height="49" />
</picture>

</p>
<ul>
<li>
<p><strong>数据域</strong>：用于存储数据元素的<strong>值</strong>；</p>
</li>
<li>
<p><strong>指针域</strong>：用于存储当前元素的直接前驱或直接后继的<strong>位置信息</strong>（直接前或后驱的<strong>指针</strong>，称其为指针或链）。</p>
<p>存储各数据元素的结点的<u>地址并不要求是连续的</u>，因此存储数据元素的同时必须存储元素之间的逻辑关系。</p>
</li>
</ul>
<p>链式表的特点：</p>
<ul>
<li><u>结点空间只有在需要的时候才申请</u>，无须事先分配；</li>
<li>长度不固定。</li>
</ul>
<p>链式表结点之间通过指针域构成一个链表，<u>若结点中只有一个指针域，则称为线性链表</u>。</p>
<p><picture><img class="img-fluid " alt="链式表存储结构" src="/docs/ruan-she/data-structure/uTools_1680610514354.png" loading="lazy" width="685" height="64" />
</picture>

</p>
<p>上图中的Head：一个指向链表第一个结点的针，称为头指针。使用它就可以顺序地访问到表中的任意一个元素。</p>
<p>插入和删除操作时间复杂度（带不带头节点的复杂度都一样）：</p>
<ul>
<li>最好情况（在$i=1$位置）：$O(1)$；</li>
<li>最坏情况（在$n+1$位置插入/删除$n$位置）：$O(n)$</li>
<li>平均复杂度：$O(n)$</li>
</ul>
<p>链表操作的时间复杂度取决于指针遍历。</p>
<hr>
<h1 id="栈" data-numberify>栈<a class="anchor ms-1" href="#栈"></a></h1>
<p>栈是一种<strong>后入先出</strong>（Last In First Out，LIFO）的线性表。<u>栈只能通过访问它的一端来实现数据存储和检索。</u></p>
<p>栈的基本操作有：</p>
<ul>
<li><strong>入栈</strong>：将元素置入栈顶；</li>
<li><strong>出栈</strong>：将元素从栈顶中取出。</li>
<li>读取栈顶元素</li>
</ul>
<p>栈的出栈顺序一定和入栈顺序<strong>相反</strong>。</p>
<h2 id="顺序存储结构-1" data-numberify>顺序存储结构<a class="anchor ms-1" href="#顺序存储结构-1"></a></h2>
<p>栈的顺序存储结构也称为<strong>顺序栈</strong>。</p>
<p>顺序栈使用一个栈顶指针标记栈顶元素的索引位置。每次出栈时都需要重置栈顶指针，将栈顶指针向下移动，标记到新的栈顶元素。</p>
<p>顺序栈的空间容量有限，所以每次入栈时都需要判断栈是否为满。</p>
<h2 id="链式存储结构-1" data-numberify>链式存储结构<a class="anchor ms-1" href="#链式存储结构-1"></a></h2>
<p>栈的链式存储结构称为<strong>链栈</strong>。链栈的头指针就是栈顶指针。</p>
<p><picture><img class="img-fluid " alt="链栈的存储结构" src="/docs/ruan-she/data-structure/uTools_1680676944766.png" loading="lazy" width="238" height="265" />
</picture>

</p>
<h2 id="栈的应用" data-numberify>栈的应用<a class="anchor ms-1" href="#栈的应用"></a></h2>
<p>栈的典型应用包括<strong>表达式求值、括号匹配</strong>等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈有重要的作用。</p>
<hr>
<h1 id="队列" data-numberify>队列<a class="anchor ms-1" href="#队列"></a></h1>
<p>队列是一种<strong>先入先出</strong>（First In First Out，FIFO）的线性表。</p>
<p><u>队列只允许在表的一端插入元素，在表的另一端删除元素。</u></p>
<ul>
<li><strong>队头</strong>（Front）：允许<strong>删除</strong>元素的一端；</li>
<li><strong>队尾</strong>（Rear）：允许<strong>插入</strong>元素的一端。</li>
</ul>
<p>队列的基本操作有：</p>
<ul>
<li><strong>入队</strong>：将元素加入到队尾；</li>
<li><strong>出队</strong>：将元素加入到对头。</li>
</ul>
<p>队列的入队顺序一定<strong>等于</strong>出队顺序。</p>
<blockquote>
<p>使用两个栈可以来模拟一个队列（从一个栈出栈后的元素入另一个栈后再出栈）。</p>
</blockquote>
<h2 id="顺序存储结构-2" data-numberify>顺序存储结构<a class="anchor ms-1" href="#顺序存储结构-2"></a></h2>
<p>队列的顺序存储结构称为<strong>顺序队列</strong>。</p>
<p>顺序队列设置两个指针：</p>
<ul>
<li>队头指针：指向对头元素的下标；</li>
<li>队尾指针：指向队尾元素的下标。</li>
</ul>
<p>如果顺序队列只按照数组下标大小顺序来设置指针（对头指针的值永不大于队尾指针），那么在经过一段时间的操作后，对头指针有可能指向的并不是数组的第一个元素，此时队列的长度永远都到达不了数组的长度（空间无法被充分利用，实际使用的长度和逻辑长度不符）。</p>
<p><picture><img class="img-fluid " alt="队列操作" src="/docs/ruan-she/data-structure/uTools_1680677900098.png" loading="lazy" width="959" height="323" />
</picture>

</p>
<p>为了解决这个问题，我们可以把数组想象为一个环型的结构（将最后一个元素和第一个元素连接起来，队头指针可以比队尾指针大）。如果此时队列的状态是上图中步骤$(e)$的状态，此时再插入元素，可以将元素放在数组索引0的位置，再让队尾指针始终保持在队列最后一个元素的索引之后即可。将这种队列称为<strong>循环队列</strong>，如：</p>
<p><picture><img class="img-fluid " alt="循环队列" src="/docs/ruan-she/data-structure/uTools_1680678225885.png" loading="lazy" width="907" height="202" />
</picture>

</p>
<h2 id="链式存储结构-2" data-numberify>链式存储结构<a class="anchor ms-1" href="#链式存储结构-2"></a></h2>
<p>队列的链式存储也称为<strong>链队列</strong>（<strong>链队</strong>）。这里为了便于操作，可以给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件是头指针和尾指针的值相同，且
均指向头结点。</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/data-structure/uTools_1680678441791.png" loading="lazy" width="278" height="340" />
</picture>

</p>
<h2 id="队列的应用" data-numberify>队列的应用<a class="anchor ms-1" href="#队列的应用"></a></h2>
<p>队列结构常用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。</p>
<hr>
<h1 id="串" data-numberify>串<a class="anchor ms-1" href="#串"></a></h1>
<p><strong>串</strong>（<strong>字符串</strong>）是一种<strong>特殊的线性表</strong>，其<strong>数据元素为字符</strong>。</p>
<p>串具有自身的特性，运算时常常把一个串作为一个整体来处理。</p>
<p>串的基本概念和操作：</p>
<ul>
<li>
<p><strong>空串</strong>：长度为0的串；</p>
</li>
<li>
<p><strong>子串</strong>：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。</p>
</li>
<li>
<p><strong>串相等</strong>：指两个串长度相等且对应序号的字符也相同。</p>
</li>
<li>
<p><strong>串比较</strong>：两个串比较大小时以字符的ASCⅡ码值（或其他字符编码集合）作为依据。</p>
<p>实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串先结束，则以串长较大者为大。</p>
</li>
<li>
<p>赋值：</p>
<ul>
<li>拷贝赋值：将一个串的值赋给另一个串；</li>
<li>引用（地址）赋值：将一个串的引用（地址）赋给另一个串。那么这个串可以使用另一个串中的值，但是对这个串所做的操作，也会作用到另一个串。</li>
</ul>
</li>
<li>
<p><strong>连接串</strong>：将一个串插入到另一个串尾。</p>
</li>
<li>
<p><strong>插入串</strong>：将一个串插入到另一个串的任意位置中。</p>
</li>
</ul>
<h2 id="顺序存储结构-3" data-numberify>顺序存储结构<a class="anchor ms-1" href="#顺序存储结构-3"></a></h2>
<p>串的顺序存储结构是一种定长的串（类似顺序表）。</p>
<h2 id="链式存储结构-3" data-numberify>链式存储结构<a class="anchor ms-1" href="#链式存储结构-3"></a></h2>
<p>串的链式存储结构可以方便地对串进行插入删除操作（类似链表）。</p>
<h2 id="串的模式匹配" data-numberify>串的模式匹配<a class="anchor ms-1" href="#串的模式匹配"></a></h2>
<p>子串的定位操作通常称为串的模式匹配。子串也称为模式串。</p>
<p>有关串模式匹配算法的详细讲解可以查看：<a href="../%e7%bb%8f%e5%85%b8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d">经典字符串匹配</a></p>
<h3 id="朴素的模式匹配算法" data-numberify>朴素的模式匹配算法<a class="anchor ms-1" href="#朴素的模式匹配算法"></a></h3>
<p>朴素的模式匹配算法也称为布鲁特一福斯算法（即暴力匹配算法），其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符依次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。</p>
<p>设主串和模式串的长度分别为$n$和$m$，算法时间复杂度和比较次数：</p>
<ul>
<li>
<p>最好情况：$O(m)$，次数为$m$；</p>
</li>
<li>
<p>最坏情况：$O(n \times m)$，次数为$\cfrac{1}{2} m(n-m+2)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i\big( (i+1) \times m \big)} = \cfrac{m}{n-m+1} \sum_{i=0}^{n-m}{(i+1)} = \cfrac{1}{2} m(n-m+2)
$$</p>
</li>
<li>
<p>平均：$O(n+m)$，次数为$\cfrac{1}{2} (n+m)$：</p>
<p>$$
\sum_{i=0}^{n-m}{p_i(i+m)} = \cfrac{1}{n-m+1} \sum_{i=0}^{n-m}{i+m} = \cfrac{1}{2} (n+m)
$$</p>
</li>
</ul>
<h3 id="kmp-算法" data-numberify>KMP 算法<a class="anchor ms-1" href="#kmp-算法"></a></h3>
<p>KMP算法又称为改进的模式匹配算法。</p>
<ul>
<li>串的<strong>前缀</strong>：包含第一个字符，且不包含最后一个字符的子串；</li>
<li>串的<strong>后缀</strong>：包含最后一个字符，且不包含第一个字符的子串。</li>
<li>前缀集合：包含串的所有前缀的集合；</li>
<li>后缀集合：包含串的所有后缀的集合。</li>
</ul>
<p>KMP的重点是求模式串字符的next值（失配指针$Next[\ i\ ]$），假设$a_{i-1}$为当前要求next值的模式串字符：</p>
<ul>
<li>
<p>前缀集合：</p>
<p>$$
Prefix=\{p_0,p_0p_1,\cdots,p_0&hellip;p_{i-1}\}
$$</p>
</li>
<li>
<p>后缀集合：</p>
<p>$$
Postfix=\{p_{i-1},p_{i-2}p_{i-1},\cdots,p_1&hellip;p_{i-1}\}
$$</p>
</li>
<li>
<p>失配指针：</p>
<p>$$
Next[i] =
\begin{cases}
-1 &amp; 当\ i=0 时 \\
max &amp; \{ k|0&lt;k&lt;i 且 &ldquo;p_0\cdots p_{k-1}&rdquo; = &ldquo;p_{i-k}\cdots p_{i-1}&rdquo; \} \\
0 &amp; 其他情况
\end{cases}
$$</p>
<p>即：</p>
<ul>
<li>$Next[0] = -1$；</li>
<li>$Next[i] = maxLen(Prefix \cap Postfix)$</li>
</ul>
<p>可以解释为：</p>
<p>$$
Next[\ i\ ] = 前i个子串的最长相同前后缀的长度
$$</p>
<p>特殊情况：$Next[\ 1\ ] = 0$，因为其前缀集合和后缀集合都为空。</p>
</li>
</ul>
<blockquote>
<p>失配表是用来指示匹配失败后指针该如何移动的。</p>
<p>失配表的建立跟要匹配的串没有任何关系，仅跟模式串有关。</p>
</blockquote>
<hr>
<h1 id="多维数组" data-numberify>多维数组<a class="anchor ms-1" href="#多维数组"></a></h1>
<p>多维数组是定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。多维数组是一种“同构”的数据结构，其每个数据元素类型相同、结构一致。</p>
<ul>
<li>
<p>一维数组：即线性表。</p>
</li>
<li>
<p>二维数组（仅讨论顺序存储结构）：</p>
<p>二维数组的存储结构（如下图），可以分为以行为主序（下图左边）和以列为主序（下图右边）两种。</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/data-structure/uTools_1680693946560.png" loading="lazy" width="451" height="448" />
</picture>

</p>
<p>设：</p>
<ul>
<li>二维数组为$A[n,m]$，$n$为行数，$m$为列数；</li>
<li>数组元素$a_{i,j},\ 0 \le i \le n-1,\ 0 \le j \le m-1$；</li>
<li>$LOC(a_{i,j})$为元素$a_{i,j}$的地址；</li>
<li>$L$为单个元素的存储空间大小。</li>
</ul>
<p>则有：</p>
<ul>
<li>
<p>以行为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i \times n + j) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) \times n + (j-1) \big) \times L
$$</p>
</li>
<li>
<p>以列为主序优先存储：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{0,0}) + (i + j \times m) \times L
$$</p>
<p>如果下标从1开始（$1 \le i \le n,\ 1 \le j \le m$）：</p>
<p>$$
LOC(a_{i,j}) = LOC(a_{1,1}) + \big( (i-1) + (j-1) \times m \big) \times L
$$</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>优先存储说法问题：</p>
<p>以行为主序优先存储的意思应该是在内存中按行存储。以列为主序优先存储的意思应该是在内存中按列存储。</p>
<p>假设一个二维数组为：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\
a_{51} &amp; a_{52} &amp; a_{53} &amp; a_{54}
\end{vmatrix}
$$</p>
<p>按照以行为主序优先存储的公式，它在内存中应该是分为了5个地址连续的数组来存储。即内存中，$[a_{11},a_{12},a_{13},a_{14}]$为一个数组，其后再接一个数组$[a_{12},a_{22},a_{23},a_{24}]$，以此类推，在内存中按照列的元素作为一个连续的一维数组单位，再按照第1行后接第2行作为整个连续的二维数组。它们在内存中的地址顺序是：</p>
<p>$$
a_{11},a_{12},&hellip;,a_{14},\\
a_{21},&hellip;,a_{24},\\
a_{31},&hellip;,a_{34},\\
a_{41},&hellip;,a_{44},\\
a_{51},&hellip;,a_{54}
$$</p>
<p>那么以列为主序优先存储的地址顺序就为：</p>
<p>$$
a_{11},a_{21},&hellip;,a_{51},\\
a_{12},&hellip;,a_{52},\\
a_{13},&hellip;,a_{53},\\
a_{14},&hellip;,a_{54}
$$</p>
</blockquote>
<p>一般矩阵都用二维数组来表示，但是对于一些特殊矩阵，如对称矩阵、三角矩阵和对角矩阵。它们的非0元素的分布存在一定规律，所以可以将其压缩存储在一维数组中，并且它们的多个值相同的元素（按照对应特殊矩阵定义上的值相同，并非简单的值相同）只分配一个存储单位。</p>
<h2 id="对称矩阵" data-numberify>对称矩阵<a class="anchor ms-1" href="#对称矩阵"></a></h2>
<p>若矩阵$A_{n \times n}$中的元素特点为$a_{ij}=a_{ji}\ (1 \le i,j \le n)$，则称之为$n$阶对称矩阵。</p>
<p>对称矩阵$A_{n \times n}$：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{vmatrix}
$$</p>
<p>其中以对角线划分为三个区域：</p>
<ul>
<li>
<p><strong>主对角线</strong>：$a{11},a_{22},\cdots,a_{nn}$，共有$n$个元素；</p>
</li>
<li>
<p><strong>上三角区</strong>：对角线以上的所有元素，即：</p>
<p>$$
\begin{vmatrix}
0 &amp; a_{12} &amp; a_{13} &amp; \cdots &amp; a_{1n} \\
0 &amp; 0 &amp; a_{23} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; a_{(n-1)n} \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0
\end{vmatrix}
$$</p>
</li>
<li>
<p><strong>下三角区</strong>：对角线以下的所有元素，和上三角区的个数相等并且重复。</p>
</li>
</ul>
<p>可以将对称矩阵中，$n^2$个元素压缩存储到$\cfrac{n(n+1)}{2}$个元素的存储空间中。一般是存储下三角区和对角线。</p>
<p>假设将$n$阶对称矩阵$A_{n \times n}$压缩存储到一维数组$B\left[ \cfrac{n(n+1)}{2} \right]$，则$B[k]\ (1 \le k \le \cfrac{n(n+1)}{2})$与矩阵元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$之间存在一一对应关系（以行为主序）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i-1)}{2} + j, &amp; 当\ i \ge j \\
\cfrac{j(j-1)}{2} + i, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<p>如果下标从0开始（第一个元素为$a_{00}$，$0 \le k \le \cfrac{n(n+1)}{2} - 1$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k =
\begin{cases}
\cfrac{i(i+1)}{2} + j + 1, &amp; 当\ i \ge j \\
\cfrac{j(j+1)}{2} + i + 1, &amp; 当\ i &lt; j
\end{cases}
$$</p>
<blockquote>
<p>为什么$length(B) = \cfrac{n(n+1)}{2}$（压缩存储的一维数组大小）：</p>
<p>主对角线的元素的大小为$n$，下三角区的对角线大小分别为$n-1,n-2,&hellip;,1$。即：
$$
length(B) = \sum_{i=1}^{n}{i} = \cfrac{n(n+1)}{2}
$$</p>
</blockquote>
<blockquote>
<p>PS：《软件设计师教程（第五版）》中一维数组的下标$k$的取值范围错了：</p>
<p><picture><img class="img-fluid " alt="对称矩阵" src="/docs/ruan-she/data-structure/1680698007514.png" loading="lazy" width="999" height="344" />
</picture>


很明显不是$\left[ 1, \cfrac{n(n+1)}{2} \right)$，而应该是$\left[ 1, \cfrac{n(n+1)}{2} \right]$。</p>
</blockquote>
<h2 id="三对角矩阵" data-numberify>三对角矩阵<a class="anchor ms-1" href="#三对角矩阵"></a></h2>
<p>对角矩阵是指矩阵中的<u>非0元素都集中在以主对角线为中心的带状区域中</u>，即除了主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。三对角矩阵是对角矩阵中的一种，包括主对角线和在主对角线上、下方的各一条对角为非0元素：</p>
<p>$$
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; 0      &amp; \cdots &amp; 0              &amp; 0          \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; \cdots &amp; 0              &amp; 0          \\
0      &amp; a_{32} &amp; a_{33} &amp; \cdots &amp; 0              &amp; 0          \\
0      &amp; 0      &amp; a_{43} &amp; \cdots &amp; 0              &amp; 0          \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots         &amp; \vdots     \\
0      &amp; 0      &amp; 0      &amp; \cdots &amp; a_{(n-1)(n-1)} &amp; a_{(n-1)n} \\
0      &amp; 0      &amp; 0      &amp; \cdots &amp; a_{n(n-1)}     &amp; a_{nn}
\end{vmatrix}
$$</p>
<p>设有$n$阶三对角矩阵$A_{n \times n}$，将其非0元素$a_{ij}(a_{ji})\ (1 \le i,j \le n)$存储在一维数组$B[k](1 \le k \le 3 \times n - 2)$中，则元素位置之间的对应关系为：</p>
<p>$$
k = 3 \times (i-1) - 1 + j - i + 1 + 1 = 2i + j -2
$$</p>
<p>如果下标从0开始（$0 \le k \le 3(n-1)$，并且$0 \le i,j \le n-1$）：</p>
<p>$$
k = 3 \times i - 1 + j - i + 1 + 1 = 2i + j + 1
$$</p>
<h2 id="稀疏矩阵" data-numberify>稀疏矩阵<a class="anchor ms-1" href="#稀疏矩阵"></a></h2>
<p>在一个矩阵中，若<u>非0元素的个数远远少于0元素的个数，且非0元素的分布<strong>没有规律</strong></u>，则称之为稀疏矩阵。</p>
<p>对于稀疏矩阵，存储非0元素时<strong>必须同时存储其位置</strong>（即行号和列号），用<u>三元组$(i,j,a_{ij})$可唯一确定矩阵$A$中的一个元素</u>。</p>
<p>可以用三元组表来存储这些三元组。稀疏矩阵的三元组表的顺序存储结构称为<strong>三元组顺序表</strong>，常用的三元组表的链式存储结构是<strong>十字链表</strong>。</p>
<hr>
<h1 id="树" data-numberify>树<a class="anchor ms-1" href="#树"></a></h1>
<p><strong>树</strong>结构是一种<strong>非线性结构</strong>，该结构中的一个数据元素可以有<strong>两个或两个以上的直接后继</strong>元素。</p>
<p><strong>树</strong>（Tree）是 $n(n\ge0)$ 个结点的有限集。</p>
<ul>
<li><strong>空树</strong>：$n=0$；</li>
<li><strong>非空树</strong>：$n&gt;0$，
<ul>
<li>有且仅有一个<strong>根结点</strong>，</li>
<li>除根节点外的其余结点可分为 $m(m&gt;0)$ 个互不相交的集合，即<strong>子树</strong>（SubTree）$T_1,T_2,\cdots,T_m$。</li>
</ul>
</li>
</ul>
<p>树的定义是<strong>递归</strong>的：</p>
<ul>
<li>一棵树由若干棵子树构成；</li>
<li>子树又由更小的子树构成。</li>
</ul>
<h2 id="基本概念" data-numberify>基本概念<a class="anchor ms-1" href="#基本概念"></a></h2>
<h3 id="术语" data-numberify>术语<a class="anchor ms-1" href="#术语"></a></h3>
<ul>
<li><strong>度</strong>：结点拥有的子树数。整个树的度是树内各结点度的最大值。</li>
<li><strong>叶结点</strong>：度为 0 的结点，也称<strong>终端结点</strong>。</li>
<li><strong>非终端结点</strong>：度不为 0 的结点，也称<strong>分支结点</strong>。</li>
<li><strong>内部结点</strong>：除根节点外的非终端结点。</li>
<li><strong>子节点</strong>：结点<u>子树的根结点</u>。</li>
<li><strong>父结点</strong>：与子结点相连的上一层的唯一一个结点。</li>
<li><strong>兄弟结点</strong>：同一个父节点的子节点之间互为兄弟。</li>
<li><strong>祖先结点</strong>：从根结点到该结点所经分支上的所有结点（包括其父节点，但不包括其本身）。</li>
<li><strong>子孙结点</strong>：以某结点为根的子树中的所有结点。</li>
<li><strong>堂兄弟结点</strong>：父节点在同一层（但不是同一个）的结点互为堂兄弟。</li>
<li><strong>层次</strong>：以根结点为第一层，根的子节点为第二层 …… 树中任意结点的层次等于其父节点的层次加 1。</li>
<li><strong>树的高度</strong>：树中结点的最大层次，也称<strong>树的深度</strong>。</li>
<li><strong>森林</strong>：是 $m(m\ge0)$ 棵互不相交的树的集合。树中每个结点的子树的集合即为森林。</li>
</ul>
<h3 id="树的类型" data-numberify>树的类型<a class="anchor ms-1" href="#树的类型"></a></h3>
<ul>
<li><strong>有序树</strong>：树中结点的各子树从左到右是有次序的，即不能互换。</li>
<li><strong>无序树</strong>：树中结点的各子树相互之间可以互换，没有次序。</li>
</ul>
<h3 id="树的性质" data-numberify>树的性质<a class="anchor ms-1" href="#树的性质"></a></h3>
<ul>
<li>
<p>设$n$个结点的树，$d_i \ (1 \le i \le n)$为该树中结点的度：</p>
<p>$$
n = (\sum_{i=1}^{n}{d_i})+1
$$</p>
</li>
<li>
<p>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点（$i \ge 1$）。</p>
</li>
<li>
<p>高度为$h$的$m$度树至多有$\cfrac{m^h-1}{m-1}$个结点。</p>
</li>
</ul>
<h2 id="树的逻辑结构" data-numberify>树的逻辑结构<a class="anchor ms-1" href="#树的逻辑结构"></a></h2>
<p>树可以用二元组 $Tree=(root,F)$ 表示。其中 $root$ 是根结点，$F$ 是 $m(m\ge0)$ 棵子树的森林，即 $F=(T_1,T_2,\cdots,T_m)$，其中 $T_i=(r_i,F_i)$ 为根 $root$ 的第 $i$ 棵子树。</p>
<p>树根与其子树森林之间的关系：
$$
RF = \{ &lt;root,r_i&gt;|i=1,2,4,m,\quad m&gt;0 \}
$$</p>
<hr>
<h1 id="二叉树" data-numberify>二叉树<a class="anchor ms-1" href="#二叉树"></a></h1>
<p>二叉树是（$n \ge 0$）个结点的有限集合：</p>
<ul>
<li>空树：$n=0$；</li>
<li>由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成（两个子数顺序不可交换）。</li>
</ul>
<p>二叉树同样具有递归性质。</p>
<p>二叉树的性质：</p>
<ul>
<li>
<p>第$i$层（$i \ge 1$）上<u>最多</u>有$2^{i-1}$个结点。</p>
<p>因为二叉树每个结点至多有两个分支（结点）。</p>
</li>
<li>
<p>高度为$k$的二叉树最多有$2^k-1$个结点（$k \ge 1$）。</p>
<p>每层结点都取最大值后累加：</p>
<p>$$
\sum_{i=1}^{k}{2^{i-1}} = 2^k - 1
$$</p>
<p>将深度为$k$且有$2^k-1$个结点的二叉树称为<strong>满二叉树</strong>。</p>
<p>对满二叉树自上而下、从左至右进行编号（即层序遍历的顺序）。一个深度为$k$、有$n$个结点的二叉树，当且仅当其每一个结点都于深度为$k$的满二叉树中编号从1至$n$的结点一一对应时，称之为<strong>完全二叉树</strong>。</p>
<blockquote>
<p>完全二叉树有一个隐藏关系：$n &gt; 2^{k-1}-1$。即深度为$k$的完全二叉树，其结点数$n$必须要比深度为$k-1$的满二叉树至少多1个结点。</p>
</blockquote>
<blockquote>
<p>深度为$k$的满二叉树结点数$n$和其第$k$层结点数$m$的关系：</p>
<p>$$
n = 2m-1
$$</p>
</blockquote>
</li>
<li>
<p>任何一棵二叉树，若其终端结点数（度为0的结点数）为$n_0$，度2的结点数为$n_2$，则$n_0=n_2+1$。</p>
<p>即：</p>
<p>$$
终端结点数（度0结点数）=度2结点数+1
$$</p>
</li>
<li>
<p>具有$n$个结点的完全二叉树的深度（高度）为：</p>
<p>$$
\lfloor \log_2{n} \rfloor + 1;
$$</p>
<p>或：</p>
<p>$$
\lceil \log_2{(n+1)} \rceil
$$</p>
</li>
</ul>
<p>二叉树形态总数（卡特兰数）：</p>
<p>$$
\cfrac{C^{n}_{2n}}{n+1}
$$</p>
<blockquote>
<p>排列组合公式：</p>
<p>$$
A^n_m = m \times (m-1) \times \cdots \times (m-n+1)
$$</p>
<p>$m$是起点，$n$是次数。</p>
<p>$$
C^n_m = \cfrac{A^n_m}{A^n_n}
$$</p>
</blockquote>
<h2 id="顺序存储结构-4" data-numberify>顺序存储结构<a class="anchor ms-1" href="#顺序存储结构-4"></a></h2>
<p>用一组地址连续的存储单元存储二叉树中的结点。</p>
<p>可以按照为完全二叉树编号的顺序（即层序遍历的顺序），将二叉树映射到顺序表中：</p>
<p>若编号为$i$的结点（$i \ge 1$），则：</p>
<ul>
<li>$i=1$：根结点，没有双亲（父结点）；</li>
<li>$i&gt;1$：双亲为$\left\lfloor \cfrac{i}{2} \right\rfloor$；</li>
<li>$i \le \cfrac{n}{2}$：左孩子编号为$2i$；</li>
<li>$i \le \cfrac{n-1}{2}$：右孩子编号为$2i+1$。</li>
</ul>
<p>完全二叉树适合采用顺序存储结构，而一般二叉树则不适合。</p>
<h2 id="链式存储结构-4" data-numberify>链式存储结构<a class="anchor ms-1" href="#链式存储结构-4"></a></h2>
<p>可以用<strong>三叉链表或二叉链表</strong>来存储二叉树（一个结点含有3个或2个指针，其中必须有两个指针来分别存储左子树和右子树的根结点）。链表的头指针指向二叉树根结点：</p>
<p><picture><img class="img-fluid " alt="二叉树的链表存储结构" src="/docs/ruan-she/data-structure/uTools_1680770614240.png" loading="lazy" width="980" height="337" />
</picture>

</p>
<blockquote>
<p>三叉链表仅仅是多了一个指向父结点的链表。</p>
</blockquote>
<p>设有$n$个结点的二叉树，则其<strong>空指针域数量</strong>：</p>
<ul>
<li>
<p>对于二叉链表：</p>
<ul>
<li>总指针域个数：$2n$；</li>
<li>分支数（子孙结点数，非空指针域个数）：$n-1$。</li>
</ul>
<p>可得：</p>
<p>$$
空指针域数=2n-(n-1)=n+1
$$</p>
</li>
<li>
<p>对于三叉链表：</p>
<ul>
<li>总指针域个数：$3n$；</li>
<li>分支数（子孙结点数）：$n-1$；</li>
<li>指向父结点且非空的指针域个数：$n-1$。</li>
</ul>
<p>即，非空指针域个数为：$2(n-1)$。</p>
<p>可得：</p>
<p>$$
空指针域数=3n-2(n-1)=n+2
$$</p>
</li>
</ul>
<h2 id="遍历" data-numberify>遍历<a class="anchor ms-1" href="#遍历"></a></h2>
<p>二叉树有以下遍历方法：</p>
<ul>
<li>
<p>先序遍历：根左右</p>
<ol>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ol>
</li>
<li>
<p>中序遍历：左根右</p>
<ol>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ol>
</li>
<li>
<p>后序遍历：左右根</p>
<ol>
<li>后序遍历左子树；</li>
<li>后序遍历右子树；</li>
<li>访问根结点。</li>
</ol>
<p>后序遍历可以使用栈：</p>
<ol>
<li>根结点入栈；</li>
<li>右子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；</li>
<li>左子树（如果有的话）按照步骤1至3顺序入栈（先入根结点，然后入右子树，再入左子树）；</li>
<li>将栈中所有元素出栈，出栈顺序即为后序遍历的顺序。</li>
</ol>
</li>
<li>
<p>层序遍历：根据层序从上至下，从左到右遍历</p>
<ol>
<li>
<p>访问根结点（第1层）；</p>
</li>
<li>
<p>从左到右访问第2层所有结点；</p>
</li>
<li>
<p>从左到右访问第3层所有结点；</p>
<p>&hellip;</p>
</li>
</ol>
<p>直至访问到最后一层的所有结点（从左到右）。</p>
<p>层序遍历可以使用队列：</p>
<ol>
<li>将根结点入队；</li>
<li>将对头元素出队，然后将其左右子结点（如果有的话）依序入队；</li>
<li>重复步骤2直至所有元素出队，出队顺序即为层序遍历顺序。</li>
</ol>
</li>
</ul>
<blockquote>
<p>二叉树的遍历实质上是对一个非线性结构进行线性化的过程，它使得每个结点（除第一个和最后一个）在这些线性序列中有且仅有一个直接前驱和直接后继。</p>
</blockquote>
<h2 id="平衡二叉树" data-numberify>平衡二叉树<a class="anchor ms-1" href="#平衡二叉树"></a></h2>
<p>二叉树可以用于快速查找。例如比根结点小的在左子树，比根结点大的在右子树（二叉排序树）。那么每次查找，根据根结点就可以剔除一半的范围。</p>
<p>但是如果二叉树左右子树的结点数量差别很大，那么每次查找并不一定能剔除一半的范围，查询效率大打折扣。</p>
<p>设一个二叉树的左右子树高度之差的绝对值为$d$，那么</p>
<ul>
<li>不平衡的二叉树：$d &gt; 1$；</li>
<li>平衡的二叉树：$d \le 1$。</li>
</ul>
<blockquote>
<p>完全二叉树一定是平衡二叉树，平衡二叉树不一定是完全二叉树。</p>
</blockquote>
<h2 id="二叉排序树" data-numberify>二叉排序树<a class="anchor ms-1" href="#二叉排序树"></a></h2>
<p>二叉排序树的定义：</p>
<ul>
<li><strong>左子树</strong>所有结点的关键字都<strong>小于</strong>根结点；</li>
<li><strong>右子树</strong>所有根结点的关键字都<strong>大于</strong>根结点；</li>
<li>左右子树也都是二叉排序树。</li>
</ul>
<p>二叉排序树的<strong>中序遍历</strong>（左根右）得到的是该二叉树的<strong>有序序列</strong>。</p>
<h2 id="线索二叉树" data-numberify>线索二叉树<a class="anchor ms-1" href="#线索二叉树"></a></h2>
<p>线索二叉树是在二叉树结点中保存了结点的前驱和后继的信息。</p>
<p>如果使用指针来指向其前驱和后继，增加指针信息会降低存储空间的利用率。</p>
<p>可以采用增加两个标志（<code>leftTag</code>和<code>rightTag</code>）来区分指针域指向的是左或右子结点还是前驱或后继：</p>
<table>
    <tr>
        <td>leftTag</td>
        <td>leftChild</td>
        <td>data</td>
        <td>rightChild</td>
        <td>rightTag</td>
    </tr>
</table>
<p>其中：</p>
<p>$$
leftTag =
\begin{cases}
True  &amp; leftChild指向结点左孩子 \\
False &amp; leftChild指向结点的直接前驱
\end{cases}
$$</p>
<p>$$
rightTag =
\begin{cases}
True  &amp; rightChild指向结点右孩子 \\
False &amp; rightChild指向结点的直接后继
\end{cases}
$$</p>
<p>若二叉树的二叉链表采用以上所示的结点结构，则相应的链表称为线索链表，其中指向结点前驱、后继的指针称为线索。</p>
<p>对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化。</p>
<h2 id="哈夫曼树" data-numberify>哈夫曼树<a class="anchor ms-1" href="#哈夫曼树"></a></h2>
<p>哈夫曼树即最优二叉树，是一类<strong>带权路径长度最短</strong>的树。</p>
<ul>
<li>
<p><strong>路径</strong>：指从树中<strong>一个结点到另一个结点之间的通路</strong>；</p>
</li>
<li>
<p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>；</p>
</li>
<li>
<p><strong>树的路径长度</strong>：指从树根到每一个叶子之间的路径长度之和；</p>
</li>
<li>
<p><strong>结点的带权路径长度</strong>：从该结点到树根之间的<strong>路径长度</strong>与该结点<strong>权值</strong>的乘积；</p>
</li>
<li>
<p><strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和。</p>
<p>设：</p>
<ul>
<li>带权叶子结点数：$n$；</li>
<li>叶子结点的权值：$w_k$；</li>
<li>叶子结点到根的路径长度：$l_k$。</li>
</ul>
<p>则树的带权路径长度为：</p>
<p>$$
WPL = \sum_{k=1}^{n}{w_kl_k}
$$</p>
</li>
</ul>
<p>哈夫曼树是指权值为$w_1,w_2,\cdots,w_n$的$n$个叶子结点的二叉树中，带权路径长度最小的二叉树。</p>
<p>构造最优二叉树的哈夫曼算法：</p>
<ol>
<li>根据给定的$n$个权值$\{ w_1,w_2,\cdots,w_n \}$，构成$n$棵二叉树集合$F=\{T_1,T_2,\cdots,T_n\}$，每棵树$T_i$有且仅有一个带权为$w_i$的根结点。</li>
<li>在$F$中选取2棵权值最小的树作为左、右子树，构造一棵新二叉树。新二叉树的根结点权值为其左右子树根结点权值之和。</li>
<li>从$F$中删除这2棵树，并将新树加入到$F$中。</li>
<li>重复步骤2、3直到$F$中仅含一棵树为止，这棵树便是哈夫曼树。</li>
</ol>
<p>哈夫曼算法并未规定哪棵树作为左或右子树，所以哈夫曼树并不唯一，但$WPL$值是唯一的。</p>
<p>给定$n$个权值后，哈夫曼树的结点数$m$就确定了：</p>
<p>$$
m = 2 \times n - 1
$$</p>
<p>所以可用一维数组存储哈夫曼树。</p>
<h3 id="哈夫曼编码" data-numberify>哈夫曼编码<a class="anchor ms-1" href="#哈夫曼编码"></a></h3>
<p>哈夫曼编码是一种不等长的编码，它用哈夫曼算法来构造出最优前缀码：</p>
<p>给定<strong>字符集</strong>$D=\{ d_1,d_2,\cdots,d_n \}$及<strong>字符的使用频率</strong>$W=\{w_1,w_2,\cdots,w_n\}$。</p>
<p>构造<strong>最优前缀码</strong>的方法为：</p>
<ol>
<li>以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为叶子结点的权值，构造出一棵最优二叉树。</li>
<li>将树中每个结点的左分支标上0，右分支标上1（左0右1）。</li>
<li>每个叶子结点代表字符的编码就是从根到叶子的路径上组成的0、1串。</li>
</ol>
<p><picture><img class="img-fluid " alt="哈夫曼编码" src="/docs/ruan-she/data-structure/uTools_1680836524813.png" loading="lazy" width="347" height="334" />
</picture>

</p>
<p>其中，字符$a$字符$b$、$c$、$d$、$e$的编码分别为00、01、100、11、101。</p>
<h3 id="压缩比" data-numberify>压缩比<a class="anchor ms-1" href="#压缩比"></a></h3>
<p><picture><img class="img-fluid " alt="压缩比例题" src="/docs/ruan-she/data-structure/uTools_1680959771881.png" loading="lazy" width="784" height="489" />
</picture>

</p>
<ol>
<li>
<p>按照<u>出现频率</u>计算<u>加权平均长度</u>：</p>
<p>$$
加权平均长度 = \sum_{i=1}^{5}{字符i的位数 \times 字符i出现频率}
$$</p>
<p>即：</p>
<p>$$
1 \times 40% + 3 \times (10% + 20% + 16% + 14%) = 2.2
$$</p>
<p>压缩后平均长度为2.2。</p>
</li>
<li>
<p>计算压缩比：</p>
<p>$$
压缩比 = \cfrac{压缩前编码长度 - 压缩后平均长度}{压缩前编码长度}
$$</p>
<p>即，</p>
<ul>
<li>
<p>编码5个字符至少需要3位：$2^2 &lt; 5 &lt; 2^3$，所以压缩前编码长度为3；</p>
</li>
<li>
<p>压缩比：</p>
<p>$$
\cfrac{3-2.2}{3} \approx 0.27
$$</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>哈夫曼编码方案是基于贪心策略的。</p>
</blockquote>
<hr>
<h1 id="图" data-numberify>图<a class="anchor ms-1" href="#图"></a></h1>
<p>在图中，任意两个结点之间都可能有直接的关系，所以图中<u>一个结点的前驱结点和后继结点的数目是没有限制的</u>。</p>
<p>图$G$是由集合$V$和$E$构成的二元组，记作$G=(V,E)$：</p>
<ul>
<li><strong>顶点</strong>：表示数据元素。$V$是图中顶点的非空有限集合。</li>
<li><strong>边</strong>：表示数据元素之间的关系。$E$是图中边的有限集合。</li>
</ul>
<p>图可分为两种类型：</p>
<ul>
<li><strong>有向图</strong>：有向图顶点之间的关系称为弧（或有向边），用$&lt;v_i,v_j&gt;$表示，$v_i$是<strong>弧尾</strong>（始点或起点），$v_j$是<strong>弧头</strong>（终点，箭头指向的顶点），即有向边是指<u>从弧尾指向弧头</u>的一条边。$&lt;v_i,v_j&gt;$和$&lt;v_j,v_i&gt;$分别表示的是两条边。</li>
<li><strong>无向图</strong>：无向图顶点之间的关系用$(v_i,v_j)$表示。$(v_i,v_j)$和$(v_j,v_i)$表示的是同一条边。</li>
</ul>
<h2 id="术语-1" data-numberify>术语<a class="anchor ms-1" href="#术语-1"></a></h2>
<h3 id="完全图" data-numberify>完全图<a class="anchor ms-1" href="#完全图"></a></h3>
<p><strong>完全图</strong>：</p>
<ul>
<li>
<p><strong>无向完全图</strong>：指一个有$n$个顶点的无向图，其每一个顶点与其他$n-1$个顶点之间都有边。</p>
<p>$n$个顶点的无向完全图共有$\cfrac{n(n-1)}{2}$条边：</p>
<p>$$
\sum_{i=1}^{n}{i} = \cfrac{n(n-1)}{2}
$$</p>
<p>假设$n$个顶点的无向完全图，为他们编上1到$n$的编号，按照编号顺序计算边，第1个顶点跟其他$n-1$个顶点有$n$条边；第2个顶点跟其他$n-1$个顶点也有$n$条边，除去1条跟第1个顶点相连的边，有$n-1$条不一样的边；第3个顶点出去2条跟第1和第2个顶点相连的边，有$n-2$条不一样的边……以此类推，得出上方公式。</p>
</li>
<li>
<p><strong>有向完全图</strong>：指一个有$n$个顶点的有向图，以其每一个顶点为始点与其他$n-1$个顶点之间都有弧。</p>
<p>$n$个顶点的有向完全图共有$n(n-1)$条边：</p>
<p>$$
\prod_{i=1}^{n}{n-1} = n(n-1)
$$</p>
<p>有向完全图的$n$个顶点都有$n-1$条以其他顶点作为终点的弧（出度为$n-1$），并且这$n$个顶点的$n-1$条弧都是不同的弧，所以可推出上方公式。</p>
</li>
</ul>
<h3 id="度" data-numberify>度<a class="anchor ms-1" href="#度"></a></h3>
<p><strong>度</strong>：顶点$v$的度是指关联于该顶点的边的数目，记作$D(v)$。</p>
<p>若为有向图：</p>
<ul>
<li><strong>入度</strong>：以该顶点为终点的有向边的数目，记为$ID(v)$；</li>
<li><strong>出度</strong>：以该顶点为起点的有向边的数目，记为$OD(v)$。</li>
</ul>
<p>有向图度与入度、出度的关系：</p>
<p>$$
D(v) = ID(v) + OD(v)
$$</p>
<p>对于所有的图，顶点数$n$、边数$e$与各顶点的度之间有：</p>
<p>$$
e = \cfrac{1}{2} \sum_{i=1}^{n}{D(v_i)}
$$</p>
<p>即，所有顶点的度数之和 $= 2e$。</p>
<h3 id="路径" data-numberify>路径<a class="anchor ms-1" href="#路径"></a></h3>
<p><strong>路径</strong>：</p>
<ul>
<li>
<p>无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$(v_p,v_{i1}),(v_{i1},v_{i2}),\cdots,(v_{in},v_q) \in E(G)$；</p>
</li>
<li>
<p>无向图$G$中的路径：从顶点$v_p$到顶点$v_q$的路径是指存在一个顶点序列$v_p,v_{i1},v_{i2},\cdot,v_{in},v_q$，使得$&lt;v_p,v_{i1}&gt;,&lt;v_{i1},v_{i2}&gt;,\cdots,&lt;v_{in},v_q&gt; \in E(G)$。</p>
<p>无向图中的路径也是有方向的。</p>
</li>
</ul>
<h3 id="子图" data-numberify>子图<a class="anchor ms-1" href="#子图"></a></h3>
<p><strong>子图</strong>：若有两个图$G=(V,E)$和$G&rsquo;=(V&rsquo;,E&rsquo;)$，如果$V&rsquo; \sube V$且$E&rsquo; \sube E$，则称$G&rsquo;$为$G$的子图。</p>
<h3 id="连通图" data-numberify>连通图<a class="anchor ms-1" href="#连通图"></a></h3>
<p>对于无向图：</p>
<ul>
<li><strong>连通</strong>：无向图中，若从顶点$v_i$到顶点$v_j$<u>有路径</u>，则称顶点$v_i$和顶点$v_j$是联通的。</li>
<li><strong>连通图</strong>：若无向图中<u>任意两个顶点都是联通的</u>，称其为连通图。</li>
<li><strong>连通分量</strong>：无向图$G$的<strong>极大连通子图</strong>称为$G$的连通分量。</li>
</ul>
<p>$n$个结点的连通图，它的边的取值范围是$[n-1,\cfrac{n(n-1)}{2}]$。</p>
<p>对于有向图：</p>
<ul>
<li><strong>强连通图</strong>：在有向图$G$中，如果对于每一对顶点，$v_i,v_j\in V$ 且 $v_i \neq v_j$，从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$都存在路径，则称图$G$为强连通图。</li>
<li><strong>强连通分量</strong>：有向图中的<strong>极大连通子图</strong>称为有向图的强连通分量。</li>
</ul>
<blockquote>
<p>连通图是无向图中的一种，所以一般也称为无向连通图。</p>
<p>强连通图是有向图的一种，一般也称为有向强连通图。</p>
</blockquote>
<h3 id="网" data-numberify>网<a class="anchor ms-1" href="#网"></a></h3>
<p>边（或弧）带权值的图称为网。</p>
<h3 id="有向树" data-numberify>有向树<a class="anchor ms-1" href="#有向树"></a></h3>
<p>如果一个有向图恰<u>有一个顶点的入度为0（作为root），其余顶点的入度均为1</u>，则是一棵有向树。</p>
<h2 id="基本存储结构" data-numberify>基本存储结构<a class="anchor ms-1" href="#基本存储结构"></a></h2>
<p>图的基本存储结构有：</p>
<ul>
<li>邻接矩阵表示法：使用矩阵存储顶点关系，适合存储边比较多的图；</li>
<li>邻接链表表示法：使用多个单链表存储顶点关系，适合存储边比较少的图。</li>
</ul>
<h3 id="邻接矩阵表示法" data-numberify>邻接矩阵表示法<a class="anchor ms-1" href="#邻接矩阵表示法"></a></h3>
<p>图的邻接矩阵表示法是指<u>用矩阵来表示图中顶点之间的关系</u>。</p>
<p>对于具有$n$个顶点的图$G=(V,E)$，其邻接矩阵是一个$n$阶方阵，且满足：</p>
<p>$$
A[i][j] =
\begin{cases}
1 &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt;是E中的边 \\
0 &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt;不是E中的边
\end{cases}
$$</p>
<blockquote>
<p>即，横$i$竖$j$，横出竖入。</p>
</blockquote>
<p>无向图的邻接矩阵是对称矩阵，有向图的邻接矩阵则不一定对称。</p>
<ul>
<li>无向图：顶点$v_i$的度是邻接矩阵第$i$行（或列）中值不为0的元素个数；</li>
<li>有向图：第$i$行的非0元素个数是顶点$v_i$的出度$OD(v_i)$；第$i$列的非0元素个数是顶点$v_i$的入度$ID(v_j)$。</li>
</ul>
<p>网（赋权图）的邻接矩阵定义（$W_{ij}$是边或弧上的权值）：</p>
<p>$$
A[i][j] =
\begin{cases}
W_{ij} &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt; \in E \\
\infin &amp; 若(v_i,v_j)或&lt;v_i,v_j&gt; \notin E
\end{cases}
$$</p>
<p>邻接矩阵适合用于存储边比较多的图。</p>
<h3 id="邻接链表表示法" data-numberify>邻接链表表示法<a class="anchor ms-1" href="#邻接链表表示法"></a></h3>
<p>邻接链表表示法指的是<u>为图的每个顶点建立一个单链表</u>：</p>
<ul>
<li>
<p>边结点（表结点）：</p>
  <table>
      <tr>
          <td>adjvex</td>
          <td>nextarc</td>
          <td>info</td>
      </tr>
  </table>
<ul>
<li><code>adjvex</code>：指示与顶点$v_i$邻接的顶点的序号；</li>
<li><code>nextarc</code>：指示下一条边或弧的结点；</li>
<li><code>info</code>：存储与边或弧有关的信息，如权值等。</li>
</ul>
</li>
<li>
<p>表头结点（顶点结点）：</p>
  <table>
      <tr>
          <td>data</td>
          <td>firstarc</td>
      </tr>
  </table>
<ul>
<li><code>data</code>：存储顶点$v_i$的名或其他有关信息；</li>
<li><code>firstarc</code>：指示链表中的第一个结点（邻接顶点）。</li>
</ul>
<p>表头结点通常以顺序存储结构存储，以便随机访问。</p>
</li>
</ul>
<p>对于有向图，<strong>邻接链表</strong>存储的是以当前结点作为<strong>起点</strong>的弧；<strong>逆邻接链表</strong>存储的是以当前结点作为<strong>终点</strong>的弧。</p>
<p>邻接链表适合用于存储边比较少的图。</p>
<h2 id="遍历-1" data-numberify>遍历<a class="anchor ms-1" href="#遍历-1"></a></h2>
<p>图的遍历是指<u>从某个项点出发，沿着某条搜索路径对图中的所有项点进行访问且只访问一次的过程</u>。</p>
<h3 id="深度优先搜索" data-numberify>深度优先搜索<a class="anchor ms-1" href="#深度优先搜索"></a></h3>
<p>深度优先搜索（Depth First Search，DFS）类似于树的先序遍历。从图$G$中任一结点$v$出发按深度优先搜索法进行遍历的步骤：</p>
<ol>
<li>设置搜索指针$p$，使$p$指向顶点$v$；</li>
<li>访问$p$所指顶点，并使$p$指向与其<u>相邻接的且尚未被访问过</u>的顶点。</li>
<li>若$p$所指顶点存在，则重复步骤2，否则执行步骤4。</li>
<li>沿着访问的次序和方向回溯到最后一个有未被访问过的邻接顶点的顶点，并使$p$指向这个未被访问的顶点，然后重复步骤2到4，直到所有的项点均被访问为止。</li>
</ol>
<p>时间复杂度（$n$为顶点数，$e$为边数）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<h3 id="广度优先搜索" data-numberify>广度优先搜索<a class="anchor ms-1" href="#广度优先搜索"></a></h3>
<p>图的广度优先搜索（Breadth First Search，BFS）步骤为：</p>
<ol>
<li>从图中的某个顶点$v$出发；</li>
<li>访问$v$后，依次访问$v$的各个未被访问过的邻接点；</li>
<li>分别从$v$的邻接点出发，依次访问它们的邻接点；</li>
<li>按照$v$的邻接点访问的先后顺序，重复步骤2到4，直到图中所有已被访问的项点的邻接点都被访问到；</li>
<li>若此时还有未被访问的顶点，则另选图中的一个未被访问的项点作为起点，重复上述过程，直到图中所有的顶点都被访问到为止。</li>
</ol>
<p>广度优先搜索可以引入队列来保存已访问过的顶点序列。即，每当一个顶点被访问后，就将其放入队列中；当队头顶点出队时，就访问其未被访问的邻接点并令这些邻接顶点入队。每个顶点最多入队一次。</p>
<p>广度和深度优先搜索遍历图的<u>时间复杂度相同</u>（$n$为顶点数，$e$为边数）：</p>
<ul>
<li>邻接矩阵：$O(n^2)$；</li>
<li>邻接链表：$O(n+e)$。</li>
</ul>
<blockquote>
<p>广度和深度优先搜索遍历图的不同之处在于：<u>顶点访问的次序不同</u>。</p>
</blockquote>
<h2 id="生成树" data-numberify>生成树<a class="anchor ms-1" href="#生成树"></a></h2>
<p>连通图的生成树是该图的极小连通子图（都是$n-1$条边）。</p>
<p>对于<strong>非连通图</strong>而言，每个连通分量中的顶点集和遍历时走过的边集一起构成若干棵生成树，把它们称为<strong>非连通图的生成树森林</strong>。</p>
<ul>
<li>
<p>在图的生成树中任一加一条边，则必然形成回路。</p>
<p>边数为$e$，$e \ge n$则必然形成回路。</p>
</li>
<li>
<p>图的生成树不是唯一的。</p>
<p>按深度和广度优先搜索进行遍历将得到不同的生成树，分别称为深度优先生成树和广度优先生成树。</p>
</li>
</ul>
<h3 id="最小生成树" data-numberify>最小生成树<a class="anchor ms-1" href="#最小生成树"></a></h3>
<p>连通网的生成树的边也带权，把生成树各边的权值总和称为生成树的权。<u>权值最小的生成树称为最小生成树</u>。</p>
<h2 id="aov-网" data-numberify>AOV 网<a class="anchor ms-1" href="#aov-网"></a></h2>
<p>一个大工程项目可以分为许多较小子工程（称为活动）。有向图中，用顶点表示活动，弧表示活动之间的优先级关系（活动进行时的制约关系），称这样的有向图为<u>以顶点表示活动的网</u>（Activity On Vertex network，AOV网）。</p>
<p>在AOV网中：</p>
<ul>
<li>
<p>从顶点$v_i$到$v_j$有一条有向路径：</p>
<ul>
<li>$v_i$是$v_j$的前驱，</li>
<li>$v_j$是$v_i$的后继；</li>
</ul>
</li>
<li>
<p>$&lt;v_i,v_j&gt;$：</p>
<ul>
<li>$v_i$是$v_j$的直接前驱，</li>
<li>$v_j$是$v_i$的直接后继。</li>
</ul>
</li>
</ul>
<p>AOV网中不应出现有向环。检测工程是否可行，首先应检查对应AOV网是否存在回路。不存在回路的有向图称为有向无环图（DAG，Directed Acycline Graph）。</p>
<h2 id="拓扑排序" data-numberify>拓扑排序<a class="anchor ms-1" href="#拓扑排序"></a></h2>
<p>检测AOV网是否是DAG的方法是对AOV网构造其<u>顶点的拓扑有序序列</u>。</p>
<p>拓扑排序是将AOV网中的所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点$v_i$到$v_j$有一条路径，则在该线性序列中，$v_i$必在$v_j$之前。对AOV网进行拓扑排序的方法如下：</p>
<ol>
<li>在AOV网中选择一个入度为0（没有前驱）的顶点且输出它。</li>
<li>从网中删除该顶点及与该顶点有关的所有弧。</li>
<li>重复上述两步，直到网中不存在入度为0的顶点为止。</li>
</ol>
<p>两种结果：</p>
<ul>
<li>所有顶点已输出，说明网中不存在回路。</li>
<li>尚有未输出的顶点，剩余顶点均有前驱顶点，表面网中存在回路。</li>
</ul>
<p>有向无环图的拓扑序列中，顶点$v_i$在$v_j$之前，则：</p>
<ul>
<li>可能存在弧$&lt;v_i,v_j&gt;$，一定不存在弧$&lt;v_j,v_i&gt;$；</li>
<li>可能存在$v_i$到$v_j$的路径，一定不存在$v_j$到$v_i$的路径。</li>
</ul>
<p><picture><img class="img-fluid " alt="AOV网拓扑排序例子" src="/docs/ruan-she/data-structure/uTools_1681115534531.png" loading="lazy" width="133" height="173" />
</picture>

</p>
<p>上图拓扑排序的结果为：6,1,4,3,2,5（结果并不唯一）。</p>
<blockquote>
<p>当有向图中无环时，也可以利用深度优先遍历进行逆拓扑排序。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>程序设计语言篇</title>
      <link>/docs/ruan-she/programming-language/</link>
      <pubDate>Thu, 30 Mar 2023 19:58:41 +0800</pubDate>
      
      <guid>/docs/ruan-she/programming-language/</guid>
      <description><![CDATA[低级和高级语言 程序设计语言根据硬件是否能识别区分为两类： 低级语言：二进制机器指令、汇编语言。 高级语言：面向各类应用的程序设计语言，更加接近自]]></description>
      <content:encoded><![CDATA[<h1 id="低级和高级语言" data-numberify>低级和高级语言<a class="anchor ms-1" href="#低级和高级语言"></a></h1>
<p>程序设计语言根据硬件是否能识别区分为两类：</p>
<ul>
<li><strong>低级语言</strong>：二进制机器指令、汇编语言。</li>
<li><strong>高级语言</strong>：面向各类应用的程序设计语言，更加接近自然语言。需要通过编译器或解释器（翻译）来让机器执行。</li>
</ul>
<hr>
<h1 id="编译和解释" data-numberify>编译和解释<a class="anchor ms-1" href="#编译和解释"></a></h1>
<p>程序设计语言按照翻译的方式可分为：</p>
<ul>
<li>
<p><strong>编译</strong>：需要通过<strong>编译器</strong>（<strong>编译程序</strong>）将<u>源程序（源代码）</u>编译为包含二进制指令的<u>可执行文件（目标程序）</u>。</p>
<p>真正在机器上运行的是与源程序（逻辑）等价的目标程序。</p>
<p>源程序和编译器都不再参与目标程序的运行过程。</p>
<p>汇编程序也是属于编译执行。</p>
</li>
<li>
<p><strong>解释</strong>：需要通过<strong>解释器</strong>（<strong>解释程序</strong>）将<u>源程序（源代码）</u>中的指令解释为二进制指令后给机器执行。</p>
<p>该过程不会产生独立的目标程序。</p>
<p>并且解释器和源程序都会参与到程序的运行过程（运行控制）中。</p>
<blockquote>
<p>与编译方式相比，解释方式程序执行的速度慢，因为解释方式执行的程序，需要解释器在其中充当一个原程序与机器之前实时的翻译。</p>
<p>脚本语言属于动态语言，其程序结构可以在运行中改变。</p>
</blockquote>
</li>
</ul>
<h2 id="编译过程" data-numberify>编译过程<a class="anchor ms-1" href="#编译过程"></a></h2>
<p>编译程序的功能是把某高级语言书写的<u>源程序翻译成与之等价的目标程序</u>（汇编语言或机
器语言)。</p>
<p>编译程序的工作过程如下图所示：</p>
<p><picture><img class="img-fluid " alt="编译过程" src="/docs/ruan-she/programming-language/uTools_1680232196718.png" loading="lazy" width="549" height="466" />
</picture>

</p>
<p>其中，以下几个阶段对于编译过程来说是必须的：</p>
<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>目标代码生成</li>
</ol>
<p>以下两个阶段对于编译过程来说不是必须的（可省略）：</p>
<ul>
<li>中间代码生成</li>
<li>（中间或目标）代码优化</li>
</ul>
<h3 id="词法分析" data-numberify>词法分析<a class="anchor ms-1" href="#词法分析"></a></h3>
<p>源程序可以简单地被看成是一个<u>多行的字符串</u>。<strong>词法分析</strong>阶段的任务是<u>对源程序从前到后（从左到右）逐个字符地扫描，从中识别出一个个“单词”符号</u>。<strong>“单词”符号</strong>是程序设计语言的<strong>基本语法单位</strong>，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等。</p>
<p>词法分析程序输出的“单词”<u>常以<strong>二元组</strong>的方式输出</u>，即单词种别和单词自身的值。</p>
<p>词法分析过程依据的是语言的<u>词法规则</u>，即描述“单词”结构的规则。</p>
<h4 id="词法规则" data-numberify>词法规则<a class="anchor ms-1" href="#词法规则"></a></h4>
<p>词法分析根据词法规则将构成源程序的字符串转换成单词符号序列。词法规则可用3型文法（正规文法）或正规表达式描述。</p>
<h5 id="正规表达式" data-numberify>正规表达式<a class="anchor ms-1" href="#正规表达式"></a></h5>
<p>正规表达式（正规式）有以下符号：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">闭包</td>
<td style="text-align:left">表示其前面链接的符号或集合可以出现$[0, +\infty]$次。</td>
</tr>
<tr>
<td style="text-align:center"><code>·</code></td>
<td style="text-align:center">连接</td>
<td style="text-align:left">可省略，将多个符号或集合连接起来。表示逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><code>|</code></td>
<td style="text-align:center">或</td>
<td style="text-align:left">表示逻辑或。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/1680248469003.png" loading="lazy" width="990" height="277" />
</picture>

</p>
<p>设$U$、$V$和$W$均为正规式：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680249034196.png" loading="lazy" width="974" height="185" />
</picture>

</p>
<h4 id="有限自动机" data-numberify>有限自动机<a class="anchor ms-1" href="#有限自动机"></a></h4>
<p><strong>有限自动机</strong>是词法分析的一个工具（一种识别装置的抽象概念），它能正确地<strong>识别正规集</strong>。</p>
<ul>
<li>
<p><strong>确定的有限自动机</strong>（Deterministic Finite Automata，DFA）：对每一个状态来说识别字符后转移的<strong>状态是唯一的</strong>。</p>
<p>一个DFA是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$：</p>
<ul>
<li>
<p>$S$：包含<u>状态的有限集</u>（每个元素称为一个状态）。</p>
</li>
<li>
<p>$\Sigma$：有穷<u>字母表</u>，其每个元素称为一个<u>输入字符</u>。</p>
</li>
<li>
<p>$f$：$S \times \Sigma \to S$ 上的<u>单值部分映像</u>。</p>
<p>$$
f(A,a)=Q \qquad A \in S, a \in \Sigma
$$</p>
<p>表示当前状态为$A$、输入为$a$时，将转换到下一状态$Q$，称$Q$为$A$的一个后继状态。</p>
</li>
<li>
<p>$s_0$：唯一的<u>开始状态</u>，$s_0 \in S$。</p>
</li>
<li>
<p>$Z$：非空的<u>终止状态集合</u>，$Z \subseteq S$。</p>
</li>
</ul>
<p>DFA可以用两种直观的方式表示：</p>
<ul>
<li>
<p><strong>状态转换图</strong>：简称为转换图，是一个有向图。</p>
<ul>
<li>
<p>DFA中的每个<strong>状态</strong>对应转换图中的一个<strong>结点</strong>。</p>
</li>
<li>
<p>DFA中的每个<strong>转换函数</strong>对应图中的一条<strong>有向弧</strong>。</p>
</li>
<li>
<p><strong>双圈表示的结点是终态结点。</strong></p>
<blockquote>
<p>终态也可以是初态。</p>
</blockquote>
</li>
</ul>
<p>若转换函数为$f(A,a)=Q$，则该有向弧从结点$A$出发，进入结点$Q$,字符$a$是弧上的标记。</p>
</li>
<li>
<p><strong>状态转换矩阵</strong>：用一个二位数组$M$表示。</p>
<p>矩阵元素$M[A,a]$：</p>
<ul>
<li><strong>行下标</strong>：表示状态。当前状态为$A$。</li>
<li><strong>列下标</strong>：表示输入的字符。当前输入为$a$。</li>
<li>$M[A,a]$的值：当前状态为$A$、输入为$a$时，应该转换到的下一状态。</li>
</ul>
</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680251834262.png" loading="lazy" width="983" height="160" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680251962756.png" loading="lazy" width="982" height="585" />
</picture>

</p>
</li>
<li>
<p><strong>不确定的有限自动机</strong>（Nondeterministic Finite Automata，NFA）：对每一个状态来说识别字符后转移的<strong>状态是不唯一的</strong>。</p>
<p>NFA也是一个<strong>五元组</strong>$(S, \Sigma, f, s_0, Z)$。与DFA的区别是：</p>
<ul>
<li>
<p>$f$是$S \times \Sigma \to 2^S$ 上的映像。</p>
<p>对于$S$中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。</p>
</li>
<li>
<p>有向弧上的标记可以是 $\varepsilon$（$\varepsilon$ 表示空）。</p>
</li>
</ul>
<blockquote>
<p>DFA是NFA的特例。</p>
</blockquote>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680252743732.png" loading="lazy" width="918" height="407" />
</picture>

</p>
</li>
</ul>
<p><u>有限自动机识别成功的依据是路跑的通并且跑完后的终点是终态。</u></p>
<blockquote>
<p>有向弧中出现如 $a,b$，代表该有向弧输入的值可以为$a$<strong>或</strong>$b$。即<code>,</code>代表或。</p>
</blockquote>
<h3 id="语法分析" data-numberify>语法分析<a class="anchor ms-1" href="#语法分析"></a></h3>
<p><strong>语法分析</strong>的任务是在词法分析的基础上，<u>根据语言的语法规则将单词符号序列分解成各类语法单位</u>，如“表达式”“语句”和“程序”等。</p>
<p>如果源程序中没有语法错误，语法分析后就能正确地<u>构造出其语法树</u>；否则<u>指出语法错误</u>，并<u>给出相应的诊断信息</u>。</p>
<p>例如对<code>id1 := id2 + id3 * 60</code>进行语法分析后形成的语法树：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680233200526.png" loading="lazy" width="888" height="266" />
</picture>

</p>
<p>一般来说，根据表达式生成的语法树，运算符在表达式种优先级越高，它在语法树中的层次就越低，反之亦然。</p>
<blockquote>
<p>词法分析和语法分析在本质上都是对源程序的结构进行分析。</p>
<p>到达语法分析阶段可以发现程序中所有的语法错误。例如：</p>
<ul>
<li>变量的值是否正确；</li>
<li>语句的形式是否正确；</li>
<li>语句的结构是否合法；</li>
<li>检查括号是否匹配；</li>
<li>&hellip;&hellip;</li>
</ul>
</blockquote>
<p>语法分析方法有多种，根据产生语法树的方向，可分为<strong>自底向上</strong>和<strong>自顶向下</strong>两类。</p>
<h4 id="上下文无关文法" data-numberify>上下文无关文法<a class="anchor ms-1" href="#上下文无关文法"></a></h4>
<p>程序设计语言的<u>绝大多数<strong>语法规则</strong>可以采用<strong>上下文无关文法</strong>进行描述</u>。</p>
<p>上下文无关文法属于乔姆斯基定义的2型文法。</p>
<p>对于上下文无关文法，$G[S] = (V_N, V_T, P, S)$，其产生式的形式都是 $A \to \beta$，其中 $A \in V_n$，$\beta \in (V_N \cup V_T)^*$。即：</p>
<ul>
<li>$V_N$：非终结符号集合，</li>
<li>$V_T$：终结符号集合，</li>
<li>$P$：产生式集合，</li>
<li>$S$：开始符号。</li>
</ul>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680255073014.png" loading="lazy" width="990" height="393" />
</picture>

</p>
<p>上下文无关文法的推导过程可用树型结构描述：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/programming-language/uTools_1680255429332.png" loading="lazy" width="210" height="346" />
</picture>

</p>
<p>由上下文无关文法的推导过程也可以看出它是自顶向下推导。</p>
<p>对于上下文无关文法中的集合，有以下对应关系：</p>
<ul>
<li>$S \to P$</li>
<li>$P \to V_N$</li>
<li>$V_N \to V_T$</li>
</ul>
<h3 id="语义分析" data-numberify>语义分析<a class="anchor ms-1" href="#语义分析"></a></h3>
<p><strong>语义分析</strong>阶段分析各语法结构的含义，<u>检查源程序是否包含静态语义错误</u>，并<u>收集类型信息</u>供后面的代码生成阶段使用。<u>只有语法和语义都正确的源程序才能翻译成正确的目标代码。</u></p>
<p>语义分析的一个主要工作是<u>进行类型分析和检查</u>。程序设计语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。</p>
<p>语义分析阶段的输入是上一个阶段（语法分析）所构造的语法树。</p>
<blockquote>
<p>语义分析后语法树中可能会出现一些语义处理结点。例如<code>inttoreal</code>，表示将一个整型数转换为浮点数。</p>
</blockquote>
<blockquote>
<p>语义分析不能发现程序中所有的语义错误。语义分析只能发现静态语义错误，动态语义错误需要在生成目标程序后运行时才能发现。</p>
<p>有语义错误是可以编译成功的。例如<code>a/0</code>，符合语法，也符合静态语义，编译器检验不出来这个是错的，只有运行才会报错，也就是动态语义，动态语义错误常见的还有死循环。</p>
<p>PS：现在有些IDE会对一些常见的动态语义错误进行检查，在程序编译前提示给用户。</p>
</blockquote>
<h3 id="中间代码生成" data-numberify>中间代码生成<a class="anchor ms-1" href="#中间代码生成"></a></h3>
<p><strong>中间代码生成</strong>阶段的工作是<u>根据语义分析的输出生成中间代码</u>。</p>
<p>“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。最常用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。四元式的形式为：</p>
<pre tabindex="0"><code>(运算符, 运算对象1, 运算对象2, 运算结果)
</code></pre><blockquote>
<p>语义分析和中间代码生成所依据的是语言的语义规则。</p>
<p><u>中间代码生成阶段</u>对于编译过程来说是<u>可省略的</u>。但是<u>前面的三个阶段词法分析、语法分析和语义分析还有最后的目标代码生成是不可省略的</u>。</p>
</blockquote>
<h4 id="编译器前后端" data-numberify>编译器前后端<a class="anchor ms-1" href="#编译器前后端"></a></h4>
<p>对于编译过程的各个阶段，在逻辑上可以把它们划分为：</p>
<ul>
<li><strong>前端</strong>：
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>中间代码生成</li>
</ul>
</li>
<li><strong>后端</strong>：
<ul>
<li>中间代码优化</li>
<li>目标代码生成</li>
</ul>
</li>
</ul>
<p>以中间代码为分水岭（中间代码作为前端的输出，然后再作为后端的输入来连接前后端），把编译器分成了与机器有关的部分（后端）和与机器无关的部分（前端）。如此一来，对于同一种程序设计语言的编译器，开发出一个前端之后，就可以针对不同的机器开发相应的后端，前、后端有机结合后就形成了该语言的一个编译器。当语言有改动时，只会涉及前端部分的维护。</p>
<p>对于不同的程序设计语言，分别设计出相应的前端，然后将各个语言的前端与同一个后端相结合，就可以得到各个语言在某种机器上的编译器。</p>
<p>使用中间代码，将编译器分为前后端的好处是，有利于编译程序的可移植性。</p>
<blockquote>
<p>编译程序的可移植性提高了，那么相应的源程序（源代码）的可移植也会提高。</p>
</blockquote>
<h4 id="中缀和后缀表达式" data-numberify>中缀和后缀表达式<a class="anchor ms-1" href="#中缀和后缀表达式"></a></h4>
<p>中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。</p>
<p>根据生成的语法树，按照不同的方式遍历即可生成形式不同的表达式：</p>
<ul>
<li>
<p>中缀表达式：中序遍历（左-根-右）；</p>
</li>
<li>
<p>后缀表达式：后序便利（左-右-根）。</p>
<p>后缀转中缀用到了栈。</p>
</li>
</ul>
<blockquote>
<p>逆波兰式其实就是后缀式。</p>
</blockquote>
<h3 id="代码优化" data-numberify>代码优化<a class="anchor ms-1" href="#代码优化"></a></h3>
<p>由于编译器将源程序翻译成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间上和空间上有较大的浪费。<u>当需要生成高效的目标代码时，必须进行优化。</u>优化过程<u>可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行</u>。</p>
<p>由于中间代码不依赖于具体机器，此时<u>所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关</u>。优化所依据的原则是<strong>程序的等价变换规则</strong>。</p>
<h3 id="目标代码生成" data-numberify>目标代码生成<a class="anchor ms-1" href="#目标代码生成"></a></h3>
<p><strong>目标代码</strong>生成阶段的任务是<u>把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码</u>，这个阶段的工作<strong>与具体的机器密切相关</strong>。</p>
<p>寄存器的分配：寄存器访问速度快，但数量有限，所以如何分配及使用寄存器是目标代码生成时需要着重考虑的。</p>
<blockquote>
<p>编译过程中为变量分配的存储单元所用的地址是<strong>逻辑地址</strong>，程序运行时再将逻辑地址映射为物理地址。</p>
</blockquote>
<h3 id="符号表管理" data-numberify>符号表管理<a class="anchor ms-1" href="#符号表管理"></a></h3>
<p><strong>符号表</strong>的作用是：</p>
<ul>
<li>记录源程序中各个符号的必要信息；</li>
<li>辅助语义的正确性检查和代码生成。</li>
</ul>
<p>在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。</p>
<ul>
<li><u>符号表在前三个阶段构建</u>：可以始于词法分析阶段，也可以放到语法分析和语义分析阶段</li>
<li>符号表的使用有时会<u>延续到目标代码的运行阶段</u>。</li>
</ul>
<blockquote>
<p>编译过程中翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需的信息正确地填入符号表；对可执行语句，则是将其翻译成中间代码或目标代码。</p>
</blockquote>
<h3 id="出错处理" data-numberify>出错处理<a class="anchor ms-1" href="#出错处理"></a></h3>
<p>编写的源程序中出现的错误分为：</p>
<ul>
<li>
<p><strong>静态错误</strong>：</p>
<p>编译阶段发现的程序错误，又可分为：</p>
<ul>
<li>语法错误：有关语言结构上的错误。</li>
</ul>
<p>如单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等。</p>
<ul>
<li>静态语义错误：运算符与运算对象类型不合法等错误。</li>
</ul>
</li>
<li>
<p><strong>动态错误</strong>（动态语义错误）：发生在程序运行时。</p>
<p>常见的动态错误例如除数为0。</p>
</li>
</ul>
<p>在编译时发现程序中的错误后，编译程序应采用适当的策略修复它们，使得分析过程能够继续下去，以便在一次编译过程中尽可能多地找出程序中的错误。</p>
<hr>
<h1 id="程序设计语言的基本成分" data-numberify>程序设计语言的基本成分<a class="anchor ms-1" href="#程序设计语言的基本成分"></a></h1>
<p>程序设计语言的基本成分包括：</p>
<ul>
<li>数据</li>
<li>运算</li>
<li>控制</li>
<li>传输</li>
<li>（函数）</li>
</ul>
<h2 id="数据成分" data-numberify>数据成分<a class="anchor ms-1" href="#数据成分"></a></h2>
<p>数据成分包含以下内容：</p>
<ul>
<li>
<p><strong>标识符</strong>：标识符通常是由字母、数字和下划线<code>_</code>组成，并且不能由数字开头。</p>
<p>一般有如下种类标识符：</p>
<ul>
<li>关键字。</li>
<li>变量名。</li>
<li>函数名。</li>
</ul>
<blockquote>
<p>现在，某些高级语言已经支持中文等字符来当作变量名。</p>
</blockquote>
</li>
<li>
<p><strong>常量</strong>：一般有<u>字面量</u>（例如<code>123</code>、<code>&quot;abc&quot;</code>）和<u>不可变变量（在某些语言中也称其为常量）</u>。</p>
<blockquote>
<ul>
<li>常量也具有类型；</li>
<li>常量也有对应的存储单元。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>变量</strong>：用来存储数据或对象。有存储类别、类型、名称（变量名）、作用域和生存周期等属性（这些也是数据的属性）。</p>
</li>
<li>
<p><strong>全局量</strong>：在程序代码中的<u>作用域（作用范围）为整个文件或程序</u>的数据。</p>
</li>
<li>
<p><strong>局部量</strong>：在程序代码中的<u>作用域（作用范围）为定义它的函数或语句块中</u>的数据。</p>
</li>
<li>
<p><strong>数据类型</strong>：按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型（C和C++）及其他类型等。</p>
<p>许多程序设计语言都规定，程序中的数据都必须具有类型，其作用是：</p>
<ul>
<li><strong>分配存储单元</strong>：便于为数据合理分配存储单元；</li>
<li><strong>检查数据对象</strong>：便于对参与表达式计算的数据对象进行（合法性）检查；</li>
<li><strong>取值范围</strong>：便于规定数据对象的取值范围及能够进行的运算</li>
</ul>
</li>
</ul>
<blockquote>
<p>动态数据结构，其数据的结构会在程序运行过程中改变，例如链表、二叉树等。</p>
<p>动态数据结构的数据空间必须采用<strong>堆存储</strong>分配策略，数据存放在<strong>堆区</strong>。</p>
<p>在C/C++中，全局变量的存储空间在静态数据区分配。</p>
</blockquote>
<h2 id="运算成分" data-numberify>运算成分<a class="anchor ms-1" href="#运算成分"></a></h2>
<p>大多数高级程序设计语言的基本运算可以分为：</p>
<ul>
<li>算术运算。</li>
<li>关系运算。</li>
<li>逻辑运算。</li>
<li>位运算。</li>
<li>&hellip;</li>
</ul>
<h2 id="控制结构" data-numberify>控制结构<a class="anchor ms-1" href="#控制结构"></a></h2>
<p>有以下三种结构来构造程序中的控制逻辑：</p>
<ul>
<li>顺序结构。</li>
<li>选择结构。</li>
<li>循环结构。</li>
</ul>
<blockquote>
<p>大多数高级语言都针对循环结构提供了<code>break</code>、<code>continue</code>等控制流跳转语句。</p>
</blockquote>
<h2 id="传输成分" data-numberify>传输成分<a class="anchor ms-1" href="#传输成分"></a></h2>
<p>程序设计语言的传输成分指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。</p>
<h2 id="函数" data-numberify>函数<a class="anchor ms-1" href="#函数"></a></h2>
<p><strong>函数定义</strong>：</p>
<ul>
<li>函数首部：
<ul>
<li>返回值类型</li>
<li>函数名</li>
<li>形参表</li>
</ul>
</li>
<li>函数体：定义函数所实现的功能。</li>
</ul>
<p><strong>函数声明</strong>：在C（C++）中，函数需要先声明后引用。</p>
<p><strong>函数调用</strong>：在调用函数中使用被调函数实现的功能。函数调用的一般形式为：</p>
<pre tabindex="0"><code>函数名(实参表)
</code></pre><p>调用函数与被调函数之间参数的传递有两种形式：</p>
<ul>
<li>
<p><strong>值调用</strong>（Call by Value）：形参是实参的一份拷贝。即实参将值传递给形参，对形参值的更改并不会作用到实参上。</p>
</li>
<li>
<p><strong>引用调用</strong>（Call by Reference）：形参是实参的一个别名。即函数中对形参的访问和修改实际上是对其相应实参所做的访问和修改。</p>
<p>引用调用下，可以实现形参和实参之间数据的双向传递。</p>
</li>
</ul>
<blockquote>
<p>在进行函数调用和返回时，由系统使用栈区来进行控制和管理。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>计算机系统篇</title>
      <link>/docs/ruan-she/computer-system/</link>
      <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/ruan-she/computer-system/</guid>
      <description><![CDATA[计算机的基本单位 位（比特） 最小数据单位 bit、b 字节 最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节 MB 1MB = 1024KB 吉字节 GB 1GB = 1024MB 太字节 TB 1TB = 1024GB 计]]></description>
      <content:encoded><![CDATA[<h1 id="计算机的基本单位" data-numberify>计算机的基本单位<a class="anchor ms-1" href="#计算机的基本单位"></a></h1>
<table>
<tr>
    <td>位（比特）<br>最小数据单位</td>
    <td><b>bit、b</b></td>
    <td></td>
</tr>
<tr>
    <td>字节<br>最小存储单位</td>
    <td>byte、B</td>
    <td>1B = 8b</td>
</tr>
<tr>
    <td>千字节</td>
    <td>KB</td>
    <td>1KB = 1024B</td>
</tr>
<tr>
    <td>兆字节</td>
    <td>MB</td>
    <td>1MB = 1024KB</td>
</tr>
<tr>
    <td>吉字节</td>
    <td>GB</td>
    <td>1GB = 1024MB</td>
</tr>
<tr>
    <td>太字节</td>
    <td>TB</td>
    <td>1TB = 1024GB</td>
</tr>
</table>
<hr>
<h1 id="计算机系统" data-numberify>计算机系统<a class="anchor ms-1" href="#计算机系统"></a></h1>
<p>计算机系统由<u>硬件</u>和<u>软件</u>组成。</p>
<p>计算机基本硬件系统：</p>
<ul>
<li>运算器</li>
<li>控制器</li>
<li>存储器</li>
<li>输入设备</li>
<li>输出设备</li>
</ul>
<hr>
<h1 id="中央处理单元" data-numberify>中央处理单元<a class="anchor ms-1" href="#中央处理单元"></a></h1>
<p>运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。</p>
<p>中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。</p>
<p>CPU的功能：</p>
<ul>
<li>
<p>程序控制：通过执行指令来控制程序的执行顺序。</p>
</li>
<li>
<p>操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</p>
</li>
<li>
<p>时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</p>
</li>
<li>
<p>数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。</p>
<p>对数据的加工处理也是CPU最根本的任务。</p>
</li>
<li>
<p>对系统内部和外部的中断（异常）做出响应，进行相应的处理。</p>
</li>
</ul>
<p>CPU的组成：</p>
<ul>
<li>运算器</li>
<li>控制器</li>
<li>寄存器组</li>
<li>内部总线</li>
</ul>
<h2 id="运算器" data-numberify>运算器<a class="anchor ms-1" href="#运算器"></a></h2>
<p>运算器组成部件：</p>
<ul>
<li>
<p>算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。</p>
</li>
<li>
<p>累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。</p>
<p>其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。
运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。</p>
</li>
<li>
<p>数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。</p>
<p>DR的主要作用为：</p>
<ul>
<li>作为CPU和内存、外部设备之间数据传送的中转站；</li>
<li>作为CPU和内存、外围设备之间在操作速度上的缓冲；</li>
<li>在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。</li>
</ul>
</li>
<li>
<p>状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。</p>
</li>
</ul>
<h2 id="控制器" data-numberify>控制器<a class="anchor ms-1" href="#控制器"></a></h2>
<p>控制器用于控制整个CPU的工作，它决定了计算机运行过程的
自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。</p>
<p>指令控制逻辑要完<u>取指令</u>、<u>分析指令</u>和<u>执行指令</u>的操作，其过程分为<u>取指令</u>、<u>指令译码</u>、<u>按指令操作码执行</u>、<u>形成下一条指令地址</u>等步骤。</p>
<ul>
<li>
<p>指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。</p>
<p>当CPU执行一条指令时：</p>
<ol>
<li>把指令从内存储器取到缓冲寄存器中。</li>
<li>送入IR暂存。</li>
<li>指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。</li>
</ol>
</li>
<li>
<p>程序计数器（PC，指令计数器）：具有寄存信息和计数两种</p>
<ol>
<li>在程序开始执行前，将程序的起始地址送入PC。
该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。</li>
<li>执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。</li>
</ol>
<p>由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。</p>
<p>执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。</p>
</li>
<li>
<p>地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。</p>
</li>
<li>
<p>指令译码器（ID）：指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。</p>
</li>
</ul>
<hr>
<h1 id="数据表示" data-numberify>数据表示<a class="anchor ms-1" href="#数据表示"></a></h1>
<h2 id="原码" data-numberify>原码<a class="anchor ms-1" href="#原码"></a></h2>
<p>原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。</p>
<p>原码特点：</p>
<ul>
<li>0的表示不唯一（有正负0）；</li>
<li>加、减运算方式不统一；</li>
<li>需额外对符号位进行处理，不利于硬件设计；</li>
<li>当 $a &lt; b$ 时，实现 $a-b$ 比较困难。</li>
</ul>
<h2 id="反码" data-numberify>反码<a class="anchor ms-1" href="#反码"></a></h2>
<p>最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。</p>
<p>原码特点：0的表示不唯一。</p>
<h2 id="补码" data-numberify>补码<a class="anchor ms-1" href="#补码"></a></h2>
<p>计算机中的补码是模2补码</p>
<p>概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。</p>
<p>补码的定义：有 $n$ 位时，$[X]_补=(2^n+X)\mod{2^n}\quad (-2^{n-1}\leq X&lt;2^{n-1})$。</p>
<ul>
<li>
<p>当 $X&lt;0$ 时，补码有两种求法：</p>
<ul>
<li>各位取反，末位加 1。</li>
<li>从第 2 个 1 开始往右各位取反。</li>
</ul>
</li>
<li>
<p>当 $X&gt;0$ 时，补码与原码相同。</p>
</li>
</ul>
<p>补码的减法：$Y-X=Y+[-X]_补$。</p>
<p>特殊的补码：</p>
<ol>
<li>
<p>$[-2^{n-1}]_补=(2^n-2^{n-1})\mod{2^n}=(10\ldots0)_2\ (n-1 个0)$。</p>
<p>这个数的最高位（符号位）即表示符号，又表示数值。如，-128。</p>
</li>
<li>
<p>$[-1]_补=2^n-1=(11\ldots1)_2\ (n个1)$。</p>
</li>
<li>
<p>$[+0]_补=[-0]_补=(00\ldots0)\ (n个0)$。
补码的0表示唯一。</p>
</li>
</ol>
<h2 id="移码" data-numberify>移码<a class="anchor ms-1" href="#移码"></a></h2>
<ul>
<li>移码就是将每个数值加上一个偏置常数（Excess/Bias）。</li>
<li>通常，当编码位数为 $n$ 时，bias 取 $2^{n-1}$ 或 $2^{n-1}-1$。</li>
<li>移码可以方便地进行大小的比较。</li>
</ul>
<p>移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。</p>
<blockquote>
<p>其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为$2^n$。</p>
</blockquote>
<h2 id="各种码制带符号数的范围" data-numberify>各种码制带符号数的范围<a class="anchor ms-1" href="#各种码制带符号数的范围"></a></h2>
<p><picture><img class="img-fluid " alt="带符号数的范围" src="/docs/ruan-she/computer-system/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4.png" loading="lazy" width="1174" height="273" />
</picture>

</p>
<h2 id="浮点数" data-numberify>浮点数<a class="anchor ms-1" href="#浮点数"></a></h2>
<p>浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：$N=2^E \times F$。</p>
<ul>
<li>一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。</li>
<li>浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。</li>
</ul>
<p>规格化浮点数：</p>
<ul>
<li>尾数$M \ge 0$，其规格化尾数形式为$M=0.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[0.5,1]$。</li>
<li>尾数$M \le 0$，其规格化尾数形式为$M=1.\times\times\times$，$\times$可为0也可为1。即$M$限定在了$[-1,-0.5]$。</li>
</ul>
<p>一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为：</p>
<p>$$
-1 \times 2^{(2^{R-1}-1)} \sim +(1-2^{-M+1}) \times 2^{(2^{R-1}-1)}
$$</p>
<p>现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。</p>
<hr>
<h1 id="寻址方式" data-numberify>寻址方式<a class="anchor ms-1" href="#寻址方式"></a></h1>
<ul>
<li>立即寻址：操作数就包含在指令中。</li>
<li>直接寻址：操作数在内存，指令给出操作数的地址。</li>
<li>寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。</li>
<li>寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。</li>
<li>间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。</li>
<li>相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。</li>
<li>变址寻址：操作数地址等于变址寄存器的内容加偏移量。</li>
</ul>
<hr>
<h1 id="校验码" data-numberify>校验码<a class="anchor ms-1" href="#校验码"></a></h1>
<p>码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为<code>0000 0001</code>和<code>0000 0010</code>他们最后两位不同，所以，码距为2。</p>
<ul>
<li>一个编码系统的码距$\ge 2$时，该编码系统具有<u>检错能力</u>；</li>
<li>一个编码系统的码距$\ge 3$时，该编码系统才<u>可能有纠错能力</u>。</li>
</ul>
<p>即，一个校验码要想能够检错和纠错那么它的码距至少是3。</p>
<h2 id="奇偶校验码" data-numberify>奇偶校验码<a class="anchor ms-1" href="#奇偶校验码"></a></h2>
<p>奇偶校验（Parity Codes）是通过在编码中增加一位校验位来<u>使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）</u>。但该编码只能检错，但不能纠错。</p>
<p>奇偶校验：</p>
<ul>
<li>
<p>码距为2。</p>
</li>
<li>
<p>仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。</p>
<pre tabindex="0"><code>奇数 + 偶数 = 奇数
奇数 + 奇数 = 偶数
偶数 + 偶数 = 偶数
偶数 + 奇数 = 奇数
</code></pre><p>即奇数可以改变奇偶性，偶数不能，所以当代码中偶数位出错时，奇偶性不变，无法发现错误。</p>
</li>
<li>
<p>常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。</p>
</li>
</ul>
<h2 id="海明码" data-numberify>海明码<a class="anchor ms-1" href="#海明码"></a></h2>
<p>海明码（Hamming Code）是一种利用奇偶性来<u>检错和纠错</u>的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是$n$位，校验位是$k$位，则$n$和$k$必须满足以下关系：</p>
<p>$$
2^k-1 \ge n+k
$$</p>
<blockquote>
<p>该公式的字面意思为，$k$个校验位的最大值（$k$个校验位都为1），要比海明码的位数（$n+k$）要大。
海明码的码距为3。</p>
</blockquote>
<p>海明码的编码规则如下：</p>
<ul>
<li>
<p>$k$个校验位：$P_k, P_{k-1}, \cdots, P_1$。</p>
</li>
<li>
<p>$n$个数据位：$D_{n-1}, D_{n-2}, \cdots, D_1, D_0$。</p>
</li>
<li>
<p>对应的海明码：$H_{n+k}, H_{n+k-1}, \cdots, H_1$。</p>
<ul>
<li>$H_j = P_i, j=2^{i-1}$。</li>
<li>数据位依序插入到海明码中剩下的位置。</li>
</ul>
</li>
</ul>
<p>海明码中任一位都是由若干个校验位来检验：</p>
<ul>
<li>校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。</li>
<li>校验位由自身校验。</li>
</ul>
<p>Example：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679983905932.png" loading="lazy" width="1023" height="1049" />
</picture>

</p>
<ul>
<li>
<p>偶校验：$G_4G_3G_2G_1={(0000)}_{2}$则表示数据无错误，否则表示接收到的数据有错误。</p>
<p>若出错，$G_4G_3G_2G_1$的十进制值指出来出错位置。如$G_4G_3G_2G_1=1010$，说明$H_{10}(D_5)$出错，将其取反即可纠错。</p>
</li>
<li>
<p>奇校验：$G_4G_3G_2G_1=(1111)_2$则表示数据无错误，否则表示接收到的数据有错误。</p>
</li>
</ul>
<h2 id="循环冗余码" data-numberify>循环冗余码<a class="anchor ms-1" href="#循环冗余码"></a></h2>
<p>循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679825785079.png" loading="lazy" width="613" height="92" />
</picture>

</p>
<p>若CRC码的字长为n，又可称其为（n,k）码，则：</p>
<ul>
<li>
<p>左边为信息码（数据），占k位；</p>
</li>
<li>
<p>右边为校验码，占n-k位。</p>
<p>校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。</p>
</li>
</ul>
<p>在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。</p>
<p>CRC码距为2，可以检错不能纠错。</p>
<hr>
<h1 id="计算机指令集" data-numberify>计算机指令集<a class="anchor ms-1" href="#计算机指令集"></a></h1>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">RISC<br>精简指令集（计算机）</th>
<th style="text-align:center">CISC<br>复杂指令集（计算机）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指令种类</td>
<td style="text-align:center">少、精简</td>
<td style="text-align:center">多、复杂</td>
</tr>
<tr>
<td style="text-align:center">指令复杂度</td>
<td style="text-align:center">低（简单）</td>
<td style="text-align:center">高（复杂）</td>
</tr>
<tr>
<td style="text-align:center">指令长度</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">变化</td>
</tr>
<tr>
<td style="text-align:center">寻址方式</td>
<td style="text-align:center">少</td>
<td style="text-align:center">复杂多样</td>
</tr>
<tr>
<td style="text-align:center">实现（译码方式）</td>
<td style="text-align:center">硬布线控制逻辑（组合逻辑控制器）</td>
<td style="text-align:center">微程序控制技术</td>
</tr>
<tr>
<td style="text-align:center">通用寄存器数量</td>
<td style="text-align:center">多、大量</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">流水线技术</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="流水线技术" data-numberify>流水线技术<a class="anchor ms-1" href="#流水线技术"></a></h1>
<p>计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。</p>
<p>若要执行$n$条指令：</p>
<ul>
<li>
<p>顺序执行总时间：</p>
<p>$$
顺序执行总时间=单条指令执行的时间\times n
$$</p>
</li>
<li>
<p>流水线执行总时间：</p>
<p>$$
流水线执行总时间=一条指令执行的时间+流水线周期 \times (n-1)
$$</p>
<p>流水线（操作）周期为执行时间最长的一段操作的时间。</p>
</li>
<li>
<p>连续输入$n$条指令的吞吐率：</p>
<p>$$
吞吐率=\cfrac {n}{总执行时间}
$$</p>
<p>如果是流水线的吞吐率，则总执行时间为流水线执行总时间。
流水线的吞吐率是最长流水段操作时间的倒数。即：</p>
<p>$$
最长流水段操作时间=\cfrac {流水线执行总时间}{n}
$$</p>
</li>
<li>
<p>加速比：</p>
<p>$$
加速比 = \cfrac{顺序执行总时间}{流水线执行总时间}
$$</p>
</li>
</ul>
<hr>
<h1 id="存储器" data-numberify>存储器<a class="anchor ms-1" href="#存储器"></a></h1>
<p>按存储器所处位置可分为：</p>
<ul>
<li>内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。</li>
<li>外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。</li>
</ul>
<p>按存储器的构成材料分类：</p>
<ul>
<li>磁存储器</li>
<li>半导体存储器</li>
<li>光存储器</li>
</ul>
<p>按存储器工作方式：</p>
<ul>
<li>读/写存储器（RAM）。</li>
<li>只读存储器：ROM、PROM、EPROM、EEPROM等。
<ul>
<li>固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。</li>
<li>可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。</li>
</ul>
</li>
</ul>
<p>按访问方式：</p>
<ul>
<li>
<p>按地址访问：</p>
<p>可分为：</p>
<ul>
<li>随机存储器</li>
<li>顺序存储器</li>
<li>直接存储器</li>
</ul>
</li>
<li>
<p>按内容访问：例如相联存储器。</p>
</li>
</ul>
<p>虚拟存储器由主存与辅存组成。</p>
<p>DRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。</p>
<p>SRAM（静态随机存储器）构成Cache（缓存）。</p>
<p>闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。</p>
<h2 id="缓存" data-numberify>缓存<a class="anchor ms-1" href="#缓存"></a></h2>
<p>高速缓存用来存放当前最活跃的程序和数据，其特点是：</p>
<ul>
<li>位于CPU与主存之间；容量一般在几千字节到几兆字节之间；</li>
<li>速度一般比主存快5~10倍，由快速半导体存储器构成；</li>
<li>其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。</li>
</ul>
<p>Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。</p>
<h2 id="缓存地址映射" data-numberify>缓存地址映射<a class="anchor ms-1" href="#缓存地址映射"></a></h2>
<p>CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。</p>
<p>高速缓存中的地址映像方法：</p>
<ul>
<li>
<p>直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679884025087.png" loading="lazy" width="825" height="526" />
</picture>

</p>
</li>
<li>
<p>全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679884252415.png" loading="lazy" width="730" height="538" />
</picture>

</p>
</li>
<li>
<p>组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。</p>
</li>
</ul>
<blockquote>
<p>发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。</p>
<p>地址映像都是由硬件自动完成。</p>
</blockquote>
<hr>
<h1 id="中断" data-numberify>中断<a class="anchor ms-1" href="#中断"></a></h1>
<p>计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。</p>
<p>中断是一种非常重要的技术，<u>输入输出</u>设备和<u>主机交换数据</u>、<u>分时操作</u>、<u>实时系统</u>、<u>计算机网络</u>和<u>分布式计算机系统</u>中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。</p>
<h2 id="输入输出控制方式" data-numberify>输入输出控制方式<a class="anchor ms-1" href="#输入输出控制方式"></a></h2>
<p>程序查询方式（程序直接控制方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679888001780.png" loading="lazy" width="754" height="1174" />
</picture>

</p>
<ul>
<li>CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数放入内存。</li>
</ul>
<p>中断驱动方式：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679888578058.png" loading="lazy" width="787" height="1134" />
</picture>

</p>
<ul>
<li>I/O设备通过中断信号主动向CPU报告I/O操作已完成。</li>
<li>CPU和I/O可并行工作。</li>
<li>CPU利用率得到提升。</li>
<li>一次只能读/写一个字。</li>
<li>由CPU将数据放入内存。</li>
</ul>
<p>DMA方式（直接存储器存储方式）：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/uTools_1679888972074.png" loading="lazy" width="816" height="723" />
</picture>

</p>
<ul>
<li>CPU和I/O可并行工作。</li>
<li>仅在传送数据块多开始和结束时才需要CPU的干预。</li>
<li>由外设直接将数据放入内存。</li>
<li>一次读写的单位为&quot;块&quot;而不是字。</li>
</ul>
<p>DMA传输数据比中断驱动方式传输数据要快一点。</p>
<hr>
<h1 id="总线" data-numberify>总线<a class="anchor ms-1" href="#总线"></a></h1>
<p>总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。</p>
<p>采用总线结构主要有以下优点：</p>
<ul>
<li>简化系统结构，便于系统设计制造；</li>
<li>大大减少了连线数目，便于布线，减小体积，提高系统的可靠性；</li>
<li>便于接口设计，所有与总线连接的设备均采用类似的接口；</li>
<li>便于系统的扩充、更新与灵活配置，易于实现系统的模块化；</li>
<li>便于设备的软件设计；</li>
<li>便于故障诊断和维修，同时也降低了成本。</li>
</ul>
<p>在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。</p>
<p>微机中的总线分为：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<p>常见总线：</p>
<ul>
<li>ISA总线。</li>
<li>EISA总线。</li>
<li>PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。</li>
<li>PCI Express 总线。</li>
<li>前端总线。</li>
<li>RS-232C。</li>
<li>SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。</li>
<li>SATA。</li>
<li>USB。</li>
<li>IEEE-1394。</li>
<li>IEEE-488总线。</li>
</ul>
<p>地址总线宽度：例如，内存容量4GB，$4GB=2^{2+10+10+10}B=2^32B$。所以内存单元的地址宽度为32位，即地址总线宽度为32位。</p>
<p>数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。</p>
<hr>
<h1 id="加密技术与认证技术" data-numberify>加密技术与认证技术<a class="anchor ms-1" href="#加密技术与认证技术"></a></h1>
<h2 id="加密技术" data-numberify>加密技术<a class="anchor ms-1" href="#加密技术"></a></h2>
<p>加密技术用于防止第三方窃听。</p>
<ul>
<li>
<p>对称加密：只有一把密钥。加密和解密用同一把密钥。</p>
<ul>
<li>密钥分发有缺陷。</li>
<li>加密解密速度很快。</li>
<li>适合加量大量明文数据。</li>
</ul>
</li>
<li>
<p>非对称加密：</p>
<ul>
<li>加密和解密不是同一把密钥。</li>
<li>一共有两把密钥，分别是公钥和私钥。</li>
<li>用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。</li>
<li>不能通过一把密钥推出另一把密钥。</li>
<li>用接收方的公钥加密明文可以实现防止窃听的效果。</li>
<li>密钥分发没有缺陷。</li>
<li>加密解密速度很慢。</li>
</ul>
</li>
</ul>
<h2 id="认证技术" data-numberify>认证技术<a class="anchor ms-1" href="#认证技术"></a></h2>
<p>认证技术用于防止篡改、假冒和否认。</p>
<p>摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。</p>
<p>数字签名（防止假冒和否认）：</p>
<p>发送方用自己的<u>私钥对摘要进行签名</u>（加密）。得到数字签名放在密文后一起发送过去。</p>
<p>接收方用发送方的<u>公钥对数字签名进行验证</u>（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。</p>
<h2 id="数字证书" data-numberify>数字证书<a class="anchor ms-1" href="#数字证书"></a></h2>
<p>数字证书是第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。</p>
<h2 id="加密算法" data-numberify>加密算法<a class="anchor ms-1" href="#加密算法"></a></h2>
<p>对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）：</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>RC-5</li>
<li>IDEA</li>
<li>AES</li>
<li>RC4</li>
</ul>
<p>非对称密钥（公钥、公开密钥加密）算法：</p>
<ul>
<li>RSA</li>
<li>ECC</li>
<li>DSA</li>
</ul>
<p>其他加密算法：</p>
<ul>
<li>
<p>Hash函数</p>
</li>
<li>
<p>SHA-1安全散列算法</p>
</li>
<li>
<p>MD5摘要算法：</p>
<ul>
<li>输出结果为128位</li>
<li>摘要算法防止发送的报文被篡改</li>
</ul>
</li>
</ul>
<p>加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。</p>
<hr>
<h1 id="系统可靠度" data-numberify>系统可靠度<a class="anchor ms-1" href="#系统可靠度"></a></h1>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/%E4%B8%B2%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1157" height="400" />
</picture>

</p>
<p><picture><img class="img-fluid " alt="" src="/docs/ruan-she/computer-system/%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F.png" loading="lazy" width="1133" height="376" />
</picture>

</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

