<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SpringCloud on Linner&#39;s Blog</title>
    <link>/tags/springcloud/</link>
    <description>Recent content in SpringCloud on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>Copyright © 2020-2023 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Fri, 04 Aug 2023 08:40:11 +0000</lastBuildDate><atom:link href="/tags/springcloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring AMQP</title>
      <link>/docs/spring/springcloud/communications/spring-amqp/</link>
      <pubDate>Fri, 04 Aug 2023 08:40:11 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/spring-amqp/</guid>
      <description><![CDATA[AMQP（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要]]></description>
      <content:encoded><![CDATA[<p>AMQP（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p>
<p>RabbitMQ实现了AMQP协议。<a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">Spring AMQP<i class="fas fa-external-link-square-alt ms-1"></i></a>是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中<code>spring-amqp</code>是基础抽象，<code>spring-rabbit</code>是底层的默认实现。</p>
<p>Spring AMQP的依赖如下，其中包含了RabbitMQ的依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- AMQP依赖，包含RabbitMQ --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-amqp<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>在Spring中使用RabbitMQ可以使用Spring AMQP的依赖。对于RabbitMQ来说，Publisher和Consumer都是使用这个依赖，所以这个依赖坐标可以放在它们的父工程中。</p>
<p>导入依赖后，需要先编写<code>application.yml</code>，添加RabbitMQ连接信息（Publisher和Consumer都需要编写此配置）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">rabbitmq</span><span class="p">:</span><span class="w">   </span><span class="c"># RabbitMQ配置信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">localhost  </span><span class="w"> </span><span class="c"># 主机地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5672</span><span class="w">        </span><span class="c"># 端口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">virtual-host</span><span class="p">:</span><span class="w"> </span><span class="l">/  </span><span class="w"> </span><span class="c"># 虚拟主机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">linner </span><span class="w"> </span><span class="c"># 用户名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="m">123456</span><span class="w">  </span><span class="c"># 密码</span><span class="w">
</span></span></span></code></pre></div><p>RabbitMQ官方文档中给出了5个Demo，它们分别对应几种不同的用法：</p>
<ul>
<li>
<p>基本消息队列（Basic Queue）：</p>
<p><picture><img class="img-fluid " alt="Basic Queue" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691056818833.png" loading="lazy" width="286" height="158" />
</picture>

</p>
</li>
<li>
<p>工作消息队列（Work Queue）：</p>
<p><picture><img class="img-fluid " alt="Work Queue" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691056877775.png" loading="lazy" width="258" height="231" />
</picture>

</p>
</li>
<li>
<p>发布与订阅（Publish/Subscribe）。</p>
<p>根据交换机类型的不同，可分为三种：</p>
<ul>
<li>
<p>Fanout Exchange（广播）：</p>
<p><picture><img class="img-fluid " alt="Fanout Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057092864.png" loading="lazy" width="272" height="182" />
</picture>

</p>
</li>
<li>
<p>Direct Exchange（路由，Routing）：</p>
<p><picture><img class="img-fluid " alt="Direct Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057130360.png" loading="lazy" width="262" height="212" />
</picture>

</p>
</li>
<li>
<p>Topic Exchange（主题）：</p>
<p><picture><img class="img-fluid " alt="Topic Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057168656.png" loading="lazy" width="276" height="209" />
</picture>

</p>
</li>
</ul>
</li>
</ul>
<p>接下来分别按照这5个模型来实现。</p>
<hr>
<h1 id="基本消息队列" data-numberify>基本消息队列<a class="anchor ms-1" href="#基本消息队列"></a></h1>
<p>基本消息队列模型只包含三种角色：</p>
<ul>
<li><strong>Publisher</strong>：消息发布者，将消息发送到队列Queue。</li>
<li><strong>Queue</strong>：消息队列，负责接受并缓存消息。</li>
<li><strong>Consumer</strong>：订阅队列，处理队列中的消息。</li>
</ul>
<p>Spring AMQP通过RabbitMQ提供的AMQP接口，整合了RabbitMQ，让RabbitMQ使用起来更加方便。</p>
<p>Spring AMQP提供了<code>RabbitTemplate</code>来给RabbitMQ发送消息，在使用之时直接<code>@Autowired</code>即可。</p>
<p>在<code>Publisher</code>模块中新建一个<code>SpringAmqpTest</code>测试类，然后使用<code>RabbitTemplate</code>发送消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSimpleQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello Spring AMQP!&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>将以上代码放在业务代码中即可实现异步通讯。</p>
<p>在<code>Consumer</code>中新建一个<code>listener</code>包，并且在包中创建<code>SpringRabbitListener</code>，然后使用<code>@RabbitListener</code>定义接收消息的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;simple.queue&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenSimpleQueue</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>直接启动<code>Consumer</code>的启动类即可开始接收消息。</p>
<blockquote>
<p>注：<code>@RabbitListener</code>的<code>queues</code>属性没有创建消息队列的能力。如果先启动<code>Consumer</code>报错<code>Failed to declare queue: simple.queue</code>，可以创建一个<code>RabbitConfig</code>，然后在<code>RabbitConfig</code>中创建队列；或者直接在启动类中创建队列。</p>
<p>在<code>Consumer</code>中创建<code>simple.queue</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getSimpleQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="s">&#34;simple.queue&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>另外还需要注意，导入的<code>Queue</code>是<code>org.springframework.amqp.core</code>包下的。</p>
</blockquote>
<hr>
<h1 id="工作队列模型" data-numberify>工作队列模型<a class="anchor ms-1" href="#工作队列模型"></a></h1>
<p>修改<code>Publisher</code>，模拟每秒钟发送50条消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testWorkQueue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;work.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello Message__&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>   <span class="c1">// 休眠 20ms，1s == 1000ms，所以1s最多只能发50条
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>修改<code>Consumer</code>，模拟两个消费者共同接收<code>work.queue</code>的消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@Queue</span><span class="o">(</span><span class="n">WORK_QUEUE</span><span class="o">)})</span> <span class="c1">// 声明并订阅Queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenWorkQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&#34;消费者 1 收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>   <span class="c1">// 用不同的日志级别区分消费者1和消费者2，更易于阅读
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>   <span class="c1">// 处理速度约：50条/s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@Queue</span><span class="o">(</span><span class="n">WORK_QUEUE</span><span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenWorkQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;消费者 2 收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span>  <span class="c1">// 处理速度约：5条/s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>@RabbitListener</code>的<code>queuesToDeclare</code>属性是<code>@Queue</code>类型数组。<code>queuesToDeclare</code>在指定多个队列的同时，会去声明它们，这样就能不通过创建Bean来声明它们。</p>
<p>先启动<code>Consumer</code>，然后在启动<code>Publisher</code>，发现消息被两个消费者平分处理了（一个消费者处理单数号消息，另一个处理双数号消息），并没有按照各自处理速度去分配。这是因为消费者存在消费预取。无论在规定时间内是否能处理得完，消费者都会按照配置去自动预取。所以就导致了两个消费者各取一半消息去处理。</p>
<p>要解决这个消费预取限制，让消费者能根据自己的能力预取消息，可以在<code>application.yml</code>中修改<code>spring.rebbitmq.listener.simple.prefetch</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">rabbitmq</span><span class="p">:</span><span class="w">   </span><span class="c"># RabbitMQ配置信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">##### 连接信息... #####</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">listener</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">simple</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">prefetch</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c"># 每次只能预取 1 条消息，处理完才能获取下一条</span><span class="w">
</span></span></span></code></pre></div><p>然后按照上方，先启动（或重启）<code>Consumer</code>，然后在启动<code>Publisher</code>，观察控制台打印的日志可以发现这次处理完50条消息的时间大约为1秒。</p>
<p>工作队列模式的特点是：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理。</li>
<li>通过设置Prefetch来控制消费者预取的消息数量。</li>
</ul>
<hr>
<h1 id="发布订阅模型" data-numberify>发布/订阅模型<a class="anchor ms-1" href="#发布订阅模型"></a></h1>
<p>发布/订阅模式通过Exchange（交换机）方式实现了将同一消息发送给多个消费者。</p>
<p>发布/订阅的模型如图：</p>
<p><picture><img class="img-fluid " alt="发布/订阅模型" src="/docs/spring/springcloud/communications/spring-amqp/image-20210717165309625.png" loading="lazy" width="1431" height="462" />
</picture>

</p>
<p>模型中多了Exchange角色，并且过程略有变化：</p>
<ul>
<li><strong>Publisher</strong>（生产者）：值要发送消息的程序，但是不再发送到队列中，而是发给Exchange（交换机）。</li>
<li><strong>Exchange</strong>（交换机）：一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。
<ul>
<li>Topic：</li>
</ul>
</li>
<li><strong>Consumer</strong>（消费者）：订阅队列，处理队列中的消息。。</li>
<li><strong>Queue</strong>：接收消息、缓存消息。</li>
</ul>
<blockquote>
<p>注：Exchange负责消息路由，而不是存储，路由失败则消息丢失。</p>
</blockquote>
<p>常见Exchange类型包括：</p>
<ul>
<li>Fanout（扇出）：广播，将消息交给所有绑定到交换机的队列。</li>
<li>Direct（定向）：路由，把消息交给符合指定Routing Key的队列。</li>
<li>Topic（话题）：通配符，把消息交给符合Routing Pattern（路由模式）的队列。</li>
</ul>
<p>Spring AMQP提供了声明交换机、队列、绑定关系的API，声明交换机API的继承关系图如下：</p>
<p><picture><img class="img-fluid " alt="交换机API继承关系图" src="/docs/spring/springcloud/communications/spring-amqp/1691157574294.png" loading="lazy" width="1212" height="410" />
</picture>

</p>
<h2 id="fanout-exchange" data-numberify>Fanout Exchange<a class="anchor ms-1" href="#fanout-exchange"></a></h2>
<p>Fanout Exchange会将接收到的消息路由到每一个跟其绑定的Queue。声明队列、声明交换机和绑定关系都要在Consumer中完成。</p>
<p>在<code>Consumer</code>中添加新的配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FanoutConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.fanout&#34;</span><span class="o">;</span>   <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_QUEUE_1</span> <span class="o">=</span> <span class="s">&#34;fanout.queue1&#34;</span><span class="o">;</span>    <span class="c1">// 队列1名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_QUEUE_2</span> <span class="o">=</span> <span class="s">&#34;fanout.queue2&#34;</span><span class="o">;</span>    <span class="c1">// 队列2名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 声明FanoutExchange交换机
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">FanoutExchange</span> <span class="nf">getFanoutExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">FanoutExchange</span><span class="o">(</span><span class="n">FANOUT_EXCHANGE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 声明第1个队列
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="s">&#34;fanoutQueue1&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getFanoutQueue1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">FANOUT_QUEUE_1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 绑定队列1和交换机
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Binding</span> <span class="nf">bindingQueue1</span><span class="o">(</span><span class="n">Queue</span> <span class="n">fanoutQueue1</span><span class="o">,</span> <span class="n">FanoutExchange</span> <span class="n">fanoutExchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BindingBuilder</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">fanoutQueue1</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="n">fanoutExchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="s">&#34;fanoutQueue2&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getFanoutQueue2</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">FANOUT_QUEUE_2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Binding</span> <span class="nf">bindingQueue2</span><span class="o">(</span><span class="n">Queue</span> <span class="n">fanoutQueue2</span><span class="o">,</span> <span class="n">FanoutExchange</span> <span class="n">fanoutExchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BindingBuilder</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">fanoutQueue2</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="n">fanoutExchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 第3个队列以相同方式声明，并绑定... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后修改<code>Consumer</code>的<code>SpringRabbitListener</code>类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_1</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenFanoutQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_1</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_2</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenFanoutQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_2</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>修改<code>Publisher</code>，添加新的测试方法模拟发送消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.fanout&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendFanoutExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello everyone!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">FANOUT_EXCHANGE</span><span class="o">,</span> <span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先运行<code>Consumer</code>，然后再运行<code>Publisher</code>的<code>testSendFanoutExchange()</code>测试方法发送消息，在<code>Consumer</code>的终端可以发现，两个消费者都接收到消息了。</p>
<p><code>RabbitTemplate</code>的<code>convertAndSend()</code>方法有不同的实现，可以向队列发送消息，也可以向交换机发送。</p>
<p>Fanout Exchange的特点：</p>
<ul>
<li>可以有多个队列；</li>
<li>每个队列都要绑定到Exchange；</li>
<li>生产者发送的消息，只能发送到Exchange，由Exchange决定发给哪个队列，生产者无法决定（也不知道）；</li>
<li>交换机把消息发送给绑定过的所有队列；</li>
<li>订阅队列的消费者都能拿到消息。</li>
</ul>
<p>Fanout Exchange的作用：</p>
<ul>
<li>接收Publisher发送的消息；</li>
<li>将消息按照规则路由到与之绑定的队列，Fanout Exchange的会将消息路由到每个绑定的队列；</li>
<li>不能缓存消息，路由失败，消息丢失。</li>
</ul>
<h2 id="direct-exchange" data-numberify>Direct Exchange<a class="anchor ms-1" href="#direct-exchange"></a></h2>
<p>Direct Exchange通过Binding Key（绑定密钥）和Routing Key（路由密钥）将消息路由到不同的队列上。</p>
<p>在Direct Exchange模式下，队列在声明时可以指定一个或多个Binding Key；Publisher在向Exchange发送消息时，通过指定Routing Key，告诉Exchange要将消息发送到哪个队列上。</p>
<p>在<code>Consumer</code>中添加新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_EXCHANGE_NAME</span> <span class="o">=</span> <span class="s">&#34;linner.direct&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_QUEUE_1_NAME</span> <span class="o">=</span> <span class="s">&#34;direct.queue1&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_QUEUE_2_NAME</span> <span class="o">=</span> <span class="s">&#34;direct.queue2&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@QueueBinding</span><span class="o">(</span>   <span class="c1">// 设置绑定关系，绑定队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">DIRECT_QUEUE_1_NAME</span><span class="o">),</span>    <span class="c1">// 设置绑定的队列（会自动创建队列）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">DIRECT_EXCHANGE_NAME</span><span class="o">,</span>   <span class="c1">// 设置绑定的交换机（会自动创建交换机）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">DIRECT</span> <span class="cm">/* 设置交换机类型，默认为Direct */</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;red&#34;</span><span class="o">,</span> <span class="s">&#34;blue&#34;</span><span class="o">}</span>   <span class="c1">// Binding Keys，可以指定多个，当
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenDirectQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">DIRECT_QUEUE_1_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">DIRECT_QUEUE_2_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">DIRECT_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">DIRECT</span> <span class="cm">/* 默认 */</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;red&#34;</span><span class="o">,</span> <span class="s">&#34;yellow&#34;</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenDirectQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">DIRECT_QUEUE_2_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>@RabbitListener</code>的<code>bindings</code>属性提供了简便的绑定方式。<code>bindings</code>属性是<code>@QueueBinding</code>类型数组，可以同时有多个绑定。其中的每个绑定使用<code>@QueueBinding</code>来定义。</p>
<p><code>@QueueBinding</code>通常需要设置的属性有以下三个：</p>
<ul>
<li><code>value</code>：指明绑定的队列，类型为<code>@Queue</code>。通过使用<code>@Queue</code>来声明并订阅队列。</li>
<li><code>exchange</code>：指明绑定的交换机，类型为<code>@Exchange</code>。通过使用<code>@Exchange</code>，可以指定交换机的名称和类型。交换机类型可以使用<code>ExchangeTypes</code>下的字符串常量。</li>
<li><code>key</code>：指明Binding Key(s)，是一个字符串数组类型。</li>
</ul>
<p>在<code>Publisher</code>中添加新的<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.direct&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendDirectExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">routingKey</span> <span class="o">=</span> <span class="s">&#34;red&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello direct exchange &#34;</span> <span class="o">+</span> <span class="n">routingKey</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息（发送消息时需要指定Routing Key）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">DIRECT_EXCHANGE</span><span class="o">,</span> <span class="n">routingKey</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先启动<code>Consumer</code>，然后再启动<code>Publisher</code>的<code>testSendDirectExchange()</code>方法来进行测试。你可以通过将<code>routingKey</code>修改为<code>blue</code>或<code>yellow</code>来测试其它路由密钥。</p>
<p>Direct Exchange的规则是这样的：</p>
<ul>
<li>Queue绑定一个或多个Binding Key(s)到Exchange。</li>
<li>Publisher在给Exchange发送消息时，指定Routing Key。</li>
<li>Exchange收到消息，并且根据Publisher指定的Routing Key去匹配对应的Queue(s)。当Exchange发现有Queue(s)的Binding Keys中，有与Publisher指定的Routing Key对应的Key时，就将消息发送给对应的Queue(s)。</li>
</ul>
<blockquote>
<p>注：如果在Direct Exchange模式下使用Fanout Exchange的方式发送消息（即<code>rabbitTemplate.convertAndSend(DIRECT_EXCHANGE, &quot;&quot;, message);</code>），那么是不会有任何一个队列接收到此消息的。除非在绑定队列时，设置了这样一个Key：<code>key = {&quot;&quot;}</code>。Direct Exchange模式将<code>&quot;&quot;</code>识别为一个Key。</p>
</blockquote>
<h2 id="topic-exchange" data-numberify>Topic Exchange<a class="anchor ms-1" href="#topic-exchange"></a></h2>
<p>Topic Exchange模式与Direct Exchange模式类似，区别在于Topic Exchange下的Routing Key必须是个多个单词的列表，并且以<code>.</code>分割。</p>
<p>例如：</p>
<ul>
<li><code>china.news</code>：代表有中国的新闻消息；</li>
<li><code>china.weather</code>：代表中国的天气消息。</li>
</ul>
<p>Topic Exchange模式中，Queue与Exchange指定Binding Key时可以使用通配符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">通配符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:left">代指0个或多个单词。</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">代指1个单词。</td>
</tr>
</tbody>
</table>
<p>在<code>Consumer</code>中添加新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_EXCHANGE_NAME</span> <span class="o">=</span> <span class="s">&#34;linner.topic&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_QUEUE_1_NAME</span> <span class="o">=</span> <span class="s">&#34;topic.queue1&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_QUEUE_2_NAME</span> <span class="o">=</span> <span class="s">&#34;topic.queue2&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">TOPIC_QUEUE_1_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">name</span> <span class="o">=</span> <span class="n">TOPIC_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">TOPIC</span>  <span class="c1">// 设置交换机类型为Topic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;china.#&#34;</span>                     <span class="c1">// 设置包含通配符的Binding Key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenTopicQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">TOPIC_QUEUE_1_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">TOPIC_QUEUE_2_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">name</span> <span class="o">=</span> <span class="n">TOPIC_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">TOPIC</span>
</span></span><span class="line"><span class="cl">            <span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;#.news&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenTopicQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">TOPIC_QUEUE_2_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在<code>Publisher</code>中添加新的<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.topic&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendTopicExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">routingKey</span> <span class="o">=</span> <span class="s">&#34;china.news&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello &#34;</span> <span class="o">+</span> <span class="n">TOPIC_EXCHANGE</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">routingKey</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">TOPIC_EXCHANGE</span><span class="o">,</span> <span class="n">routingKey</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>同样是以先启动<code>Consumer</code>，再启动<code>Publisher</code>的方式进行测试，然后再通过修改<code>routingKey</code>来测试不同的匹配规则。</p>
<hr>
<h1 id="消息转换器" data-numberify>消息转换器<a class="anchor ms-1" href="#消息转换器"></a></h1>
<p>在Spring AMOP中，发送消息的<code>RabbitTemplate.convertAndSend()</code>方法，其实发送的是<code>Object</code>类型。在发送消息时，Spring AMOP会将发送的消息序列化为字节发送给RabbitMQ；接收消息的时候，还会把字节反序列化为Java对象。也就是说，通讯过程传输的消息可以是任意类型的对象。</p>
<h2 id="默认序列化方式" data-numberify>默认序列化方式<a class="anchor ms-1" href="#默认序列化方式"></a></h2>
<p>默认情况下Spring AMOP采用的序列化方式是JDK序列化。</p>
<p>在<code>Consumer</code>的<code>RabbitConfig</code>中，添加一个新的队列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getObjectQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后启动<code>Consumer</code>（这是为了展示Spring AMQP默认序列化方式在RabbitMQ中的序列化结果，所以先不在<code>Consumer</code>中接收消息）。</p>
<p>接着在<code>Publisher</code>中创建<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendObjectQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">msg</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;Linner&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">msg</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>  <span class="c1">// 发送一个Map对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>启动测试方法，在RabbitMQ管理页面可以看到<code>object.queue</code>中存在这样一条消息：</p>
<p><picture><img class="img-fluid " alt="Spring AMOP 默认序列化结果" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691229847478.png" loading="lazy" width="1146" height="291" />
</picture>

</p>
<p>可以发现JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大；</li>
<li>有安全漏洞；</li>
<li>可读性差。</li>
</ul>
<h2 id="自定义序列化方式" data-numberify>自定义序列化方式<a class="anchor ms-1" href="#自定义序列化方式"></a></h2>
<p>JSON是一种很好的序列化方式，我们可以将Spring AMQP默认的JDK序列化改成Jackson。</p>
<p>首先导入依赖，由于序列化后还需反序列化，所以<code>Publisher</code>和<code>Consumser</code>模块都需要导入Jackson依赖。我们可以将依赖导入它们的父工程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Jackson核心依赖--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.9.10<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后分别在<code>Publisher</code>和<code>Consumser</code>中替换Spring AMQP默认序列化方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AmqpConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 自定义消息转换器
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">MessageConverter</span> <span class="nf">getMessageConverter</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Jackson2JsonMessageConverter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先运行<code>Publisher.testSendObjectQueue()</code>方法，观察Jackson是否有生效。运行结果如下：</p>
<p><picture><img class="img-fluid " alt="Jackson 序列化结果" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691230403117.png" loading="lazy" width="619" height="361" />
</picture>

</p>
<p>最后在<code>Consumser</code>中创建一个新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenObjectQueue</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: &#34;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>重启<code>Consumser</code>，观察终端输出的日志，如果成功打印出Map对象，说明反序列化成功。</p>
<blockquote>
<p>注：自定义Spring AMQP序列化方式时，Publisher和Consumer配置的消息转换器都必须相同。就是说，序列化和反序列化一定要使用同个消息转换器。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>RabbitMQ</title>
      <link>/docs/spring/springcloud/communications/rabbit-mq/</link>
      <pubDate>Thu, 03 Aug 2023 08:10:45 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/rabbit-mq/</guid>
      <description><![CDATA[RabbitMQ官网：https://www.rabbitmq.com/。 官方文档：https://rabbitmq.com/documen]]></description>
      <content:encoded><![CDATA[<p>RabbitMQ官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener noreferrer">https://www.rabbitmq.com/<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>官方文档：<a href="https://rabbitmq.com/documentation.html" target="_blank" rel="noopener noreferrer">https://rabbitmq.com/documentation.html<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>官方Demo：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">https://www.rabbitmq.com/getstarted.html<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<hr>
<h1 id="部署-rabbitmq" data-numberify>部署 RabbitMQ<a class="anchor ms-1" href="#部署-rabbitmq"></a></h1>
<p>使用Docker来部署RabbitMQ只需要两个步骤：</p>
<ol>
<li>
<p><code>pull</code> RabbitMQ镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker pull rabbitmq:3-management
</span></span></code></pre></div><p>RabbitMQ通过插件的方式提供了一个可视化界面。在RabbitMQ官方的镜像中，带<code>management</code>版本的就是集成了该可视化插件的镜像。</p>
<p>通过Docker官方的镜像源来<code>pull</code> RabbitMQ镜像可能会有点慢，可以使用一些国内的镜像源：</p>
<p>提供方          |镜像URL
中国区官方镜像  |<code>https://registry.docker-cn.com</code>
清华源          |<code>https://docker.mirrors.ustc.edu.cn</code>
阿里源          |<code>https://cr.console.aliyun.com</code>
腾讯源          |<code>https://mirror.ccs.tencentyun.com</code>
网易源          |<code>http://hub-mirror.c.163.com</code>
道客镜像站      |<code>http://f1361db2.m.daocloud.io</code></p>
</li>
<li>
<p>启动RabbitMQ容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">RABBITMQ_DEFAULT_USER</span><span class="o">=</span>linner <span class="se">\ </span>  <span class="c1"># RabbitMQ用户名（默认为guest）</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">RABBITMQ_DEFAULT_PASS</span><span class="o">=</span><span class="m">123456</span> <span class="se">\ </span>  <span class="c1"># RabbitMQ密码（默认为guest）</span>
</span></span><span class="line"><span class="cl">    --name rabbitmq-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --hostname rabbitmq <span class="se">\ </span>              <span class="c1"># 域名，单机下可忽略，通常用于集群部署时</span>
</span></span><span class="line"><span class="cl">    -p 15672:15672 <span class="se">\ </span>                   <span class="c1"># 可视化管理界面端口</span>
</span></span><span class="line"><span class="cl">    -p 5672:5672 <span class="se">\ </span>                     <span class="c1"># 服务端口</span>
</span></span><span class="line"><span class="cl">    -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    rabbitmq:3-management
</span></span></code></pre></div></li>
</ol>
<p>启动容器后，进入<a href="http://localhost:15672/" target="_blank" rel="noopener noreferrer">http://localhost:15672/<i class="fas fa-external-link-square-alt ms-1"></i></a>即可进入RabbitMQ管理界面。</p>
<p>使用以下命令查看RabbitMQ日志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker logs rabbitmq-server <span class="c1"># 替换成你容器的名称</span>
</span></span></code></pre></div><hr>
<h1 id="rabbitmq-结构" data-numberify>RabbitMQ 结构<a class="anchor ms-1" href="#rabbitmq-结构"></a></h1>
<p>RabbitMQ的基本结构如下：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ的基本结构" src="/docs/spring/springcloud/communications/rabbit-mq/image-20210717162752376.png" loading="lazy" width="1401" height="610" />
</picture>

</p>
<p>在RabbitMQ中有几个概念：</p>
<ul>
<li><code>channel</code>：操作RabbitMQ的工具。</li>
<li><code>exchange</code>：路由消息到队列中。</li>
<li><code>queue</code>：缓存消息。</li>
<li><code>virtual host</code>：虚拟主机，是对<code>queue</code>、<code>exchange</code>等资源的逻辑分组。</li>
</ul>
<p>RabbitMQ中的角色主要有：</p>
<ul>
<li>Publisher：生产者。将消息发送给Queue（队列）或Exchange（交换机）。</li>
<li>Consumer：消费者。从Queue获取消息，并做响应的处理。</li>
<li>Exchange：交换机。负责消息路由，将从Publisher接受到的消息分发到不同的Queues上。</li>
<li>Queue：队列。用于从Publishers或Exchange接收消息并存储。</li>
<li>Virtual Host：虚拟主机。隔离不同用户的Exchange、Queue，消息的隔离。</li>
</ul>
<hr>
<h1 id="消息模型" data-numberify>消息模型<a class="anchor ms-1" href="#消息模型"></a></h1>
<p>RabbitMQ官方文档中给出了5个Demo，它们分别对应几种不同的用法：</p>
<ul>
<li>
<p>基本消息队列（Basic Queue）：</p>
<p><picture><img class="img-fluid " alt="Basic Queue" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691056818833.png" loading="lazy" width="286" height="158" />
</picture>

</p>
</li>
<li>
<p>工作消息队列（Work Queue）：</p>
<p><picture><img class="img-fluid " alt="Work Queue" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691056877775.png" loading="lazy" width="258" height="231" />
</picture>

</p>
</li>
<li>
<p>发布与订阅（Publish and Subscribe）。</p>
<p>根据交换机类型的不同，可分为三种：</p>
<ul>
<li>
<p>Fanout Exchange（广播）：</p>
<p><picture><img class="img-fluid " alt="Fanout Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057092864.png" loading="lazy" width="272" height="182" />
</picture>

</p>
</li>
<li>
<p>Direct Exchange（路由）：</p>
<p><picture><img class="img-fluid " alt="Direct Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057130360.png" loading="lazy" width="262" height="212" />
</picture>

</p>
</li>
<li>
<p>Topic Exchange（主题）：</p>
<p><picture><img class="img-fluid " alt="Topic Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057168656.png" loading="lazy" width="276" height="209" />
</picture>

</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="rabbitmq-依赖" data-numberify>RabbitMQ 依赖<a class="anchor ms-1" href="#rabbitmq-依赖"></a></h1>
<p>使用RabbitMQ之前需要先导入依赖。可以导入Spring AMQP的依赖，其中包含了RabbitMQ的依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- AMQP依赖，包含RabbitMQ --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-amqp<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>对于RabbitMQ来说，Publisher和Consumer都是使用这个依赖，所以这个依赖坐标可以放在它们的父工程中。</p>
<hr>
<h1 id="基本消息队列" data-numberify>基本消息队列<a class="anchor ms-1" href="#基本消息队列"></a></h1>
<p>最基础的消息队列模型只包含三种角色：</p>
<ul>
<li><strong>Publisher</strong>：消息发布者，将消息发送到队列Queue。</li>
<li><strong>Queue</strong>：消息队列，负责接受并缓存Publisher发送的消息。</li>
<li><strong>Consumer</strong>：订阅队列，处理Queue中的消息。</li>
</ul>
<p>Queue由RabbitMQ实现，需要由我们实现的角色为Publisher和Consumer。</p>
<p>实现基本消息队列可以使用RabbitMQ的原生接口来模拟。创建两个Spring模块<code>Publisher</code>和<code>Consumer</code>来模拟消息的发送和接收：</p>
<ul>
<li>
<p>在<code>Publisher</code>模块中创建<code>PublisherTest</code>测试类来模拟消息发送：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PublisherTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendMessage</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.1. 设置连接参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>   <span class="c1">// 主机地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPort</span><span class="o">(</span><span class="mi">5672</span><span class="o">);</span>          <span class="c1">// 端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setVirtualHost</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>    <span class="c1">// 虚拟主机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">&#34;linner&#34;</span><span class="o">);</span>  <span class="c1">// 账号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">&#34;123456&#34;</span><span class="o">);</span>  <span class="c1">// 密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1.2. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 创建通道Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 创建队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello RabbitMQ!&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">basicPublish</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">queueName</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">message</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;发送消息成功：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 关闭通道和连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">channel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>Consumer</code>模块中创建<code>ConsumerTest</code>来模拟消息接收：</p>
<blockquote>
<p>注：接收消息需要在<code>main()</code>中创建回调函数。不能使用一般的测试方法。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span>  <span class="nc">ConsumerTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 创建连接工厂，建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.1. 设置连接参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>   <span class="c1">// 主机地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPort</span><span class="o">(</span><span class="mi">5672</span><span class="o">);</span>          <span class="c1">// 端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setVirtualHost</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>    <span class="c1">// 虚拟主机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">&#34;linner&#34;</span><span class="o">);</span>  <span class="c1">// 用户名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">&#34;123456&#34;</span><span class="o">);</span>  <span class="c1">// 密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1.2. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 创建通道Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 创建队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 订阅消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">channel</span><span class="o">.</span><span class="na">basicConsume</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="k">new</span> <span class="n">DefaultConsumer</span><span class="o">(</span><span class="n">channel</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleDelivery</span><span class="o">(</span><span class="n">String</span> <span class="n">consumerTag</span><span class="o">,</span> <span class="n">Envelope</span> <span class="n">envelope</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">AMQP</span><span class="o">.</span><span class="na">BasicProperties</span> <span class="n">properties</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 5. 处理消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;接收到消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;等待接收消息......&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ul>
<p>模拟过程：</p>
<ol>
<li>
<p>先给<code>testSendMessage()</code>打个断点，然后再以调试模式启动<code>PublisherTest</code>，逐条执行。可以在RabbitMQ管理界面中发现创建了对应的连接、通道和消息队列。并且，进入队列后可以发现有一条消息在准备中。</p>
<p>MQ连接：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ 连接" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073342130.png" loading="lazy" width="968" height="562" />
</picture>

</p>
<p>MQ通道：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ 通道" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073381002.png" loading="lazy" width="1430" height="436" />
</picture>

</p>
<p>消息队列（Read项为1，表示有1条准备消息）：</p>
<p><picture><img class="img-fluid " alt="消息队列" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073449245.png" loading="lazy" width="1156" height="471" />
</picture>

</p>
<p>准备中的消息：</p>
<p><picture><img class="img-fluid " alt="准备中的消息" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073499794.png" loading="lazy" width="547" height="524" />
</picture>

</p>
</li>
<li>
<p>此时启动<code>Consumer</code>，可以发现有一条新的连接和新的通道。并且消息队列中的准备消息变为0。</p>
<p>新的MQ连接：</p>
<p><picture><img class="img-fluid " alt="新的 RabbitMQ 连接" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073659703.png" loading="lazy" width="917" height="141" />
</picture>

</p>
<p>新的MQ通道：</p>
<p><picture><img class="img-fluid " alt="新的 RabbitMQ 通道" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073733155.png" loading="lazy" width="1414" height="117" />
</picture>

</p>
<p>消息队列：</p>
<p><picture><img class="img-fluid " alt="消息队列" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073860449.png" loading="lazy" width="1138" height="114" />
</picture>

</p>
<p>在<code>Consumer</code>的控制台中可以发现打印了一条新消息：</p>
<pre tabindex="0"><code>接收到消息：[Hello RabbitMQ!]
</code></pre></li>
<li>
<p>再次启动<code>PublisherTest</code>，<code>Consumer</code>控制台再次打印一条消息：</p>
<pre tabindex="0"><code>接收到消息：[Hello RabbitMQ!]
</code></pre></li>
</ol>
<p>在搭建基本消息队列的过程中，创建队列之前的操作对于Publisher和Consumer来说是一致的。建立连接这个过程对于Publisher和Consumer来说都是必要的，之所以它们都要创建队列，是为了防止队列不存在的情况发生。它们的流程中不同的是Publisher创建队列后是为了发送消息，Consumer创建队列后是为了接收消息。</p>
<p>创建基本消息队列的流程大致可总结为：</p>
<ol>
<li>建立连接（Connection）。
<ol>
<li>创建连接工厂；</li>
<li>设置连接参数；</li>
<li>最后再建立连接。</li>
</ol>
</li>
<li>利用Connection创建通道（Channel）。</li>
<li>利用Channel声明消息队列。</li>
<li>利用Channel在指定的消息队列中发送消息或订阅消息。
<ul>
<li>对于Publisher来说，需要在消息队列中发送消息。发送完消息后，需要按顺序关闭通道和连接。</li>
<li>对于Consumer来说，需要在消息队列中接收消息。</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>通讯方式</title>
      <link>/docs/spring/springcloud/communications/introduction/</link>
      <pubDate>Thu, 03 Aug 2023 07:34:34 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/introduction/</guid>
      <description><![CDATA[微服务间通讯有两种方式： 同步通讯：实时响应。 异步通讯：不需要马上回复。 两种方式各有优劣，同步通讯可以立即得到响应，但是却不能跟多个服务同时通]]></description>
      <content:encoded><![CDATA[<p>微服务间通讯有两种方式：</p>
<ul>
<li>同步通讯：实时响应。</li>
<li>异步通讯：不需要马上回复。</li>
</ul>
<p>两种方式各有优劣，同步通讯可以立即得到响应，但是却不能跟多个服务同时通讯。异步通讯可以同时与多个服务通讯，但是往往响应会有所延迟。</p>
<hr>
<h1 id="同步通讯" data-numberify>同步通讯<a class="anchor ms-1" href="#同步通讯"></a></h1>
<p>Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>
<ul>
<li><strong>耦合度高</strong>：消费者与提供者之间存在直接的调用关系。在服务中每次加入新的需求，都要修改原来的代码。</li>
<li><strong>性能下降</strong>：消费者需要等待提供者响应，如果调用链过长，响应时间等于每次调用的时间之和。</li>
<li><strong>资源浪费</strong>：消费者在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。</li>
<li><strong>级联失败</strong>：如果提供者出现问题，所有消费者都会跟着出问题。如同多米话骨牌一样，迅速导致整个微服务群故障。</li>
</ul>
<blockquote>
<p>还有一个导致性能下降和资源浪费的原因：消费者在给提供者发请求时，提供者在处理别的消费者的请求，无法及时响应，这也会导致该消费者等待过长时间的响应。</p>
</blockquote>
<p>同步通讯并非只有缺点没有优点，其优点为时效性较强，可以立即得到结果。</p>
<hr>
<h1 id="异步通讯" data-numberify>异步通讯<a class="anchor ms-1" href="#异步通讯"></a></h1>
<p>异步调用可以避免上述同步通讯时造成的问题。</p>
<p>在异步通讯中，使用<strong>事件</strong>（<strong>Event</strong>）和<strong>代理</strong>（<strong>Broker</strong>）处理通讯。在异步通讯中有三种角色：</p>
<ul>
<li><strong>事件发布者</strong>（<strong>Publisher</strong>）：Publisher在处理完自己的业务后，发布一个事件给Broker。</li>
<li><strong>事件代理者</strong>（<strong>Broker</strong>）：Borker在接收到Publisher的事件消息后，将该消息发送给订阅了该事件的Consumer。</li>
<li><strong>事件订阅者</strong>（<strong>Consumer</strong>）：Consumer接收到自己订阅的事件消息后，根据事件做相应的业务处理。并且Consumer可以根据自己的情况和业务处理能力来处理（就好比说能力不够就不要揽太多活，Consumer性能不够就不会同时处理太多业务）。</li>
</ul>
<p>在事件模式中，Publisher在处理完业务后，就只管发布事件给Broker。剩下的由Broker和Consumer完成。这样Publisher与Consumer并没有直接通讯，而且Publisher也无需等待响应，即可以降低耦合、减少级联失败的情况，又能提高性能、减少资源浪费。Broker在这一模式中，就像是一个数据总线，所有的服务要接收数据和发送数据都发到这个总线上；这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<blockquote>
<p>在实际应用中，发布者与订阅者是相对的。也就是说，从整个系统来看，发布者可以是订阅者，订阅者也可以是发布者；从具体的业务逻辑线上看，才有某个服务是另外某个服务的发布者，某个服务是另外某个服务的订阅者。</p>
</blockquote>
<p>使用事件模式的异步通讯的好处：</p>
<ul>
<li><strong>吞吐量提升</strong>：发布者无需等待订阅者处理完成，响应更快速。</li>
<li><strong>故障隔离</strong>：服务没有直接调用，不存在级联失败问题。</li>
<li><strong>提高资源利用</strong>：调用间没有阻塞，不会造成无效的资源占用。</li>
<li><strong>耦合度极低</strong>：由Borker做代理，每个服务都可以灵活插拔，可替换。</li>
<li><strong>流量削峰</strong>：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件。</li>
</ul>
<p>虽然异步通讯好处多，但是也不是没有缺点：</p>
<ul>
<li>架构复杂，业务没有明显的流程线，不易于管理。</li>
<li>需要依赖于Broker的可靠、安全、性能（Broker挂了，就没人给订阅者发消息了）。</li>
</ul>
<hr>
<h1 id="mq-技术" data-numberify>MQ 技术<a class="anchor ms-1" href="#mq-技术"></a></h1>
<p>MQ（Message Queue，消息队列），就是存放消息的队列，是实现事件驱动架构中的Broker的一种方法。</p>
<p>比较常见的几种MQ实现及其对比如下：</p>
<pre><code>       | **RabbitMQ**            | **ActiveMQ**                     | **RocketMQ** | **Kafka**
</code></pre>
<p>&mdash;&mdash;&mdash;- | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | &mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;-
公司/社区  | Rabbit                  | Apache                           | 阿里         | Apache
开发语言   | Erlang                  | Java                             | Java         | Scala&amp;Java
协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire，STOMP，REST，XMPP，AMQP| 自定义协议   | 自定义协议
可用性     | 高                      | 一般                             | 高           | 高
单机吞吐量 | 一般                    | 差                               | 高           | 非常高
消息延迟   | 微秒级                  | 毫秒级                           | 毫秒级       | 毫秒以内
消息可靠性 | 高                      | 一般                             | 高           | 一般</p>
<p>一般按照以下方式选取：</p>
<ul>
<li>追求可用性：Kafka、 RocketMQ 、RabbitMQ。</li>
<li>追求可靠性：RabbitMQ、RocketMQ。</li>
<li>追求吞吐能力：RocketMQ、Kafka。</li>
<li>追求消息低延迟：RabbitMQ、Kafka。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Eureka</title>
      <link>/docs/spring/springcloud/eureka/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/eureka/</guid>
      <description><![CDATA[Eureka 服务注册中心 Eureka架构下将服务分为以下两个角色： 注册中心（Eureka Server，服务端）。 客户端（Eureka Client）。 E]]></description>
      <content:encoded><![CDATA[<h1 id="eureka-服务注册中心" data-numberify>Eureka 服务注册中心<a class="anchor ms-1" href="#eureka-服务注册中心"></a></h1>
<p>Eureka架构下将服务分为以下两个角色：</p>
<ul>
<li>注册中心（Eureka Server，服务端）。</li>
<li>客户端（Eureka Client）。</li>
</ul>
<p>Eureka会将客户端（即服务）的信息进行注册，让客户端可以通过Eureka注册中心获取服务信息并进行调用。</p>
<p><strong>Eureka的作用：</strong></p>
<ul>
<li><strong>注册服务信息</strong>：服务提供者启动时向Eureka注册自己的信息，Eureka保存这些服务信息到服务列表中。</li>
<li><strong>获取服务信息</strong>：服务消费者根据服务名称向Eureka拉取服务列表。</li>
<li><strong>负载均衡</strong>：有多个服务提供者时，服务消费者利用负载均衡算法，从Eureka注册的服务列表中挑选一个服务后发起远程调用。</li>
<li><strong>感知服务健康状态</strong>：
<ul>
<li>服务提供者会每隔30秒向Eureka Server发送心跳请求，报告自己的健康状态。</li>
<li>Eureka会更新记录服务信息列表，心跳不正常的服务会被剔除。</li>
</ul>
</li>
</ul>
<p>在Eureka架构中，角色有以下分工：</p>
<ul>
<li>Eureka Server：记录服务信息；进行心跳监控，剔除心跳不正常的服务。</li>
<li>Eureka Client：
<ul>
<li>Provider：注册自己的信息到Eureka Server；每隔30秒向Eureka Server发送心跳。</li>
<li>Consumer：根据服务名称从Eureka Server拉取服务列表；基于服务列表做负载均衡，选中一个服务后发起远程调用。</li>
</ul>
</li>
</ul>
<h2 id="eureka-示例" data-numberify>Eureka 示例<a class="anchor ms-1" href="#eureka-示例"></a></h2>
<p>依照上例，订单服务在获取订单信息时需要从用户服务中获取用户信息并一同发送：</p>
<ol>
<li>
<p>首先需要创建一个新的Maven模块来运行Eureka Server。</p>
<ul>
<li>
<p>Eureka Server的<code>pom.xml</code>如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;maven.compiler.source&gt;</span>8<span class="nt">&lt;/maven.compiler.source&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;maven.compiler.target&gt;</span>8<span class="nt">&lt;/maven.compiler.target&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中最主要的就是导入<code>eureka-server</code>起步依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>在Eureka中，服务端和客户端有不同的依赖，服务端的起步依赖就是<code>spring-cloud-starter-netflix-eureka-server</code>。</p>
</li>
</ul>
</li>
<li>
<p>编写<code>EurekaApplication</code>启动类，并在启动类上使用<code>@EnableEurekaServer</code>注解装配EurekaServer：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableEurekaServer</span>     <span class="c1">// EurekaServer开关，自动装配EurekaServer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EurekaApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">EurekaApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>eureka-server</code>中，添加<code>application.yml</code>并加入以下配置信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 服务端口（视具体情况进行更改）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8180</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">eureka-server</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Eureka的地址信息（如果有多个，则用逗号”,“隔开）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>分别在<code>order-service</code>和<code>user-service</code>中添加Eureka客户端依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Eureka客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>分别在Eureka客户端的<code>application.yml</code>中添加如下配置信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 配置eureka-server的信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># defaultZone要与eureka-server中的defaultZone相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div><p>分别在Eureka客户端的<code>application.yml</code>中添加服务名称（<code>spring.application.name</code>），如<code>order-service</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span></code></pre></div><p>Eureka Server利用<code>spring.application.name</code>来找到对应模块的信息，并返回。利用<code>spring.application.name</code>也可以做负载均衡。</p>
<blockquote>
<p>由于所有模块都可能作为服务提供者被其他服务调用，所以项目中所有服务模块都应该在Eureka Server中进行注册。</p>
</blockquote>
</li>
<li>
<p>在服务消费者中，需要在注册<code>RestTemplate</code>的方法上使用注解<code>@LoadBalanced</code>来开启Eureka的负载均衡。</p>
<p>如<code>order-service</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>服务消费者通过Eureka，使用<code>RestTemplate</code>调用其他模块。</p>
<p>如<code>order-service</code>调用<code>user-service</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入RestTemplate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用RestTemplate发起HTTP请求，查询用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2.1.URL路径（将服务的IP改为服务的名称）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://user-service/user/&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2.发送HTTP（GET）请求，实现远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这里面最主要的是，配置了Eureka后，使用<code>RestTemplate</code>调用其他模块时，URL中的IP可以改为服务提供者（被调模块）的服务名称，并且可以自动做负载均衡。即，原本是使用<code>localhost:8081</code>这个IP端口来调用<code>user-service</code>，但是现在可以直接使用<code>http://user-service</code>来调用<code>user-service</code>提供的接口。</p>
</li>
</ol>
<h2 id="eureka-服务注册配置总结" data-numberify>Eureka 服务注册配置总结<a class="anchor ms-1" href="#eureka-服务注册配置总结"></a></h2>
<p>按照角色配置Eureka，至少需要做如下配置：</p>
<ul>
<li>
<p>Eureka Server：</p>
<p>依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Eureka服务端口（视具体情况进行更改）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8180</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">eureka-server</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Eureka的地址信息（如果有多个，则用逗号”,“隔开）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>Eureka Client：</p>
<p>依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Eureka客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">clinet-1-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># defaultZone要与eureka-server中的defaultZone相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>服务消费者：</p>
<p>开启负载均衡：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>RestTemplate</code>调用其他服务时，URL中的IP可以改为服务提供者（被调模块）的服务名称。</p>
</li>
</ul>
<hr>
<h1 id="idea-配置模块的多个实例" data-numberify>Idea 配置模块的多个实例<a class="anchor ms-1" href="#idea-配置模块的多个实例"></a></h1>
<ol>
<li>
<p>复制现有的配置：</p>
<p><picture><img class="img-fluid " alt="复制现有的配置" src="/docs/spring/springcloud/eureka/uTools_1687857604691.png" loading="lazy" width="491" height="267" />
</picture>

</p>
</li>
<li>
<p>使用VM Options修改端口，避免与原有的模块产生端口冲突：</p>
<p><picture><img class="img-fluid " alt="修改端口" src="/docs/spring/springcloud/eureka/uTools_1687857691207.png" loading="lazy" width="557" height="317" />
</picture>

</p>
</li>
</ol>
<hr>
<h1 id="ribbon-负载均衡" data-numberify>Ribbon 负载均衡<a class="anchor ms-1" href="#ribbon-负载均衡"></a></h1>
<p>Ribbon是一款负载均衡组件，而Eureka的负载均衡则是基于Ribbon实现的。如上例（<code>order-service</code>）中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="负载均衡流程" data-numberify>负载均衡流程<a class="anchor ms-1" href="#负载均衡流程"></a></h2>
<p>Eureka中使用注解<code>@LoadBalanced</code>标识<code>RestTemplate</code>，从而实现拦截<code>RestTemplate</code>发起的请求，并获取相应的服务信息和执行负载均衡策略。</p>
<p><code>@LoadBalanced</code>注解使用<code>LoadBalancerInterceptor</code>来执行请求的拦截。<code>LoadBalancerInterceptor</code>实现了<code>ClientHttpRequestInterceptor</code>接口。而<code>ClientHttpRequestInterceptor</code>接口主要用于拦截客户端HTTP请求。</p>
<p><code>ClientHttpRequestInterceptor</code>接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ClientHttpRequestInterceptor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ClientHttpResponse</span> <span class="nf">intercept</span><span class="o">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">,</span> <span class="n">ClientHttpRequestExecution</span> <span class="n">execution</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">			<span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>拦截流程：</p>
<ol>
<li>
<p>使用<code>RestTemplate</code>发送请求时，Eureka会使用<code>LoadBalancerInterceptor</code>的<code>intercept()</code>来执行拦截：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoadBalancerInterceptor</span> <span class="kd">implements</span> <span class="n">ClientHttpRequestInterceptor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">LoadBalancerClient</span> <span class="n">loadBalancer</span><span class="o">;</span>    <span class="c1">// 负载均衡客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ClientHttpResponse</span> <span class="nf">intercept</span><span class="o">(</span><span class="kd">final</span> <span class="n">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="kd">final</span> <span class="n">ClientHttpRequestExecution</span> <span class="n">execution</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            获取请求发出的URL
</span></span></span><span class="line"><span class="cl"><span class="cm">            例如order-service中获取订单信息时，会发出[http://user-service/user/{userId}]这个请求
</span></span></span><span class="line"><span class="cl"><span class="cm">            这里的request.getURI()会获取到[http://user-service/user/{userId}]这个请求的URI
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="kd">final</span> <span class="n">URI</span> <span class="n">originalUri</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getURI</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            通过URI获取请求的Host
</span></span></span><span class="line"><span class="cl"><span class="cm">            如：user-service
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">serviceName</span> <span class="o">=</span> <span class="n">originalUri</span><span class="o">.</span><span class="na">getHost</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Assert</span><span class="o">.</span><span class="na">state</span><span class="o">(</span><span class="n">serviceName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Request URI does not contain a valid hostname: &#34;</span> <span class="o">+</span> <span class="n">originalUri</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            将Host作为Eureka客户端名称，获取相应的服务信息并执行负载均衡策略
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">loadBalancer</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="o">.</span><span class="na">requestFactory</span><span class="o">.</span><span class="na">createRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">body</span><span class="o">,</span> <span class="n">execution</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p><code>LoadBalancerClient</code>是一个客户端执行负载均衡的接口，当实际执行时，使用的是<code>RibbonLoadBalancerClient</code>这个实现类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RibbonLoadBalancerClient</span> <span class="kd">implements</span> <span class="n">LoadBalancerClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 实际执行的是这个方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">execute</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">String</span> <span class="n">serviceId</span><span class="o">,</span> <span class="c1">// 传入的是serviceName，如 user-service
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">LoadBalancerRequest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">            <span class="n">Object</span> <span class="n">hint</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            根据serviceId获取负载均衡器
</span></span></span><span class="line"><span class="cl"><span class="cm">            loadBalancer中有这么两个属性：
</span></span></span><span class="line"><span class="cl"><span class="cm">            - AllServerList
</span></span></span><span class="line"><span class="cl"><span class="cm">            - UpServerList
</span></span></span><span class="line"><span class="cl"><span class="cm">            它们记录了获取到的Eureka客户端信息
</span></span></span><span class="line"><span class="cl"><span class="cm">            实际执行时，loadBalancer的类型是ZoneAwareLoadBalancer
</span></span></span><span class="line"><span class="cl"><span class="cm">            ZoneAwareLoadBalancer继承了DynamicServerListLoadBalancer
</span></span></span><span class="line"><span class="cl"><span class="cm">            在loadBalancer中，使用IRule定义负载均衡策略
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">ILoadBalancer</span> <span class="n">loadBalancer</span> <span class="o">=</span> <span class="n">getLoadBalancer</span><span class="o">(</span><span class="n">serviceId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            根据LoadBalancer，执行负载均衡策略，获取Eureka客户端的真实服务地址
</span></span></span><span class="line"><span class="cl"><span class="cm">            如，获取到 localhost:8081
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">Server</span> <span class="n">server</span> <span class="o">=</span> <span class="n">getServer</span><span class="o">(</span><span class="n">loadBalancer</span><span class="o">,</span> <span class="n">hint</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="负载均衡策略" data-numberify>负载均衡策略<a class="anchor ms-1" href="#负载均衡策略"></a></h2>
<p>Ribbon的负载均衡策略是使用<code>IRule</code>这个接口来定义。在Eureka中给出了几个负载均衡策略的实现，它们的继承关系图如下：</p>
<p><picture><img class="img-fluid " alt="负载均衡策略继承关系图" src="/docs/spring/springcloud/eureka/uTools_1687859350530.png" loading="lazy" width="1067" height="418" />
</picture>

</p>
<p>Eureka中负载均衡默认的实现是<code>ZoneAvoidanceRule</code>，它们的含义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>RoundRobinRule</code></td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td style="text-align:center"><code>AvailabilityFilteringRule</code></td>
<td>对以下两种服务器进行忽略：<ul><li>短路的服务器：<br>在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。<br>短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。</li><li>并发数过高的服务器：<br>如果一个服务器的并发连接数过高，配置了<code>AvailabilityFilteringRule</code>规则的客户端也会将其忽略。<br>并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>属性进行配置。</li></ol></td>
</tr>
<tr>
<td style="text-align:center"><code>WeightedResponseTimeRule</code></td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。<br>这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td style="text-align:center"><strong><code>ZoneAvoidanceRule</code></strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。<br>使用Zone对服务器进行分类（这个Zone可以理解为一个机房、一个机架等）。而后再对Zone内的多个服务做轮询。<br>在配置服务注册时，Zone的值可以被设置（按照服务器所在的地理位置进行设置）。使用此规则，服务消费者会优先选择跟自己在同一个Zone内的服务，然后再做轮询。</td>
</tr>
<tr>
<td style="text-align:center"><code>BestAvailableRule</code></td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td style="text-align:center"><code>RandomRule</code></td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td style="text-align:center"><code>RetryRule</code></td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody>
</table>
<h2 id="配置负载均衡规则" data-numberify>配置负载均衡规则<a class="anchor ms-1" href="#配置负载均衡规则"></a></h2>
<p>配置负载均衡规则有两种方式：</p>
<ul>
<li>
<p>配置<strong>全局默认</strong>的负载均衡规则：</p>
<p>在任何一个配置类或新建一个配置类，然后添加一个新的Bean。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IRule</span> <span class="nf">getLoadBalancerRule</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 此处以RandomRule为例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="n">RandomRule</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用Bean的方式配置负载均衡规则，无论当前服务远程调用哪个服务提供者，都是采用这个Bean里面配置的规则。</p>
</li>
<li>
<p>为<strong>指定的服务提供者</strong>配置单独的负载均衡规则：</p>
<p>可以在<code>application.yml</code>中使用<code>serverName.ribbon.NFLoadBalancerRuleClassName</code>配置指定服务的负载均衡规则，它的值是具体规则的实现类的全类名。</p>
<p>例如在<code>order-service</code>中配置<code>user-service</code>的负载均衡规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">user-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 负载均衡规则</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">NFLoadBalancerRuleClassName</span><span class="p">:</span><span class="w"> </span><span class="l">com.netflix.loadbalancer.RandomRule</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="ribbon-饥饿加载" data-numberify>Ribbon 饥饿加载<a class="anchor ms-1" href="#ribbon-饥饿加载"></a></h2>
<ul>
<li>懒加载：第一次访问时才加载。</li>
<li>饥饿加载：在项目启动时就开始加载。</li>
</ul>
<p>Ribbon默认是采用懒加载，即第一次访问时才会去创建<code>LoadBalanceClient</code>，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时。</p>
<p>可以在<code>application.yml</code>中，通过下面配置开启Ribbon的饥饿加载：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">eager-load</span><span class="p">:</span><span class="w"> </span><span class="c"># 饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">clients</span><span class="p">:</span><span class="w"> </span><span class="l">user-service</span><span class="w"> </span><span class="c"># 指定对userservice这个服务饥饿加载</span><span class="w">
</span></span></span></code></pre></div><p><code>ribbon.eager-load.clients</code>是一个集合类型，如果要对多个服务提供者开启饥饿加载，可以这样配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">eager-load</span><span class="p">:</span><span class="w"> </span><span class="c"># 饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 对多个服务提供者开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">clients</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-1-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-2-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-3-service</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Feign</title>
      <link>/docs/spring/springcloud/feign/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/feign/</guid>
      <description><![CDATA[尽管使用了注册中心来解决URL的硬编码等问题，但是如今使用RestTemplate还是存在以下问题： 代码可读性差，编程体验不统一； 参数复杂U]]></description>
      <content:encoded><![CDATA[<p>尽管使用了注册中心来解决URL的硬编码等问题，但是如今使用<code>RestTemplate</code>还是存在以下问题：</p>
<ul>
<li>代码可读性差，编程体验不统一；</li>
<li>参数复杂URL难以维护。</li>
</ul>
<p>Feign是一个声明式的HTTP客户端，作用于服务消费者，在服务消费者中为服务提供者创建一个HTTP远程调用。官方地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener noreferrer">https://github.com/OpenFeign/feign<i class="fas fa-external-link-square-alt ms-1"></i></a>。其作用就是帮助我们优雅的实现HTTP请求的发送，解决上面提到的问题。</p>
<h1 id="使用-feign" data-numberify>使用 Feign<a class="anchor ms-1" href="#使用-feign"></a></h1>
<p>使用Feign非常简单，大致分为以下步骤：</p>
<ol>
<li>
<p>在<code>pom.xml</code>中引入Feign客户端依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>在项目的启动类上添加注解<code>@EnableFeignClients</code>以开启Feign的功能。例如为<code>order-service</code>（服务消费者）开启Feign：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span>
</span></span><span class="line"><span class="cl"><span class="nd">@MapperScan</span><span class="o">(</span><span class="s">&#34;asia.linner.demo.order.mapper&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">OrderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>为服务提供者编写一个<code>FeignClient</code>接口。例如在<code>order-service</code>（消费者）中为<code>user-service</code>（提供者）编写<code>FeignClient</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;user-service&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><ul>
<li><code>@FeignClient</code>：标注该接口为<code>FeignClient</code>，其<code>value</code>属性指定一个客户端的服务名称。</li>
<li><code>@GetMapping</code>：为了方便使用，Feign使用的是Spring的注解，其用法和作用与Spring中的类似。</li>
</ul>
<blockquote>
<p><code>FeignClient</code>可以放在项目中的<code>clients</code>包下。</p>
</blockquote>
</li>
<li>
<p>通过<code>FeignClient</code>远程调用服务。例如在<code>order-service</code>（消费者）中通过<code>FeignClient</code>远程调用<code>user-service</code>（提供者）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入Feign客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserClient</span> <span class="n">userClient</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用Feign远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userClient</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<blockquote>
<p>注意：使用了<code>FeignClient</code>，原本声明<code>RestTemplate</code>的<code>Bean</code>可以删除掉。因为使用<code>FeignClient</code>并不需要<code>RestTemplate</code>的<code>Bean</code>。</p>
</blockquote>
<hr>
<h1 id="feignclient-配置" data-numberify>FeignClient 配置<a class="anchor ms-1" href="#feignclient-配置"></a></h1>
<p>Feign可以修改的配置如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">作用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>feign.Logger.Level</code></td>
<td style="text-align:center">修改日志级别</td>
<td style="text-align:left">Feign包含四种不同的日志级别：<br><ul><li><code>NONE</code>：不记录任何日志。</li><li><code>BASIC</code>：基础日志级别。记录请求方法、URL以及响应状态代码和执行时间。</li><li><code>HEADERS</code>：记录基本信息以及请求和响应头信息。</li><li><code>FULL</code>：全日志级别。记录基本信息以及请求和响应头信息、请求和响应体信息。</li></ul></td>
</tr>
<tr>
<td style="text-align:center"><code>feign.codec.Decoder</code></td>
<td style="text-align:center">响应结果的解析器</td>
<td style="text-align:left">HTTP远程调用的结果做解析，例如解析JSON字符串为Java对象。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.codec.Encoder</code></td>
<td style="text-align:center">请求参数编码</td>
<td style="text-align:left">将请求参数编码，便于通过HTTP请求发送。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.Contract</code></td>
<td style="text-align:center">支持的注解格式</td>
<td style="text-align:left">默认是SpringMVC的注解。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.Retryer</code></td>
<td style="text-align:center">失败重试机制</td>
<td style="text-align:left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试。</td>
</tr>
</tbody>
</table>
<p>一般需要配置的是日志级别。有以下几种配置方式：</p>
<p>在<code>application.yml</code>中对全局进行配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">          </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">       </span><span class="c"># 客户端配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">default</span><span class="p">:</span><span class="w">  </span><span class="c"># 默认配置（全局生效）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">logger-level</span><span class="p">:</span><span class="w"> </span><span class="l">FULL </span><span class="w"> </span><span class="c"># 日志级别</span><span class="w">
</span></span></span></code></pre></div><p>在<code>application.yml</code>中对指定的服务进行配置。例如在<code>order-service</code>中对<code>user-service</code>进行配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">                </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">             </span><span class="c"># 客户端配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">user-service</span><span class="p">:</span><span class="w">   </span><span class="c"># 指定服务进行配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">logger-level</span><span class="p">:</span><span class="w"> </span><span class="l">HEADERS  </span><span class="w"> </span><span class="c"># 日志级别</span><span class="w">
</span></span></span></code></pre></div><p>只需要将全局默认配置中的<code>default</code>改成指定的服务名称即可。</p>
<p>另外一种方法是创建<code>FeignClient</code>配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">feign.Logger</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * FeignClient配置类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultFeignClientConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Logger</span><span class="o">.</span><span class="na">Level</span> <span class="nf">getFeignLogLevel</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Logger</span><span class="o">.</span><span class="na">Level</span><span class="o">.</span><span class="na">BASIC</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>注意：<code>FeignClient</code>配置类中的<code>Logger</code>导入的是<code>feign</code>包下的<code>Logger</code>。并且在<code>application.yml</code>中的配置需要注释掉，否则即使开启了配置，配置类中的配置也不会生效。因为<code>application.yml</code>中的配置会将配置类中的配置覆盖掉。</p>
</blockquote>
<p>创建好了<code>FeignClient</code>配置类，这些配置并不会生效。因为<code>FeignClient</code>配置类中并没有任何信息告诉Spring这个是个配置类。所以需要对配置类进行声明。</p>
<p>有两种声明方式，一种是在项目的启动类中进行声明，告诉Spring这个是<code>FeignClient</code>的配置类。并且这种声明方式会在全局生效。声明<code>FeignClient</code>的配置类需要在启动类中使用<code>@EnableFeignClients</code>注解，并为其<code>defaultConfiguration</code>属性指定该<code>FeignClient</code>的配置类的<code>class</code>。例如为<code>order-service</code>声明该配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>  <span class="c1">// 全局默认的Feign配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@MapperScan</span><span class="o">(</span><span class="s">&#34;asia.linner.demo.order.mapper&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">OrderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>另外一种方式是，在某个具体服务<code>FeignClient</code>的接口中进行声明。该方式使用<code>@FeignClient</code>注解，并为其<code>configuration</code>属性指定一个<code>FeignClient</code>配置类的<code>class</code>。例如在<code>order-service</code>中为<code>user-service</code>声明使用一个<code>UserFeignClientConfig</code>配置类（假设已经创建好了该配置类）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;user-service&#34;</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="n">UserFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>记录日志会损耗一部分性能，所以除了在开发过程中使用<code>FULL</code>日志级别。在生产环境中最好使用<code>BASIC</code>或<code>NONE</code>日志级别以减少性能损耗（尽量使用<code>BASIC</code>）。</p>
</blockquote>
<hr>
<h1 id="配置连接池" data-numberify>配置连接池<a class="anchor ms-1" href="#配置连接池"></a></h1>
<p>每次HTTP请求，都需要三次握手去建立连接，完成后再断开连接。在高并发的情况下，这样往复地操作会造成的性能损耗是比较大的。引入连接池是为了减少这种性能的损耗。</p>
<p>Feign底层发起HTTP请求，依赖于其它的框架。其底层客户端实现包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接池</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">URLConnection</td>
<td style="text-align:left">默认实现，不支持连接池</td>
</tr>
<tr>
<td style="text-align:center">Apache HttpClient</td>
<td style="text-align:left">支持连接池</td>
</tr>
<tr>
<td style="text-align:center">OKHttp</td>
<td style="text-align:left">支持连接池</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提高Feign的性能主要手段就是使用HttpClient或OKHttp连接池代替默认的URLConnection。</p>
</blockquote>
<p>这里选择使用HttpClient。首先在消费者中引入其依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--HttpClient依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>io.github.openfeign<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-httpclient<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后在<code>application.yml</code>中修改配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">                </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">httpclient</span><span class="p">:</span><span class="w"> </span><span class="c"># HttpClient配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c"># 如果要使用OKHttp，在feign.okhttp中做相应的配置即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 支持HttpClient的开关</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c"># 默认是true，但是没引入依赖不会生效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">max-connections</span><span class="p">:</span><span class="w"> </span><span class="m">200</span><span class="w">  </span><span class="c"># 最大连接数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">max-connections-per-route</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w"> </span><span class="c"># 单个请求路径的最大连接数</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>提高Feign的性能还可以对连接池客户端的最大连接数根据实际情况进行相应的配置调整。</p>
</blockquote>
<hr>
<h1 id="抽取api接口" data-numberify>抽取API接口<a class="anchor ms-1" href="#抽取api接口"></a></h1>
<p>由于<code>FeignClient</code>接口中编写的接口方法与其对应的提供者中的Controller的方法一致。所以可以对<code>FeignClient</code>接口和Controller做一个统一的API接口抽取，然后再通过集成的方式分别去实现<code>FeignClient</code>和Controller。但是这样的方法有以下缺点：</p>
<ul>
<li>
<p>服务提供方、服务消费方紧耦合。</p>
</li>
<li>
<p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解。</p>
<p>在API父接口的方法参数中使用的注解不会对Spring（也就是Controller）生效。即<code>@PathVariable</code>、<code>@RequestParam</code>这样的注解，在API父接口中声明了，在对应的Controller中也需要再次声明。</p>
</li>
</ul>
<p>以<code>user-service</code>为例：</p>
<ul>
<li>
<p>API父接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserAPI</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p><code>FeignClient</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;user-service&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{}</span>
</span></span></code></pre></div></li>
<li>
<p>Controller：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserAPI</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 业务代码... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ul>
<blockquote>
<p>这种方法的优点是简单、实现了代码共享，遵循了面向契约的编程思想。</p>
</blockquote>
<hr>
<h1 id="抽取-feign-api-模块" data-numberify>抽取 feign-api 模块<a class="anchor ms-1" href="#抽取-feign-api-模块"></a></h1>
<p>另外一种方式是将所有的提供者对应的FeignClient抽取为独立的模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，通过Maven引入依赖的方式提供给所有消费者使用。</p>
<p>假设有多个消费者都需要调用到同一个提供者。如果让消费者分别实现自己的FeignClient，不仅会有许多冗余的代码，而且也不利于维护。但是如果使用这种方式将FeignClient抽取出来，可以由实现提供者的程序员来提供对应的feign-api实现。</p>
<p>这样的方法也有一些缺点，在使用一个提供者的接口时，需要同时引入该提供者的所有接口和其它提供者的所有接口。</p>
<p>抽取<code>feign-api</code>的步骤：</p>
<ol>
<li>
<p>创建一个新的模块，命名为<code>feign-api</code>。</p>
</li>
<li>
<p>在<code>feign-api</code>中引入Feign的Stater依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Feign客户端依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>如果要默认使用<code>HttpClient</code>连接池，还需要导入其坐标：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--HttpClient依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>io.github.openfeign<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-httpclient<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><blockquote>
<p>注：引入坐标是为了在消费者的<code>pom.xml</code>中可以不同显式地导入<code>HttpClient</code>的依赖（使用Maven的依赖传递），但是<code>HttpClient</code>的配置还是得在消费者中的<code>application.yml</code>中配置。</p>
<p>如果在<code>feign-api</code>中创建<code>application.yml</code>中并配置<code>HttpClient</code>，这样的配置是不会在消费者中生效的。因为<code>feign-api</code>没有启动类，而且消费者的启动类也不会使用<code>feign-api</code>中<code>application.yml</code>的配置。除非使用配置类编写对<code>HttpClient</code>的配置，并且在消费者中启用这个配置类。</p>
</blockquote>
</li>
<li>
<p>将所有消费者的<code>FeignClient</code>、POJO和<code>DefaultFeignClientConfig</code>都抽取到<code>feign-api</code>模块中。</p>
<blockquote>
<p>注：<code>DefaultFeignClientConfig</code>的抽取是对所有的<code>FeignClient</code>做一个默认的配置抽取。</p>
</blockquote>
</li>
<li>
<p>在消费者中引入<code>feign-api</code>依赖。</p>
</li>
<li>
<p>在消费者中使用<code>feign-api</code>提供的API接口。</p>
<blockquote>
<p>注：需要修改消费者的启动类，在消费者的启动类上使用<code>@EnableFeignClients</code>注解的<code>basePackages</code>或<code>clients</code>属性指定扫描的<code>FeignClient</code>包或具体的<code>FeignClient</code>类，让消费者的启动类能扫描到<code>feign-api</code>的<code>FeignClient</code>。</p>
</blockquote>
</li>
</ol>
<p>以<code>order-service</code>（消费者）和<code>user-service</code>（提供者）为例：</p>
<ol>
<li>
<p>创建<code>feign-api</code>，并导入Feign依赖。</p>
</li>
<li>
<p>将原本编写在<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>抽取出来，放在<code>feign-api</code>中对应的包下。例如：</p>
<p><code>asia.linner.demo.feign</code>（<code>feign-api</code>的包名）下的包结构:</p>
<ul>
<li><code>clients</code>：
<ul>
<li><code>UserClient.java</code></li>
</ul>
</li>
<li><code>pojo</code>：
<ul>
<li><code>User.java</code></li>
</ul>
</li>
<li><code>config</code>：
<ul>
<li><code>DefaultFeignClientConfig.java</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>抽取完成后，原本在<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>都可以删除。但是需要注意复制在<code>feign-api</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>它们的包名要改成<code>feign-api</code>的包名。</p>
</blockquote>
</li>
<li>
<p>在<code>order-service</code>中导入<code>feign-api</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--引入抽取的feign-api模块--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-api<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><blockquote>
<p>在<code>order-service</code>中的Feign依赖可以删除；如果有在<code>feign-api</code>中导入并配置HttpClient，HttpClient的依赖也可以删除。需要注意引入<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>它们的包名要改成<code>feign-api</code>的包名。</p>
</blockquote>
</li>
<li>
<p>让<code>order-service</code>的启动类扫描<code>FeignClient</code>。</p>
<p>因为<code>feign-api</code>和<code>order-service</code>的包名并不相同（如<code>asia.linner.demo.feign</code>和<code>asia.linner.demo.order</code>），所以在没有扫描包指定的情况下<code>order-service</code>的启动类并不能扫描到<code>feign-api</code>中的<code>UserClient</code>，所以会导致<code>order-service</code>中的<code>UserClient</code>注入失败。</p>
<p>Feign的<code>@EnableFeignClients</code>注解提供了两种方式来让消费者的启动类扫描到<code>FeignClient</code>：</p>
<ul>
<li>
<p><code>basePackages</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePackages</span> <span class="o">=</span> <span class="s">&#34;asia.linner.demo.feign.clients&#34;</span> <span class="c1">// 扫描整个clients包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">)</span>
</span></span></code></pre></div></li>
<li>
<p><code>clients</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">clients</span> <span class="o">=</span> <span class="o">{</span><span class="n">UserClient</span><span class="o">.</span><span class="na">class</span><span class="o">}</span>    <span class="c1">// 指定需要加载的FeignClient接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">)</span>
</span></span></code></pre></div><p><code>clients</code>属性的类型是一个<code>class</code>数组，所以可以指定多个<code>FeignClient</code>。推荐使用该方式。</p>
</li>
</ul>
<p>在上述方法中选一种，然后修改<code>order-service</code>的启动类即可。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Gateway</title>
      <link>/docs/spring/springcloud/gateway/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/gateway/</guid>
      <description><![CDATA[网关 网关是所有微服务的统一入口。网关的核心功能特性： 请求路由：一切请求都必须先经过网关，但网关不处理业务，而是根据某种规则，把请求转发到某个]]></description>
      <content:encoded><![CDATA[<h1 id="网关" data-numberify>网关<a class="anchor ms-1" href="#网关"></a></h1>
<p>网关是所有微服务的统一入口。网关的核心功能特性：</p>
<ul>
<li><strong>请求路由</strong>：一切请求都必须先经过网关，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当路由的目标服务有多个时，还需要做<strong>负载均衡</strong>。</li>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</li>
</ul>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>Gateway：基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
<li>Zuul：基于Servlet的实现，属于阻塞式编程。</li>
</ul>
<blockquote>
<p>Spring Cloud Gateway旨在为微服务架构提供一种简单有效的统一的API路由管理方式。</p>
</blockquote>
<hr>
<h1 id="创建-gateway-服务" data-numberify>创建 Gateway 服务<a class="anchor ms-1" href="#创建-gateway-服务"></a></h1>
<p>创建一个Gateway服务的基本步骤如下：</p>
<ol>
<li>
<p>创建一个新的gateway模块。</p>
</li>
<li>
<p>导入Gateway所需依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos服务注册发现依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 网关Gateway依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-gateway<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>因为Gateway属于一个服务，所以需要创建并编写<code>GatewayApplication</code>启动类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GatewayApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">GatewayApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在配置文件<code>application.yml</code>中编写Gateway相关配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">10010</span><span class="w"> </span><span class="c"># 网关端口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">gateway</span><span class="w"> </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nacos</span><span class="p">:</span><span class="w">  </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">routes</span><span class="p">:</span><span class="w">   </span><span class="c"># 网关路由配置（是数组类型，可以配置多个）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w"> </span><span class="c"># 路由ID，自定义，只要唯一即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri支持以下两种方式，推荐使用lb方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri: http://localhost:8081  # 路由的目标地址，使用http表示固定地址（不推荐使用）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w"> </span><span class="c"># 路由的目标地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># lb是Load Balance的缩写，表示负载均衡</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># 后面是服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> </span><span class="c"># 路由断言，判断请求是否符合路由规则的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/user/**</span><span class="w"> </span><span class="c"># 路径断言，匹配&#34;/user/&#34;开头的请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://${spring.cloud.gateway.routes[1].id} </span><span class="w"> </span><span class="c"># 通过yaml变量设置uri</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Before=2037-01-20T17:42:47.789-07:00[America/Denver]</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>启动<code>GatewayApplication</code>，使用<code>localhost:10010</code>来访问系统上的服务。</p>
<p>例如访问<code>user-service</code>上的<code>/user/{id}</code>请求，就可以使用<code>http://localhost:10010/user/{id}</code>访问。获取<code>id</code>为<code>1</code>的<code>user</code>就访问<a href="http://localhost:10010/user/1" target="_blank" rel="noopener noreferrer"><code>http://localhost:10010/user/1</code><i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>如上所述，访问<code>order-service</code>上的<code>/order/{id}</code>就使用<code>http://localhost:10010/order/{id}</code>访问。</p>
</li>
</ol>
<p>使用网关就可以通过网关来访问服务中的资源，并且还能做到负载均衡和权限控制等。</p>
<hr>
<h1 id="路由配置" data-numberify>路由配置<a class="anchor ms-1" href="#路由配置"></a></h1>
<p>Gateway的路由配置如上所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">routes</span><span class="p">:</span><span class="w">   </span><span class="c"># 网关路由配置（是数组类型，可以配置多个）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w"> </span><span class="c"># 路由ID，自定义，只要唯一即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri支持以下两种方式，推荐使用lb方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri: http://localhost:8081  # 路由的目标地址，使用http表示固定地址（不推荐使用）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w"> </span><span class="c"># 路由的目标地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># lb是Load Balance的缩写，表示负载均衡</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># 后面是服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> </span><span class="c"># 路由断言，判断请求是否符合路由规则的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/user/**</span><span class="w"> </span><span class="c"># 路径断言，匹配&#34;/user/&#34;开头的请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://${spring.cloud.gateway.routes[1].id} </span><span class="w"> </span><span class="c"># 通过yaml变量设置uri</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Before=2037-01-20T17:42:47.789-07:00[America/Denver]</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>
<p><code>cloud.gateway.routes</code>：Gateway的网关路由配置，数组类型。其元素可以有<code>id</code>、<code>uri</code>和<code>predicates</code>等属性。</p>
</li>
<li>
<p><code>id</code>属性：标识一个服务的路由配置的唯一ID。可由用户自定义，但在当前Gateway网关服务中不可重复存在。</p>
</li>
<li>
<p><code>uri</code>属性：标识当前服务路由配置的目标地址。有两种配置方式：</p>
<ul>
<li>
<p><code>http</code>：使用<code>http://</code>前缀，表示当前的地址是固定地址。例如<code>http://localhost:8081</code>。</p>
</li>
<li>
<p><code>lb</code>：使用<code>lb://</code>前缀，表示当前的地址是非固定的，需要做负载均衡。例如：<code>lb://user-service</code>。</p>
<blockquote>
<p><code>lb</code>是Load Balance的缩写，表示负载均衡。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>predicates</code>属性：路由断言，根据Gateway提供的断言工厂，对经过网关的请求进行权限的断言（也就是判断有没有权限可以访问该服务）。<code>predicates</code>是数组属性，可以配置多个规则。</p>
</li>
</ul>
<h1 id="断言工厂" data-numberify>断言工厂<a class="anchor ms-1" href="#断言工厂"></a></h1>
<p>在配置文件中写的断言规则，会被Predicate Factory读取并处理，转变为路由判断的条件。</p>
<p>例如上方<code>Path=/user/**</code>就是按照路径匹配，断言只有<code>/user/**</code>这个请求方式才能通过网关访问到<code>user-service</code>。<code>order-service</code>中的<code>Path=/order/**</code>同理。这两条规则是由<code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的。</p>
<p>在Gateway中还有以下断言工厂：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>After</code></td>
<td>是某个时间点后的请求。</td>
<td><code>After=2037-01-20T17:42:47.789-07:00[America/Denver]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Before</code></td>
<td>是某个时间点之前的请求。</td>
<td><code>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Between</code></td>
<td>是某两个时间点之前的请求。</td>
<td><code>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Cookie</code></td>
<td>请求必须包含某些cookie。</td>
<td><code>Cookie=chocolate, ch.p</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Header</code></td>
<td>请求必须包含某些header。</td>
<td><code>Header=X-Request-Id, \d+</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Host</code></td>
<td>请求必须是访问某个host（域名）。</td>
<td><code>Host=**.somehost.org,**.anotherhost.org</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Method</code></td>
<td>请求方式必须是指定方式。</td>
<td><code>Method=GET,POST</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Path</code></td>
<td>请求路径必须符合指定规则。</td>
<td><code>Path=/red/{segment},/blue/**</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Query</code></td>
<td>请求参数必须包含指定参数。</td>
<td><code>Query=name, Jack</code>，<br>或者<code>Query=name</code></td>
</tr>
<tr>
<td style="text-align:center"><code>RemoteAddr</code></td>
<td>请求者的ip必须是指定范围。</td>
<td><code>RemoteAddr=192.168.1.1/24</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Weight</code></td>
<td>权重处理。</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="路由过滤器" data-numberify>路由过滤器<a class="anchor ms-1" href="#路由过滤器"></a></h1>
<p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>
<p>Spring提供了31种不同的路由过滤器工厂。常用的有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AddRequestHeader</code></td>
<td>给当前请求添加一个请求头。</td>
</tr>
<tr>
<td><code>RemoveRequestHeader</code></td>
<td>移除请求中的一个请求头。</td>
</tr>
<tr>
<td><code>AddResponseHeader</code></td>
<td>给响应结果中添加一个响应头。</td>
</tr>
<tr>
<td><code>RemoveResponseHeader</code></td>
<td>从响应结果中移除有一个响应头。</td>
</tr>
<tr>
<td><code>RequestRateLimiter</code></td>
<td>限制请求的流量。</td>
</tr>
</tbody>
</table>
<p>GatewayFilter的使用也是在<code>application.yml</code>中配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">routes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/user/** </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">filters</span><span class="p">:</span><span class="w"> </span><span class="c"># 过滤器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">AddRequestHeader=Hello, Hello Spring Cloud Gateway!</span><span class="w"> </span><span class="c"># 添加请求头</span><span class="w">
</span></span></span></code></pre></div><h1 id="defaultfilter" data-numberify>DefaultFilter<a class="anchor ms-1" href="#defaultfilter"></a></h1>
<p>上方所示的GatewayFilter只有在访问<code>user-service</code>时才能生效。Spring Cloud Gateway还提供了全局默认的GatewayFilter配置方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">routes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://userservice </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/user/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://order-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">default-filters</span><span class="p">:</span><span class="w"> </span><span class="c"># 默认过滤项</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">AddRequestHeader=Truth, Itcast is freaking awesome! </span><span class="w">
</span></span></span></code></pre></div><p>这种方式无论访问的是<code>user-service</code>还是<code>order-service</code>都会生效。</p>
<p>在Spring Cloud Gateway的官方文档中可以查找更多路由工厂及其使用方式：</p>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories" target="_blank" rel="noopener noreferrer"><picture><img class="img-fluid " alt="Spring Cloud Gateway 官方文档" src="/docs/spring/springcloud/gateway/uTools_1690728134391.png" loading="lazy" width="1897" height="949" />
</picture>

<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<h1 id="globalfilter" data-numberify>GlobalFilter<a class="anchor ms-1" href="#globalfilter"></a></h1>
<p>GlobalFilter的作用与GatewayFilter的作用一样，也是处理一切进入网关的请求和微服务响应。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现，可以自定义实现。</p>
<p><code>GlobalFilter</code>接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GlobalFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * 处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @param exchange 请求上下文，里面可以获取Request、Responses等信息
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @param chain 用来把请求委托给下一个过滤器（放行请求）
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @return {@code Mono&lt;Void&gt;} 返回一个当前过滤器业务结束的标示
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>注：<code>GlobalFilter</code>是在<code>org.springframework.cloud.gateway.filter</code>包下的，是属于Spring Cloud Gateway中的一部分。</p>
</blockquote>
<p>在Filter中编写自定义逻辑，可以实现登录状态判断、权限校验、请求限流等等功能。</p>
<p>假设实现一个简单的用户权限判断，其判断逻辑如下：</p>
<ul>
<li>请求参数中是否有<code>authorization</code>；</li>
<li><code>authorization</code>参数值是否为<code>admin</code>。</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 识别用户权限
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Order</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>   <span class="c1">// 顺序注解（定义过滤器的执行顺序），值越小优先级越高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizeFilter</span> <span class="kd">implements</span> <span class="n">GlobalFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 获取请求参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ServerHttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getRequest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">MultiValueMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getQueryParams</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 获取参数中的 authorization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">auth</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="na">getFirst</span><span class="o">(</span><span class="s">&#34;authorization&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 判断参数值是否等于 admin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="s">&#34;admin&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">auth</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 4. 是则放行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// chain.filter()的返回值是Mono&lt;Void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 否则拦截
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ServerHttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getResponse</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 5.1. 设置状态码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// HttpStatus.UNAUTHORIZED 表示用户未认证，状态码为401
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">response</span><span class="o">.</span><span class="na">setStatusCode</span><span class="o">(</span><span class="n">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 5.2. 拦截请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// setComplete()的返回也是Mono&lt;Void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">setComplete</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>定义GlobalFilter的过程可总结为：</p>
<ol>
<li>
<p>继承<code>GlobalFilter</code>接口。</p>
</li>
<li>
<p>实现<code>GlobalFilter.filter()</code>方法。</p>
<p>在实现<code>GlobalFilter.filter()</code>时，可以使用<code>exchange</code>对象获取请求的<code>Request</code>、<code>Response</code>、<code>Attribute</code>、<code>Session</code>、<code>FormData</code>等信息。其中获取到的<code>Request</code>和<code>Response</code>分别是<code>ServerHttpRequest</code>和<code>ServerHttpResponse</code>对象。</p>
<blockquote>
<p>使用<code>exchange</code>获取到的对象与使用标准的ServletAPI获取到的不一样。</p>
</blockquote>
<p>放行资源使用的是<code>chain</code>对象。该对象仅有一个方法<code>filter()</code>。该方法接受一个<code>ServerWebExchange</code>对象（也就是<code>exchange</code>，相当于将<code>exchange</code>传给下一级Filter），并返回给上层Filter一个<code>Mono&lt;Void&gt;</code>对象。放行资源时标准的用法是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span></code></pre></div><p>拦截资源使用的是从<code>exchange</code>中获取的<code>response</code>对象。调用<code>response</code>对象的<code>setComplete()</code>方法，返回给上层Filter一个<code>Mono&lt;Void&gt;</code>。标准用法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">setComplete</span><span class="o">();</span>
</span></span></code></pre></div><p>这样相当于直接将业务结束标示<code>Mono&lt;Void&gt;</code>返回给上层Filter。而没有调用<code>chain.filter(exchange)</code>的话，请求也就不会进入到下层Filter。</p>
</li>
<li>
<p>为实现的<code>GlobalFilter</code>使用<code>@Component</code>注解，让Spring可以将该过滤器加载为Bean。</p>
</li>
<li>
<p>为实现的<code>GlobalFilter</code>定义顺序（有两种定义方式）。</p>
<p>定义<code>GlobalFilter</code>执行的优先级顺序的一个方法就是使用如上所示的<code>@Order</code>注解。在<code>@Order</code>注解中，其<code>value</code>属性是一个<code>int</code>类型的值，默认为<code>Integer.MAX_VALUE</code>也就是<code>int</code>类型的最大值<code>2147483647</code>（即$2^{31}-1$，按32位补码计算），<code>value</code>越小优先级越高。</p>
<p>另一种方式就是继承一个<code>Ordered</code>接口，并实现其<code>getOrder()</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizeFilter</span> <span class="kd">implements</span> <span class="n">GlobalFilter</span><span class="o">,</span> <span class="n">Ordered</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 拦截/放行逻辑... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 定义过滤器执行顺序，效果与{@code @Order}相同
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 过滤器的执行顺序，值越小优先级越高
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getOrder</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<h1 id="过滤器链" data-numberify>过滤器链<a class="anchor ms-1" href="#过滤器链"></a></h1>
<p>请求进入网关后会遇到三类过滤器：</p>
<ul>
<li>当前路由的过滤器；</li>
<li>默认过滤器（DefaultFilter）；</li>
<li>全局过滤器（GlobalFilter）。</li>
</ul>
<p>在请求路由后，Spring Cloud Gateway会将每个路由的路由过滤器、默认过滤器和全局过滤器合并到一个过滤器链（集合）中，并进行排序。然后Spring Cloud Gateway会根据请求，按顺序执行路由对应的过滤器链。</p>
<blockquote>
<p>在CSDN上看到一个Gateway执行流程图，确实是在请求路由之后才开始组装过滤器链：</p>
<p><picture><img class="img-fluid " alt="Gateway执行流程图" src="/docs/spring/springcloud/gateway/20210405115550799.png" loading="lazy" width="1076" height="1268" />
</picture>

</p>
<p>原文链接：<a href="https://blog.csdn.net/riemann_/article/details/115440231" target="_blank" rel="noopener noreferrer">Spring Cloud Gateway 源码剖析之Filter Chain过滤器链<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
</blockquote>
<p>路由过滤器和默认过滤器的实现十分接近，它们的本质都是<code>AddRequestHeaderGatewayFilterFactory</code>，并且最后通过<code>apply()</code>方法读取配置后生成统一的过滤器对象<code>GatewayFilter</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddRequestHeaderGatewayFilterFactory</span>
</span></span><span class="line"><span class="cl">		<span class="kd">extends</span> <span class="n">AbstractNameValueGatewayFilterFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">GatewayFilter</span> <span class="nf">apply</span><span class="o">(</span><span class="n">NameValueConfig</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">GatewayFilter</span><span class="o">()</span> <span class="o">{</span>    <span class="c1">// 生成过滤器对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">			<span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">					<span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">			<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">		<span class="o">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>全局过滤器则是通过<code>FilteringWebHandler</code>中的私有类<code>GatewayFilterAdapter</code>（过滤器适配器）生成，使用<code>loadFilters()</code>将所有<code>GlobalFilter</code>转化为<code>GatewayFilterAdapter</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FilteringWebHandler</span> <span class="kd">implements</span> <span class="n">WebHandler</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">globalFilters</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">FilteringWebHandler</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GlobalFilter</span><span class="o">&gt;</span> <span class="n">globalFilters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">globalFilters</span> <span class="o">=</span> <span class="n">loadFilters</span><span class="o">(</span><span class="n">globalFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 将所有GlobalFilter链转为GatewayFilter
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="nf">loadFilters</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GlobalFilter</span><span class="o">&gt;</span> <span class="n">filters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">filters</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">filter</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">GatewayFilterAdapter</span> <span class="n">gatewayFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GatewayFilterAdapter</span><span class="o">(</span><span class="n">filter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="o">(</span><span class="n">filter</span> <span class="k">instanceof</span> <span class="n">Ordered</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="o">((</span><span class="n">Ordered</span><span class="o">)</span> <span class="n">filter</span><span class="o">).</span><span class="na">getOrder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="k">new</span> <span class="n">OrderedGatewayFilter</span><span class="o">(</span><span class="n">gatewayFilter</span><span class="o">,</span> <span class="n">order</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">gatewayFilter</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">		<span class="o">}).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 加载全局过滤器，与所有的路由过滤器和默认过滤器合并后更具Order排序、组织过滤器链
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">handle</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Route</span> <span class="n">route</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getRequiredAttribute</span><span class="o">(</span><span class="n">GATEWAY_ROUTE_ATTR</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 加载所有的默认过滤器和路由过滤器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 加载方式是，先加载默认过滤器链，然后根据Route（规则）加载路由过滤器链，最后合并为一个过滤器链
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">gatewayFilters</span> <span class="o">=</span> <span class="n">route</span><span class="o">.</span><span class="na">getFilters</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">combined</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">.</span><span class="na">globalFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">combined</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">gatewayFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// TODO: needed or cached?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">combined</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Sorted gatewayFilterFactories: &#34;</span> <span class="o">+</span> <span class="n">combined</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="k">new</span> <span class="n">DefaultGatewayFilterChain</span><span class="o">(</span><span class="n">combined</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">GatewayFilterAdapter</span> <span class="kd">implements</span> <span class="n">GatewayFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kd">final</span> <span class="n">GlobalFilter</span> <span class="n">delegate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 私有类构造方法
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="n">GatewayFilterAdapter</span><span class="o">(</span><span class="n">GlobalFilter</span> <span class="n">delegate</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 实现GatewayFilter的filter()方法
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">delegate</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">,</span> <span class="n">chain</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>综上所述，Spring Cloud Gateway加载过滤器链的过程大致如下：</p>
<ol>
<li>
<p>加载默认过滤器链。</p>
</li>
<li>
<p>加载路由过滤器链。</p>
</li>
<li>
<p>合并默认过滤器链和路由过滤器链为一条过滤器链。</p>
<p>路由过滤器和默认过滤器的<code>Order</code>由Spring指定，默认是按照声明顺序从1递增。</p>
</li>
<li>
<p>加载全局过滤器链。</p>
</li>
<li>
<p>将全局过滤器链和 默认过滤器与路由过滤器合并的链 合并。</p>
<blockquote>
<p>所有的过滤器都有一个<code>int</code>类型的<code>Order</code>值，<code>Order</code>值越小，优先级越高，执行顺序越靠前。</p>
</blockquote>
<p>当过滤器的<code>Order</code>值一样时，会按照 <strong>默认过滤器 &gt; 路由过滤器 &gt; 全局过滤器</strong> 的顺序执行。</p>
</li>
</ol>
<h1 id="跨域问题处理" data-numberify>跨域问题处理<a class="anchor ms-1" href="#跨域问题处理"></a></h1>
<p>跨域是指发送与当前服务的域名（或端口）不一致的请求。</p>
<p>跨域问题的产生原因是浏览器不允许Ajax请求对域名不同或端口不同的服务发起请求。例如：</p>
<ul>
<li>域名不同： <code>www.taobao.com</code>和<code>www.taobao.org</code>，<code>www.linner.asia</code>和<code>blog.linner.asia</code>。</li>
<li>域名相同，端口不同：<code>localhost:8080</code>和<code>localhost8081</code>。</li>
</ul>
<p>解决方案之一就是CORS。Gateway为我们提供了使用CORS处理跨域问题的方法，只需修改<code>application.yml</code>即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">globalcors</span><span class="p">:</span><span class="w"> </span><span class="c"># 全局的跨域处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">add-to-simple-url-handler-mapping</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 解决options请求被拦截问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cors-configurations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">&#39;[/**]&#39;</span><span class="p">:</span><span class="w">  </span><span class="c"># 对所有请求进行跨域处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedOrigins</span><span class="p">:</span><span class="w"> </span><span class="c"># 允许跨域请求的网站</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;http://localhost:5500&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;http://http://127.0.0.1:5500&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedMethods</span><span class="p">:</span><span class="w"> </span><span class="c"># 允许的跨域ajax的请求方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;GET&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;POST&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;DELETE&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;PUT&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;OPTIONS&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedHeaders</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;*&#34;</span><span class="w"> </span><span class="c"># 允许在请求中携带的头信息（这里是允许所有）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowCredentials</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># 是否允许携带cookie</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">maxAge</span><span class="p">:</span><span class="w"> </span><span class="m">360000</span><span class="w">  </span><span class="c"># 每次跨域检测的有效期（在有效期内浏览器不会重复询问跨域请求）</span><span class="w">
</span></span></span></code></pre></div><p>模拟一个跨域问题：</p>
<ol>
<li>
<p>编写一个简单的页面，其中用Ajax发起跨域请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;ie=edge&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Document<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>模拟跨域问题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/axios/dist/axios.min.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发送请求到Gateway网关上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;http://localhost:10010/user/1?authorization=admin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resp</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>使用Tomcat或Nginx之类的Web服务器放置这个Html页面。</p>
<blockquote>
<p>我在模拟时使用的是VS Code的<code>Live Server</code>插件。它会想Web服务器一样在你电脑上开一个端口加载页面，让你能实时预览你的页面效果。用在这里做个简单的静态页面Web服务器也很方便。</p>
<p><picture><img class="img-fluid " alt="Live Server 插件" src="/docs/spring/springcloud/gateway/uTools_1690798301739.png" loading="lazy" width="919" height="238" />
</picture>

</p>
<p>Live Server使用的端口是<code>5500</code>，当然也有可能不同。</p>
</blockquote>
</li>
<li>
<p>在给Gateway网关配置跨域请求处理之前，通过Web服务器访问页面，可以在浏览器控制台发现类似以下的报错：</p>
<p><picture><img class="img-fluid " alt="跨域报错信息" src="/docs/spring/springcloud/gateway/uTools_1690798524991.png" loading="lazy" width="702" height="66" />
</picture>

</p>
</li>
<li>
<p>配置成功后重启Gateway网关，再次访问页面，可以发现浏览器控制台打印出了跨域请求获取到的结果。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Nacos</title>
      <link>/docs/spring/springcloud/nacos/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/nacos/</guid>
      <description><![CDATA[部署 Nacos Server 安装和配置好Nacos后，在nacos的bin目录中使用脚本启动： Windows： 单机启动： startup.cmd -m standalone Linux： 单机启动： sh startup.sh -m standalone 在浏]]></description>
      <content:encoded><![CDATA[<h1 id="部署-nacos-server" data-numberify>部署 Nacos Server<a class="anchor ms-1" href="#部署-nacos-server"></a></h1>
<p>安装和配置好Nacos后，在<code>nacos</code>的<code>bin</code>目录中使用脚本启动：</p>
<ul>
<li>
<p>Windows：</p>
<p>单机启动：</p>
<pre tabindex="0"><code>startup.cmd -m standalone
</code></pre></li>
<li>
<p>Linux：</p>
<p>单机启动：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sh startup.sh -m standalone
</span></span></code></pre></div></li>
</ul>
<p>在浏览器中使用对应的IP和端口访问，如<code>http://localhost:8848/nacos</code>。</p>
<p>默认账号和密码均为<code>nacos</code>。</p>
<blockquote>
<p>更多Nacos的部署方式：<a href="/p/nacos-%e9%83%a8%e7%bd%b2/">Nacos 部署</a></p>
</blockquote>
<hr>
<h1 id="服务注册中心" data-numberify>服务注册中心<a class="anchor ms-1" href="#服务注册中心"></a></h1>
<h2 id="nacos-客户端依赖" data-numberify>Nacos 客户端依赖<a class="anchor ms-1" href="#nacos-客户端依赖"></a></h2>
<ul>
<li>
<p>父工程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--
</span></span></span><span class="line"><span class="cl"><span class="c">    Spring Cloud Alibaba
</span></span></span><span class="line"><span class="cl"><span class="c">    包含了Nacos的版本管理
</span></span></span><span class="line"><span class="cl"><span class="c"> --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-alibaba-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.2.5.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos 客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>配置Nacos（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="服务器集群" data-numberify>服务器集群<a class="anchor ms-1" href="#服务器集群"></a></h2>
<p>在Nacos中配置服务器集群，需要在<code>application.yml</code>使用来配置<code>spring.cloud.nacos.discovery.cluster-name</code>客户端服务器的集群名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cluster-name</span><span class="p">:</span><span class="w"> </span><span class="l">HZ </span><span class="w"> </span><span class="c"># 集群名称</span><span class="w">
</span></span></span></code></pre></div><p>使用Nacos提供的集群配置，就可以将同一机房内的实例划分为一个集群。</p>
<p><picture><img class="img-fluid " alt="服务器集群" src="/docs/spring/springcloud/nacos/uTools_1688717062670.png" loading="lazy" width="1145" height="540" />
</picture>

</p>
<h2 id="负载均衡策略" data-numberify>负载均衡策略<a class="anchor ms-1" href="#负载均衡策略"></a></h2>
<p>Nacos提供了一个负载均衡策略<code>NacosRule</code>配置它和配置其它的Ribbon负载均衡策略相同。在<code>application.yml</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">service-name</span><span class="p">:</span><span class="w"> </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 负载均衡规则</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># Nacos提供的负载均衡策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">NFLoadBalancerRuleClassName</span><span class="p">:</span><span class="w"> </span><span class="l">com.alibaba.cloud.nacos.ribbon.NacosRule</span><span class="w">
</span></span></span></code></pre></div><p>当然也可以使用Bean的方式配置全局的负载均衡策略：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IRule</span> <span class="nf">getLoadBalancerRule</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">NacosRule</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>NacosRule</code>会根据当前服务所在的集群，优先挑选与当前服务相同的集群。因为在同一机房同一集群的配置下，访问本地的集群（即相同的集群）速度将会更快。如果相同的集群下无可用实例，才会选择其它示例，并且控制台会给出警告。如果在相同集群的情况下，则使用随机轮询，随机选择一个实例。</p>
<h2 id="访问权重" data-numberify>访问权重<a class="anchor ms-1" href="#访问权重"></a></h2>
<p>默认情况下使用NacosRule是在同集群内随机挑选，并不会考虑机器的性能问题。</p>
<p>为了让性能更快的服务可以被分配到更多的请求，Nacos提供了权重配置来控制访问频率。使用访问权重，可以调节服务被访问到的概率。访问权重的<u>取值为0~1</u>，<u>默认值是1</u>，<u>权重越高</u>，被访问到的<u>概率就越大</u>。如果将访问<u>权重修改为0</u>，那么该实例将<u>永远不会被访问</u>。</p>
<blockquote>
<p>将访问权重修改为0并不意味着服务器停机，只是后续的请求不会使用到这个服务器，而当前该服务器所处理的请求还会继续。</p>
</blockquote>
<p>修改访问权重可以在Nacos控制台中修改：</p>
<p>例如，修改<code>user-service</code>的权重，找到<code>user-service</code>的实例列表，点击编辑，即可修改权重：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210713235133225.png" loading="lazy" width="1229" height="357" />
</picture>

</p>
<p>在弹出的编辑窗口，修改权重：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210713235235219.png" loading="lazy" width="749" height="639" />
</picture>

</p>
<h2 id="非临时实例" data-numberify>非临时实例<a class="anchor ms-1" href="#非临时实例"></a></h2>
<p>Nacos的服务实例（服务提供者）分为两种类型：</p>
<ul>
<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，是所有实例默认的类型。</li>
<li><strong>非临时实例</strong>（永久实例）：如果实例宕机，不会将其从服务列表剔除。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">ephemeral</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">  </span><span class="c"># 注册为非临时实例</span><span class="w">
</span></span></span></code></pre></div><h2 id="环境隔离" data-numberify>环境隔离<a class="anchor ms-1" href="#环境隔离"></a></h2>
<p>Nacos提供了<code>namespace</code>（命名空间）来实现环境隔离功能。默认情况下，所有<code>service</code>、<code>data</code>、<code>group</code>都在同一个名为<code>public</code>的<code>namespace</code>。每个<code>namespace</code>都有一个唯一的ID，并且不同<code>namespace</code>下的服务之间互不可见。<code>namespace</code>可以在Nacos控制台中创建。</p>
<p>为服务设置<code>namespace</code>，需要在<code>application.yml</code>中配置<code>spring.cloud.nacos.discovery.namespace</code>，它的值为对应命名空间的ID：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 命名空间，值为对应命名空间的ID</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">df79820e-775d-4787-b0a8-0b6e5fabeb13</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="nacos-与-eureka-的区别" data-numberify>Nacos 与 Eureka 的区别<a class="anchor ms-1" href="#nacos-与-eureka-的区别"></a></h1>
<p><picture><img class="img-fluid " alt="Nacos远程调用流程" src="/docs/spring/springcloud/nacos/uTools_1688717257055.png" loading="lazy" width="966" height="370" />
</picture>

</p>
<p>Nacos和Eureka整体结构类似，都有服务注册、服务拉取、心跳等待等，但是也存在一些差异：</p>
<ul>
<li>共同点：
<ul>
<li>都支持服务注册和服务拉取。</li>
<li>都支持服务提供者心跳方式做健康检测。</li>
</ul>
</li>
<li>不同点：
<ul>
<li>
<p>Nacos支持服务端主动检测提供者状态：</p>
<ul>
<li>临时实例采用心跳模式；</li>
<li>非临时实例采用主动检测模式。</li>
</ul>
<p>主动检测的弊端：会给服务器造成一定的压力。一般情况下使用临时实例的心跳模式即可。</p>
</li>
<li>
<p>在Nacos中，临时实例心跳不正常会被剔除，非临时实例则不会被剔除。</p>
</li>
<li>
<p>Nacos支持服务列表变更的消息推送模式，服务列表更新更加及时。</p>
</li>
<li>
<p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="配置管理" data-numberify>配置管理<a class="anchor ms-1" href="#配置管理"></a></h1>
<p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>
<p>在Nacos中，配置获取的步骤如下：</p>
<ol>
<li>项目启动。</li>
<li>读取Nacos中的给服务定义的配置文件。</li>
<li>读取本地配置文件<code>application.yml</code>。与上一步在Nacos中读取到的配置相合并。</li>
<li>创建Spring容器。</li>
<li>加载Bean</li>
</ol>
<p>依赖<code>pom.xml</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos配置管理依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>新建配置文件<code>bootstrap.yml</code>，进行如下配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">service-name</span><span class="w"> </span><span class="c"># 服务名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">profiles</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">active</span><span class="p">:</span><span class="w"> </span><span class="l">env-name</span><span class="w"> </span><span class="c"># 环境名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos 配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">file-extension</span><span class="p">:</span><span class="w"> </span><span class="l">yml</span><span class="w"> </span><span class="c"># 配置文件后缀名</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>依赖和配置在需要配置管理的服务中添加和修改。</p>
<p>在<code>bootstrap.yml</code>中已经配置过的配置，在<code>application.yml</code>中可以不用重复配置。</p>
</blockquote>
<p>在Nacos控制台中添加配置文件：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210714164742924.png" loading="lazy" width="1466" height="600" />
</picture>

</p>
<p>对新添加的配置文件进行编辑，编辑完成好后点击发布进行提交：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/uTools_1689498771620.png" loading="lazy" width="872" height="771" />
</picture>

</p>
<h2 id="多环境配置共享" data-numberify>多环境配置共享<a class="anchor ms-1" href="#多环境配置共享"></a></h2>
<p>微服务启动时会从Nacos中读取多个配置文件：</p>
<ul>
<li><code>[service-name]-[env-name].[file-extension]</code>：<strong>当前环境配置</strong>。只能在对应环境的情况下进行读取。</li>
<li><code>[service-name].[file-extension]</code>：<strong>共享环境配置</strong>。无论当前实例处于什么环境下，该文件一定会被加载。所以多环境共享配置可以写在这个文件中。</li>
</ul>
<blockquote>
<p><code>[file-extension]</code>为配置中对应的文件扩展名。</p>
</blockquote>
<h2 id="读取配置" data-numberify>读取配置<a class="anchor ms-1" href="#读取配置"></a></h2>
<ul>
<li>
<p>使用<code>@RefreshScope</code>注解进行配置自动刷新：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RefreshScope</span>   <span class="c1">// 配置自动刷新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${pattern.dateformat}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">dateformat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 返回当前按照规定格式进行格式化的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/now&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">now</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">format</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">dateformat</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>使用<code>@ConfigurationProperties</code>注解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Data</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 读取以pattern为开头的配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">&#34;pattern&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PatternProperties</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">dateformat</span><span class="o">;</span>  <span class="c1">// 相当于 pattern.dateformat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">PatternProperties</span> <span class="n">properties</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/now&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">now</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">format</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getDateformat</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>@ConfigurationProperties</code>注解将配置读取到类中，在配置更改的时候，类将会自动更新，而无需使用<code>@RefreshScope</code>注解。</p>
</li>
</ul>
<h2 id="配置文件优先级" data-numberify>配置文件优先级<a class="anchor ms-1" href="#配置文件优先级"></a></h2>
<p>Nacos中多种配置文件的优先级从高到低的顺序如下：</p>
<ol>
<li><code>[service-name]-[env-name].yml</code></li>
<li><code>[service-name].yml</code></li>
<li>本地配置文件（如<code>application.yml</code>，本地配置文件也有自己的优先级）</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>RestTemplate</title>
      <link>/docs/spring/springcloud/remote-call/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/remote-call/</guid>
      <description><![CDATA[微服务远程调用 在微服务架构中，不同微服务都应该有自己独立的数据库以减少服务之间的冗余。而不同的服务之间可能需要共享数据。但拆分后的服务，它们]]></description>
      <content:encoded><![CDATA[<h1 id="微服务远程调用" data-numberify>微服务远程调用<a class="anchor ms-1" href="#微服务远程调用"></a></h1>
<p>在微服务架构中，不同微服务都应该有自己独立的数据库以减少服务之间的冗余。而不同的服务之间可能需要共享数据。但拆分后的服务，它们的数据库是相互独立的，一个服务不可能去调用另一个服务的数据库，所以服务之间的信息共享成为一个问题。</p>
<p>为了解决服务之间的信息共享，微服务通过将业务暴露为接口，以供其它微服务使用。这种服务调用方式与用户调用服务的方式是相同的，都是通过URL来远程调用接口。</p>
<p>在微服务远程调用中，有一下两种角色：</p>
<ul>
<li>
<p>服务<strong>提供者</strong>（Provider）：一次业务中，被其它微服务调用的服务。</p>
<p>即提供接口给其它微服务的服务。</p>
</li>
<li>
<p>服务<strong>消费者</strong>（Consumer）：一次业务中，调用其它微服务的服务。</p>
<p>即调用其它微服务提供的接口的服务。</p>
</li>
</ul>
<p>服务的角色是相对而言的。抛开业务来讲，服务既可以是提供者也可以消费者。</p>
<hr>
<h1 id="resttemplate-远程调用" data-numberify>RestTemplate 远程调用<a class="anchor ms-1" href="#resttemplate-远程调用"></a></h1>
<p>在SpringCloud中，微服务的远程调用方式可以通过<code>RestTemplate</code>发起HTTP请求来调用。而HTTP请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。</p>
<p>例如有两个服务，分别是用户服务和订单服务，订单服务在获取订单信息时需要将用户信息一同发送：</p>
<ol>
<li>
<p>使用<code>RestTemplate</code>需要先进行注册（配置）。</p>
<p>在订单服务模块（消费者）中新建一个配置并声明一个Bean：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 创建RestTemplate，并注入Spring容器
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">getRestTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>OrderService</code>中注入<code>RestTemplate</code>，并通过<code>RestTemplate</code>远程调用用户服务模块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入RestTemplate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用RestTemplate发起HTTP请求，查询用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2.1.URL路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://localhost:8081/user/&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2.发送HTTP（GET）请求，实现远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>RestTemplate.getForObject()</code>是<code>RestTemplate</code>调用HTTP-GET请求的方法，该方法接收一个字符串类型的URL参数，并可以通过<code>.class</code>来指定响应的类型。</p>
<p>用户服务模块中相应的接口如下（假设服务的端口为本地<code>8081</code>端口）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&#34;/user&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserService</span> <span class="n">userService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 根据用户ID获取用户信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param id 用户ID
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 用户信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">User</span> <span class="nf">queryById</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">userService</span><span class="o">.</span><span class="na">queryById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<p>使用<code>RestTemplate</code>存在以下问题：</p>
<ul>
<li>URL的硬编码问题。</li>
<li>服务消费者该如何获取服务提供者的地址信息。</li>
<li>如果有多个服务提供者，消费者该如何选择。</li>
<li>消费者如何得知服务提供者的健康状态。</li>
</ul>
<blockquote>
<p><code>RestTemplate</code>是Spring Cloud自带的，所以不用引入依赖。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Spring 环境和配置</title>
      <link>/docs/spring/springcloud/config/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/config/</guid>
      <description><![CDATA[微服务需要根据业务模块拆分，做到单一职责，不要重复开发相同业务。 父工程 微服务是一种分布式开发，要将一个项目拆分为若干个服务，所以会有很多个服]]></description>
      <content:encoded><![CDATA[<p>微服务需要根据业务模块拆分，做到单一职责，不要重复开发相同业务。</p>
<h1 id="父工程" data-numberify>父工程<a class="anchor ms-1" href="#父工程"></a></h1>
<p>微服务是一种分布式开发，要将一个项目拆分为若干个服务，所以会有很多个服务模块。而要统一管理这些服务模块，可以创建一个父工程来管理。</p>
<p>在Maven中，用来统一管理的父工程是一个不包含实际代码，只含有<code>pom.xml</code>的模块。通过在<code>pom.xml</code>定义一些统一的信息（如依赖、依赖的版本等等），从而来管理整个工程。</p>
<p>父工程Maven依赖（<code>pom.xml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 声明子模块 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;module&gt;</span>user-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;module&gt;</span>order-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/modules&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 打包方式 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 父工程 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>2.3.9.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;relativePath/&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.reporting.outputEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.reporting.outputEncoding&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;spring-cloud.version&gt;</span>Hoxton.SR10<span class="nt">&lt;/spring-cloud.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;mysql.version&gt;</span>5.1.47<span class="nt">&lt;/mysql.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;mybatis.version&gt;</span>2.1.1<span class="nt">&lt;/mybatis.version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 声明依赖，并不进行导入（子模块依然需要导入，但不用指定版面） --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- SpringCloud依赖库 --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- MySQL驱动 --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${mysql.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- MyBatis --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.mybatis.spring.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>mybatis-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${mybatis.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.projectlombok<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>lombok<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中主要的有：</p>
<ul>
<li>
<p>父工程：和SpringBoot一样，使用SpringCloud需要导入父工程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- 父工程 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.3.9.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;relativePath/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>SpringCloud依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- SpringCloud依赖库 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>声明在<code>&lt;dependencyManagement&gt;</code>的<code>&lt;dependencies&gt;</code>中。SpringCloud依赖库定义了SpringCloud的依赖以及它们的版本。</p>
<blockquote>
<p><code>&lt;dependencyManagement&gt;</code>是对整个项目的依赖版本的管理。在<code>&lt;dependencyManagement&gt;</code>元素中声明所依赖的jar包的版本号等信息，那么所有子项目再次引入此依赖jar包时则无需显式的列出版本号，Maven会沿着父子层级向上寻找拥有<code>&lt;dependencyManagement&gt;</code>元素的项目，然后使用它指定的版本号。</p>
<p>例如在SpringBoot中，引入了父工程<code>spring-boot-starter-parent</code>，那么引入<code>spring-boot-starter-web</code>这些在父工程中已经将版本定义好了的依赖，就无需在当前工程的<code>pom.xml</code>中指定版本。</p>
<p>在当前<code>&lt;dependencies&gt;</code>（不是<code>&lt;dependencyManagement&gt;</code>下的<code>&lt;dependencies&gt;</code>中声明的依赖，会直接被导入，并且被子子项目所继承。</p>
</blockquote>
</li>
<li>
<p><code>&lt;modules&gt;</code>：利用<code>&lt;modules&gt;</code>可以很好地进行多模块开发。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- 声明模块 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;module&gt;</span>user-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;module&gt;</span>order-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/modules&gt;</span>
</span></span></code></pre></div><p>在构建当前项目时，Maven会根据<code>&lt;modules&gt;</code>中的声明，去寻找相应的模块并自动完成构建。</p>
<p><code>&lt;modules&gt;</code>的值是对应模块的<code>&lt;artifactId&gt;</code>的值。</p>
</li>
</ul>
<h1 id="微服务拆分" data-numberify>微服务拆分<a class="anchor ms-1" href="#微服务拆分"></a></h1>
<p>子模块Maven依赖示例（<code>pom.xml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 与父工程中所定义的相对应 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>user-service<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- MySQL --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- MyBatis --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.mybatis.spring.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>mybatis-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;finalName&gt;</span>app<span class="nt">&lt;/finalName&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/build&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中，该项目的父工程为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span></code></pre></div><p>模块声明的父工程对应父工程中定义的<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>和<code>&lt;version&gt;</code>。当前项目会继承父工程中定义的版本号和依赖。所以<code>spring-boot-starter-web</code>、<code>mysql-connector-java</code>和<code>mybatis-spring-boot-starter</code>都无需显式地声明版本。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>微服务简介</title>
      <link>/docs/spring/springcloud/introduction/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/introduction/</guid>
      <description><![CDATA[微服务架构 从前的项目是使用单体架构，单体架构是指将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优点是： 架构简单； 部署成本低]]></description>
      <content:encoded><![CDATA[<h1 id="微服务架构" data-numberify>微服务架构<a class="anchor ms-1" href="#微服务架构"></a></h1>
<p>从前的项目是使用单体架构，单体架构是指<u>将业务的所有功能集中在一个项目中开发，打成一个包部署</u>。</p>
<p>单体架构的优点是：</p>
<ul>
<li>架构简单；</li>
<li>部署成本低。</li>
</ul>
<p>缺点是模块之间的耦合度高，不利于大型项目开发。</p>
<p>随着互联网行业的发展，服务架构从单体架构逐渐演变为现在流行的微服务架构（属于分布式架构的一种）。</p>
<p><picture><img class="img-fluid " alt="微服务架构" src="/docs/spring/springcloud/introduction/uTools_1687757195463.png" loading="lazy" width="624" height="544" />
</picture>

</p>
<p>分布式架构是指<u>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务</u>。</p>
<p>分布式架构的优点：</p>
<ul>
<li>降低服务之间的耦合；</li>
<li>有利于服务升级拓展。</li>
</ul>
<p>微服务是一种经过良好架构设计的分布式架构方案。</p>
<p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责。</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付。</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。</li>
</ul>
<p>微服务按照服务的不同将项目分为不同的项目，每个项目运行一个服务。</p>
<p>例如，将用户服务和订单服务分为两个项目。</p>
<h1 id="微服务技术栈" data-numberify>微服务技术栈<a class="anchor ms-1" href="#微服务技术栈"></a></h1>
<p>微服务技术栈包括：</p>
<ul>
<li>微服务技术</li>
<li>异步通讯技术</li>
<li>缓存技术</li>
<li>DevOps</li>
<li>搜索技术</li>
</ul>
<h1 id="微服务技术" data-numberify>微服务技术<a class="anchor ms-1" href="#微服务技术"></a></h1>
<blockquote>
<p>在国内知名的微服务落地技术有SpringCloud和阿里的Dubbo。</p>
</blockquote>
<p>常见微服务技术的对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:center">Dubbo</th>
<th style="text-align:center">SpringCloud</th>
<th style="text-align:left">SpringCloudAlibaba</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">注册中心</td>
<td style="text-align:center"><code>Zookeeper</code>、<code>Redis</code></td>
<td style="text-align:center">Eureka、Consul</td>
<td style="text-align:left">Nacos、Eureka</td>
</tr>
<tr>
<td style="text-align:center">服务远程调用</td>
<td style="text-align:center">Dubbo协议</td>
<td style="text-align:center">Feign（HTTP协议）</td>
<td style="text-align:left">Dubbo、Feign</td>
</tr>
<tr>
<td style="text-align:center">配置中心</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SpringCloudConfig</td>
<td style="text-align:left">SpringCloudConfig、Nacos</td>
</tr>
<tr>
<td style="text-align:center">服务网关</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SpringCloudGateway、Zuul</td>
<td style="text-align:left">SpringCloudGateway、Zuul</td>
</tr>
<tr>
<td style="text-align:center">服务监控和保护</td>
<td style="text-align:center">dubbo-admin（功能弱）</td>
<td style="text-align:center">Hystix</td>
<td style="text-align:left">Sentinel</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud 官网<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配。而SpringCloud与SpringBoot的之间的版本存在一个兼容关系，可通过官网的说明文档查看。</p>
</blockquote>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

