<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring Cloud on Linner&#39;s Blog</title>
    <link>/docs/spring/springcloud/</link>
    <description>Recent content in Spring Cloud on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2026 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Fri, 04 Aug 2023 08:40:11 +0000</lastBuildDate><atom:link href="/docs/spring/springcloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nacos 部署</title>
      <link>/docs/spring/springcloud/nacos-deploy/</link>
      <pubDate>Mon, 24 Jul 2023 02:58:36 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/nacos-deploy/</guid>
      <description><![CDATA[本地部署 Nacos是一个开源项目，已经在Github上开源。在本地搭建Nacos需要访问Nacos项目仓库，你可以选择将该项目clone到本]]></description>
      <content:encoded><![CDATA[<h1 id="本地部署" data-numberify>本地部署<a class="anchor ms-1" href="#本地部署"></a></h1>
<p>Nacos是一个开源项目，已经在Github上开源。在本地搭建Nacos需要访问<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener noreferrer">Nacos项目仓库<i class="fas fa-external-link-square-alt ms-1"></i></a>，你可以选择将该项目<code>clone</code>到本地自己打包后部署，也可以选择直接访问<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener noreferrer">Nacos的Releases页面<i class="fas fa-external-link-square-alt ms-1"></i></a>下载已经打包好的项目压缩文件进行部署。你也可以访问<a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener noreferrer">Nacos官网<i class="fas fa-external-link-square-alt ms-1"></i></a>查看如何部署。</p>
<ul>
<li>
<p><code>clone</code>到本地：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/alibaba/nacos
</span></span></code></pre></div></li>
<li>
<p>访问<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener noreferrer">Nacos的Releases页面<i class="fas fa-external-link-square-alt ms-1"></i></a>：</p>
<p><picture><img class="img-fluid " alt="Nacos的Releases页面" src="/docs/spring/springcloud/nacos-deploy/uTools_1690139609912.png" loading="lazy" width="1715" height="946" />
</picture>

</p>
<p>选择自己想要的版本（如<code>2.2.3</code>）进行下载：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos-deploy/uTools_1690139697680.png" loading="lazy" width="1021" height="252" />
</picture>

</p>
<p>无论是选择下载<code>.zip</code>还是<code>.tar.gz</code>后缀的压缩包都可以。但是在Linux环境下选择下载<code>.tar.gz</code>为佳。</p>
<p>Linux中解压<code>.tar.gz</code>的命令如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar -zxvf 压缩包文件名.tar.gz
</span></span></code></pre></div></li>
</ul>
<p>将下载好的压缩包解压到任意非中文目录下。解压好的目录结构大致如下：</p>
<p><picture><img class="img-fluid " alt="Nacos目录结构" src="/docs/spring/springcloud/nacos-deploy/uTools_1690140191883.png" loading="lazy" width="116" height="198" />
</picture>

</p>
<ul>
<li>
<p><code>target</code>：存放Nacos<code>jar</code>包的目录。</p>
</li>
<li>
<p><code>logs</code>：存放日志文件。</p>
</li>
<li>
<p><code>conf</code>：存放项目的配置文件（如<code>application.properties</code>等）以及搭建存放Nacos配置信息的数据库的<code>.sql</code>脚本文件（如<code>nacos-mysql.sql</code>等）。</p>
</li>
<li>
<p><code>bin</code>：存放启动和关闭Nacos Server的脚本文件以及一些其它的文件。</p>
<p>在Windows系统中启动和关闭Nacos使用的是<code>.cmd</code>文件，即<code>startup.cmd</code>和<code>shutdown.cmd</code>，分别对应启动和关闭。在Linux系统中使用的是<code>.sh</code>文件，<code>startup.sh</code>启动，<code>shutdown.sh</code>关闭。</p>
<p>使用<code>startup.cmd</code>或<code>startup.sh</code>默认为集群模式，可以添加参数<code>-m standalone</code>使用单机模式启动。</p>
<p>Windows系统：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bat" data-lang="bat"><span class="line"><span class="cl"><span class="k">cd</span> Nacos的路径\bin
</span></span><span class="line"><span class="cl">.\startup.cmd -m standalone
</span></span></code></pre></div><p>Linux系统：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> Nacos的路径/bin
</span></span><span class="line"><span class="cl">./startup.sh -m standalone
</span></span></code></pre></div></li>
</ul>
<blockquote>
<p>在Windows系统和Linux系统上进行本地简单地部署Nacos并没有区别，这里不再分别进行赘述。</p>
</blockquote>
<p>访问<a href="http://localhsot:8848/nacos" target="_blank" rel="noopener noreferrer">http://localhsot:8848/nacos<i class="fas fa-external-link-square-alt ms-1"></i></a>即可。默认的用户名和密码均为<code>nacos</code>。</p>
<p>启动成功后的Nacos大概长这样子：</p>
<p><picture><img class="img-fluid " alt="Nacos 页面" src="/docs/spring/springcloud/nacos-deploy/uTools_1690143487422.png" loading="lazy" width="1919" height="682" />
</picture>

</p>
<hr>
<h1 id="基于-mysql-数据库部署" data-numberify>基于 MySQL 数据库部署<a class="anchor ms-1" href="#基于-mysql-数据库部署"></a></h1>
<p>Nacos可以使用MySQL数据库存放配置信息。首先需要确保你的电脑上有MySQL。</p>
<blockquote>
<p>注意：使用MySQL搭建Nacos的数据库，推荐使用MySQL 5，因为Nacos的MySQL驱动版本可以不支持MySQL 8。如果非要使用MySQL 8，可以在Nacos中升级MySQL的驱动。</p>
</blockquote>
<p>首先在MySQL中新建一个数据库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="n">nacos</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">USE</span><span class="w"> </span><span class="n">nacos</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">source</span><span class="w"> </span><span class="s2">&#34;Nacos的路径/bin/mysql-schema.sql&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>创建成功后的Nacos数据库如下：</p>
<p><picture><img class="img-fluid " alt="Nacos数据库的表" src="/docs/spring/springcloud/nacos-deploy/uTools_1690142171755.png" loading="lazy" width="184" height="290" />
</picture>

</p>
<p>接着修改在<code>conf</code>目录里的<code>application.properties</code>文件（如果没有，就将<code>application.properties.example</code>文件复制一份，改名为<code>application.properties</code>）。需要修改的配置如下：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties"># 数据源
spring.datasource.platform=mysql
# 数据库数量
db.num=1
# 连接第1个数据库的url（替换成自己的）
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
# 连接第1个数据库的用户和密码（替换成自己的）
db.user.0=root
db.password.0=root

# 数据库驱动（如果其它配置正确，但无法启动时，修改该配置）
# db.driver-class-name=com.mysql.cj.jdbc.Driver
</code></pre><p>接下来重启Nacos即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./shutdown.sh <span class="c1"># 也可以直接 CTRL+C 结束</span>
</span></span><span class="line"><span class="cl">./startup.sh -m standalone
</span></span></code></pre></div><hr>
<h1 id="部署-nacos-集群" data-numberify>部署 Nacos 集群<a class="anchor ms-1" href="#部署-nacos-集群"></a></h1>
<p>在本地部署Nacos集群首先将Nacos整个应用目录复制，要在集群中部署几个Nacos就复制几份。接着再分别修改它们的配置文件<code>application.properties</code>。</p>
<p>例如要部署两个Nacos，做负载均衡：</p>
<p>第一个Nacos的配置文件可以如下：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties"># 服务端口
server.port=8841

# 数据库配置
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
db.user.0=root
db.password.0=root
</code></pre><p>第二个Nacos的配置文件可以如下：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties"># 服务端口
server.port=8842

# 数据库配置
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
db.user.0=root
db.password.0=root
</code></pre><blockquote>
<p>因为是部署在本地（即一台机器上），所以两个Nacos的端口不能相同（否则会发生冲突）。</p>
</blockquote>
<p>接着使用<code>startup.cmd</code>或<code>startup.sh</code>分别启动这两个Nacos（这里要使用集群模式启动，Nacos默认使用集群模式启动，所以不能加上<code>-m standalone</code>参数）。</p>
<p>此时分别访问这两个服务（例如使用<a href="http://localhost:8841/nacos" target="_blank" rel="noopener noreferrer">http://localhost:8841/nacos<i class="fas fa-external-link-square-alt ms-1"></i></a>和<a href="http://localhost:8842/nacos" target="_blank" rel="noopener noreferrer">http://localhost:8842/nacos<i class="fas fa-external-link-square-alt ms-1"></i></a>访问），都能正常使用。</p>
<p>最后需要给这个Nacos集群加个路由（例如使用Nginx）。Nginx的配置如下：</p>
<pre tabindex="0"><code># Nacos 集群
upstream nacos-cluster {
    server nacos-cluster-test-1:8848;
    server nacos-cluster-test-2:8848;
}

# Nacos 服务
server {
    listen 8849;

    server_name localhost;

    location /nacos {
        proxy_pass http://nacos-cluster;
    }
}
</code></pre><p>添加完配置后重启Nginx即可，这里不做赘述。</p>
<p>配置完后访问<a href="http://localhsot:8848/nacos" target="_blank" rel="noopener noreferrer">http://localhsot:8849/nacos<i class="fas fa-external-link-square-alt ms-1"></i></a>即可。</p>
<hr>
<h1 id="基于-docker-部署" data-numberify>基于 Docker 部署<a class="anchor ms-1" href="#基于-docker-部署"></a></h1>
<p>使用Docker部署，首先需要下载Nacos的镜像。Nacos官方提供了对应的镜像<code>nacos/nacos-server</code>。使用下方命令下载该容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker pull nacos/nacos-server
</span></span></code></pre></div><blockquote>
<p>上方的命令拉取（下载）的是版本为<code>latest</code>。要拉取对应版本的镜像，可以查看Docker官方提供的网站<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">hub.docker.com<i class="fas fa-external-link-square-alt ms-1"></i></a>，在其中搜索<code>nacos-server</code>并点击<code>tags</code>查找对应的版本（<a href="https://hub.docker.com/r/nacos/nacos-server/tags" target="_blank" rel="noopener noreferrer">点击快速查找Nacos Server版本<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>例如拉取<code>v1.4.6</code>版本的<code>nacos/nacos-server</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker pull nacos/nacos-server:v1.4.6
</span></span></code></pre></div></blockquote>
<p><code>nacos/nacos-server</code>拉取完成后就可以创建对应容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nacos-server <span class="se">\ </span><span class="c1"># 容器名称</span>
</span></span><span class="line"><span class="cl">    -p 8848:8848 <span class="se">\ </span><span class="c1"># 端口映射，分号左边为本地端口，分号右边为容器的内部端口</span>
</span></span><span class="line"><span class="cl">    --privileged<span class="o">=</span><span class="nb">true</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MODE</span><span class="o">=</span>standalone <span class="se">\ </span><span class="c1"># 指定为单机模式（使用Docker创建的Docker容器默认也为集群模式，所以需要指定单机模式）</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">PREFER_HOST_MODE</span><span class="o">=</span>hostname <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /home/nacos/nacos-server/logs:/home/nacos/logs <span class="se">\ </span><span class="c1"># 文件挂载，分号左边为本地目录，分号右边为容器内部的目录，这里是进行日志文件目录映射</span>
</span></span><span class="line"><span class="cl">    -v /home/nacos/nacos-server/conf/:/home/nacos/conf/ <span class="se">\ </span><span class="c1"># 配置文件映射</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">JVM_XMS</span><span class="o">=</span>256m -e <span class="nv">JVM_XMX</span><span class="o">=</span>256m <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nacos/nacos-server <span class="se">\ </span><span class="c1"># 创建容器所使用的镜像</span>
</span></span><span class="line"><span class="cl">    /usr/sbin/init
</span></span></code></pre></div><p>访问<a href="http://localhsot:8848/nacos" target="_blank" rel="noopener noreferrer">http://localhsot:8848/nacos<i class="fas fa-external-link-square-alt ms-1"></i></a>即可。默认的用户名和密码均为<code>nacos</code>。</p>
<p>如果是在Windows中使用Docker Desktop部署，目录映射的路径应该这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bat" data-lang="bat"><span class="line"><span class="cl">docker run -d \
</span></span><span class="line"><span class="cl">    --name nacos-server \
</span></span><span class="line"><span class="cl">    -p 8848:8848 \
</span></span><span class="line"><span class="cl">    --privileged=true \
</span></span><span class="line"><span class="cl">    -e MODE=standalone \
</span></span><span class="line"><span class="cl">    -e PREFER_HOST_MODE=hostname \
</span></span><span class="line"><span class="cl">    -v /d/docker-volume/nacos/nacos-server/logs:/home/nacos/logs \
</span></span><span class="line"><span class="cl">    -v /d/docker-volume/nacos/nacos-server/conf/:/home/nacos/conf/ \
</span></span><span class="line"><span class="cl">    -e JVM_XMS=256m -e JVM_XMX=256m \
</span></span><span class="line"><span class="cl">    nacos/nacos-server \
</span></span><span class="line"><span class="cl">    /usr/sbin/init
</span></span></code></pre></div><hr>
<h1 id="基于-docker-使用-mysql-部署" data-numberify>基于 Docker 使用 MySQL 部署<a class="anchor ms-1" href="#基于-docker-使用-mysql-部署"></a></h1>
<p>根据如上方法创建Nacos容器，然后修改映射到本地的配置文件。例如修改<code>/home/nacos/nacos-server/conf</code>下的<code>application.properties</code>：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties"># 数据库配置（根据你的配置环境修改）
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
db.user.0=root
db.password.0=root
</code></pre><blockquote>
<p>注：这个MySQL需要使用<code>mysql-schema.sql</code>创建<code>nacos</code>数据库。</p>
</blockquote>
<p>如果MySQL也是使用Docker创建的，可以给Nacos容器和MySQL容器添加一个Docker Network，并将它们都加入这个Network中：</p>
<ol>
<li>
<p>创建Docker Network：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker network create nacos-network
</span></span></code></pre></div></li>
<li>
<p>分别将Nacos容器和MySQL容器加入Docker Network（假设MySQL的容器名为<code>mysql</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker network connect nacos-network nacos-server
</span></span><span class="line"><span class="cl">docker network connect nacos-network mysql
</span></span></code></pre></div></li>
</ol>
<p>之后在加入这个Network的容器中，可以将它们的容器名当作IP地址来使用。所以在<code>nacos-server</code>中可以将<code>db.url</code>修改为如下：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties">db.url.0=jdbc:mysql://mysql:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre><p>其实使用Docker部署并使用MySQL数据库还有一个简便的方法（按照上述方法直接修改配置文件可能不生效），可以在创建容器的Docker命令中通过<code>nacos-server</code>提供的环境变量直接指定MySQL服务的配置信息（<code>nacos-server</code>容器在创建时会自动生成对应的配置文件）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nacos-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p 8848:8848 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --network nacos-network<span class="se">\ </span><span class="c1"># 在创建容器时指定Network</span>
</span></span><span class="line"><span class="cl">    --privileged<span class="o">=</span><span class="nb">true</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">SPRING_DATASOURCE_PLATFORM</span><span class="o">=</span>mysql <span class="se">\ </span><span class="c1"># 指定数据源类型为MySQL</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">MYSQL_SERVICE_HOST</span><span class="o">=</span>mysql <span class="se">\ </span><span class="c1"># MySQL服务器的地址（这里加入了Network所以可以直接使用容器名称来当Host）</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">MYSQL_SERVICE_PORT</span><span class="o">=</span><span class="m">3306</span> <span class="se">\ </span><span class="c1"># MySQL服务端口</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">MYSQL_SERVICE_USER</span><span class="o">=</span>root <span class="se">\ </span><span class="c1"># MySQL用户名</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">MYSQL_SERVICE_PASSWORD</span><span class="o">=</span>root <span class="se">\ </span><span class="c1"># MySQL密码</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">MYSQL_SERVICE_DB_NAME</span><span class="o">=</span>nacos <span class="se">\ </span><span class="c1"># MySQL的数据库名称</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">PREFER_HOST_MODE</span><span class="o">=</span>hostname <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /d/27120/docker-volume/nacos/%name%/logs:/home/nacos/logs <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /d/27120/docker-volume/nacos/%name%/conf/:/home/nacos/conf/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">JVM_XMS</span><span class="o">=</span>256m -e <span class="nv">JVM_XMX</span><span class="o">=</span>256m <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nacos/nacos-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    /usr/sbin/init
</span></span></code></pre></div><blockquote>
<p>使用Docker创建的MySQL容器同样需要创建<code>nacos</code>数据库。可以通过其它文件传输方式传输到容器中（这种方式适用于你有一个已经在运行的MySQL容器）。</p>
<p>在容器中创建数据库可以在本机输入命令（假设<code>mysql-schema.sql</code>导入到了容器的<code>root</code>目录中）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker <span class="nb">exec</span> mysql mysql -uroot -proot -e <span class="s2">&#34;CREATE DATABASE nacos; USE nacos; SOURCE /root/mysql-schema.sql;&#34;</span>
</span></span></code></pre></div><p>上方命令第一个<code>mysql</code>是指容器名称，第二个是指容器中的<code>mysql</code>命令。</p>
<p>或者是在本地使用Docker登录MySQL后进行操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker <span class="nb">exec</span> mysql mysql -uroot -p
</span></span><span class="line"><span class="cl"><span class="c1"># 然后输入你的密码，回车</span>
</span></span><span class="line"><span class="cl">mysql&gt; CREATE DATABASE nacos<span class="p">;</span>
</span></span><span class="line"><span class="cl">mysql&gt; USE nacos<span class="p">;</span>
</span></span><span class="line"><span class="cl">mysql&gt; SOURCE /root/mysql-schema.sql<span class="p">;</span>
</span></span></code></pre></div></blockquote>
<p>推荐使用Dockerfile方式创建一个包含<code>nacos</code>数据库的MySQL容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> mysql:5.7</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">TZ</span><span class="o">=</span>Asia/Shanghai<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="m">123456</span>
</span></span><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">LANG</span><span class="o">=</span>C.UTF-8<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> ./mysql-schema.sql /docker-entrypoint-initdb.d<span class="err">
</span></span></span></code></pre></div><p>这是利用MySQL镜像的机制。MySQL容器在创建时会自动执行<code>/docker-entrypoint-initdb.d</code>目录下的<code>.sh</code>、<code>.sql</code>等文件。因为Nacos官方提供的<code>mysql-schema.sql</code>中并没有创建数据库和使用数据库的SQL语句，所以在创建容器之前还需要对<code>mysql-schema.sql</code>稍加修改。在<code>mysql-schema.sql</code>里面最上方添加这么两句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w"> </span><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">nacos</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="n">USE</span><span class="w"> </span><span class="n">nacos</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>需要注意的是这里的数据库名称要和创建<code>nacos-server</code>时配置的一致。</p>
<p>然后将<code>mysql-schema.sql</code>复制到与Dockerfile同级的目录中（或者你也可以在Dockerfile将<code>mysql-schema.sql</code>的路径修改到你想要的位置）。接着使用<code>docker build</code>命令构建镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker build -f .<span class="se">\D</span>ockerfile . -t linner/mysql-nacos
</span></span></code></pre></div><p>最后使用<code>docker run</code>运行容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run -id --name mysql-nacos -p 3306:3306 linner/nacos-mysql
</span></span></code></pre></div><blockquote>
<p>因为一些配置在Dockerfile提前设置过了，所以这条构建MySQL容器的命令十分简洁。</p>
</blockquote>
<hr>
<h1 id="基于-docker-搭建-nacos-集群" data-numberify>基于 Docker 搭建 Nacos 集群<a class="anchor ms-1" href="#基于-docker-搭建-nacos-集群"></a></h1>
<p>基于Docker搭建Nacos集群，首先可以创建一个用于创建集群模式Nacos的脚本<code>create_nacos.sh</code>（使用MySQL）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">name</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl"><span class="nv">port</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name <span class="nv">$name</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p <span class="nv">$port</span>:8848 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --network nacos-network <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --privileged<span class="o">=</span><span class="nb">true</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">SPRING_DATASOURCE_PLATFORM</span><span class="o">=</span>mysql <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_SERVICE_HOST</span><span class="o">=</span>mysql <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_SERVICE_PORT</span><span class="o">=</span><span class="m">3306</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_SERVICE_USER</span><span class="o">=</span>root <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_SERVICE_PASSWORD</span><span class="o">=</span><span class="m">123456</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_SERVICE_DB_NAME</span><span class="o">=</span>nacos_config <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">PREFER_HOST_MODE</span><span class="o">=</span>hostname <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /home/nacos/<span class="nv">$name</span>/logs:/home/nacos/logs <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /home/nacos/<span class="nv">$name</span>/conf/:/home/nacos/conf/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">JVM_XMS</span><span class="o">=</span>256m -e <span class="nv">JVM_XMX</span><span class="o">=</span>256m <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nacos/nacos-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    /usr/sbin/init
</span></span></code></pre></div><p>例如创建两个Nacos容器（在本地创建两个容器，端口不能重复）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./create_nacos.sh nacos1 <span class="m">8841</span>
</span></span><span class="line"><span class="cl">./create_nacos.sh nacos2 <span class="m">8842</span>
</span></span></code></pre></div><p>接着将它们加入<code>nacos-network</code>后重启（如果这两个Nacos容器没有停止运行的话，可以忽略）：</p>
<pre tabindex="0"><code>docker restart nacos1
docker restart nacos2
</code></pre><p>接着配置Nginx的方法和之前描述的方式类似。如果Nginx是使用Docker创建的，也可以将该Nginx容器加入<code>nacos-network</code>，然后直接使用容器的名称作为Host即可。</p>
<p>最后访问Nginx即可。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Eureka</title>
      <link>/docs/spring/springcloud/eureka/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/eureka/</guid>
      <description><![CDATA[Eureka 服务注册中心 Eureka架构下将服务分为以下两个角色： 注册中心（Eureka Server，服务端）。 客户端（Eureka Client）。 E]]></description>
      <content:encoded><![CDATA[<h1 id="eureka-服务注册中心" data-numberify>Eureka 服务注册中心<a class="anchor ms-1" href="#eureka-服务注册中心"></a></h1>
<p>Eureka架构下将服务分为以下两个角色：</p>
<ul>
<li>注册中心（Eureka Server，服务端）。</li>
<li>客户端（Eureka Client）。</li>
</ul>
<p>Eureka会将客户端（即服务）的信息进行注册，让客户端可以通过Eureka注册中心获取服务信息并进行调用。</p>
<p><strong>Eureka的作用：</strong></p>
<ul>
<li><strong>注册服务信息</strong>：服务提供者启动时向Eureka注册自己的信息，Eureka保存这些服务信息到服务列表中。</li>
<li><strong>获取服务信息</strong>：服务消费者根据服务名称向Eureka拉取服务列表。</li>
<li><strong>负载均衡</strong>：有多个服务提供者时，服务消费者利用负载均衡算法，从Eureka注册的服务列表中挑选一个服务后发起远程调用。</li>
<li><strong>感知服务健康状态</strong>：
<ul>
<li>服务提供者会每隔30秒向Eureka Server发送心跳请求，报告自己的健康状态。</li>
<li>Eureka会更新记录服务信息列表，心跳不正常的服务会被剔除。</li>
</ul>
</li>
</ul>
<p>在Eureka架构中，角色有以下分工：</p>
<ul>
<li>Eureka Server：记录服务信息；进行心跳监控，剔除心跳不正常的服务。</li>
<li>Eureka Client：
<ul>
<li>Provider：注册自己的信息到Eureka Server；每隔30秒向Eureka Server发送心跳。</li>
<li>Consumer：根据服务名称从Eureka Server拉取服务列表；基于服务列表做负载均衡，选中一个服务后发起远程调用。</li>
</ul>
</li>
</ul>
<h2 id="eureka-示例" data-numberify>Eureka 示例<a class="anchor ms-1" href="#eureka-示例"></a></h2>
<p>依照上例，订单服务在获取订单信息时需要从用户服务中获取用户信息并一同发送：</p>
<ol>
<li>
<p>首先需要创建一个新的Maven模块来运行Eureka Server。</p>
<ul>
<li>
<p>Eureka Server的<code>pom.xml</code>如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;maven.compiler.source&gt;</span>8<span class="nt">&lt;/maven.compiler.source&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;maven.compiler.target&gt;</span>8<span class="nt">&lt;/maven.compiler.target&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中最主要的就是导入<code>eureka-server</code>起步依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>在Eureka中，服务端和客户端有不同的依赖，服务端的起步依赖就是<code>spring-cloud-starter-netflix-eureka-server</code>。</p>
</li>
</ul>
</li>
<li>
<p>编写<code>EurekaApplication</code>启动类，并在启动类上使用<code>@EnableEurekaServer</code>注解装配EurekaServer：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableEurekaServer</span>     <span class="c1">// EurekaServer开关，自动装配EurekaServer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EurekaApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">EurekaApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>eureka-server</code>中，添加<code>application.yml</code>并加入以下配置信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 服务端口（视具体情况进行更改）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8180</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">eureka-server</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Eureka的地址信息（如果有多个，则用逗号”,“隔开）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>分别在<code>order-service</code>和<code>user-service</code>中添加Eureka客户端依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Eureka客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>分别在Eureka客户端的<code>application.yml</code>中添加如下配置信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 配置eureka-server的信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># defaultZone要与eureka-server中的defaultZone相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div><p>分别在Eureka客户端的<code>application.yml</code>中添加服务名称（<code>spring.application.name</code>），如<code>order-service</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span></code></pre></div><p>Eureka Server利用<code>spring.application.name</code>来找到对应模块的信息，并返回。利用<code>spring.application.name</code>也可以做负载均衡。</p>
<blockquote>
<p>由于所有模块都可能作为服务提供者被其他服务调用，所以项目中所有服务模块都应该在Eureka Server中进行注册。</p>
</blockquote>
</li>
<li>
<p>在服务消费者中，需要在注册<code>RestTemplate</code>的方法上使用注解<code>@LoadBalanced</code>来开启Eureka的负载均衡。</p>
<p>如<code>order-service</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>服务消费者通过Eureka，使用<code>RestTemplate</code>调用其他模块。</p>
<p>如<code>order-service</code>调用<code>user-service</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入RestTemplate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用RestTemplate发起HTTP请求，查询用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2.1.URL路径（将服务的IP改为服务的名称）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://user-service/user/&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2.发送HTTP（GET）请求，实现远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这里面最主要的是，配置了Eureka后，使用<code>RestTemplate</code>调用其他模块时，URL中的IP可以改为服务提供者（被调模块）的服务名称，并且可以自动做负载均衡。即，原本是使用<code>localhost:8081</code>这个IP端口来调用<code>user-service</code>，但是现在可以直接使用<code>http://user-service</code>来调用<code>user-service</code>提供的接口。</p>
</li>
</ol>
<h2 id="eureka-服务注册配置总结" data-numberify>Eureka 服务注册配置总结<a class="anchor ms-1" href="#eureka-服务注册配置总结"></a></h2>
<p>按照角色配置Eureka，至少需要做如下配置：</p>
<ul>
<li>
<p>Eureka Server：</p>
<p>依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Eureka服务端--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Eureka服务端口（视具体情况进行更改）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8180</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">eureka-server</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># Eureka的地址信息（如果有多个，则用逗号”,“隔开）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>Eureka Client：</p>
<p>依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Eureka客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>配置（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">clinet-1-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">eureka</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">service-url</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># defaultZone要与eureka-server中的defaultZone相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">defaultZone</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8180/eureka</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>服务消费者：</p>
<p>开启负载均衡：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>RestTemplate</code>调用其他服务时，URL中的IP可以改为服务提供者（被调模块）的服务名称。</p>
</li>
</ul>
<hr>
<h1 id="idea-配置模块的多个实例" data-numberify>Idea 配置模块的多个实例<a class="anchor ms-1" href="#idea-配置模块的多个实例"></a></h1>
<ol>
<li>
<p>复制现有的配置：</p>
<p><picture><img class="img-fluid " alt="复制现有的配置" src="/docs/spring/springcloud/eureka/uTools_1687857604691.png" loading="lazy" width="491" height="267" />
</picture>

</p>
</li>
<li>
<p>使用VM Options修改端口，避免与原有的模块产生端口冲突：</p>
<p><picture><img class="img-fluid " alt="修改端口" src="/docs/spring/springcloud/eureka/uTools_1687857691207.png" loading="lazy" width="557" height="317" />
</picture>

</p>
</li>
</ol>
<hr>
<h1 id="ribbon-负载均衡" data-numberify>Ribbon 负载均衡<a class="anchor ms-1" href="#ribbon-负载均衡"></a></h1>
<p>Ribbon是一款负载均衡组件，而Eureka的负载均衡则是基于Ribbon实现的。如上例（<code>order-service</code>）中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="nd">@LoadBalanced</span>   <span class="c1">// 开启Eureka负载均衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="负载均衡流程" data-numberify>负载均衡流程<a class="anchor ms-1" href="#负载均衡流程"></a></h2>
<p>Eureka中使用注解<code>@LoadBalanced</code>标识<code>RestTemplate</code>，从而实现拦截<code>RestTemplate</code>发起的请求，并获取相应的服务信息和执行负载均衡策略。</p>
<p><code>@LoadBalanced</code>注解使用<code>LoadBalancerInterceptor</code>来执行请求的拦截。<code>LoadBalancerInterceptor</code>实现了<code>ClientHttpRequestInterceptor</code>接口。而<code>ClientHttpRequestInterceptor</code>接口主要用于拦截客户端HTTP请求。</p>
<p><code>ClientHttpRequestInterceptor</code>接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FunctionalInterface</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ClientHttpRequestInterceptor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ClientHttpResponse</span> <span class="nf">intercept</span><span class="o">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">,</span> <span class="n">ClientHttpRequestExecution</span> <span class="n">execution</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">			<span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>拦截流程：</p>
<ol>
<li>
<p>使用<code>RestTemplate</code>发送请求时，Eureka会使用<code>LoadBalancerInterceptor</code>的<code>intercept()</code>来执行拦截：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoadBalancerInterceptor</span> <span class="kd">implements</span> <span class="n">ClientHttpRequestInterceptor</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">LoadBalancerClient</span> <span class="n">loadBalancer</span><span class="o">;</span>    <span class="c1">// 负载均衡客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ClientHttpResponse</span> <span class="nf">intercept</span><span class="o">(</span><span class="kd">final</span> <span class="n">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="kd">final</span> <span class="n">ClientHttpRequestExecution</span> <span class="n">execution</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            获取请求发出的URL
</span></span></span><span class="line"><span class="cl"><span class="cm">            例如order-service中获取订单信息时，会发出[http://user-service/user/{userId}]这个请求
</span></span></span><span class="line"><span class="cl"><span class="cm">            这里的request.getURI()会获取到[http://user-service/user/{userId}]这个请求的URI
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="kd">final</span> <span class="n">URI</span> <span class="n">originalUri</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getURI</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            通过URI获取请求的Host
</span></span></span><span class="line"><span class="cl"><span class="cm">            如：user-service
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">serviceName</span> <span class="o">=</span> <span class="n">originalUri</span><span class="o">.</span><span class="na">getHost</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Assert</span><span class="o">.</span><span class="na">state</span><span class="o">(</span><span class="n">serviceName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Request URI does not contain a valid hostname: &#34;</span> <span class="o">+</span> <span class="n">originalUri</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            将Host作为Eureka客户端名称，获取相应的服务信息并执行负载均衡策略
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">loadBalancer</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="o">.</span><span class="na">requestFactory</span><span class="o">.</span><span class="na">createRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">body</span><span class="o">,</span> <span class="n">execution</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p><code>LoadBalancerClient</code>是一个客户端执行负载均衡的接口，当实际执行时，使用的是<code>RibbonLoadBalancerClient</code>这个实现类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RibbonLoadBalancerClient</span> <span class="kd">implements</span> <span class="n">LoadBalancerClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 实际执行的是这个方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">execute</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">String</span> <span class="n">serviceId</span><span class="o">,</span> <span class="c1">// 传入的是serviceName，如 user-service
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">LoadBalancerRequest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">            <span class="n">Object</span> <span class="n">hint</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            根据serviceId获取负载均衡器
</span></span></span><span class="line"><span class="cl"><span class="cm">            loadBalancer中有这么两个属性：
</span></span></span><span class="line"><span class="cl"><span class="cm">            - AllServerList
</span></span></span><span class="line"><span class="cl"><span class="cm">            - UpServerList
</span></span></span><span class="line"><span class="cl"><span class="cm">            它们记录了获取到的Eureka客户端信息
</span></span></span><span class="line"><span class="cl"><span class="cm">            实际执行时，loadBalancer的类型是ZoneAwareLoadBalancer
</span></span></span><span class="line"><span class="cl"><span class="cm">            ZoneAwareLoadBalancer继承了DynamicServerListLoadBalancer
</span></span></span><span class="line"><span class="cl"><span class="cm">            在loadBalancer中，使用IRule定义负载均衡策略
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">ILoadBalancer</span> <span class="n">loadBalancer</span> <span class="o">=</span> <span class="n">getLoadBalancer</span><span class="o">(</span><span class="n">serviceId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            根据LoadBalancer，执行负载均衡策略，获取Eureka客户端的真实服务地址
</span></span></span><span class="line"><span class="cl"><span class="cm">            如，获取到 localhost:8081
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">Server</span> <span class="n">server</span> <span class="o">=</span> <span class="n">getServer</span><span class="o">(</span><span class="n">loadBalancer</span><span class="o">,</span> <span class="n">hint</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="负载均衡策略" data-numberify>负载均衡策略<a class="anchor ms-1" href="#负载均衡策略"></a></h2>
<p>Ribbon的负载均衡策略是使用<code>IRule</code>这个接口来定义。在Eureka中给出了几个负载均衡策略的实现，它们的继承关系图如下：</p>
<p><picture><img class="img-fluid " alt="负载均衡策略继承关系图" src="/docs/spring/springcloud/eureka/uTools_1687859350530.png" loading="lazy" width="1067" height="418" />
</picture>

</p>
<p>Eureka中负载均衡默认的实现是<code>ZoneAvoidanceRule</code>，它们的含义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>RoundRobinRule</code></td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td style="text-align:center"><code>AvailabilityFilteringRule</code></td>
<td>对以下两种服务器进行忽略：<ul><li>短路的服务器：<br>在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。<br>短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。</li><li>并发数过高的服务器：<br>如果一个服务器的并发连接数过高，配置了<code>AvailabilityFilteringRule</code>规则的客户端也会将其忽略。<br>并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>属性进行配置。</li></ol></td>
</tr>
<tr>
<td style="text-align:center"><code>WeightedResponseTimeRule</code></td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。<br>这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td style="text-align:center"><strong><code>ZoneAvoidanceRule</code></strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。<br>使用Zone对服务器进行分类（这个Zone可以理解为一个机房、一个机架等）。而后再对Zone内的多个服务做轮询。<br>在配置服务注册时，Zone的值可以被设置（按照服务器所在的地理位置进行设置）。使用此规则，服务消费者会优先选择跟自己在同一个Zone内的服务，然后再做轮询。</td>
</tr>
<tr>
<td style="text-align:center"><code>BestAvailableRule</code></td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td style="text-align:center"><code>RandomRule</code></td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td style="text-align:center"><code>RetryRule</code></td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody>
</table>
<h2 id="配置负载均衡规则" data-numberify>配置负载均衡规则<a class="anchor ms-1" href="#配置负载均衡规则"></a></h2>
<p>配置负载均衡规则有两种方式：</p>
<ul>
<li>
<p>配置<strong>全局默认</strong>的负载均衡规则：</p>
<p>在任何一个配置类或新建一个配置类，然后添加一个新的Bean。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IRule</span> <span class="nf">getLoadBalancerRule</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 此处以RandomRule为例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="n">RandomRule</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用Bean的方式配置负载均衡规则，无论当前服务远程调用哪个服务提供者，都是采用这个Bean里面配置的规则。</p>
</li>
<li>
<p>为<strong>指定的服务提供者</strong>配置单独的负载均衡规则：</p>
<p>可以在<code>application.yml</code>中使用<code>serverName.ribbon.NFLoadBalancerRuleClassName</code>配置指定服务的负载均衡规则，它的值是具体规则的实现类的全类名。</p>
<p>例如在<code>order-service</code>中配置<code>user-service</code>的负载均衡规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">user-service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 负载均衡规则</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">NFLoadBalancerRuleClassName</span><span class="p">:</span><span class="w"> </span><span class="l">com.netflix.loadbalancer.RandomRule</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="ribbon-饥饿加载" data-numberify>Ribbon 饥饿加载<a class="anchor ms-1" href="#ribbon-饥饿加载"></a></h2>
<ul>
<li>懒加载：第一次访问时才加载。</li>
<li>饥饿加载：在项目启动时就开始加载。</li>
</ul>
<p>Ribbon默认是采用懒加载，即第一次访问时才会去创建<code>LoadBalanceClient</code>，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时。</p>
<p>可以在<code>application.yml</code>中，通过下面配置开启Ribbon的饥饿加载：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">eager-load</span><span class="p">:</span><span class="w"> </span><span class="c"># 饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">clients</span><span class="p">:</span><span class="w"> </span><span class="l">user-service</span><span class="w"> </span><span class="c"># 指定对userservice这个服务饥饿加载</span><span class="w">
</span></span></span></code></pre></div><p><code>ribbon.eager-load.clients</code>是一个集合类型，如果要对多个服务提供者开启饥饿加载，可以这样配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">eager-load</span><span class="p">:</span><span class="w"> </span><span class="c"># 饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 对多个服务提供者开启饥饿加载</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">clients</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-1-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-2-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">clinet-3-service</span><span class="w">
</span></span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Feign</title>
      <link>/docs/spring/springcloud/feign/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/feign/</guid>
      <description><![CDATA[尽管使用了注册中心来解决URL的硬编码等问题，但是如今使用RestTemplate还是存在以下问题： 代码可读性差，编程体验不统一； 参数复杂U]]></description>
      <content:encoded><![CDATA[<p>尽管使用了注册中心来解决URL的硬编码等问题，但是如今使用<code>RestTemplate</code>还是存在以下问题：</p>
<ul>
<li>代码可读性差，编程体验不统一；</li>
<li>参数复杂URL难以维护。</li>
</ul>
<p>Feign是一个声明式的HTTP客户端，作用于服务消费者，在服务消费者中为服务提供者创建一个HTTP远程调用。官方地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener noreferrer">https://github.com/OpenFeign/feign<i class="fas fa-external-link-square-alt ms-1"></i></a>。其作用就是帮助我们优雅的实现HTTP请求的发送，解决上面提到的问题。</p>
<h1 id="使用-feign" data-numberify>使用 Feign<a class="anchor ms-1" href="#使用-feign"></a></h1>
<p>使用Feign非常简单，大致分为以下步骤：</p>
<ol>
<li>
<p>在<code>pom.xml</code>中引入Feign客户端依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>在项目的启动类上添加注解<code>@EnableFeignClients</code>以开启Feign的功能。例如为<code>order-service</code>（服务消费者）开启Feign：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span>
</span></span><span class="line"><span class="cl"><span class="nd">@MapperScan</span><span class="o">(</span><span class="s">&#34;asia.linner.demo.order.mapper&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">OrderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>为服务提供者编写一个<code>FeignClient</code>接口。例如在<code>order-service</code>（消费者）中为<code>user-service</code>（提供者）编写<code>FeignClient</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;user-service&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><ul>
<li><code>@FeignClient</code>：标注该接口为<code>FeignClient</code>，其<code>value</code>属性指定一个客户端的服务名称。</li>
<li><code>@GetMapping</code>：为了方便使用，Feign使用的是Spring的注解，其用法和作用与Spring中的类似。</li>
</ul>
<blockquote>
<p><code>FeignClient</code>可以放在项目中的<code>clients</code>包下。</p>
</blockquote>
</li>
<li>
<p>通过<code>FeignClient</code>远程调用服务。例如在<code>order-service</code>（消费者）中通过<code>FeignClient</code>远程调用<code>user-service</code>（提供者）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入Feign客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserClient</span> <span class="n">userClient</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用Feign远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userClient</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<blockquote>
<p>注意：使用了<code>FeignClient</code>，原本声明<code>RestTemplate</code>的<code>Bean</code>可以删除掉。因为使用<code>FeignClient</code>并不需要<code>RestTemplate</code>的<code>Bean</code>。</p>
</blockquote>
<hr>
<h1 id="feignclient-配置" data-numberify>FeignClient 配置<a class="anchor ms-1" href="#feignclient-配置"></a></h1>
<p>Feign可以修改的配置如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">作用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>feign.Logger.Level</code></td>
<td style="text-align:center">修改日志级别</td>
<td style="text-align:left">Feign包含四种不同的日志级别：<br><ul><li><code>NONE</code>：不记录任何日志。</li><li><code>BASIC</code>：基础日志级别。记录请求方法、URL以及响应状态代码和执行时间。</li><li><code>HEADERS</code>：记录基本信息以及请求和响应头信息。</li><li><code>FULL</code>：全日志级别。记录基本信息以及请求和响应头信息、请求和响应体信息。</li></ul></td>
</tr>
<tr>
<td style="text-align:center"><code>feign.codec.Decoder</code></td>
<td style="text-align:center">响应结果的解析器</td>
<td style="text-align:left">HTTP远程调用的结果做解析，例如解析JSON字符串为Java对象。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.codec.Encoder</code></td>
<td style="text-align:center">请求参数编码</td>
<td style="text-align:left">将请求参数编码，便于通过HTTP请求发送。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.Contract</code></td>
<td style="text-align:center">支持的注解格式</td>
<td style="text-align:left">默认是SpringMVC的注解。</td>
</tr>
<tr>
<td style="text-align:center"><code>feign.Retryer</code></td>
<td style="text-align:center">失败重试机制</td>
<td style="text-align:left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试。</td>
</tr>
</tbody>
</table>
<p>一般需要配置的是日志级别。有以下几种配置方式：</p>
<p>在<code>application.yml</code>中对全局进行配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">          </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">       </span><span class="c"># 客户端配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">default</span><span class="p">:</span><span class="w">  </span><span class="c"># 默认配置（全局生效）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">logger-level</span><span class="p">:</span><span class="w"> </span><span class="l">FULL </span><span class="w"> </span><span class="c"># 日志级别</span><span class="w">
</span></span></span></code></pre></div><p>在<code>application.yml</code>中对指定的服务进行配置。例如在<code>order-service</code>中对<code>user-service</code>进行配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">                </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">client</span><span class="p">:</span><span class="w">             </span><span class="c"># 客户端配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">user-service</span><span class="p">:</span><span class="w">   </span><span class="c"># 指定服务进行配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">logger-level</span><span class="p">:</span><span class="w"> </span><span class="l">HEADERS  </span><span class="w"> </span><span class="c"># 日志级别</span><span class="w">
</span></span></span></code></pre></div><p>只需要将全局默认配置中的<code>default</code>改成指定的服务名称即可。</p>
<p>另外一种方法是创建<code>FeignClient</code>配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">feign.Logger</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * FeignClient配置类
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultFeignClientConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Logger</span><span class="o">.</span><span class="na">Level</span> <span class="nf">getFeignLogLevel</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Logger</span><span class="o">.</span><span class="na">Level</span><span class="o">.</span><span class="na">BASIC</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>注意：<code>FeignClient</code>配置类中的<code>Logger</code>导入的是<code>feign</code>包下的<code>Logger</code>。并且在<code>application.yml</code>中的配置需要注释掉，否则即使开启了配置，配置类中的配置也不会生效。因为<code>application.yml</code>中的配置会将配置类中的配置覆盖掉。</p>
</blockquote>
<p>创建好了<code>FeignClient</code>配置类，这些配置并不会生效。因为<code>FeignClient</code>配置类中并没有任何信息告诉Spring这个是个配置类。所以需要对配置类进行声明。</p>
<p>有两种声明方式，一种是在项目的启动类中进行声明，告诉Spring这个是<code>FeignClient</code>的配置类。并且这种声明方式会在全局生效。声明<code>FeignClient</code>的配置类需要在启动类中使用<code>@EnableFeignClients</code>注解，并为其<code>defaultConfiguration</code>属性指定该<code>FeignClient</code>的配置类的<code>class</code>。例如为<code>order-service</code>声明该配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>  <span class="c1">// 全局默认的Feign配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@MapperScan</span><span class="o">(</span><span class="s">&#34;asia.linner.demo.order.mapper&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">OrderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>另外一种方式是，在某个具体服务<code>FeignClient</code>的接口中进行声明。该方式使用<code>@FeignClient</code>注解，并为其<code>configuration</code>属性指定一个<code>FeignClient</code>配置类的<code>class</code>。例如在<code>order-service</code>中为<code>user-service</code>声明使用一个<code>UserFeignClientConfig</code>配置类（假设已经创建好了该配置类）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;user-service&#34;</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="n">UserFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>记录日志会损耗一部分性能，所以除了在开发过程中使用<code>FULL</code>日志级别。在生产环境中最好使用<code>BASIC</code>或<code>NONE</code>日志级别以减少性能损耗（尽量使用<code>BASIC</code>）。</p>
</blockquote>
<hr>
<h1 id="配置连接池" data-numberify>配置连接池<a class="anchor ms-1" href="#配置连接池"></a></h1>
<p>每次HTTP请求，都需要三次握手去建立连接，完成后再断开连接。在高并发的情况下，这样往复地操作会造成的性能损耗是比较大的。引入连接池是为了减少这种性能的损耗。</p>
<p>Feign底层发起HTTP请求，依赖于其它的框架。其底层客户端实现包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接池</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">URLConnection</td>
<td style="text-align:left">默认实现，不支持连接池</td>
</tr>
<tr>
<td style="text-align:center">Apache HttpClient</td>
<td style="text-align:left">支持连接池</td>
</tr>
<tr>
<td style="text-align:center">OKHttp</td>
<td style="text-align:left">支持连接池</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提高Feign的性能主要手段就是使用HttpClient或OKHttp连接池代替默认的URLConnection。</p>
</blockquote>
<p>这里选择使用HttpClient。首先在消费者中引入其依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--HttpClient依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>io.github.openfeign<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-httpclient<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后在<code>application.yml</code>中修改配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">feign</span><span class="p">:</span><span class="w">                </span><span class="c"># Feign配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">httpclient</span><span class="p">:</span><span class="w"> </span><span class="c"># HttpClient配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c"># 如果要使用OKHttp，在feign.okhttp中做相应的配置即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 支持HttpClient的开关</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c"># 默认是true，但是没引入依赖不会生效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">max-connections</span><span class="p">:</span><span class="w"> </span><span class="m">200</span><span class="w">  </span><span class="c"># 最大连接数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">max-connections-per-route</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w"> </span><span class="c"># 单个请求路径的最大连接数</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>提高Feign的性能还可以对连接池客户端的最大连接数根据实际情况进行相应的配置调整。</p>
</blockquote>
<hr>
<h1 id="抽取api接口" data-numberify>抽取API接口<a class="anchor ms-1" href="#抽取api接口"></a></h1>
<p>由于<code>FeignClient</code>接口中编写的接口方法与其对应的提供者中的Controller的方法一致。所以可以对<code>FeignClient</code>接口和Controller做一个统一的API接口抽取，然后再通过集成的方式分别去实现<code>FeignClient</code>和Controller。但是这样的方法有以下缺点：</p>
<ul>
<li>
<p>服务提供方、服务消费方紧耦合。</p>
</li>
<li>
<p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解。</p>
<p>在API父接口的方法参数中使用的注解不会对Spring（也就是Controller）生效。即<code>@PathVariable</code>、<code>@RequestParam</code>这样的注解，在API父接口中声明了，在对应的Controller中也需要再次声明。</p>
</li>
</ul>
<p>以<code>user-service</code>为例：</p>
<ul>
<li>
<p>API父接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserAPI</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/user/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p><code>FeignClient</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;user-service&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserClient</span> <span class="o">{}</span>
</span></span></code></pre></div></li>
<li>
<p>Controller：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserAPI</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">User</span> <span class="nf">findById</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 业务代码... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ul>
<blockquote>
<p>这种方法的优点是简单、实现了代码共享，遵循了面向契约的编程思想。</p>
</blockquote>
<hr>
<h1 id="抽取-feign-api-模块" data-numberify>抽取 feign-api 模块<a class="anchor ms-1" href="#抽取-feign-api-模块"></a></h1>
<p>另外一种方式是将所有的提供者对应的FeignClient抽取为独立的模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，通过Maven引入依赖的方式提供给所有消费者使用。</p>
<p>假设有多个消费者都需要调用到同一个提供者。如果让消费者分别实现自己的FeignClient，不仅会有许多冗余的代码，而且也不利于维护。但是如果使用这种方式将FeignClient抽取出来，可以由实现提供者的程序员来提供对应的feign-api实现。</p>
<p>这样的方法也有一些缺点，在使用一个提供者的接口时，需要同时引入该提供者的所有接口和其它提供者的所有接口。</p>
<p>抽取<code>feign-api</code>的步骤：</p>
<ol>
<li>
<p>创建一个新的模块，命名为<code>feign-api</code>。</p>
</li>
<li>
<p>在<code>feign-api</code>中引入Feign的Stater依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Feign客户端依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>如果要默认使用<code>HttpClient</code>连接池，还需要导入其坐标：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--HttpClient依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>io.github.openfeign<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-httpclient<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><blockquote>
<p>注：引入坐标是为了在消费者的<code>pom.xml</code>中可以不同显式地导入<code>HttpClient</code>的依赖（使用Maven的依赖传递），但是<code>HttpClient</code>的配置还是得在消费者中的<code>application.yml</code>中配置。</p>
<p>如果在<code>feign-api</code>中创建<code>application.yml</code>中并配置<code>HttpClient</code>，这样的配置是不会在消费者中生效的。因为<code>feign-api</code>没有启动类，而且消费者的启动类也不会使用<code>feign-api</code>中<code>application.yml</code>的配置。除非使用配置类编写对<code>HttpClient</code>的配置，并且在消费者中启用这个配置类。</p>
</blockquote>
</li>
<li>
<p>将所有消费者的<code>FeignClient</code>、POJO和<code>DefaultFeignClientConfig</code>都抽取到<code>feign-api</code>模块中。</p>
<blockquote>
<p>注：<code>DefaultFeignClientConfig</code>的抽取是对所有的<code>FeignClient</code>做一个默认的配置抽取。</p>
</blockquote>
</li>
<li>
<p>在消费者中引入<code>feign-api</code>依赖。</p>
</li>
<li>
<p>在消费者中使用<code>feign-api</code>提供的API接口。</p>
<blockquote>
<p>注：需要修改消费者的启动类，在消费者的启动类上使用<code>@EnableFeignClients</code>注解的<code>basePackages</code>或<code>clients</code>属性指定扫描的<code>FeignClient</code>包或具体的<code>FeignClient</code>类，让消费者的启动类能扫描到<code>feign-api</code>的<code>FeignClient</code>。</p>
</blockquote>
</li>
</ol>
<p>以<code>order-service</code>（消费者）和<code>user-service</code>（提供者）为例：</p>
<ol>
<li>
<p>创建<code>feign-api</code>，并导入Feign依赖。</p>
</li>
<li>
<p>将原本编写在<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>抽取出来，放在<code>feign-api</code>中对应的包下。例如：</p>
<p><code>asia.linner.demo.feign</code>（<code>feign-api</code>的包名）下的包结构:</p>
<ul>
<li><code>clients</code>：
<ul>
<li><code>UserClient.java</code></li>
</ul>
</li>
<li><code>pojo</code>：
<ul>
<li><code>User.java</code></li>
</ul>
</li>
<li><code>config</code>：
<ul>
<li><code>DefaultFeignClientConfig.java</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>抽取完成后，原本在<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>都可以删除。但是需要注意复制在<code>feign-api</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>它们的包名要改成<code>feign-api</code>的包名。</p>
</blockquote>
</li>
<li>
<p>在<code>order-service</code>中导入<code>feign-api</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--引入抽取的feign-api模块--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>feign-api<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><blockquote>
<p>在<code>order-service</code>中的Feign依赖可以删除；如果有在<code>feign-api</code>中导入并配置HttpClient，HttpClient的依赖也可以删除。需要注意引入<code>order-service</code>中的<code>UserClient</code>、<code>User</code>和<code>DefaultFeignClientConfig</code>它们的包名要改成<code>feign-api</code>的包名。</p>
</blockquote>
</li>
<li>
<p>让<code>order-service</code>的启动类扫描<code>FeignClient</code>。</p>
<p>因为<code>feign-api</code>和<code>order-service</code>的包名并不相同（如<code>asia.linner.demo.feign</code>和<code>asia.linner.demo.order</code>），所以在没有扫描包指定的情况下<code>order-service</code>的启动类并不能扫描到<code>feign-api</code>中的<code>UserClient</code>，所以会导致<code>order-service</code>中的<code>UserClient</code>注入失败。</p>
<p>Feign的<code>@EnableFeignClients</code>注解提供了两种方式来让消费者的启动类扫描到<code>FeignClient</code>：</p>
<ul>
<li>
<p><code>basePackages</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePackages</span> <span class="o">=</span> <span class="s">&#34;asia.linner.demo.feign.clients&#34;</span> <span class="c1">// 扫描整个clients包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">)</span>
</span></span></code></pre></div></li>
<li>
<p><code>clients</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableFeignClients</span><span class="o">(</span><span class="n">defaultConfiguration</span> <span class="o">=</span> <span class="n">DefaultFeignClientConfig</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">clients</span> <span class="o">=</span> <span class="o">{</span><span class="n">UserClient</span><span class="o">.</span><span class="na">class</span><span class="o">}</span>    <span class="c1">// 指定需要加载的FeignClient接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">)</span>
</span></span></code></pre></div><p><code>clients</code>属性的类型是一个<code>class</code>数组，所以可以指定多个<code>FeignClient</code>。推荐使用该方式。</p>
</li>
</ul>
<p>在上述方法中选一种，然后修改<code>order-service</code>的启动类即可。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Gateway</title>
      <link>/docs/spring/springcloud/gateway/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/gateway/</guid>
      <description><![CDATA[网关 网关是所有微服务的统一入口。网关的核心功能特性： 请求路由：一切请求都必须先经过网关，但网关不处理业务，而是根据某种规则，把请求转发到某个]]></description>
      <content:encoded><![CDATA[<h1 id="网关" data-numberify>网关<a class="anchor ms-1" href="#网关"></a></h1>
<p>网关是所有微服务的统一入口。网关的核心功能特性：</p>
<ul>
<li><strong>请求路由</strong>：一切请求都必须先经过网关，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当路由的目标服务有多个时，还需要做<strong>负载均衡</strong>。</li>
<li><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li>
<li><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</li>
</ul>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>Gateway：基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
<li>Zuul：基于Servlet的实现，属于阻塞式编程。</li>
</ul>
<blockquote>
<p>Spring Cloud Gateway旨在为微服务架构提供一种简单有效的统一的API路由管理方式。</p>
</blockquote>
<hr>
<h1 id="创建-gateway-服务" data-numberify>创建 Gateway 服务<a class="anchor ms-1" href="#创建-gateway-服务"></a></h1>
<p>创建一个Gateway服务的基本步骤如下：</p>
<ol>
<li>
<p>创建一个新的gateway模块。</p>
</li>
<li>
<p>导入Gateway所需依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos服务注册发现依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- 网关Gateway依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-gateway<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>因为Gateway属于一个服务，所以需要创建并编写<code>GatewayApplication</code>启动类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@SpringBootApplication</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GatewayApplication</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">GatewayApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在配置文件<code>application.yml</code>中编写Gateway相关配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">10010</span><span class="w"> </span><span class="c"># 网关端口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">gateway</span><span class="w"> </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nacos</span><span class="p">:</span><span class="w">  </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">routes</span><span class="p">:</span><span class="w">   </span><span class="c"># 网关路由配置（是数组类型，可以配置多个）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w"> </span><span class="c"># 路由ID，自定义，只要唯一即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri支持以下两种方式，推荐使用lb方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri: http://localhost:8081  # 路由的目标地址，使用http表示固定地址（不推荐使用）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w"> </span><span class="c"># 路由的目标地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># lb是Load Balance的缩写，表示负载均衡</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># 后面是服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> </span><span class="c"># 路由断言，判断请求是否符合路由规则的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/user/**</span><span class="w"> </span><span class="c"># 路径断言，匹配&#34;/user/&#34;开头的请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://${spring.cloud.gateway.routes[1].id} </span><span class="w"> </span><span class="c"># 通过yaml变量设置uri</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Before=2037-01-20T17:42:47.789-07:00[America/Denver]</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>启动<code>GatewayApplication</code>，使用<code>localhost:10010</code>来访问系统上的服务。</p>
<p>例如访问<code>user-service</code>上的<code>/user/{id}</code>请求，就可以使用<code>http://localhost:10010/user/{id}</code>访问。获取<code>id</code>为<code>1</code>的<code>user</code>就访问<a href="http://localhost:10010/user/1" target="_blank" rel="noopener noreferrer"><code>http://localhost:10010/user/1</code><i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>如上所述，访问<code>order-service</code>上的<code>/order/{id}</code>就使用<code>http://localhost:10010/order/{id}</code>访问。</p>
</li>
</ol>
<p>使用网关就可以通过网关来访问服务中的资源，并且还能做到负载均衡和权限控制等。</p>
<hr>
<h1 id="路由配置" data-numberify>路由配置<a class="anchor ms-1" href="#路由配置"></a></h1>
<p>Gateway的路由配置如上所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">routes</span><span class="p">:</span><span class="w">   </span><span class="c"># 网关路由配置（是数组类型，可以配置多个）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w"> </span><span class="c"># 路由ID，自定义，只要唯一即可</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri支持以下两种方式，推荐使用lb方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># uri: http://localhost:8081  # 路由的目标地址，使用http表示固定地址（不推荐使用）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w"> </span><span class="c"># 路由的目标地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># lb是Load Balance的缩写，表示负载均衡</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c"># 后面是服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> </span><span class="c"># 路由断言，判断请求是否符合路由规则的条件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/user/**</span><span class="w"> </span><span class="c"># 路径断言，匹配&#34;/user/&#34;开头的请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://${spring.cloud.gateway.routes[1].id} </span><span class="w"> </span><span class="c"># 通过yaml变量设置uri</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="l">Before=2037-01-20T17:42:47.789-07:00[America/Denver]</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>
<p><code>cloud.gateway.routes</code>：Gateway的网关路由配置，数组类型。其元素可以有<code>id</code>、<code>uri</code>和<code>predicates</code>等属性。</p>
</li>
<li>
<p><code>id</code>属性：标识一个服务的路由配置的唯一ID。可由用户自定义，但在当前Gateway网关服务中不可重复存在。</p>
</li>
<li>
<p><code>uri</code>属性：标识当前服务路由配置的目标地址。有两种配置方式：</p>
<ul>
<li>
<p><code>http</code>：使用<code>http://</code>前缀，表示当前的地址是固定地址。例如<code>http://localhost:8081</code>。</p>
</li>
<li>
<p><code>lb</code>：使用<code>lb://</code>前缀，表示当前的地址是非固定的，需要做负载均衡。例如：<code>lb://user-service</code>。</p>
<blockquote>
<p><code>lb</code>是Load Balance的缩写，表示负载均衡。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>predicates</code>属性：路由断言，根据Gateway提供的断言工厂，对经过网关的请求进行权限的断言（也就是判断有没有权限可以访问该服务）。<code>predicates</code>是数组属性，可以配置多个规则。</p>
</li>
</ul>
<h1 id="断言工厂" data-numberify>断言工厂<a class="anchor ms-1" href="#断言工厂"></a></h1>
<p>在配置文件中写的断言规则，会被Predicate Factory读取并处理，转变为路由判断的条件。</p>
<p>例如上方<code>Path=/user/**</code>就是按照路径匹配，断言只有<code>/user/**</code>这个请求方式才能通过网关访问到<code>user-service</code>。<code>order-service</code>中的<code>Path=/order/**</code>同理。这两条规则是由<code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的。</p>
<p>在Gateway中还有以下断言工厂：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>After</code></td>
<td>是某个时间点后的请求。</td>
<td><code>After=2037-01-20T17:42:47.789-07:00[America/Denver]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Before</code></td>
<td>是某个时间点之前的请求。</td>
<td><code>Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Between</code></td>
<td>是某两个时间点之前的请求。</td>
<td><code>Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Cookie</code></td>
<td>请求必须包含某些cookie。</td>
<td><code>Cookie=chocolate, ch.p</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Header</code></td>
<td>请求必须包含某些header。</td>
<td><code>Header=X-Request-Id, \d+</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Host</code></td>
<td>请求必须是访问某个host（域名）。</td>
<td><code>Host=**.somehost.org,**.anotherhost.org</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Method</code></td>
<td>请求方式必须是指定方式。</td>
<td><code>Method=GET,POST</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Path</code></td>
<td>请求路径必须符合指定规则。</td>
<td><code>Path=/red/{segment},/blue/**</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Query</code></td>
<td>请求参数必须包含指定参数。</td>
<td><code>Query=name, Jack</code>，<br>或者<code>Query=name</code></td>
</tr>
<tr>
<td style="text-align:center"><code>RemoteAddr</code></td>
<td>请求者的ip必须是指定范围。</td>
<td><code>RemoteAddr=192.168.1.1/24</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Weight</code></td>
<td>权重处理。</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="路由过滤器" data-numberify>路由过滤器<a class="anchor ms-1" href="#路由过滤器"></a></h1>
<p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>
<p>Spring提供了31种不同的路由过滤器工厂。常用的有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AddRequestHeader</code></td>
<td>给当前请求添加一个请求头。</td>
</tr>
<tr>
<td><code>RemoveRequestHeader</code></td>
<td>移除请求中的一个请求头。</td>
</tr>
<tr>
<td><code>AddResponseHeader</code></td>
<td>给响应结果中添加一个响应头。</td>
</tr>
<tr>
<td><code>RemoveResponseHeader</code></td>
<td>从响应结果中移除有一个响应头。</td>
</tr>
<tr>
<td><code>RequestRateLimiter</code></td>
<td>限制请求的流量。</td>
</tr>
</tbody>
</table>
<p>GatewayFilter的使用也是在<code>application.yml</code>中配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">routes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/user/** </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">filters</span><span class="p">:</span><span class="w"> </span><span class="c"># 过滤器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">AddRequestHeader=Hello, Hello Spring Cloud Gateway!</span><span class="w"> </span><span class="c"># 添加请求头</span><span class="w">
</span></span></span></code></pre></div><h1 id="defaultfilter" data-numberify>DefaultFilter<a class="anchor ms-1" href="#defaultfilter"></a></h1>
<p>上方所示的GatewayFilter只有在访问<code>user-service</code>时才能生效。Spring Cloud Gateway还提供了全局默认的GatewayFilter配置方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">routes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">user-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://userservice </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/user/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l">order-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">uri</span><span class="p">:</span><span class="w"> </span><span class="l">lb://order-service </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">predicates</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">Path=/order/**</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">default-filters</span><span class="p">:</span><span class="w"> </span><span class="c"># 默认过滤项</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">AddRequestHeader=Truth, Itcast is freaking awesome! </span><span class="w">
</span></span></span></code></pre></div><p>这种方式无论访问的是<code>user-service</code>还是<code>order-service</code>都会生效。</p>
<p>在Spring Cloud Gateway的官方文档中可以查找更多路由工厂及其使用方式：</p>
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories" target="_blank" rel="noopener noreferrer"><picture><img class="img-fluid " alt="Spring Cloud Gateway 官方文档" src="/docs/spring/springcloud/gateway/uTools_1690728134391.png" loading="lazy" width="1897" height="949" />
</picture>

<i class="fas fa-external-link-square-alt ms-1"></i></a></p>
<h1 id="globalfilter" data-numberify>GlobalFilter<a class="anchor ms-1" href="#globalfilter"></a></h1>
<p>GlobalFilter的作用与GatewayFilter的作用一样，也是处理一切进入网关的请求和微服务响应。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现，可以自定义实现。</p>
<p><code>GlobalFilter</code>接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GlobalFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * 处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @param exchange 请求上下文，里面可以获取Request、Responses等信息
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @param chain 用来把请求委托给下一个过滤器（放行请求）
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @return {@code Mono&lt;Void&gt;} 返回一个当前过滤器业务结束的标示
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><blockquote>
<p>注：<code>GlobalFilter</code>是在<code>org.springframework.cloud.gateway.filter</code>包下的，是属于Spring Cloud Gateway中的一部分。</p>
</blockquote>
<p>在Filter中编写自定义逻辑，可以实现登录状态判断、权限校验、请求限流等等功能。</p>
<p>假设实现一个简单的用户权限判断，其判断逻辑如下：</p>
<ul>
<li>请求参数中是否有<code>authorization</code>；</li>
<li><code>authorization</code>参数值是否为<code>admin</code>。</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 识别用户权限
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Order</span><span class="o">(-</span><span class="n">1</span><span class="o">)</span>   <span class="c1">// 顺序注解（定义过滤器的执行顺序），值越小优先级越高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizeFilter</span> <span class="kd">implements</span> <span class="n">GlobalFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 获取请求参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ServerHttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getRequest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">MultiValueMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getQueryParams</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 获取参数中的 authorization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">auth</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="na">getFirst</span><span class="o">(</span><span class="s">&#34;authorization&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 判断参数值是否等于 admin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="s">&#34;admin&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">auth</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 4. 是则放行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// chain.filter()的返回值是Mono&lt;Void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 否则拦截
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ServerHttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getResponse</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 5.1. 设置状态码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// HttpStatus.UNAUTHORIZED 表示用户未认证，状态码为401
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">response</span><span class="o">.</span><span class="na">setStatusCode</span><span class="o">(</span><span class="n">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 5.2. 拦截请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// setComplete()的返回也是Mono&lt;Void&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">setComplete</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>定义GlobalFilter的过程可总结为：</p>
<ol>
<li>
<p>继承<code>GlobalFilter</code>接口。</p>
</li>
<li>
<p>实现<code>GlobalFilter.filter()</code>方法。</p>
<p>在实现<code>GlobalFilter.filter()</code>时，可以使用<code>exchange</code>对象获取请求的<code>Request</code>、<code>Response</code>、<code>Attribute</code>、<code>Session</code>、<code>FormData</code>等信息。其中获取到的<code>Request</code>和<code>Response</code>分别是<code>ServerHttpRequest</code>和<code>ServerHttpResponse</code>对象。</p>
<blockquote>
<p>使用<code>exchange</code>获取到的对象与使用标准的ServletAPI获取到的不一样。</p>
</blockquote>
<p>放行资源使用的是<code>chain</code>对象。该对象仅有一个方法<code>filter()</code>。该方法接受一个<code>ServerWebExchange</code>对象（也就是<code>exchange</code>，相当于将<code>exchange</code>传给下一级Filter），并返回给上层Filter一个<code>Mono&lt;Void&gt;</code>对象。放行资源时标准的用法是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span></code></pre></div><p>拦截资源使用的是从<code>exchange</code>中获取的<code>response</code>对象。调用<code>response</code>对象的<code>setComplete()</code>方法，返回给上层Filter一个<code>Mono&lt;Void&gt;</code>。标准用法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">setComplete</span><span class="o">();</span>
</span></span></code></pre></div><p>这样相当于直接将业务结束标示<code>Mono&lt;Void&gt;</code>返回给上层Filter。而没有调用<code>chain.filter(exchange)</code>的话，请求也就不会进入到下层Filter。</p>
</li>
<li>
<p>为实现的<code>GlobalFilter</code>使用<code>@Component</code>注解，让Spring可以将该过滤器加载为Bean。</p>
</li>
<li>
<p>为实现的<code>GlobalFilter</code>定义顺序（有两种定义方式）。</p>
<p>定义<code>GlobalFilter</code>执行的优先级顺序的一个方法就是使用如上所示的<code>@Order</code>注解。在<code>@Order</code>注解中，其<code>value</code>属性是一个<code>int</code>类型的值，默认为<code>Integer.MAX_VALUE</code>也就是<code>int</code>类型的最大值<code>2147483647</code>（即$2^{31}-1$，按32位补码计算），<code>value</code>越小优先级越高。</p>
<p>另一种方式就是继承一个<code>Ordered</code>接口，并实现其<code>getOrder()</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizeFilter</span> <span class="kd">implements</span> <span class="n">GlobalFilter</span><span class="o">,</span> <span class="n">Ordered</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 拦截/放行逻辑... */</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 定义过滤器执行顺序，效果与{@code @Order}相同
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 过滤器的执行顺序，值越小优先级越高
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getOrder</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<h1 id="过滤器链" data-numberify>过滤器链<a class="anchor ms-1" href="#过滤器链"></a></h1>
<p>请求进入网关后会遇到三类过滤器：</p>
<ul>
<li>当前路由的过滤器；</li>
<li>默认过滤器（DefaultFilter）；</li>
<li>全局过滤器（GlobalFilter）。</li>
</ul>
<p>在请求路由后，Spring Cloud Gateway会将每个路由的路由过滤器、默认过滤器和全局过滤器合并到一个过滤器链（集合）中，并进行排序。然后Spring Cloud Gateway会根据请求，按顺序执行路由对应的过滤器链。</p>
<blockquote>
<p>在CSDN上看到一个Gateway执行流程图，确实是在请求路由之后才开始组装过滤器链：</p>
<p><picture><img class="img-fluid " alt="Gateway执行流程图" src="/docs/spring/springcloud/gateway/20210405115550799.png" loading="lazy" width="1076" height="1268" />
</picture>

</p>
<p>原文链接：<a href="https://blog.csdn.net/riemann_/article/details/115440231" target="_blank" rel="noopener noreferrer">Spring Cloud Gateway 源码剖析之Filter Chain过滤器链<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
</blockquote>
<p>路由过滤器和默认过滤器的实现十分接近，它们的本质都是<code>AddRequestHeaderGatewayFilterFactory</code>，并且最后通过<code>apply()</code>方法读取配置后生成统一的过滤器对象<code>GatewayFilter</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddRequestHeaderGatewayFilterFactory</span>
</span></span><span class="line"><span class="cl">		<span class="kd">extends</span> <span class="n">AbstractNameValueGatewayFilterFactory</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">GatewayFilter</span> <span class="nf">apply</span><span class="o">(</span><span class="n">NameValueConfig</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">GatewayFilter</span><span class="o">()</span> <span class="o">{</span>    <span class="c1">// 生成过滤器对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">			<span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">					<span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">			<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">		<span class="o">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>全局过滤器则是通过<code>FilteringWebHandler</code>中的私有类<code>GatewayFilterAdapter</code>（过滤器适配器）生成，使用<code>loadFilters()</code>将所有<code>GlobalFilter</code>转化为<code>GatewayFilterAdapter</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FilteringWebHandler</span> <span class="kd">implements</span> <span class="n">WebHandler</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">globalFilters</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">FilteringWebHandler</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GlobalFilter</span><span class="o">&gt;</span> <span class="n">globalFilters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">globalFilters</span> <span class="o">=</span> <span class="n">loadFilters</span><span class="o">(</span><span class="n">globalFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 将所有GlobalFilter链转为GatewayFilter
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="nf">loadFilters</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GlobalFilter</span><span class="o">&gt;</span> <span class="n">filters</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">filters</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">filter</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">GatewayFilterAdapter</span> <span class="n">gatewayFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GatewayFilterAdapter</span><span class="o">(</span><span class="n">filter</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="o">(</span><span class="n">filter</span> <span class="k">instanceof</span> <span class="n">Ordered</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">				<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="o">((</span><span class="n">Ordered</span><span class="o">)</span> <span class="n">filter</span><span class="o">).</span><span class="na">getOrder</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="k">new</span> <span class="n">OrderedGatewayFilter</span><span class="o">(</span><span class="n">gatewayFilter</span><span class="o">,</span> <span class="n">order</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">			<span class="o">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">gatewayFilter</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">		<span class="o">}).</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 加载全局过滤器，与所有的路由过滤器和默认过滤器合并后更具Order排序、组织过滤器链
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">handle</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Route</span> <span class="n">route</span> <span class="o">=</span> <span class="n">exchange</span><span class="o">.</span><span class="na">getRequiredAttribute</span><span class="o">(</span><span class="n">GATEWAY_ROUTE_ATTR</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 加载所有的默认过滤器和路由过滤器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 加载方式是，先加载默认过滤器链，然后根据Route（规则）加载路由过滤器链，最后合并为一个过滤器链
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">gatewayFilters</span> <span class="o">=</span> <span class="n">route</span><span class="o">.</span><span class="na">getFilters</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">List</span><span class="o">&lt;</span><span class="n">GatewayFilter</span><span class="o">&gt;</span> <span class="n">combined</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">.</span><span class="na">globalFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">combined</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">gatewayFilters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// TODO: needed or cached?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">AnnotationAwareOrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">combined</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Sorted gatewayFilterFactories: &#34;</span> <span class="o">+</span> <span class="n">combined</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="k">new</span> <span class="n">DefaultGatewayFilterChain</span><span class="o">(</span><span class="n">combined</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">GatewayFilterAdapter</span> <span class="kd">implements</span> <span class="n">GatewayFilter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kd">final</span> <span class="n">GlobalFilter</span> <span class="n">delegate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 私有类构造方法
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="n">GatewayFilterAdapter</span><span class="o">(</span><span class="n">GlobalFilter</span> <span class="n">delegate</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 实现GatewayFilter的filter()方法
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ServerWebExchange</span> <span class="n">exchange</span><span class="o">,</span> <span class="n">GatewayFilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">delegate</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">exchange</span><span class="o">,</span> <span class="n">chain</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>综上所述，Spring Cloud Gateway加载过滤器链的过程大致如下：</p>
<ol>
<li>
<p>加载默认过滤器链。</p>
</li>
<li>
<p>加载路由过滤器链。</p>
</li>
<li>
<p>合并默认过滤器链和路由过滤器链为一条过滤器链。</p>
<p>路由过滤器和默认过滤器的<code>Order</code>由Spring指定，默认是按照声明顺序从1递增。</p>
</li>
<li>
<p>加载全局过滤器链。</p>
</li>
<li>
<p>将全局过滤器链和 默认过滤器与路由过滤器合并的链 合并。</p>
<blockquote>
<p>所有的过滤器都有一个<code>int</code>类型的<code>Order</code>值，<code>Order</code>值越小，优先级越高，执行顺序越靠前。</p>
</blockquote>
<p>当过滤器的<code>Order</code>值一样时，会按照 <strong>默认过滤器 &gt; 路由过滤器 &gt; 全局过滤器</strong> 的顺序执行。</p>
</li>
</ol>
<h1 id="跨域问题处理" data-numberify>跨域问题处理<a class="anchor ms-1" href="#跨域问题处理"></a></h1>
<p>跨域是指发送与当前服务的域名（或端口、协议）不一致的请求。</p>
<p>跨域问题的产生原因是浏览器不允许Ajax请求对域名不同或端口不同的服务发起请求。例如：</p>
<ul>
<li>域名不同： <code>www.taobao.com</code>和<code>www.taobao.org</code>，<code>www.linner.asia</code>和<code>blog.linner.asia</code>。</li>
<li>域名相同，端口不同：<code>localhost:8080</code>和<code>localhost8081</code>。</li>
</ul>
<p>解决方案之一就是CORS（JSONP只支持GET请求，不推荐）。Gateway为我们提供了使用CORS处理跨域问题的方法，只需修改<code>application.yml</code>即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">gateway</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">globalcors</span><span class="p">:</span><span class="w"> </span><span class="c"># 全局的跨域处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">add-to-simple-url-handler-mapping</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 解决options请求被拦截问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cors-configurations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">&#39;[/**]&#39;</span><span class="p">:</span><span class="w">  </span><span class="c"># 对所有请求进行跨域处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedOrigins</span><span class="p">:</span><span class="w"> </span><span class="c"># 允许跨域请求的网站</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;http://localhost:5500&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;http://http://127.0.0.1:5500&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedMethods</span><span class="p">:</span><span class="w"> </span><span class="c"># 允许的跨域ajax的请求方式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;GET&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;POST&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;DELETE&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;PUT&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="s2">&#34;OPTIONS&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowedHeaders</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;*&#34;</span><span class="w"> </span><span class="c"># 允许在请求中携带的头信息（这里是允许所有）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">allowCredentials</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># 是否允许携带cookie</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">maxAge</span><span class="p">:</span><span class="w"> </span><span class="m">360000</span><span class="w">  </span><span class="c"># 每次跨域检测的有效期（在有效期内浏览器不会重复询问跨域请求）</span><span class="w">
</span></span></span></code></pre></div><p>模拟一个跨域问题：</p>
<ol>
<li>
<p>编写一个简单的页面，其中用Ajax发起跨域请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;ie=edge&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Document<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>模拟跨域问题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://unpkg.com/axios/dist/axios.min.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发送请求到Gateway网关上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;http://localhost:10010/user/1?authorization=admin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resp</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>使用Tomcat或Nginx之类的Web服务器放置这个Html页面。</p>
<blockquote>
<p>我在模拟时使用的是VS Code的<code>Live Server</code>插件。它会想Web服务器一样在你电脑上开一个端口加载页面，让你能实时预览你的页面效果。用在这里做个简单的静态页面Web服务器也很方便。</p>
<p><picture><img class="img-fluid " alt="Live Server 插件" src="/docs/spring/springcloud/gateway/uTools_1690798301739.png" loading="lazy" width="919" height="238" />
</picture>

</p>
<p>Live Server使用的端口是<code>5500</code>，当然也有可能不同。</p>
</blockquote>
</li>
<li>
<p>在给Gateway网关配置跨域请求处理之前，通过Web服务器访问页面，可以在浏览器控制台发现类似以下的报错：</p>
<p><picture><img class="img-fluid " alt="跨域报错信息" src="/docs/spring/springcloud/gateway/uTools_1690798524991.png" loading="lazy" width="702" height="66" />
</picture>

</p>
</li>
<li>
<p>配置成功后重启Gateway网关，再次访问页面，可以发现浏览器控制台打印出了跨域请求获取到的结果。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Nacos</title>
      <link>/docs/spring/springcloud/nacos/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/nacos/</guid>
      <description><![CDATA[部署 Nacos Server 安装和配置好Nacos后，在nacos的bin目录中使用脚本启动： Windows： 单机启动： startup.cmd -m standalone Linux： 单机启动： sh startup.sh -m standalone 在浏]]></description>
      <content:encoded><![CDATA[<h1 id="部署-nacos-server" data-numberify>部署 Nacos Server<a class="anchor ms-1" href="#部署-nacos-server"></a></h1>
<p>安装和配置好Nacos后，在<code>nacos</code>的<code>bin</code>目录中使用脚本启动：</p>
<ul>
<li>
<p>Windows：</p>
<p>单机启动：</p>
<pre tabindex="0"><code>startup.cmd -m standalone
</code></pre></li>
<li>
<p>Linux：</p>
<p>单机启动：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sh startup.sh -m standalone
</span></span></code></pre></div></li>
</ul>
<p>在浏览器中使用对应的IP和端口访问，如<code>http://localhost:8848/nacos</code>。</p>
<p>默认账号和密码均为<code>nacos</code>。</p>
<blockquote>
<p>更多Nacos的部署方式：<a href="/p/nacos-%e9%83%a8%e7%bd%b2/">Nacos 部署</a></p>
</blockquote>
<hr>
<h1 id="服务注册中心" data-numberify>服务注册中心<a class="anchor ms-1" href="#服务注册中心"></a></h1>
<h2 id="nacos-客户端依赖" data-numberify>Nacos 客户端依赖<a class="anchor ms-1" href="#nacos-客户端依赖"></a></h2>
<ul>
<li>
<p>父工程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--
</span></span></span><span class="line"><span class="cl"><span class="c">    Spring Cloud Alibaba
</span></span></span><span class="line"><span class="cl"><span class="c">    包含了Nacos的版本管理
</span></span></span><span class="line"><span class="cl"><span class="c"> --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-alibaba-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.2.5.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>客户端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos 客户端 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>配置Nacos（<code>application.yml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h2 id="服务器集群" data-numberify>服务器集群<a class="anchor ms-1" href="#服务器集群"></a></h2>
<p>在Nacos中配置服务器集群，需要在<code>application.yml</code>使用来配置<code>spring.cloud.nacos.discovery.cluster-name</code>客户端服务器的集群名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cluster-name</span><span class="p">:</span><span class="w"> </span><span class="l">HZ </span><span class="w"> </span><span class="c"># 集群名称</span><span class="w">
</span></span></span></code></pre></div><p>使用Nacos提供的集群配置，就可以将同一机房内的实例划分为一个集群。</p>
<p><picture><img class="img-fluid " alt="服务器集群" src="/docs/spring/springcloud/nacos/uTools_1688717062670.png" loading="lazy" width="1145" height="540" />
</picture>

</p>
<h2 id="负载均衡策略" data-numberify>负载均衡策略<a class="anchor ms-1" href="#负载均衡策略"></a></h2>
<p>Nacos提供了一个负载均衡策略<code>NacosRule</code>配置它和配置其它的Ribbon负载均衡策略相同。在<code>application.yml</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">service-name</span><span class="p">:</span><span class="w"> </span><span class="c"># 服务名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ribbon</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 负载均衡规则</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># Nacos提供的负载均衡策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">NFLoadBalancerRuleClassName</span><span class="p">:</span><span class="w"> </span><span class="l">com.alibaba.cloud.nacos.ribbon.NacosRule</span><span class="w">
</span></span></span></code></pre></div><p>当然也可以使用Bean的方式配置全局的负载均衡策略：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IRule</span> <span class="nf">getLoadBalancerRule</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">NacosRule</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>NacosRule</code>会根据当前服务所在的集群，优先挑选与当前服务相同的集群。因为在同一机房同一集群的配置下，访问本地的集群（即相同的集群）速度将会更快。如果相同的集群下无可用实例，才会选择其它示例，并且控制台会给出警告。如果在相同集群的情况下，则使用随机轮询，随机选择一个实例。</p>
<h2 id="访问权重" data-numberify>访问权重<a class="anchor ms-1" href="#访问权重"></a></h2>
<p>默认情况下使用NacosRule是在同集群内随机挑选，并不会考虑机器的性能问题。</p>
<p>为了让性能更快的服务可以被分配到更多的请求，Nacos提供了权重配置来控制访问频率。使用访问权重，可以调节服务被访问到的概率。访问权重的<u>取值为0~1</u>，<u>默认值是1</u>，<u>权重越高</u>，被访问到的<u>概率就越大</u>。如果将访问<u>权重修改为0</u>，那么该实例将<u>永远不会被访问</u>。</p>
<blockquote>
<p>将访问权重修改为0并不意味着服务器停机，只是后续的请求不会使用到这个服务器，而当前该服务器所处理的请求还会继续。</p>
</blockquote>
<p>修改访问权重可以在Nacos控制台中修改：</p>
<p>例如，修改<code>user-service</code>的权重，找到<code>user-service</code>的实例列表，点击编辑，即可修改权重：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210713235133225.png" loading="lazy" width="1229" height="357" />
</picture>

</p>
<p>在弹出的编辑窗口，修改权重：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210713235235219.png" loading="lazy" width="749" height="639" />
</picture>

</p>
<h2 id="非临时实例" data-numberify>非临时实例<a class="anchor ms-1" href="#非临时实例"></a></h2>
<p>Nacos的服务实例（服务提供者）分为两种类型：</p>
<ul>
<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，是所有实例默认的类型。</li>
<li><strong>非临时实例</strong>（永久实例）：如果实例宕机，不会将其从服务列表剔除。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">ephemeral</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">  </span><span class="c"># 注册为非临时实例</span><span class="w">
</span></span></span></code></pre></div><h2 id="环境隔离" data-numberify>环境隔离<a class="anchor ms-1" href="#环境隔离"></a></h2>
<p>Nacos提供了<code>namespace</code>（命名空间）来实现环境隔离功能。默认情况下，所有<code>service</code>、<code>data</code>、<code>group</code>都在同一个名为<code>public</code>的<code>namespace</code>。每个<code>namespace</code>都有一个唯一的ID，并且不同<code>namespace</code>下的服务之间互不可见。<code>namespace</code>可以在Nacos控制台中创建。</p>
<p>为服务设置<code>namespace</code>，需要在<code>application.yml</code>中配置<code>spring.cloud.nacos.discovery.namespace</code>，它的值为对应命名空间的ID：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w"> </span><span class="c"># Nacos服务地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 命名空间，值为对应命名空间的ID</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">df79820e-775d-4787-b0a8-0b6e5fabeb13</span><span class="w">
</span></span></span></code></pre></div><hr>
<h1 id="nacos-与-eureka-的区别" data-numberify>Nacos 与 Eureka 的区别<a class="anchor ms-1" href="#nacos-与-eureka-的区别"></a></h1>
<p><picture><img class="img-fluid " alt="Nacos远程调用流程" src="/docs/spring/springcloud/nacos/uTools_1688717257055.png" loading="lazy" width="966" height="370" />
</picture>

</p>
<p>Nacos和Eureka整体结构类似，都有服务注册、服务拉取、心跳等待等，但是也存在一些差异：</p>
<ul>
<li>共同点：
<ul>
<li>都支持服务注册和服务拉取。</li>
<li>都支持服务提供者心跳方式做健康检测。</li>
</ul>
</li>
<li>不同点：
<ul>
<li>
<p>Nacos支持服务端主动检测提供者状态：</p>
<ul>
<li>临时实例采用心跳模式；</li>
<li>非临时实例采用主动检测模式。</li>
</ul>
<p>主动检测的弊端：会给服务器造成一定的压力。一般情况下使用临时实例的心跳模式即可。</p>
</li>
<li>
<p>在Nacos中，临时实例心跳不正常会被剔除，非临时实例则不会被剔除。</p>
</li>
<li>
<p>Nacos支持服务列表变更的消息推送模式，服务列表更新更加及时。</p>
</li>
<li>
<p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="配置管理" data-numberify>配置管理<a class="anchor ms-1" href="#配置管理"></a></h1>
<p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>
<p>在Nacos中，配置获取的步骤如下：</p>
<ol>
<li>项目启动。</li>
<li>读取Nacos中的给服务定义的配置文件。</li>
<li>读取本地配置文件<code>application.yml</code>。与上一步在Nacos中读取到的配置相合并。</li>
<li>创建Spring容器。</li>
<li>加载Bean</li>
</ol>
<p>依赖<code>pom.xml</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- Nacos配置管理依赖 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>新建配置文件<code>bootstrap.yml</code>，进行如下配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">service-name</span><span class="w"> </span><span class="c"># 服务名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">profiles</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">active</span><span class="p">:</span><span class="w"> </span><span class="l">env-name</span><span class="w"> </span><span class="c"># 环境名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w"> </span><span class="c"># Nacos 配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">file-extension</span><span class="p">:</span><span class="w"> </span><span class="l">yml</span><span class="w"> </span><span class="c"># 配置文件后缀名</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>依赖和配置在需要配置管理的服务中添加和修改。</p>
<p>在<code>bootstrap.yml</code>中已经配置过的配置，在<code>application.yml</code>中可以不用重复配置。</p>
</blockquote>
<p>在Nacos控制台中添加配置文件：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/image-20210714164742924.png" loading="lazy" width="1466" height="600" />
</picture>

</p>
<p>对新添加的配置文件进行编辑，编辑完成好后点击发布进行提交：</p>
<p><picture><img class="img-fluid " alt="" src="/docs/spring/springcloud/nacos/uTools_1689498771620.png" loading="lazy" width="872" height="771" />
</picture>

</p>
<h2 id="多环境配置共享" data-numberify>多环境配置共享<a class="anchor ms-1" href="#多环境配置共享"></a></h2>
<p>微服务启动时会从Nacos中读取多个配置文件：</p>
<ul>
<li><code>[service-name]-[env-name].[file-extension]</code>：<strong>当前环境配置</strong>。只能在对应环境的情况下进行读取。</li>
<li><code>[service-name].[file-extension]</code>：<strong>共享环境配置</strong>。无论当前实例处于什么环境下，该文件一定会被加载。所以多环境共享配置可以写在这个文件中。</li>
</ul>
<blockquote>
<p><code>[file-extension]</code>为配置中对应的文件扩展名。</p>
</blockquote>
<h2 id="读取配置" data-numberify>读取配置<a class="anchor ms-1" href="#读取配置"></a></h2>
<ul>
<li>
<p>使用<code>@RefreshScope</code>注解进行配置自动刷新：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RefreshScope</span>   <span class="c1">// 配置自动刷新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${pattern.dateformat}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">dateformat</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 返回当前按照规定格式进行格式化的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/now&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">now</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">format</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">dateformat</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>使用<code>@ConfigurationProperties</code>注解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Data</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 读取以pattern为开头的配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">&#34;pattern&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PatternProperties</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">dateformat</span><span class="o">;</span>  <span class="c1">// 相当于 pattern.dateformat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">PatternProperties</span> <span class="n">properties</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/now&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">now</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">format</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="n">properties</span><span class="o">.</span><span class="na">getDateformat</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>使用<code>@ConfigurationProperties</code>注解将配置读取到类中，在配置更改的时候，类将会自动更新，而无需使用<code>@RefreshScope</code>注解。</p>
</li>
</ul>
<h2 id="配置文件优先级" data-numberify>配置文件优先级<a class="anchor ms-1" href="#配置文件优先级"></a></h2>
<p>Nacos中多种配置文件的优先级从高到低的顺序如下：</p>
<ol>
<li><code>[service-name]-[env-name].yml</code></li>
<li><code>[service-name].yml</code></li>
<li>本地配置文件（如<code>application.yml</code>，本地配置文件也有自己的优先级）</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>RestTemplate</title>
      <link>/docs/spring/springcloud/remote-call/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/remote-call/</guid>
      <description><![CDATA[微服务远程调用 在微服务架构中，不同微服务都应该有自己独立的数据库以减少服务之间的冗余。而不同的服务之间可能需要共享数据。但拆分后的服务，它们]]></description>
      <content:encoded><![CDATA[<h1 id="微服务远程调用" data-numberify>微服务远程调用<a class="anchor ms-1" href="#微服务远程调用"></a></h1>
<p>在微服务架构中，不同微服务都应该有自己独立的数据库以减少服务之间的冗余。而不同的服务之间可能需要共享数据。但拆分后的服务，它们的数据库是相互独立的，一个服务不可能去调用另一个服务的数据库，所以服务之间的信息共享成为一个问题。</p>
<p>为了解决服务之间的信息共享，微服务通过将业务暴露为接口，以供其它微服务使用。这种服务调用方式与用户调用服务的方式是相同的，都是通过URL来远程调用接口。</p>
<p>在微服务远程调用中，有一下两种角色：</p>
<ul>
<li>
<p>服务<strong>提供者</strong>（Provider）：一次业务中，被其它微服务调用的服务。</p>
<p>即提供接口给其它微服务的服务。</p>
</li>
<li>
<p>服务<strong>消费者</strong>（Consumer）：一次业务中，调用其它微服务的服务。</p>
<p>即调用其它微服务提供的接口的服务。</p>
</li>
</ul>
<p>服务的角色是相对而言的。抛开业务来讲，服务既可以是提供者也可以消费者。</p>
<hr>
<h1 id="resttemplate-远程调用" data-numberify>RestTemplate 远程调用<a class="anchor ms-1" href="#resttemplate-远程调用"></a></h1>
<p>在SpringCloud中，微服务的远程调用方式可以通过<code>RestTemplate</code>发起HTTP请求来调用。而HTTP请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。</p>
<p>例如有两个服务，分别是用户服务和订单服务，订单服务在获取订单信息时需要将用户信息一同发送：</p>
<ol>
<li>
<p>使用<code>RestTemplate</code>需要先进行注册（配置）。</p>
<p>在订单服务模块（消费者）中新建一个配置并声明一个Bean：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 创建RestTemplate，并注入Spring容器
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">getRestTemplate</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>OrderService</code>中注入<code>RestTemplate</code>，并通过<code>RestTemplate</code>远程调用用户服务模块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注入RestTemplate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Order</span> <span class="nf">queryOrderById</span><span class="o">(</span><span class="n">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.查询订单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.利用RestTemplate发起HTTP请求，查询用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2.1.URL路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;http://localhost:8081/user/&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getUserId</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.2.发送HTTP（GET）请求，实现远程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.封装User到Order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">order</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>RestTemplate.getForObject()</code>是<code>RestTemplate</code>调用HTTP-GET请求的方法，该方法接收一个字符串类型的URL参数，并可以通过<code>.class</code>来指定响应的类型。</p>
<p>用户服务模块中相应的接口如下（假设服务的端口为本地<code>8081</code>端口）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&#34;/user&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">UserService</span> <span class="n">userService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 根据用户ID获取用户信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param id 用户ID
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 用户信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/{id}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">User</span> <span class="nf">queryById</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">userService</span><span class="o">.</span><span class="na">queryById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ol>
<p>使用<code>RestTemplate</code>存在以下问题：</p>
<ul>
<li>URL的硬编码问题。</li>
<li>服务消费者该如何获取服务提供者的地址信息。</li>
<li>如果有多个服务提供者，消费者该如何选择。</li>
<li>消费者如何得知服务提供者的健康状态。</li>
</ul>
<blockquote>
<p><code>RestTemplate</code>是Spring Cloud自带的，所以不用引入依赖。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Spring 环境和配置</title>
      <link>/docs/spring/springcloud/config/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/config/</guid>
      <description><![CDATA[微服务需要根据业务模块拆分，做到单一职责，不要重复开发相同业务。 父工程 微服务是一种分布式开发，要将一个项目拆分为若干个服务，所以会有很多个服]]></description>
      <content:encoded><![CDATA[<p>微服务需要根据业务模块拆分，做到单一职责，不要重复开发相同业务。</p>
<h1 id="父工程" data-numberify>父工程<a class="anchor ms-1" href="#父工程"></a></h1>
<p>微服务是一种分布式开发，要将一个项目拆分为若干个服务，所以会有很多个服务模块。而要统一管理这些服务模块，可以创建一个父工程来管理。</p>
<p>在Maven中，用来统一管理的父工程是一个不包含实际代码，只含有<code>pom.xml</code>的模块。通过在<code>pom.xml</code>定义一些统一的信息（如依赖、依赖的版本等等），从而来管理整个工程。</p>
<p>父工程Maven依赖（<code>pom.xml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 声明子模块 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;module&gt;</span>user-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;module&gt;</span>order-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/modules&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 打包方式 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 父工程 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>2.3.9.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;relativePath/&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;project.reporting.outputEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.reporting.outputEncoding&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;spring-cloud.version&gt;</span>Hoxton.SR10<span class="nt">&lt;/spring-cloud.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;mysql.version&gt;</span>5.1.47<span class="nt">&lt;/mysql.version&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;mybatis.version&gt;</span>2.1.1<span class="nt">&lt;/mybatis.version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 声明依赖，并不进行导入（子模块依然需要导入，但不用指定版面） --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- SpringCloud依赖库 --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- MySQL驱动 --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${mysql.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- MyBatis --&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.mybatis.spring.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>mybatis-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;version&gt;</span>${mybatis.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.projectlombok<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>lombok<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中主要的有：</p>
<ul>
<li>
<p>父工程：和SpringBoot一样，使用SpringCloud需要导入父工程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- 父工程 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.3.9.RELEASE<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;relativePath/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span></code></pre></div></li>
<li>
<p>SpringCloud依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- SpringCloud依赖库 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>声明在<code>&lt;dependencyManagement&gt;</code>的<code>&lt;dependencies&gt;</code>中。SpringCloud依赖库定义了SpringCloud的依赖以及它们的版本。</p>
<blockquote>
<p><code>&lt;dependencyManagement&gt;</code>是对整个项目的依赖版本的管理。在<code>&lt;dependencyManagement&gt;</code>元素中声明所依赖的jar包的版本号等信息，那么所有子项目再次引入此依赖jar包时则无需显式的列出版本号，Maven会沿着父子层级向上寻找拥有<code>&lt;dependencyManagement&gt;</code>元素的项目，然后使用它指定的版本号。</p>
<p>例如在SpringBoot中，引入了父工程<code>spring-boot-starter-parent</code>，那么引入<code>spring-boot-starter-web</code>这些在父工程中已经将版本定义好了的依赖，就无需在当前工程的<code>pom.xml</code>中指定版本。</p>
<p>在当前<code>&lt;dependencies&gt;</code>（不是<code>&lt;dependencyManagement&gt;</code>下的<code>&lt;dependencies&gt;</code>中声明的依赖，会直接被导入，并且被子子项目所继承。</p>
</blockquote>
</li>
<li>
<p><code>&lt;modules&gt;</code>：利用<code>&lt;modules&gt;</code>可以很好地进行多模块开发。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- 声明模块 --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;module&gt;</span>user-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;module&gt;</span>order-service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- ... --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/modules&gt;</span>
</span></span></code></pre></div><p>在构建当前项目时，Maven会根据<code>&lt;modules&gt;</code>中的声明，去寻找相应的模块并自动完成构建。</p>
<p><code>&lt;modules&gt;</code>的值是对应模块的<code>&lt;artifactId&gt;</code>的值。</p>
</li>
</ul>
<h1 id="微服务拆分" data-numberify>微服务拆分<a class="anchor ms-1" href="#微服务拆分"></a></h1>
<p>子模块Maven依赖示例（<code>pom.xml</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&lt;!-- 与父工程中所定义的相对应 --&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>user-service<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- MySQL --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!-- MyBatis --&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;groupId&gt;</span>org.mybatis.spring.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;artifactId&gt;</span>mybatis-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;build&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;finalName&gt;</span>app<span class="nt">&lt;/finalName&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;plugins&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&lt;/plugin&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;/plugins&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/build&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/project&gt;</span>
</span></span></code></pre></div><p>其中，该项目的父工程为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>asia.linner.demo<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>cloud-demo<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span></code></pre></div><p>模块声明的父工程对应父工程中定义的<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>和<code>&lt;version&gt;</code>。当前项目会继承父工程中定义的版本号和依赖。所以<code>spring-boot-starter-web</code>、<code>mysql-connector-java</code>和<code>mybatis-spring-boot-starter</code>都无需显式地声明版本。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>微服务简介</title>
      <link>/docs/spring/springcloud/introduction/</link>
      <pubDate>Mon, 26 Jun 2023 11:46:12 +0800</pubDate>
      
      <guid>/docs/spring/springcloud/introduction/</guid>
      <description><![CDATA[微服务架构 从前的项目是使用单体架构，单体架构是指将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优点是： 架构简单； 部署成本低]]></description>
      <content:encoded><![CDATA[<h1 id="微服务架构" data-numberify>微服务架构<a class="anchor ms-1" href="#微服务架构"></a></h1>
<p>从前的项目是使用单体架构，单体架构是指<u>将业务的所有功能集中在一个项目中开发，打成一个包部署</u>。</p>
<p>单体架构的优点是：</p>
<ul>
<li>架构简单；</li>
<li>部署成本低。</li>
</ul>
<p>缺点是模块之间的耦合度高，不利于大型项目开发。</p>
<p>随着互联网行业的发展，服务架构从单体架构逐渐演变为现在流行的微服务架构（属于分布式架构的一种）。</p>
<p><picture><img class="img-fluid " alt="微服务架构" src="/docs/spring/springcloud/introduction/uTools_1687757195463.png" loading="lazy" width="624" height="544" />
</picture>

</p>
<p>分布式架构是指<u>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务</u>。</p>
<p>分布式架构的优点：</p>
<ul>
<li>降低服务之间的耦合；</li>
<li>有利于服务升级拓展。</li>
</ul>
<p>微服务是一种经过良好架构设计的分布式架构方案。</p>
<p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责。</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付。</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关。</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。</li>
</ul>
<p>微服务按照服务的不同将项目分为不同的项目，每个项目运行一个服务。</p>
<p>例如，将用户服务和订单服务分为两个项目。</p>
<h1 id="微服务技术栈" data-numberify>微服务技术栈<a class="anchor ms-1" href="#微服务技术栈"></a></h1>
<p>微服务技术栈包括：</p>
<ul>
<li>微服务技术</li>
<li>异步通讯技术</li>
<li>缓存技术</li>
<li>DevOps</li>
<li>搜索技术</li>
</ul>
<h1 id="微服务技术" data-numberify>微服务技术<a class="anchor ms-1" href="#微服务技术"></a></h1>
<blockquote>
<p>在国内知名的微服务落地技术有SpringCloud和阿里的Dubbo。</p>
</blockquote>
<p>常见微服务技术的对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><br></th>
<th style="text-align:center">Dubbo</th>
<th style="text-align:center">SpringCloud</th>
<th style="text-align:left">SpringCloudAlibaba</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">注册中心</td>
<td style="text-align:center"><code>Zookeeper</code>、<code>Redis</code></td>
<td style="text-align:center">Eureka、Consul</td>
<td style="text-align:left">Nacos、Eureka</td>
</tr>
<tr>
<td style="text-align:center">服务远程调用</td>
<td style="text-align:center">Dubbo协议</td>
<td style="text-align:center">Feign（HTTP协议）</td>
<td style="text-align:left">Dubbo、Feign</td>
</tr>
<tr>
<td style="text-align:center">配置中心</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SpringCloudConfig</td>
<td style="text-align:left">SpringCloudConfig、Nacos</td>
</tr>
<tr>
<td style="text-align:center">服务网关</td>
<td style="text-align:center">无</td>
<td style="text-align:center">SpringCloudGateway、Zuul</td>
<td style="text-align:left">SpringCloudGateway、Zuul</td>
</tr>
<tr>
<td style="text-align:center">服务监控和保护</td>
<td style="text-align:center">dubbo-admin（功能弱）</td>
<td style="text-align:center">Hystix</td>
<td style="text-align:left">Sentinel</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud 官网<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配。而SpringCloud与SpringBoot的之间的版本存在一个兼容关系，可通过官网的说明文档查看。</p>
</blockquote>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

