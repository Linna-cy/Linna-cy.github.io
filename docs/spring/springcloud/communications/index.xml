<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>异步通讯 on Linner&#39;s Blog</title>
    <link>/docs/spring/springcloud/communications/</link>
    <description>Recent content in 异步通讯 on Linner&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2024 Linner. All Rights Reserved.
</copyright>
    <lastBuildDate>Fri, 04 Aug 2023 08:40:11 +0000</lastBuildDate><atom:link href="/docs/spring/springcloud/communications/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring AMQP</title>
      <link>/docs/spring/springcloud/communications/spring-amqp/</link>
      <pubDate>Fri, 04 Aug 2023 08:40:11 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/spring-amqp/</guid>
      <description><![CDATA[AMQP（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要]]></description>
      <content:encoded><![CDATA[<p>AMQP（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p>
<p>RabbitMQ实现了AMQP协议。<a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">Spring AMQP<i class="fas fa-external-link-square-alt ms-1"></i></a>是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中<code>spring-amqp</code>是基础抽象，<code>spring-rabbit</code>是底层的默认实现。</p>
<p>Spring AMQP的依赖如下，其中包含了RabbitMQ的依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- AMQP依赖，包含RabbitMQ --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-amqp<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>在Spring中使用RabbitMQ可以使用Spring AMQP的依赖。对于RabbitMQ来说，Publisher和Consumer都是使用这个依赖，所以这个依赖坐标可以放在它们的父工程中。</p>
<p>导入依赖后，需要先编写<code>application.yml</code>，添加RabbitMQ连接信息（Publisher和Consumer都需要编写此配置）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">rabbitmq</span><span class="p">:</span><span class="w">   </span><span class="c"># RabbitMQ配置信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">localhost  </span><span class="w"> </span><span class="c"># 主机地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5672</span><span class="w">        </span><span class="c"># 端口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">virtual-host</span><span class="p">:</span><span class="w"> </span><span class="l">/  </span><span class="w"> </span><span class="c"># 虚拟主机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">linner </span><span class="w"> </span><span class="c"># 用户名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="m">123456</span><span class="w">  </span><span class="c"># 密码</span><span class="w">
</span></span></span></code></pre></div><p>RabbitMQ官方文档中给出了5个Demo，它们分别对应几种不同的用法：</p>
<ul>
<li>
<p>基本消息队列（Basic Queue）：</p>
<p><picture><img class="img-fluid " alt="Basic Queue" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691056818833.png" loading="lazy" width="286" height="158" />
</picture>

</p>
</li>
<li>
<p>工作消息队列（Work Queue）：</p>
<p><picture><img class="img-fluid " alt="Work Queue" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691056877775.png" loading="lazy" width="258" height="231" />
</picture>

</p>
</li>
<li>
<p>发布与订阅（Publish/Subscribe）。</p>
<p>根据交换机类型的不同，可分为三种：</p>
<ul>
<li>
<p>Fanout Exchange（广播）：</p>
<p><picture><img class="img-fluid " alt="Fanout Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057092864.png" loading="lazy" width="272" height="182" />
</picture>

</p>
</li>
<li>
<p>Direct Exchange（路由，Routing）：</p>
<p><picture><img class="img-fluid " alt="Direct Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057130360.png" loading="lazy" width="262" height="212" />
</picture>

</p>
</li>
<li>
<p>Topic Exchange（主题）：</p>
<p><picture><img class="img-fluid " alt="Topic Exchange" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691057168656.png" loading="lazy" width="276" height="209" />
</picture>

</p>
</li>
</ul>
</li>
</ul>
<p>接下来分别按照这5个模型来实现。</p>
<hr>
<h1 id="基本消息队列" data-numberify>基本消息队列<a class="anchor ms-1" href="#基本消息队列"></a></h1>
<p>基本消息队列模型只包含三种角色：</p>
<ul>
<li><strong>Publisher</strong>：消息发布者，将消息发送到队列Queue。</li>
<li><strong>Queue</strong>：消息队列，负责接受并缓存消息。</li>
<li><strong>Consumer</strong>：订阅队列，处理队列中的消息。</li>
</ul>
<p>Spring AMQP通过RabbitMQ提供的AMQP接口，整合了RabbitMQ，让RabbitMQ使用起来更加方便。</p>
<p>Spring AMQP提供了<code>RabbitTemplate</code>来给RabbitMQ发送消息，在使用之时直接<code>@Autowired</code>即可。</p>
<p>在<code>Publisher</code>模块中新建一个<code>SpringAmqpTest</code>测试类，然后使用<code>RabbitTemplate</code>发送消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSimpleQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello Spring AMQP!&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>将以上代码放在业务代码中即可实现异步通讯。</p>
<p>在<code>Consumer</code>中新建一个<code>listener</code>包，并且在包中创建<code>SpringRabbitListener</code>，然后使用<code>@RabbitListener</code>定义接收消息的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;simple.queue&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenSimpleQueue</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>直接启动<code>Consumer</code>的启动类即可开始接收消息。</p>
<blockquote>
<p>注：<code>@RabbitListener</code>的<code>queues</code>属性没有创建消息队列的能力。如果先启动<code>Consumer</code>报错<code>Failed to declare queue: simple.queue</code>，可以创建一个<code>RabbitConfig</code>，然后在<code>RabbitConfig</code>中创建队列；或者直接在启动类中创建队列。</p>
<p>在<code>Consumer</code>中创建<code>simple.queue</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getSimpleQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="s">&#34;simple.queue&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>另外还需要注意，导入的<code>Queue</code>是<code>org.springframework.amqp.core</code>包下的。</p>
</blockquote>
<hr>
<h1 id="工作队列模型" data-numberify>工作队列模型<a class="anchor ms-1" href="#工作队列模型"></a></h1>
<p>修改<code>Publisher</code>，模拟每秒钟发送50条消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testWorkQueue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;work.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello Message__&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">50</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">20</span><span class="o">);</span>   <span class="c1">// 休眠 20ms，1s == 1000ms，所以1s最多只能发50条
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>修改<code>Consumer</code>，模拟两个消费者共同接收<code>work.queue</code>的消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@Queue</span><span class="o">(</span><span class="n">WORK_QUEUE</span><span class="o">)})</span> <span class="c1">// 声明并订阅Queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenWorkQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&#34;消费者 1 收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>   <span class="c1">// 用不同的日志级别区分消费者1和消费者2，更易于阅读
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">20</span><span class="o">);</span>   <span class="c1">// 处理速度约：50条/s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@Queue</span><span class="o">(</span><span class="n">WORK_QUEUE</span><span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenWorkQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;消费者 2 收到消息：[&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">200</span><span class="o">);</span>  <span class="c1">// 处理速度约：5条/s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>@RabbitListener</code>的<code>queuesToDeclare</code>属性是<code>@Queue</code>类型数组。<code>queuesToDeclare</code>在指定多个队列的同时，会去声明它们，这样就能不通过创建Bean来声明它们。</p>
<p>先启动<code>Consumer</code>，然后在启动<code>Publisher</code>，发现消息被两个消费者平分处理了（一个消费者处理单数号消息，另一个处理双数号消息），并没有按照各自处理速度去分配。这是因为消费者存在消费预取。无论在规定时间内是否能处理得完，消费者都会按照配置去自动预取。所以就导致了两个消费者各取一半消息去处理。</p>
<p>要解决这个消费预取限制，让消费者能根据自己的能力预取消息，可以在<code>application.yml</code>中修改<code>spring.rebbitmq.listener.simple.prefetch</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">rabbitmq</span><span class="p">:</span><span class="w">   </span><span class="c"># RabbitMQ配置信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">##### 连接信息... #####</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">listener</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">simple</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">prefetch</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c"># 每次只能预取 1 条消息，处理完才能获取下一条</span><span class="w">
</span></span></span></code></pre></div><p>然后按照上方，先启动（或重启）<code>Consumer</code>，然后在启动<code>Publisher</code>，观察控制台打印的日志可以发现这次处理完50条消息的时间大约为1秒。</p>
<p>工作队列模式的特点是：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理。</li>
<li>通过设置Prefetch来控制消费者预取的消息数量。</li>
</ul>
<hr>
<h1 id="发布订阅模型" data-numberify>发布/订阅模型<a class="anchor ms-1" href="#发布订阅模型"></a></h1>
<p>发布/订阅模式通过Exchange（交换机）方式实现了将同一消息发送给多个消费者。</p>
<p>发布/订阅的模型如图：</p>
<p><picture><img class="img-fluid " alt="发布/订阅模型" src="/docs/spring/springcloud/communications/spring-amqp/image-20210717165309625.png" loading="lazy" width="1431" height="462" />
</picture>

</p>
<p>模型中多了Exchange角色，并且过程略有变化：</p>
<ul>
<li><strong>Publisher</strong>（生产者）：值要发送消息的程序，但是不再发送到队列中，而是发给Exchange（交换机）。</li>
<li><strong>Exchange</strong>（交换机）：一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。
<ul>
<li>Topic：</li>
</ul>
</li>
<li><strong>Consumer</strong>（消费者）：订阅队列，处理队列中的消息。。</li>
<li><strong>Queue</strong>：接收消息、缓存消息。</li>
</ul>
<blockquote>
<p>注：Exchange负责消息路由，而不是存储，路由失败则消息丢失。</p>
</blockquote>
<p>常见Exchange类型包括：</p>
<ul>
<li>Fanout（扇出）：广播，将消息交给所有绑定到交换机的队列。</li>
<li>Direct（定向）：路由，把消息交给符合指定Routing Key的队列。</li>
<li>Topic（话题）：通配符，把消息交给符合Routing Pattern（路由模式）的队列。</li>
</ul>
<p>Spring AMQP提供了声明交换机、队列、绑定关系的API，声明交换机API的继承关系图如下：</p>
<p><picture><img class="img-fluid " alt="交换机API继承关系图" src="/docs/spring/springcloud/communications/spring-amqp/1691157574294.png" loading="lazy" width="1212" height="410" />
</picture>

</p>
<h2 id="fanout-exchange" data-numberify>Fanout Exchange<a class="anchor ms-1" href="#fanout-exchange"></a></h2>
<p>Fanout Exchange会将接收到的消息路由到每一个跟其绑定的Queue。声明队列、声明交换机和绑定关系都要在Consumer中完成。</p>
<p>在<code>Consumer</code>中添加新的配置类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FanoutConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.fanout&#34;</span><span class="o">;</span>   <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_QUEUE_1</span> <span class="o">=</span> <span class="s">&#34;fanout.queue1&#34;</span><span class="o">;</span>    <span class="c1">// 队列1名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_QUEUE_2</span> <span class="o">=</span> <span class="s">&#34;fanout.queue2&#34;</span><span class="o">;</span>    <span class="c1">// 队列2名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 声明FanoutExchange交换机
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">FanoutExchange</span> <span class="nf">getFanoutExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">FanoutExchange</span><span class="o">(</span><span class="n">FANOUT_EXCHANGE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 声明第1个队列
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="s">&#34;fanoutQueue1&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getFanoutQueue1</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">FANOUT_QUEUE_1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 绑定队列1和交换机
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Binding</span> <span class="nf">bindingQueue1</span><span class="o">(</span><span class="n">Queue</span> <span class="n">fanoutQueue1</span><span class="o">,</span> <span class="n">FanoutExchange</span> <span class="n">fanoutExchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BindingBuilder</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">fanoutQueue1</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="n">fanoutExchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span><span class="o">(</span><span class="s">&#34;fanoutQueue2&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getFanoutQueue2</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">FANOUT_QUEUE_2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Binding</span> <span class="nf">bindingQueue2</span><span class="o">(</span><span class="n">Queue</span> <span class="n">fanoutQueue2</span><span class="o">,</span> <span class="n">FanoutExchange</span> <span class="n">fanoutExchange</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">BindingBuilder</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">fanoutQueue2</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="n">fanoutExchange</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 第3个队列以相同方式声明，并绑定... */</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后修改<code>Consumer</code>的<code>SpringRabbitListener</code>类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_1</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenFanoutQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_1</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queues</span> <span class="o">=</span> <span class="o">{</span><span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_2</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenFanoutQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">FanoutConfig</span><span class="o">.</span><span class="na">FANOUT_QUEUE_2</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>修改<code>Publisher</code>，添加新的测试方法模拟发送消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FANOUT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.fanout&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendFanoutExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello everyone!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">FANOUT_EXCHANGE</span><span class="o">,</span> <span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先运行<code>Consumer</code>，然后再运行<code>Publisher</code>的<code>testSendFanoutExchange()</code>测试方法发送消息，在<code>Consumer</code>的终端可以发现，两个消费者都接收到消息了。</p>
<p><code>RabbitTemplate</code>的<code>convertAndSend()</code>方法有不同的实现，可以向队列发送消息，也可以向交换机发送。</p>
<p>Fanout Exchange的特点：</p>
<ul>
<li>可以有多个队列；</li>
<li>每个队列都要绑定到Exchange；</li>
<li>生产者发送的消息，只能发送到Exchange，由Exchange决定发给哪个队列，生产者无法决定（也不知道）；</li>
<li>交换机把消息发送给绑定过的所有队列；</li>
<li>订阅队列的消费者都能拿到消息。</li>
</ul>
<p>Fanout Exchange的作用：</p>
<ul>
<li>接收Publisher发送的消息；</li>
<li>将消息按照规则路由到与之绑定的队列，Fanout Exchange的会将消息路由到每个绑定的队列；</li>
<li>不能缓存消息，路由失败，消息丢失。</li>
</ul>
<h2 id="direct-exchange" data-numberify>Direct Exchange<a class="anchor ms-1" href="#direct-exchange"></a></h2>
<p>Direct Exchange通过Binding Key（绑定密钥）和Routing Key（路由密钥）将消息路由到不同的队列上。</p>
<p>在Direct Exchange模式下，队列在声明时可以指定一个或多个Binding Key；Publisher在向Exchange发送消息时，通过指定Routing Key，告诉Exchange要将消息发送到哪个队列上。</p>
<p>在<code>Consumer</code>中添加新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_EXCHANGE_NAME</span> <span class="o">=</span> <span class="s">&#34;linner.direct&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_QUEUE_1_NAME</span> <span class="o">=</span> <span class="s">&#34;direct.queue1&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_QUEUE_2_NAME</span> <span class="o">=</span> <span class="s">&#34;direct.queue2&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@QueueBinding</span><span class="o">(</span>   <span class="c1">// 设置绑定关系，绑定队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">DIRECT_QUEUE_1_NAME</span><span class="o">),</span>    <span class="c1">// 设置绑定的队列（会自动创建队列）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">DIRECT_EXCHANGE_NAME</span><span class="o">,</span>   <span class="c1">// 设置绑定的交换机（会自动创建交换机）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">DIRECT</span> <span class="cm">/* 设置交换机类型，默认为Direct */</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;red&#34;</span><span class="o">,</span> <span class="s">&#34;blue&#34;</span><span class="o">}</span>   <span class="c1">// Binding Keys，可以指定多个，当
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenDirectQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">DIRECT_QUEUE_1_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">DIRECT_QUEUE_2_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">DIRECT_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">DIRECT</span> <span class="cm">/* 默认 */</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;red&#34;</span><span class="o">,</span> <span class="s">&#34;yellow&#34;</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">)})</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenDirectQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">DIRECT_QUEUE_2_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>@RabbitListener</code>的<code>bindings</code>属性提供了简便的绑定方式。<code>bindings</code>属性是<code>@QueueBinding</code>类型数组，可以同时有多个绑定。其中的每个绑定使用<code>@QueueBinding</code>来定义。</p>
<p><code>@QueueBinding</code>通常需要设置的属性有以下三个：</p>
<ul>
<li><code>value</code>：指明绑定的队列，类型为<code>@Queue</code>。通过使用<code>@Queue</code>来声明并订阅队列。</li>
<li><code>exchange</code>：指明绑定的交换机，类型为<code>@Exchange</code>。通过使用<code>@Exchange</code>，可以指定交换机的名称和类型。交换机类型可以使用<code>ExchangeTypes</code>下的字符串常量。</li>
<li><code>key</code>：指明Binding Key(s)，是一个字符串数组类型。</li>
</ul>
<p>在<code>Publisher</code>中添加新的<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIRECT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.direct&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendDirectExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">routingKey</span> <span class="o">=</span> <span class="s">&#34;red&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello direct exchange &#34;</span> <span class="o">+</span> <span class="n">routingKey</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息（发送消息时需要指定Routing Key）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">DIRECT_EXCHANGE</span><span class="o">,</span> <span class="n">routingKey</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先启动<code>Consumer</code>，然后再启动<code>Publisher</code>的<code>testSendDirectExchange()</code>方法来进行测试。你可以通过将<code>routingKey</code>修改为<code>blue</code>或<code>yellow</code>来测试其它路由密钥。</p>
<p>Direct Exchange的规则是这样的：</p>
<ul>
<li>Queue绑定一个或多个Binding Key(s)到Exchange。</li>
<li>Publisher在给Exchange发送消息时，指定Routing Key。</li>
<li>Exchange收到消息，并且根据Publisher指定的Routing Key去匹配对应的Queue(s)。当Exchange发现有Queue(s)的Binding Keys中，有与Publisher指定的Routing Key对应的Key时，就将消息发送给对应的Queue(s)。</li>
</ul>
<blockquote>
<p>注：如果在Direct Exchange模式下使用Fanout Exchange的方式发送消息（即<code>rabbitTemplate.convertAndSend(DIRECT_EXCHANGE, &quot;&quot;, message);</code>），那么是不会有任何一个队列接收到此消息的。除非在绑定队列时，设置了这样一个Key：<code>key = {&quot;&quot;}</code>。Direct Exchange模式将<code>&quot;&quot;</code>识别为一个Key。</p>
</blockquote>
<h2 id="topic-exchange" data-numberify>Topic Exchange<a class="anchor ms-1" href="#topic-exchange"></a></h2>
<p>Topic Exchange模式与Direct Exchange模式类似，区别在于Topic Exchange下的Routing Key必须是个多个单词的列表，并且以<code>.</code>分割。</p>
<p>例如：</p>
<ul>
<li><code>china.news</code>：代表有中国的新闻消息；</li>
<li><code>china.weather</code>：代表中国的天气消息。</li>
</ul>
<p>Topic Exchange模式中，Queue与Exchange指定Binding Key时可以使用通配符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">通配符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>#</code></td>
<td style="text-align:left">代指0个或多个单词。</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">代指1个单词。</td>
</tr>
</tbody>
</table>
<p>在<code>Consumer</code>中添加新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_EXCHANGE_NAME</span> <span class="o">=</span> <span class="s">&#34;linner.topic&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_QUEUE_1_NAME</span> <span class="o">=</span> <span class="s">&#34;topic.queue1&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_QUEUE_2_NAME</span> <span class="o">=</span> <span class="s">&#34;topic.queue2&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">TOPIC_QUEUE_1_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">name</span> <span class="o">=</span> <span class="n">TOPIC_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">TOPIC</span>  <span class="c1">// 设置交换机类型为Topic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;china.#&#34;</span>                     <span class="c1">// 设置包含通配符的Binding Key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenTopicQueue1</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">TOPIC_QUEUE_1_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">bindings</span> <span class="o">=</span> <span class="nd">@QueueBinding</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">value</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">TOPIC_QUEUE_2_NAME</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">exchange</span> <span class="o">=</span> <span class="nd">@Exchange</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">name</span> <span class="o">=</span> <span class="n">TOPIC_EXCHANGE_NAME</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">type</span> <span class="o">=</span> <span class="n">ExchangeTypes</span><span class="o">.</span><span class="na">TOPIC</span>
</span></span><span class="line"><span class="cl">            <span class="o">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;#.news&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenTopicQueue2</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">TOPIC_QUEUE_2_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: [&#34;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在<code>Publisher</code>中添加新的<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TOPIC_EXCHANGE</span> <span class="o">=</span> <span class="s">&#34;linner.topic&#34;</span><span class="o">;</span>  <span class="c1">// 交换机名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendTopicExchange</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">routingKey</span> <span class="o">=</span> <span class="s">&#34;china.news&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello &#34;</span> <span class="o">+</span> <span class="n">TOPIC_EXCHANGE</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">routingKey</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span><span class="o">;</span> <span class="c1">// 消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">TOPIC_EXCHANGE</span><span class="o">,</span> <span class="n">routingKey</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;发送消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>同样是以先启动<code>Consumer</code>，再启动<code>Publisher</code>的方式进行测试，然后再通过修改<code>routingKey</code>来测试不同的匹配规则。</p>
<hr>
<h1 id="消息转换器" data-numberify>消息转换器<a class="anchor ms-1" href="#消息转换器"></a></h1>
<p>在Spring AMOP中，发送消息的<code>RabbitTemplate.convertAndSend()</code>方法，其实发送的是<code>Object</code>类型。在发送消息时，Spring AMOP会将发送的消息序列化为字节发送给RabbitMQ；接收消息的时候，还会把字节反序列化为Java对象。也就是说，通讯过程传输的消息可以是任意类型的对象。</p>
<h2 id="默认序列化方式" data-numberify>默认序列化方式<a class="anchor ms-1" href="#默认序列化方式"></a></h2>
<p>默认情况下Spring AMOP采用的序列化方式是JDK序列化。</p>
<p>在<code>Consumer</code>的<code>RabbitConfig</code>中，添加一个新的队列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Queue</span> <span class="nf">getObjectQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>然后启动<code>Consumer</code>（这是为了展示Spring AMQP默认序列化方式在RabbitMQ中的序列化结果，所以先不在<code>Consumer</code>中接收消息）。</p>
<p>接着在<code>Publisher</code>中创建<code>testSend</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RunWith</span><span class="o">(</span><span class="n">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@SpringBootTest</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAmqpTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">RabbitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendObjectQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="n">msg</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;Linner&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">msg</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>  <span class="c1">// 发送一个Map对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>启动测试方法，在RabbitMQ管理页面可以看到<code>object.queue</code>中存在这样一条消息：</p>
<p><picture><img class="img-fluid " alt="Spring AMOP 默认序列化结果" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691229847478.png" loading="lazy" width="1146" height="291" />
</picture>

</p>
<p>可以发现JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大；</li>
<li>有安全漏洞；</li>
<li>可读性差。</li>
</ul>
<h2 id="自定义序列化方式" data-numberify>自定义序列化方式<a class="anchor ms-1" href="#自定义序列化方式"></a></h2>
<p>JSON是一种很好的序列化方式，我们可以将Spring AMQP默认的JDK序列化改成Jackson。</p>
<p>首先导入依赖，由于序列化后还需反序列化，所以<code>Publisher</code>和<code>Consumser</code>模块都需要导入Jackson依赖。我们可以将依赖导入它们的父工程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--Jackson核心依赖--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>2.9.10<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后分别在<code>Publisher</code>和<code>Consumser</code>中替换Spring AMQP默认序列化方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Configuration</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AmqpConfig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 自定义消息转换器
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Bean</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">MessageConverter</span> <span class="nf">getMessageConverter</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">Jackson2JsonMessageConverter</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>先运行<code>Publisher.testSendObjectQueue()</code>方法，观察Jackson是否有生效。运行结果如下：</p>
<p><picture><img class="img-fluid " alt="Jackson 序列化结果" src="/docs/spring/springcloud/communications/spring-amqp/uTools_1691230403117.png" loading="lazy" width="619" height="361" />
</picture>

</p>
<p>最后在<code>Consumser</code>中创建一个新的<code>listen</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Component</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringRabbitListener</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;object.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@RabbitListener</span><span class="o">(</span><span class="n">queuesToDeclare</span> <span class="o">=</span> <span class="nd">@Queue</span><span class="o">(</span><span class="n">OBJECT_QUEUE_NAME</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listenObjectQueue</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;消费者收到 [&#34;</span> <span class="o">+</span> <span class="n">OBJECT_QUEUE_NAME</span> <span class="o">+</span> <span class="s">&#34;] 的消息: &#34;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>重启<code>Consumser</code>，观察终端输出的日志，如果成功打印出Map对象，说明反序列化成功。</p>
<blockquote>
<p>注：自定义Spring AMQP序列化方式时，Publisher和Consumer配置的消息转换器都必须相同。就是说，序列化和反序列化一定要使用同个消息转换器。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>RabbitMQ</title>
      <link>/docs/spring/springcloud/communications/rabbit-mq/</link>
      <pubDate>Thu, 03 Aug 2023 08:10:45 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/rabbit-mq/</guid>
      <description><![CDATA[RabbitMQ官网：https://www.rabbitmq.com/。 官方文档：https://rabbitmq.com/documen]]></description>
      <content:encoded><![CDATA[<p>RabbitMQ官网：<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener noreferrer">https://www.rabbitmq.com/<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>官方文档：<a href="https://rabbitmq.com/documentation.html" target="_blank" rel="noopener noreferrer">https://rabbitmq.com/documentation.html<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<p>官方Demo：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">https://www.rabbitmq.com/getstarted.html<i class="fas fa-external-link-square-alt ms-1"></i></a>。</p>
<hr>
<h1 id="部署-rabbitmq" data-numberify>部署 RabbitMQ<a class="anchor ms-1" href="#部署-rabbitmq"></a></h1>
<p>使用Docker来部署RabbitMQ只需要两个步骤：</p>
<ol>
<li>
<p><code>pull</code> RabbitMQ镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker pull rabbitmq:3-management
</span></span></code></pre></div><p>RabbitMQ通过插件的方式提供了一个可视化界面。在RabbitMQ官方的镜像中，带<code>management</code>版本的就是集成了该可视化插件的镜像。</p>
<p>通过Docker官方的镜像源来<code>pull</code> RabbitMQ镜像可能会有点慢，可以使用一些国内的镜像源：</p>
<p>提供方          |镜像URL
中国区官方镜像  |<code>https://registry.docker-cn.com</code>
清华源          |<code>https://docker.mirrors.ustc.edu.cn</code>
阿里源          |<code>https://cr.console.aliyun.com</code>
腾讯源          |<code>https://mirror.ccs.tencentyun.com</code>
网易源          |<code>http://hub-mirror.c.163.com</code>
道客镜像站      |<code>http://f1361db2.m.daocloud.io</code></p>
</li>
<li>
<p>启动RabbitMQ容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">RABBITMQ_DEFAULT_USER</span><span class="o">=</span>linner <span class="se">\ </span>  <span class="c1"># RabbitMQ用户名（默认为guest）</span>
</span></span><span class="line"><span class="cl">    -e <span class="nv">RABBITMQ_DEFAULT_PASS</span><span class="o">=</span><span class="m">123456</span> <span class="se">\ </span>  <span class="c1"># RabbitMQ密码（默认为guest）</span>
</span></span><span class="line"><span class="cl">    --name rabbitmq-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --hostname rabbitmq <span class="se">\ </span>              <span class="c1"># 域名，单机下可忽略，通常用于集群部署时</span>
</span></span><span class="line"><span class="cl">    -p 15672:15672 <span class="se">\ </span>                   <span class="c1"># 可视化管理界面端口</span>
</span></span><span class="line"><span class="cl">    -p 5672:5672 <span class="se">\ </span>                     <span class="c1"># 服务端口</span>
</span></span><span class="line"><span class="cl">    -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    rabbitmq:3-management
</span></span></code></pre></div></li>
</ol>
<p>启动容器后，进入<a href="http://localhost:15672/" target="_blank" rel="noopener noreferrer">http://localhost:15672/<i class="fas fa-external-link-square-alt ms-1"></i></a>即可进入RabbitMQ管理界面。</p>
<p>使用以下命令查看RabbitMQ日志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker logs rabbitmq-server <span class="c1"># 替换成你容器的名称</span>
</span></span></code></pre></div><hr>
<h1 id="rabbitmq-结构" data-numberify>RabbitMQ 结构<a class="anchor ms-1" href="#rabbitmq-结构"></a></h1>
<p>RabbitMQ的基本结构如下：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ的基本结构" src="/docs/spring/springcloud/communications/rabbit-mq/image-20210717162752376.png" loading="lazy" width="1401" height="610" />
</picture>

</p>
<p>在RabbitMQ中有几个概念：</p>
<ul>
<li><code>channel</code>：操作RabbitMQ的工具。</li>
<li><code>exchange</code>：路由消息到队列中。</li>
<li><code>queue</code>：缓存消息。</li>
<li><code>virtual host</code>：虚拟主机，是对<code>queue</code>、<code>exchange</code>等资源的逻辑分组。</li>
</ul>
<p>RabbitMQ中的角色主要有：</p>
<ul>
<li>Publisher：生产者。将消息发送给Queue（队列）或Exchange（交换机）。</li>
<li>Consumer：消费者。从Queue获取消息，并做响应的处理。</li>
<li>Exchange：交换机。负责消息路由，将从Publisher接受到的消息分发到不同的Queues上。</li>
<li>Queue：队列。用于从Publishers或Exchange接收消息并存储。</li>
<li>Virtual Host：虚拟主机。隔离不同用户的Exchange、Queue，消息的隔离。</li>
</ul>
<hr>
<h1 id="消息模型" data-numberify>消息模型<a class="anchor ms-1" href="#消息模型"></a></h1>
<p>RabbitMQ官方文档中给出了5个Demo，它们分别对应几种不同的用法：</p>
<ul>
<li>
<p>基本消息队列（Basic Queue）：</p>
<p><picture><img class="img-fluid " alt="Basic Queue" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691056818833.png" loading="lazy" width="286" height="158" />
</picture>

</p>
</li>
<li>
<p>工作消息队列（Work Queue）：</p>
<p><picture><img class="img-fluid " alt="Work Queue" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691056877775.png" loading="lazy" width="258" height="231" />
</picture>

</p>
</li>
<li>
<p>发布与订阅（Publish and Subscribe）。</p>
<p>根据交换机类型的不同，可分为三种：</p>
<ul>
<li>
<p>Fanout Exchange（广播）：</p>
<p><picture><img class="img-fluid " alt="Fanout Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057092864.png" loading="lazy" width="272" height="182" />
</picture>

</p>
</li>
<li>
<p>Direct Exchange（路由）：</p>
<p><picture><img class="img-fluid " alt="Direct Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057130360.png" loading="lazy" width="262" height="212" />
</picture>

</p>
</li>
<li>
<p>Topic Exchange（主题）：</p>
<p><picture><img class="img-fluid " alt="Topic Exchange" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691057168656.png" loading="lazy" width="276" height="209" />
</picture>

</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="rabbitmq-依赖" data-numberify>RabbitMQ 依赖<a class="anchor ms-1" href="#rabbitmq-依赖"></a></h1>
<p>使用RabbitMQ之前需要先导入依赖。可以导入Spring AMQP的依赖，其中包含了RabbitMQ的依赖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!-- AMQP依赖，包含RabbitMQ --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-amqp<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>对于RabbitMQ来说，Publisher和Consumer都是使用这个依赖，所以这个依赖坐标可以放在它们的父工程中。</p>
<hr>
<h1 id="基本消息队列" data-numberify>基本消息队列<a class="anchor ms-1" href="#基本消息队列"></a></h1>
<p>最基础的消息队列模型只包含三种角色：</p>
<ul>
<li><strong>Publisher</strong>：消息发布者，将消息发送到队列Queue。</li>
<li><strong>Queue</strong>：消息队列，负责接受并缓存Publisher发送的消息。</li>
<li><strong>Consumer</strong>：订阅队列，处理Queue中的消息。</li>
</ul>
<p>Queue由RabbitMQ实现，需要由我们实现的角色为Publisher和Consumer。</p>
<p>实现基本消息队列可以使用RabbitMQ的原生接口来模拟。创建两个Spring模块<code>Publisher</code>和<code>Consumer</code>来模拟消息的发送和接收：</p>
<ul>
<li>
<p>在<code>Publisher</code>模块中创建<code>PublisherTest</code>测试类来模拟消息发送：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PublisherTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSendMessage</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.1. 设置连接参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>   <span class="c1">// 主机地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPort</span><span class="o">(</span><span class="n">5672</span><span class="o">);</span>          <span class="c1">// 端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setVirtualHost</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>    <span class="c1">// 虚拟主机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">&#34;linner&#34;</span><span class="o">);</span>  <span class="c1">// 账号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">&#34;123456&#34;</span><span class="o">);</span>  <span class="c1">// 密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1.2. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 创建通道Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 创建队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 发送消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello RabbitMQ!&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">basicPublish</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">queueName</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">message</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;发送消息成功：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 关闭通道和连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">channel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
<li>
<p>在<code>Consumer</code>模块中创建<code>ConsumerTest</code>来模拟消息接收：</p>
<blockquote>
<p>注：接收消息需要在<code>main()</code>中创建回调函数。不能使用一般的测试方法。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span>  <span class="nc">ConsumerTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">TimeoutException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 创建连接工厂，建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.1. 设置连接参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>   <span class="c1">// 主机地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPort</span><span class="o">(</span><span class="n">5672</span><span class="o">);</span>          <span class="c1">// 端口号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setVirtualHost</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>    <span class="c1">// 虚拟主机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">&#34;linner&#34;</span><span class="o">);</span>  <span class="c1">// 用户名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">factory</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">&#34;123456&#34;</span><span class="o">);</span>  <span class="c1">// 密码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1.2. 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 创建通道Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 创建队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">String</span> <span class="n">queueName</span> <span class="o">=</span> <span class="s">&#34;simple.queue&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 订阅消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">channel</span><span class="o">.</span><span class="na">basicConsume</span><span class="o">(</span><span class="n">queueName</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="k">new</span> <span class="n">DefaultConsumer</span><span class="o">(</span><span class="n">channel</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleDelivery</span><span class="o">(</span><span class="n">String</span> <span class="n">consumerTag</span><span class="o">,</span> <span class="n">Envelope</span> <span class="n">envelope</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">AMQP</span><span class="o">.</span><span class="na">BasicProperties</span> <span class="n">properties</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">body</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 5. 处理消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;接收到消息：[&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;等待接收消息......&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div></li>
</ul>
<p>模拟过程：</p>
<ol>
<li>
<p>先给<code>testSendMessage()</code>打个断点，然后再以调试模式启动<code>PublisherTest</code>，逐条执行。可以在RabbitMQ管理界面中发现创建了对应的连接、通道和消息队列。并且，进入队列后可以发现有一条消息在准备中。</p>
<p>MQ连接：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ 连接" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073342130.png" loading="lazy" width="968" height="562" />
</picture>

</p>
<p>MQ通道：</p>
<p><picture><img class="img-fluid " alt="RabbitMQ 通道" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073381002.png" loading="lazy" width="1430" height="436" />
</picture>

</p>
<p>消息队列（Read项为1，表示有1条准备消息）：</p>
<p><picture><img class="img-fluid " alt="消息队列" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073449245.png" loading="lazy" width="1156" height="471" />
</picture>

</p>
<p>准备中的消息：</p>
<p><picture><img class="img-fluid " alt="准备中的消息" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073499794.png" loading="lazy" width="547" height="524" />
</picture>

</p>
</li>
<li>
<p>此时启动<code>Consumer</code>，可以发现有一条新的连接和新的通道。并且消息队列中的准备消息变为0。</p>
<p>新的MQ连接：</p>
<p><picture><img class="img-fluid " alt="新的 RabbitMQ 连接" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073659703.png" loading="lazy" width="917" height="141" />
</picture>

</p>
<p>新的MQ通道：</p>
<p><picture><img class="img-fluid " alt="新的 RabbitMQ 通道" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073733155.png" loading="lazy" width="1414" height="117" />
</picture>

</p>
<p>消息队列：</p>
<p><picture><img class="img-fluid " alt="消息队列" src="/docs/spring/springcloud/communications/rabbit-mq/uTools_1691073860449.png" loading="lazy" width="1138" height="114" />
</picture>

</p>
<p>在<code>Consumer</code>的控制台中可以发现打印了一条新消息：</p>
<pre tabindex="0"><code>接收到消息：[Hello RabbitMQ!]
</code></pre></li>
<li>
<p>再次启动<code>PublisherTest</code>，<code>Consumer</code>控制台再次打印一条消息：</p>
<pre tabindex="0"><code>接收到消息：[Hello RabbitMQ!]
</code></pre></li>
</ol>
<p>在搭建基本消息队列的过程中，创建队列之前的操作对于Publisher和Consumer来说是一致的。建立连接这个过程对于Publisher和Consumer来说都是必要的，之所以它们都要创建队列，是为了防止队列不存在的情况发生。它们的流程中不同的是Publisher创建队列后是为了发送消息，Consumer创建队列后是为了接收消息。</p>
<p>创建基本消息队列的流程大致可总结为：</p>
<ol>
<li>建立连接（Connection）。
<ol>
<li>创建连接工厂；</li>
<li>设置连接参数；</li>
<li>最后再建立连接。</li>
</ol>
</li>
<li>利用Connection创建通道（Channel）。</li>
<li>利用Channel声明消息队列。</li>
<li>利用Channel在指定的消息队列中发送消息或订阅消息。
<ul>
<li>对于Publisher来说，需要在消息队列中发送消息。发送完消息后，需要按顺序关闭通道和连接。</li>
<li>对于Consumer来说，需要在消息队列中接收消息。</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>通讯方式</title>
      <link>/docs/spring/springcloud/communications/introduction/</link>
      <pubDate>Thu, 03 Aug 2023 07:34:34 +0000</pubDate>
      
      <guid>/docs/spring/springcloud/communications/introduction/</guid>
      <description><![CDATA[微服务间通讯有两种方式： 同步通讯：实时响应。 异步通讯：不需要马上回复。 两种方式各有优劣，同步通讯可以立即得到响应，但是却不能跟多个服务同时通]]></description>
      <content:encoded><![CDATA[<p>微服务间通讯有两种方式：</p>
<ul>
<li>同步通讯：实时响应。</li>
<li>异步通讯：不需要马上回复。</li>
</ul>
<p>两种方式各有优劣，同步通讯可以立即得到响应，但是却不能跟多个服务同时通讯。异步通讯可以同时与多个服务通讯，但是往往响应会有所延迟。</p>
<hr>
<h1 id="同步通讯" data-numberify>同步通讯<a class="anchor ms-1" href="#同步通讯"></a></h1>
<p>Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>
<ul>
<li><strong>耦合度高</strong>：消费者与提供者之间存在直接的调用关系。在服务中每次加入新的需求，都要修改原来的代码。</li>
<li><strong>性能下降</strong>：消费者需要等待提供者响应，如果调用链过长，响应时间等于每次调用的时间之和。</li>
<li><strong>资源浪费</strong>：消费者在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。</li>
<li><strong>级联失败</strong>：如果提供者出现问题，所有消费者都会跟着出问题。如同多米话骨牌一样，迅速导致整个微服务群故障。</li>
</ul>
<blockquote>
<p>还有一个导致性能下降和资源浪费的原因：消费者在给提供者发请求时，提供者在处理别的消费者的请求，无法及时响应，这也会导致该消费者等待过长时间的响应。</p>
</blockquote>
<p>同步通讯并非只有缺点没有优点，其优点为时效性较强，可以立即得到结果。</p>
<hr>
<h1 id="异步通讯" data-numberify>异步通讯<a class="anchor ms-1" href="#异步通讯"></a></h1>
<p>异步调用可以避免上述同步通讯时造成的问题。</p>
<p>在异步通讯中，使用<strong>事件</strong>（<strong>Event</strong>）和<strong>代理</strong>（<strong>Broker</strong>）处理通讯。在异步通讯中有三种角色：</p>
<ul>
<li><strong>事件发布者</strong>（<strong>Publisher</strong>）：Publisher在处理完自己的业务后，发布一个事件给Broker。</li>
<li><strong>事件代理者</strong>（<strong>Broker</strong>）：Borker在接收到Publisher的事件消息后，将该消息发送给订阅了该事件的Consumer。</li>
<li><strong>事件订阅者</strong>（<strong>Consumer</strong>）：Consumer接收到自己订阅的事件消息后，根据事件做相应的业务处理。并且Consumer可以根据自己的情况和业务处理能力来处理（就好比说能力不够就不要揽太多活，Consumer性能不够就不会同时处理太多业务）。</li>
</ul>
<p>在事件模式中，Publisher在处理完业务后，就只管发布事件给Broker。剩下的由Broker和Consumer完成。这样Publisher与Consumer并没有直接通讯，而且Publisher也无需等待响应，即可以降低耦合、减少级联失败的情况，又能提高性能、减少资源浪费。Broker在这一模式中，就像是一个数据总线，所有的服务要接收数据和发送数据都发到这个总线上；这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<blockquote>
<p>在实际应用中，发布者与订阅者是相对的。也就是说，从整个系统来看，发布者可以是订阅者，订阅者也可以是发布者；从具体的业务逻辑线上看，才有某个服务是另外某个服务的发布者，某个服务是另外某个服务的订阅者。</p>
</blockquote>
<p>使用事件模式的异步通讯的好处：</p>
<ul>
<li><strong>吞吐量提升</strong>：发布者无需等待订阅者处理完成，响应更快速。</li>
<li><strong>故障隔离</strong>：服务没有直接调用，不存在级联失败问题。</li>
<li><strong>提高资源利用</strong>：调用间没有阻塞，不会造成无效的资源占用。</li>
<li><strong>耦合度极低</strong>：由Borker做代理，每个服务都可以灵活插拔，可替换。</li>
<li><strong>流量削峰</strong>：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件。</li>
</ul>
<p>虽然异步通讯好处多，但是也不是没有缺点：</p>
<ul>
<li>架构复杂，业务没有明显的流程线，不易于管理。</li>
<li>需要依赖于Broker的可靠、安全、性能（Broker挂了，就没人给订阅者发消息了）。</li>
</ul>
<hr>
<h1 id="mq-技术" data-numberify>MQ 技术<a class="anchor ms-1" href="#mq-技术"></a></h1>
<p>MQ（Message Queue，消息队列），就是存放消息的队列，是实现事件驱动架构中的Broker的一种方法。</p>
<p>比较常见的几种MQ实现及其对比如下：</p>
<pre><code>       | **RabbitMQ**            | **ActiveMQ**                     | **RocketMQ** | **Kafka**
</code></pre>
<p>&mdash;&mdash;&mdash;- | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | &mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;-
公司/社区  | Rabbit                  | Apache                           | 阿里         | Apache
开发语言   | Erlang                  | Java                             | Java         | Scala&amp;Java
协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire，STOMP，REST，XMPP，AMQP| 自定义协议   | 自定义协议
可用性     | 高                      | 一般                             | 高           | 高
单机吞吐量 | 一般                    | 差                               | 高           | 非常高
消息延迟   | 微秒级                  | 毫秒级                           | 毫秒级       | 毫秒以内
消息可靠性 | 高                      | 一般                             | 高           | 一般</p>
<p>一般按照以下方式选取：</p>
<ul>
<li>追求可用性：Kafka、 RocketMQ 、RabbitMQ。</li>
<li>追求可靠性：RabbitMQ、RocketMQ。</li>
<li>追求吞吐能力：RocketMQ、Kafka。</li>
<li>追求消息低延迟：RabbitMQ、Kafka。</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>

